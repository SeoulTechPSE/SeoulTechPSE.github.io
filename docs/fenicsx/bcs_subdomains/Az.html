<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  </head>
  <body>
    <div class="content"></div>
<script type="text/javascript">
!function(){var e={346:function(){const e=document.querySelector("head");e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement("link");n.setAttribute("rel","icon"),n.setAttribute("href",`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute("sizes",`${t}x${t}`),n.setAttribute("type","image/png"),e.appendChild(n)}))},975:function(e,t,n){"use strict";n.r(t),n.d(t,{initLocalFileLoader:function(){return bC},load:function(){return yC}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return T},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return G},fromQuat2:function(){return D},fromRotation:function(){return P},fromRotationTranslation:function(){return V},fromRotationTranslationScale:function(){return F},fromRotationTranslationScaleOrigin:function(){return _},fromScaling:function(){return O},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return E},frustum:function(){return k},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return y},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return Ve},multiplyScalarAndAdd:function(){return De},normalFromMat4:function(){return we},projection:function(){return Oe},rotate:function(){return ye},scale:function(){return be},set:function(){return de},str:function(){return Pe},sub:function(){return Fe},subtract:function(){return Ee},translate:function(){return Te},transpose:function(){return fe}}),n(346);var a=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],T=n*s-r*i,y=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,O=d*h-p*m,P=d*v-f*m,R=p*v-f*h,M=T*R-y*P+b*O+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*P+c*O)*M,e[1]=(o*P-r*R-a*O)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*y)*M,e[7]=(u*S-p*b+f*y)*M,e[8]=(i*P-s*w+c*A)*M,e[9]=(r*w-n*P-a*A)*M,e[10]=(g*C-m*b+v*T)*M,e[11]=(d*b-u*C-f*T)*M,e[12]=(s*I-i*O-l*A)*M,e[13]=(n*O-r*I+o*A)*M,e[14]=(m*y-g*x-h*T)*M,e[15]=(u*x-d*y+p*T)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function T(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function y(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],T=t[15],y=n[0],b=n[1],x=n[2],C=n[3];return e[0]=y*r+b*s+x*d+C*m,e[1]=y*o+b*l+x*p+C*h,e[2]=y*a+b*c+x*f+C*v,e[3]=y*i+b*u+x*g+C*T,y=n[4],b=n[5],x=n[6],C=n[7],e[4]=y*r+b*s+x*d+C*m,e[5]=y*o+b*l+x*p+C*h,e[6]=y*a+b*c+x*f+C*v,e[7]=y*i+b*u+x*g+C*T,y=n[8],b=n[9],x=n[10],C=n[11],e[8]=y*r+b*s+x*d+C*m,e[9]=y*o+b*l+x*p+C*h,e[10]=y*a+b*c+x*f+C*v,e[11]=y*i+b*u+x*g+C*T,y=n[12],b=n[13],x=n[14],C=n[15],e[12]=y*r+b*s+x*d+C*m,e[13]=y*o+b*l+x*p+C*h,e[14]=y*a+b*c+x*f+C*v,e[15]=y*i+b*u+x*g+C*T,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,T,y,b,x,C,S,A,I,w,O,P,R=r[0],M=r[1],E=r[2],V=Math.hypot(R,M,E);return V<a?null:(R*=V=1/V,M*=V,E*=V,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],T=t[10],y=t[11],b=R*R*s+i,x=M*R*s+E*o,C=E*R*s-M*o,S=R*M*s-E*o,A=M*M*s+i,I=E*M*s+R*o,w=R*E*s+M*o,O=M*E*s-R*o,P=E*E*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+T*C,e[3]=d*b+m*x+y*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+T*I,e[7]=d*S+m*A+y*I,e[8]=l*w+p*O+h*P,e[9]=c*w+f*O+v*P,e[10]=u*w+g*O+T*P,e[11]=d*w+m*O+y*P,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function O(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function P(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function V(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,T=i*c;return e[0]=1-(f+m),e[1]=d+T,e[2]=p-v,e[3]=0,e[4]=d-T,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function D(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),V(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function F(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,T=s*c,y=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+y)*b,e[2]=(f-T)*b,e[3]=0,e[4]=(p-y)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+T)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function _(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,T=l*c,y=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],O=(1-(m+v))*x,P=(f+b)*x,R=(g-y)*x,M=(f-b)*C,E=(1-(p+v))*C,V=(h+T)*C,D=(g+y)*S,L=(h-T)*S,B=(1-(p+m))*S;return e[0]=O,e[1]=P,e[2]=R,e[3]=0,e[4]=M,e[5]=E,e[6]=V,e[7]=0,e[8]=D,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(O*A+M*I+D*w),e[13]=n[1]+I-(P*A+E*I+L*w),e[14]=n[2]+w-(R*A+V*I+B*w),e[15]=1,e}function G(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function k(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],T=t[2],y=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(T-A)<a?g(e):(d=h-C,p=v-S,f=T-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-y*f,s=y*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*T),e[13]=-(l*h+c*v+u*T),e[14]=-(d*h+p*v+f*T),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],T=e[15],y=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],O=t[8],P=t[9],R=t[10],M=t[11],E=t[12],V=t[13],D=t[14],L=t[15];return Math.abs(n-y)<=a*Math.max(1,Math.abs(n),Math.abs(y))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-O)<=a*Math.max(1,Math.abs(d),Math.abs(O))&&Math.abs(p-P)<=a*Math.max(1,Math.abs(p),Math.abs(P))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-E)<=a*Math.max(1,Math.abs(m),Math.abs(E))&&Math.abs(h-V)<=a*Math.max(1,Math.abs(h),Math.abs(V))&&Math.abs(v-D)<=a*Math.max(1,Math.abs(v),Math.abs(D))&&Math.abs(T-L)<=a*Math.max(1,Math.abs(T),Math.abs(L))}var oe=y,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],T=n[6],y=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=T*r+y*i+b*c,e[7]=T*o+y*s+b*u,e[8]=T*a+y*l+b*d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],T=n*s-r*i,y=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,O=d*h-p*m,P=d*v-f*m,R=p*v-f*h,M=T*R-y*P+b*O+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*P+c*O)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*P-s*w+c*A)*M,e[3]=(o*P-r*R-a*O)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*P-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*y)*M,e[8]=(g*C-m*b+v*T)*M,e):null}function Oe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Pe(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function Ee(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function Ve(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function De(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],T=t[6],y=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-T)<=a*Math.max(1,Math.abs(c),Math.abs(T))&&Math.abs(u-y)<=a*Math.max(1,Math.abs(u),Math.abs(y))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,Fe=Ee,_e=n(730),Ge=n.n(_e),ke=n(59);const Ue=n.n(ke)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error("Invalid VTK object"),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&"object"==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=e=>{throw new Error(`Named parameter '${e}' is missing`)},$e=Symbol("void"),qe={};function Xe(){}["log","debug","info","warn","error","time","timeEnd","group","groupEnd"].forEach((e=>{qe[e]=Xe})),Ue.console=console.hasOwnProperty("log")?console:qe;const Ye={debug:Xe,error:Ue.console.error||Xe,info:Ue.console.info||Xe,log:Ue.console.log||Xe,warn:Ue.console.warn||Xe};function Ze(e,t){Ye[e]&&(Ye[e]=t||Xe)}function Qe(){Ye.log(...arguments)}function Je(){Ye.info(...arguments)}function et(){Ye.debug(...arguments)}function tt(){Ye.error(...arguments)}function nt(){Ye.warn(...arguments)}const rt={};function ot(e){rt[e]||(Ye.error(e),rt[e]=!0)}const at=Object.create(null);at.Float32Array=Float32Array,at.Float64Array=Float64Array,at.Uint8Array=Uint8Array,at.Int8Array=Int8Array,at.Uint16Array=Uint16Array,at.Int16Array=Int16Array,at.Uint32Array=Uint32Array,at.Int32Array=Int32Array,at.Uint8ClampedArray=Uint8ClampedArray;try{at.BigInt64Array=BigInt64Array,at.BigUint64Array=BigUint64Array}catch{}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(at[e]||Float64Array)(...n)}function st(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(at[e]||Float64Array).from(...n)}function lt(e){return e.charAt(0).toUpperCase()+e.slice(1)}function ct(e){return lt("_"===e[0]?e.slice(1):e)}function ut(e){return e.charAt(0).toLowerCase()+e.slice(1)}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=["TB","GB","MB","KB"];let o=Number(e),a="B";for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function pt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:" ";const n=[];let r=e;for(;r>1e3;)n.push(("000"+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function ft(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function gt(e){return e&&e.isA?e.getState():e}function mt(e){setTimeout(e,0)}function ht(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function vt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};ft(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),"classHierarchy"in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He("vtkObject");function r(e){n[e]=null}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?tt("instance deleted - cannot call any method"):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return tt("instance deleted - cannot call any method"),null;const o=n.length;return n.push(e),function(e){return Object.freeze({unsubscribe:function(){r(e)}})}(o)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${lt(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==["mtime"].indexOf(i)||r||nt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||"_"===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(gt):function(e){return Object.values(at).some((t=>e instanceof t))}(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort();Object.keys(o).sort().forEach((e=>{const n=a.indexOf(e);-1===n?r&&et(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&et(`Untouched keys: ${a.join(", ")}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object(e,t,n){return function(){return{...t[n.name]}}}};function yt(e,t,n){n.forEach((n=>{if("object"==typeof n){const r=Tt[n.type];e[`get${ct(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${ct(n)}`]=()=>t[n]}))}const bt={enum(e,t,n){const r=`_on${ct(n.name)}Changed`;return o=>{if("string"==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw tt(`Set Enum with invalid argument ${n}, ${o}`),new RangeError("Set Enum with invalid string argument")}if("number"==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw tt(`Set Enum outside numeric range ${n}, ${o}`),new RangeError("Set Enum outside numeric range")}return!1}throw tt(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError("Set Enum with invalid argument (String/Number)")}},object(e,t,n){1===n.params?.length&&nt('Setter of type "object" with a single "param" field is not supported');const r=`_on${ct(n.name)}Changed`;return function(){for(var o=arguments.length,a=new Array(o),i=0;i<o;i++)a[i]=arguments[i];let s;if(s=a.length>1&&n.params?.length?n.params.reduce(((e,t,n)=>Object.assign(e,{[t]:a[n]})),{}):a[0],!Ge()(t[n.name],s)){const o=t[n.name];return t[n.name]=s,t[r]?.(e,t,s,o),e.modified(),!0}return!1}}};function xt(e){if("object"==typeof e){const t=bt[e.type];if(t)return(n,r)=>t(n,r,e);throw tt(`No setter for field ${e}`),new TypeError("No setter for field")}return function(t,n){const r=`_on${ct(e)}Changed`;return function(o){if(n.deleted)return tt("instance deleted - cannot call any method"),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function Ct(e,t,n){n.forEach((n=>{"object"==typeof n?e[`set${ct(n.name)}`]=xt(n)(e,t):e[`set${ct(n)}`]=xt(n)(e,t)}))}function St(e,t,n){yt(e,t,n),Ct(e,t,n)}function At(e,t,n){n.forEach((n=>{e[`get${ct(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${ct(n)}ByReference`]=()=>t[n]}))}function It(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${ct(n)}Changed`;e[`set${ct(n)}`]=function(){if(t.deleted)return tt("instance deleted - cannot call any method"),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${ct(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;At(e,t,n),It(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Pt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?tt("instance deleted - cannot call any method"):r>=t.numberOfInputs?tt(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)tt("instance deleted - cannot call any method");else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=" input ports. To add more input ports, use addInputConnection()",void tt(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(tt("instance deleted - cannot call any method"),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?tt("instance deleted - cannot call any method"):o(e,i())},e.addInputConnection=function(e){t.deleted?tt("instance deleted - cannot call any method"):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.requestData&&e.shouldUpdate()&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"Scalars";for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Rt=Symbol("Event abort");function Mt(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}e[`invoke${ct(n)}`]=function(){if(t.deleted)return void tt("instance deleted - cannot call any method");const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Rt)break}},e[`on${ct(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return tt("instance deleted - cannot call any method"),null;const s=a++;return r.push([s,e,o]),r.sort(((e,t)=>t[2]-e[2])),function(e){return Object.freeze({unsubscribe:function(){i(e)}})}(s)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Et(e,t){const n=function(){const t={};return e(t,{},arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}),Object.freeze(t)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Dt(e){return e&&e.isA&&e.isA("vtkObject")}function Lt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Dt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Lt(e,t,n,r)})):Lt(o,t,n,r)}))}return n}function Bt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=n&&!o;clearTimeout(o),o=setTimeout((()=>{o=null,n||e.apply(l,i)}),t),c&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function Nt(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let _t=1;const Gt="__root__";function kt(e,t){Ft(e,t);const n=e.delete;t.proxyId=""+_t++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),yt(e,t,["proxyId","proxyGroup","proxyName"]),St(e,t,["proxyManager"]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],a=t.proxyId,s=function(){return o[arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt]}(n)||[];for(let t=0;t<s.length;t++){const n=s[t],o=e[`get${ct(n)}`],l={id:a,name:n,value:o?o():void 0},c=i(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${ct(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${ct(c.propertyName)}`]();if(!function(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}const c={bind:function(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}},unbind:l,unsubscribe:function(){for(;o.length;)o.pop().subscription.unsubscribe()},persistent:n};return t.propertyLinkMap[e]=c,c},e.listPropertyNames=()=>i().map((e=>e.name)),e.getPropertyByName=e=>i().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:i()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,mt((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if("application"===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,"application"),n.bind(e,o,i)}}}))}function Ut(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=ct(l),d=ct(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function zt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${ct(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&yt(e,t,a)}function Wt(e){let t=0,n=0,r=0,o=0;return"detail"in e&&(n=e.detail),"wheelDelta"in e&&(n=-e.wheelDelta/120),"wheelDeltaY"in e&&(n=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(t=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,"deltaY"in e&&(o=e.deltaY),"deltaX"in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var Ht={algo:Pt,capitalize:lt,chain:Vt,debounce:Bt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Mt,EVENT_ABORT:Rt,formatBytesToProperUnit:dt,formatNumbersWithThousandSeparator:pt,get:yt,getArray:At,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:gt,isVtkObject:Dt,keystore:Ft,measurePromiseExecution:ht,moveToProtected:Ot,newInstance:Et,newTypedArray:it,newTypedArrayFrom:st,normalizeWheel:Wt,obj:vt,proxy:kt,proxyPropertyMapping:Ut,proxyPropertyState:zt,safeArrays:ft,set:Ct,setArray:It,setGet:St,setGetArray:wt,setImmediate:mt,setLoggerFunction:Ze,throttle:Nt,traverseInstanceTree:Lt,TYPED_ARRAYS:at,uncapitalize:ut,VOID:$e,vtkDebugMacro:et,vtkErrorMacro:tt,vtkInfoMacro:Je,vtkLogMacro:Qe,vtkOnceErrorMacro:ot,vtkWarningMacro:nt,objectSetterMap:bt,requiredParam:Ke},jt=Object.freeze({__proto__:null,requiredParam:Ke,VOID:$e,setLoggerFunction:Ze,vtkLogMacro:Qe,vtkInfoMacro:Je,vtkDebugMacro:et,vtkErrorMacro:tt,vtkWarningMacro:nt,vtkOnceErrorMacro:ot,TYPED_ARRAYS:at,newTypedArray:it,newTypedArrayFrom:st,capitalize:lt,_capitalize:ct,uncapitalize:ut,formatBytesToProperUnit:dt,formatNumbersWithThousandSeparator:pt,setImmediateVTK:mt,measurePromiseExecution:ht,obj:vt,get:yt,set:Ct,setGet:St,getArray:At,setArray:It,setGetArray:wt,moveToProtected:Ot,algo:Pt,EVENT_ABORT:Rt,event:Mt,newInstance:Et,chain:Vt,isVtkObject:Dt,traverseInstanceTree:Lt,debounce:Bt,throttle:Nt,keystore:Ft,proxy:kt,proxyPropertyMapping:Ut,proxyPropertyState:zt,normalizeWheel:Wt,default:Ht});const{vtkErrorMacro:Kt}=Ht,$t={renderable:null,myFactory:null,children:[],visited:!1};function qt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$t,n),Ht.obj(e,t),Ht.event(e,t,"event"),t._renderableChildMap=new Map,Ht.get(e,t,["visited"]),Ht.setGet(e,t,["_parent","renderable","myFactory"]),Ht.getArray(e,t,["children"]),Ht.moveToProtected(e,t,["parent"]),function(e,t){t.classHierarchy.push("vtkViewNode"),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.getLastAncestorOfType=e=>t._parent?t._parent.getLastAncestorOfType(e)||(t._parent.isA(e)?t._parent:null):null,e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)return r.setVisited(!0),r;const o=e.createViewNode(n);return o?(o.setParent(e),o.setVisited(!0),t._renderableChildMap.set(n,o),t.children.push(o),o):void 0},e.addMissingNodes=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n&&n.length)for(let o=0;o<n.length;++o){const a=n[o],i=e.addMissingNode(a);if(r&&void 0!==i&&t.children[o]!==i)for(let e=o+1;e<t.children.length;++e)if(t.children[e]===i){t.children.splice(e,1),t.children.splice(o,0,i);break}}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];if(-1===t.children.indexOf(o)){o.setParent(e),t.children.push(o);const n=o.getRenderable();n&&t._renderableChildMap.set(n,o)}o.setVisited(!0)}},e.removeNode=e=>{const n=t.children.findIndex((t=>t===e));if(n<0)return!1;const r=e.getRenderable();return r&&t._renderableChildMap.delete(r),e.delete(),t.children.splice(n,1),!0},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return Kt("Cannot create view nodes without my own factory"),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}(e,t)}var Xt={newInstance:Ht.newInstance(qt,"vtkViewNode"),extend:qt,PASS_TYPES:["Build","Render"]};const Yt={};function Zt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yt,n),Ht.obj(e,t),function(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push("vtkViewNodeFactory"),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s}}(e,t)}var Qt={newInstance:Ht.newInstance(Zt,"vtkViewNodeFactory"),extend:Zt};const Jt=Object.create(null);function en(e,t){Jt[e]=t}const tn={};function nn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tn,n),t.overrides=Jt,Qt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLViewNodeFactory")}(0,t)}var rn={newInstance:Ht.newInstance(nn,"vtkOpenGLViewNodeFactory"),extend:nn};const on={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const an=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,on,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},St(e,t,["context","keyMatrixTime"]),function(e,t){t.classHierarchy.push("vtkOpenGLCamera"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),y(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}(e,t)}));en("vtkCamera",an);const{vtkDebugMacro:sn}=jt,ln={context:null,_openGLRenderWindow:null,selector:null};const cn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ln,n),Xt.extend(e,t,n),yt(e,t,["shaderCache"]),St(e,t,["selector"]),Ot(0,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkOpenGLRenderer"),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps(),!0),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(sn("No lights are on, creating one."),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();r.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,r.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}(e,t)}),"vtkOpenGLRenderer");en("vtkRenderer",cn);const un={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const dn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},St(e,t,["context"]),yt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLActor"),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(t._openGLRenderer.getSelector()&&t.renderable.getNestedPickable()),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}(e,t)}));en("vtkActor",dn);const pn={context:null,activeTextures:null};const fn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pn,n),Xt.extend(e,t,n),St(e,t,["context"]),yt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLActor2D"),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}(e,t)}));function gn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function mn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function hn(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function vn(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function Tn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function yn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function bn(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}function xn(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Cn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Sn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function An(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function In(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function wn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function On(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Pn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Rn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}en("vtkActor2D",fn);var Mn=yn,En=bn,Vn=(gn(),Math.sqrt(50)),Dn=Math.sqrt(10),Ln=Math.sqrt(2);function Bn(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Vn?10:a>=Dn?5:a>=Ln?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Vn?10:a>=Dn?5:a>=Ln?2:1)}function Nn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Fn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=Nn,r=(t,n)=>Nn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const _n=Fn(Nn),Gn=_n.right;_n.left,Fn((function(e){return null===e?NaN:+e})).center;var kn=Gn;function Un(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function zn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Wn(){}var Hn=.7,jn=1/Hn,Kn="\\s*([+-]?\\d+)\\s*",$n="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",qn="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",Xn=/^#([0-9a-f]{3,8})$/,Yn=new RegExp(`^rgb\\(${Kn},${Kn},${Kn}\\)$`),Zn=new RegExp(`^rgb\\(${qn},${qn},${qn}\\)$`),Qn=new RegExp(`^rgba\\(${Kn},${Kn},${Kn},${$n}\\)$`),Jn=new RegExp(`^rgba\\(${qn},${qn},${qn},${$n}\\)$`),er=new RegExp(`^hsl\\(${$n},${qn},${qn}\\)$`),tr=new RegExp(`^hsla\\(${$n},${qn},${qn},${$n}\\)$`),nr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function rr(){return this.rgb().formatHex()}function or(){return this.rgb().formatRgb()}function ar(e){var t,n;return e=(e+"").trim().toLowerCase(),(t=Xn.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?ir(t):3===n?new cr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?sr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?sr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=Yn.exec(e))?new cr(t[1],t[2],t[3],1):(t=Zn.exec(e))?new cr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=Qn.exec(e))?sr(t[1],t[2],t[3],t[4]):(t=Jn.exec(e))?sr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=er.exec(e))?mr(t[1],t[2]/100,t[3]/100,1):(t=tr.exec(e))?mr(t[1],t[2]/100,t[3]/100,t[4]):nr.hasOwnProperty(e)?ir(nr[e]):"transparent"===e?new cr(NaN,NaN,NaN,0):null}function ir(e){return new cr(e>>16&255,e>>8&255,255&e,1)}function sr(e,t,n,r){return r<=0&&(e=t=n=NaN),new cr(e,t,n,r)}function lr(e,t,n,r){return 1===arguments.length?((o=e)instanceof Wn||(o=ar(o)),o?new cr((o=o.rgb()).r,o.g,o.b,o.opacity):new cr):new cr(e,t,n,null==r?1:r);var o}function cr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function ur(){return`#${gr(this.r)}${gr(this.g)}${gr(this.b)}`}function dr(){const e=pr(this.opacity);return`${1===e?"rgb(":"rgba("}${fr(this.r)}, ${fr(this.g)}, ${fr(this.b)}${1===e?")":`, ${e})`}`}function pr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function fr(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function gr(e){return((e=fr(e))<16?"0":"")+e.toString(16)}function mr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new vr(e,t,n,r)}function hr(e){if(e instanceof vr)return new vr(e.h,e.s,e.l,e.opacity);if(e instanceof Wn||(e=ar(e)),!e)return new vr;if(e instanceof vr)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new vr(i,s,l,e.opacity)}function vr(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Tr(e){return(e=(e||0)%360)<0?e+360:e}function yr(e){return Math.max(0,Math.min(1,e||0))}function br(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function xr(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}Un(Wn,ar,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:rr,formatHex:rr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return hr(this).formatHsl()},formatRgb:or,toString:or}),Un(cr,lr,zn(Wn,{brighter(e){return e=null==e?jn:Math.pow(jn,e),new cr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Hn:Math.pow(Hn,e),new cr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new cr(fr(this.r),fr(this.g),fr(this.b),pr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:ur,formatHex:ur,formatHex8:function(){return`#${gr(this.r)}${gr(this.g)}${gr(this.b)}${gr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:dr,toString:dr})),Un(vr,(function(e,t,n,r){return 1===arguments.length?hr(e):new vr(e,t,n,null==r?1:r)}),zn(Wn,{brighter(e){return e=null==e?jn:Math.pow(jn,e),new vr(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Hn:Math.pow(Hn,e),new vr(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new cr(br(e>=240?e-240:e+120,o,r),br(e,o,r),br(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new vr(Tr(this.h),yr(this.s),yr(this.l),pr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=pr(this.opacity);return`${1===e?"hsl(":"hsla("}${Tr(this.h)}, ${100*yr(this.s)}%, ${100*yr(this.l)}%${1===e?")":`, ${e})`}`}}));var Cr=e=>()=>e;function Sr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Cr(isNaN(e)?t:e)}var Ar=function e(t){var n=function(e){return 1==(e=+e)?Sr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Cr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=lr(e)).r,(t=lr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Sr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+""}}return r.gamma=e,r}(1);function Ir(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=lr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+""}}}function wr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Lr(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Or(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Pr(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Rr(e,t){var n,r={},o={};for(n in null!==e&&"object"==typeof e||(e={}),null!==t&&"object"==typeof t||(t={}),t)n in e?r[n]=Lr(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Ir((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return xr((n-r/t)*t,i,o,a,s)}})),Ir((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return xr((n-r/t)*t,o,a,i,s)}}));var Mr=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Er=new RegExp(Mr.source,"g");function Vr(e,t){var n,r,o,a=Mr.lastIndex=Er.lastIndex=0,i=-1,s=[],l=[];for(e+="",t+="";(n=Mr.exec(e))&&(r=Er.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Pr(n,r)})),a=Er.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+""}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join("")})}function Dr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Lr(e,t){var n,r=typeof t;return null==t||"boolean"===r?Cr(t):("number"===r?Pr:"string"===r?(n=ar(t))?(t=n,Ar):Vr:t instanceof ar?Ar:t instanceof Date?Or:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Dr:Array.isArray(t)?wr:"function"!=typeof t.valueOf&&"function"!=typeof t.toString||isNaN(t)?Rr:Pr)(e,t)}function Br(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Nr(e){return+e}var Fr=[0,1];function _r(e){return e}function Gr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function kr(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Gr(o,r),a=n(i,a)):(r=Gr(r,o),a=n(a,i)),function(e){return a(r(e))}}function Ur(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Gr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=kn(e,t,1,r)-1;return a[n](o[n](t))}}function zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Wr,Hr=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function jr(e){if(!(t=Hr.exec(e)))throw new Error("invalid format: "+e);var t;return new Kr({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function Kr(e){this.fill=void 0===e.fill?" ":e.fill+"",this.align=void 0===e.align?">":e.align+"",this.sign=void 0===e.sign?"-":e.sign+"",this.symbol=void 0===e.symbol?"":e.symbol+"",this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?"":e.type+""}function $r(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf("e"))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function qr(e){return(e=$r(Math.abs(e)))?e[1]:NaN}function Xr(e,t){var n=$r(e,t);if(!n)return e+"";var r=n[0],o=n[1];return o<0?"0."+new Array(-o).join("0")+r:r.length>o+1?r.slice(0,o+1)+"."+r.slice(o+1):r+new Array(o-r.length+2).join("0")}jr.prototype=Kr.prototype,Kr.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var Yr={"%":(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+"",d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>Xr(100*e,t),r:Xr,s:function(e,t){var n=$r(e,t);if(!n)return e+"";var r=n[0],o=n[1],a=o-(Wr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join("0"):a>0?r.slice(0,a)+"."+r.slice(a):"0."+new Array(1-a).join("0")+$r(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function Zr(e){return e}var Qr,Jr,eo,to=Array.prototype.map,no=["y","z","a","f","p","n","µ","m","","k","M","G","T","P","E","Z","Y"];function ro(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Bn(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Vn?o*=10:a>=Dn?o*=5:a>=Ln&&(o*=2),t<e?-o:o}(e,t,n);switch((r=jr(null==r?",f":r)).type){case"s":var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(qr(t)/3)))-qr(Math.abs(e)))}(a,i))||(r.precision=o),eo(r,i);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,qr(t)-qr(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(o=function(e){return Math.max(0,-qr(Math.abs(e)))}(a))||(r.precision=o-2*("%"===r.type))}return Jr(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Bn(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function oo(){var e=function(){var e,t,n,r,o,a,i=Fr,s=Fr,l=Lr,c=_r;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==_r&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?Ur:kr,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Pr)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Nr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=Br,u()},d.clamp=function(e){return arguments.length?(c=!!e||_r,u()):c!==_r},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(_r,_r);return e.copy=function(){return t=e,oo().domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());var t},zr.apply(e,arguments),ro(e)}Qr=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?Zr:(t=to.call(e.grouping,Number),n=e.thousands+"",function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?"":e.currency[0]+"",a=void 0===e.currency?"":e.currency[1]+"",i=void 0===e.decimal?".":e.decimal+"",s=void 0===e.numerals?Zr:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(to.call(e.numerals,String)),l=void 0===e.percent?"%":e.percent+"",c=void 0===e.minus?"−":e.minus+"",u=void 0===e.nan?"NaN":e.nan+"";function d(e){var t=(e=jr(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,T=e.type;"n"===T?(m=!0,T="g"):Yr[T]||(void 0===h&&(h=12),v=!0,T="g"),(f||"0"===t&&"="===n)&&(f=!0,t="0",n="=");var y="$"===p?o:"#"===p&&/[boxX]/.test(T)?"0"+T.toLowerCase():"",b="$"===p?a:/[%p]/.test(T)?l:"",x=Yr[T],C=/[defgprs%]/.test(T);function S(e){var o,a,l,p=y,S=b;if("c"===T)S=x(e)+S,e="";else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case".":o=t=r;break;case"0":0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&"+"!==d&&(A=!1),p=(A?"("===d?d:c:"-"===d||"("===d?"":d)+p,S=("s"===T?no[8+Wr/3]:"")+S+(A&&"("===d?")":""),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):"";switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=""),n){case"<":e=p+e+S+w;break;case"=":e=p+w+e+S;break;case"^":e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(T)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+""},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=jr(e)).type="f",e)),r=3*Math.max(-8,Math.min(8,Math.floor(qr(t)/3))),o=Math.pow(10,-r),a=no[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:",",grouping:[3],currency:["$",""]}),Jr=Qr.format,eo=Qr.formatPrefix;var ao=n(318),io=n.n(ao);const so=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],lo=[1,0,0,0,1,0,0,0,1],co=1e-6,uo=1e-12,{vtkErrorMacro:po,vtkWarningMacro:fo}=Ht;let go=0;function mo(e){return()=>po(`vtkMath::${e} - NOT IMPLEMENTED`)}function ho(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function vo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function To(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function yo(e){return e/180*Math.PI}function bo(e){return 180*e/Math.PI}const{round:xo,floor:Co,ceil:So,min:Ao,max:Io}=Math;const wo=mo("ceilLog2"),Oo=mo("factorial");function Po(e){let t=1;for(;t<e;)t*=2;return t}function Ro(e){return e===Po(e)}const Mo=mo("gaussian");function Eo(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Vo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function Do(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Lo(e,t){return e[0]*=t,e[1]*=t,e}function Bo(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function No(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Fo(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function _o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function Go(e){const t=_o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function ko(e,t){return e[0]*t[0]+e[1]*t[1]}function Uo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Wo(e){const t=zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Ho(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function jo(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function Ko(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function $o(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function qo(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function Xo(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:co;return e.length===t.length&&e.every((function(e,r){return Math.abs(e-t[r])<=n}))}const Yo=Xo;function Zo(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function Qo(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function Jo(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ea(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes("e"))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split("e");let r="";return+n[1]+t>0&&(r="+"),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ta(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ea(e[0],n),t[1]=ea(e[1],n),t[2]=ea(e[2],n),t}function na(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,T,y;const b=To(t),x=To(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(Qo(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),T=1/Math.sqrt(1+p*p),m=p*T,f=m/(1+T),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return fo("vtkMath::Jacobi: Error extracting eigenfunctions"),0;for(a=0;a<t-1;a++){for(i=a,y=n[i],o=a+1;o<t;o++)(n[o]>=y||Math.abs(n[o]-y)<uo)&&(i=o,y=n[i]);i!==a&&(n[i]=n[a],n[a]=y,vo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function ra(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];na([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function oa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=To(3),r=To(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(vo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,vo(t,3,1,2)),r[2]=2;let u=0;if(qo(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=To(4);if(ra(t,d),Jo(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&vo(t,3,r[1],1),0!==r[0]&&vo(t,3,r[0],0)}function aa(e,t,n){let r,o,a,i,s,l;if(na([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for($o(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,ho(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Fo([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);Go(e);const c=Fo(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void $o(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,ho(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,ho(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);qo(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),$o(n,n)}else Zo(n)}function ia(e,t,n){let r,o,a,i,s,l,c,u=0;const d=To(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return fo("Unable to factor linear system"),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=uo)return fo("Unable to factor linear system"),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function sa(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function la(e,t,n){if(2===n){const n=To(2),r=Ho(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=To(n);return 0===ia(e,r,n)?0:(sa(e,r,t,n),1)}function ca(e,t,n){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const o=(arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)||To(n),a=r||To(n);if(0===ia(e,o,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)a[e]=0;a[r]=1,sa(e,o,a,n);for(let e=0;e<n;e++)t[e*n+r]=a[e]}return t}function ua(e,t,n,r){if(e<n)return fo("Insufficient number of samples. Underdetermined."),0;let o,a,i;const s=To(n*n),l=To(n),c=To(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(na(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function da(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?1/3+s*(i-o)/(l-c):2/3+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function pa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function fa(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function ga(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function ma(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function ha(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function va(e,t){const n=[0,0,0];ha(e,n),ga(n,t)}function Ta(e,t){const n=[0,0,0];fa(e,n),ma(n,t)}function ya(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function ba(e){return!(e[1]-e[0]<0)}function xa(e,t,n){return e<t?t:e>n?n:e}function Ca(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=xa(e[0],t[0],n[0]),r[1]=xa(e[1],t[1],n[1]),r[2]=xa(e[2],t[2],n[2]),r}const Sa=mo("GetScalarTypeFittingRange"),Aa=mo("GetAdjustedScalarRange");const Ia=e=>!Number.isFinite(e),{isFinite:wa,isNaN:Oa}=Number,Pa=Oa;function Ra(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function Ma(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ea(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Va(e){return Math.round(255*e)}var Da,La={Pi:()=>Math.PI,ldexp:function(e,t){return t>1023?e*2**1023*2**(t-1023):t<-1074?5e-324*e*2**(t+1074):e*2**t},radiansFromDegrees:yo,degreesFromRadians:bo,round:xo,floor:Co,ceil:So,ceilLog2:wo,min:Ao,max:Io,arrayMin:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=1/0;for(let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=e.length;r<o;r+=t)e[r]<n&&(n=e[r]);return n},arrayMax:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=-1/0;for(let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=e.length;r<o;r+=t)n<e[r]&&(n=e[r]);return n},arrayRange:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=1/0,r=-1/0;for(let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=e.length;o<a;o+=t)e[o]<n&&(n=e[o]),r<e[o]&&(r=e[o]);return[n,r]},isPowerOfTwo:Ro,nearestPowerOfTwo:Po,factorial:Oo,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=To(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){io()(`${e}`,{global:!0}),go=e},getSeed:function(){return go},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e+((arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)-e)*Math.random()},gaussian:Mo,add:Eo,subtract:Vo,multiplyScalar:Do,multiplyScalar2D:Lo,multiplyAccumulate:Bo,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:No,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Fo,norm:_o,normalize:Go,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=No(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=No(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return Do(n,o),!0},projectVector2D:function(e,t,n){const r=ko(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=ko(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Lo(n,o),!0},distance2BetweenPoints:Uo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Fo(e,t,n),Math.atan2(_o(n),No(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:ko,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:zo,normalize2D:Wo,determinant2x2:Ho,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(ho(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,ho(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Ho(s,u,l,d),f=-Ho(i,c,l,d),g=+Ho(i,c,s,u),m=-Ho(o,u,a,d),h=+Ho(r,c,a,d),v=-Ho(r,c,o,u),T=+Ho(o,s,a,l),y=-Ho(r,i,a,l),b=+Ho(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+T*t[2],S=f*t[0]+h*t[1]+y*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:jo,multiply3x3_mat3:Ko,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&po("Number of columns of A must match number of rows of B.");const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:$o,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Ho(i,c,s,u),p=-Ho(a,l,s,u),f=+Ho(a,l,i,c),g=-Ho(r,c,o,u),m=+Ho(n,l,o,u),h=-Ho(n,l,r,c),v=+Ho(r,i,o,s),T=-Ho(n,a,o,s),y=+Ho(n,a,r,i),b=n*d+r*p+o*f;0===b&&fo("Matrix has 0 determinant"),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=T/b,t[8]=y/b},identity3x3:Zo,identity:Qo,isIdentity:function(e){return Yo(e,so,arguments.length>1&&void 0!==arguments[1]?arguments[1]:co)},isIdentity3x3:function(e){return Yo(e,lo,arguments.length>1&&void 0!==arguments[1]?arguments[1]:co)},determinant3x3:qo,quaternionToMatrix3x3:Jo,areEquals:Xo,areMatricesEqual:Yo,roundNumber:ea,roundVector:ta,matrix3x3ToQuaternion:ra,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],T=e[3]*t[3];n[0]=r-l-f-T,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:oa,diagonalize3x3:aa,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=qo(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];oa(a,t),$o(a,a),Ko(a,t,r),aa(r,n,r),Ko(t,r,t),$o(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:la,invertMatrix:ca,luFactorLinearSystem:ia,luSolveLinearSystem:sa,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return na(e,3,t,n)},jacobiN:na,solveHomogeneousLeastSquares:ua,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return fo("Insufficient number of samples. Underdetermined."),0;const s=To(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>uo&&(p=0,s[u]=0);if(p&&1===o)return fo("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"),ua(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=To(n),f=ua(e,t,n,l));const m=To(n*n),h=To(n*n),v=To(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const T=ca(m,h,n);if(T)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&T:T},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:da,hsv2rgb:pa,lab2xyz:fa,xyz2lab:ga,xyz2rgb:ma,rgb2xyz:ha,rgb2lab:va,lab2rgb:Ta,uninitializeBounds:ya,areBoundsInitialized:ba,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:xa,clampVector:Ca,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Sa,getAdjustedScalarRange:Aa,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=To(3),a=To(3),i=To(3),s=To(3),l=To(3),c=To(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=_o(s),d=_o(l),p=_o(i),f=To(3);Fo(o,a,f);const g=_o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*No(o,c)/h,T=p*p*No(s,a)/h,y=u*u*No(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+T*t[o]+y*n[o];return m},inf:1/0,negInf:-1/0,isInf:Ia,isNan:Oa,isNaN:Oa,isFinite:wa,createUninitializedBounds:Ra,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:Ma,floatToHex2:Ea,floatRGB2HexCode:function(e){return`${arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#"}${e.map(Ea).join("")}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Va).join(", ")})`:`rgba(${Va(e[0]||0)}, ${Va(e[1]||0)}, ${Va(e[2]||0)}, ${e[3]||0})`}};function Ba(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function Na(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function Fa(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function _a(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}Da=new i(4),i!=Float32Array&&(Da[0]=0,Da[1]=0,Da[2]=0,Da[3]=0);var Ga=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};gn(),hn(1,0,0),hn(0,1,0),Na(),Na(),ie();const ka={};function Ua(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ka,n),Ht.obj(e,t),Ht.setGet(e,t,["transform"]),function(e,t){t.classHierarchy.push("vtkImplicitFunction"),e.functionValue=n=>{if(!t.transform)return e.evaluateFunction(n);const r=[];return t.transform.transformPoint(n,r),e.evaluateFunction(r)},e.evaluateFunction=e=>{Ht.vtkErrorMacro("not implemented")}}(e,t)}var za={newInstance:Ht.newInstance(Ua,"vtkImplicitFunction"),extend:Ua};const Wa=1e-6,Ha="coincide",ja="disjoint";function Ka(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function $a(e,t,n,r){const o=[];Vo(e,t,o);const a=No(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function qa(e,t,n){const r=No(e,t);let o=No(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Xa(e,t,n,r){const o=[];Vo(e,t,o);const a=No(n,o),i=No(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function Ya(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Vo(t,e,a),Vo(n,e,i);const s=No(r,i),l=No(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*Wa:s*Wa,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function Za(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Fo(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<Wa){const r=[];return Vo(e,n,r),0===No(t,r)?o.error=Ha:o.error=ja,o}let s;s=i[0]>i[1]&&i[0]>i[2]?"x":i[1]>i[2]?"y":"z";const l=[],c=-No(t,e),u=-No(r,n);switch(s){case"x":l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case"y":l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case"z":l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Eo(l,a,o.l1),o.intersection=!0,o}const Qa={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ka,projectPoint:$a,projectVector:qa,generalizedProjectPoint:Xa,intersectWithLine:Ya,intersectWithPlane:Za,DISJOINT:ja,COINCIDE:Ha},Ja={normal:[0,0,1],origin:[0,0,0]};function ei(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ja,n),za.extend(e,t,n),Ht.setGetArray(e,t,["normal","origin"],3),function(e,t){t.classHierarchy.push("vtkPlane"),e.distanceToPlane=e=>Ka(e,t.origin,t.normal),e.projectPoint=(e,n)=>{$a(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Xa(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>Ya(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>Za(e,n,t.origin,t.normal)}(e,t)}var ti={newInstance:Ht.newInstance(ei,"vtkPlane"),extend:ei,...Qa};const ni=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function ri(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function oi(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ai(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function ii(e){return ai(e,ni)}function si(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function li(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)si(e,...t[n]);else for(let n=0;n<t.length;n+=3)si(e,...t.slice(n,n+3));return e}function ci(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function ui(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function di(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function pi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function fi(e,t,n,r){return!!oi(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function gi(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function mi(e,t){return e[2*t+1]-e[2*t]}function hi(e){return[mi(e,0),mi(e,1),mi(e,2)]}function vi(e){return e.slice(0,2)}function Ti(e){return e.slice(2,4)}function yi(e){return e.slice(4,6)}function bi(e){const t=hi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function xi(e){if(oi(e)){const t=hi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Ci(e){return[e[0],e[2],e[4]]}function Si(e){return[e[1],e[3],e[5]]}function Ai(e,t){return e<=0&&t>=0||e>=0&&t<=0}function Ii(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function wi(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Oi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=Ii(e,[]);for(let e=0;e<r.length;++e)wn(r[e],r[e],t);return ii(n),li(n,r)}function Pi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Ri(e,t,n,r){const o=[].concat(ni),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=No(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=No(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=No(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Mi(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ei(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ti.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function Vi(e,t){if(!oi(e)||!oi(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Di(e,t){if(!oi(e)||!oi(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function Li(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Bi(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ti.evaluate(n,t,l)}let i=2;for(;i--&&!(Ai(o[r[i][0]],o[r[i][4]])&&Ai(o[r[i][1]],o[r[i][5]])&&Ai(o[r[i][2]],o[r[i][6]])&&Ai(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class Ni{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(ni))}getBounds(){return this.bounds}equals(e){return ri(this.bounds,e)}isValid(){return oi(this.bounds)}setBounds(e){return ai(this.bounds,e)}reset(){return ii(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return si(this.bounds,...t)}addPoints(e){return li(this.bounds,e)}addBounds(e,t,n,r,o,a){return ci(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return ui(this.bounds,e,t,n)}setMaxPoint(e,t,n){return di(this.bounds,e,t,n)}inflate(e){return pi(this.bounds,e)}scale(e,t,n){return fi(this.bounds,e,t,n)}getCenter(){return gi(this.bounds)}getLength(e){return mi(this.bounds,e)}getLengths(){return hi(this.bounds)}getMaxLength(){return bi(this.bounds)}getDiagonalLength(){return xi(this.bounds)}getMinPoint(){return Ci(this.bounds)}getMaxPoint(){return Si(this.bounds)}getXRange(){return vi(this.bounds)}getYRange(){return Ti(this.bounds)}getZRange(){return yi(this.bounds)}getCorners(e){return Ii(this.bounds,e)}computeCornerPoints(e,t){return wi(this.bounds,e,t)}computeLocalBounds(e,t,n){return Ri(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Oi(this.bounds,e,t)}computeScale3(e){return Pi(this.bounds,e)}cutWithPlane(e,t){return Bi(this.bounds,e,t)}intersectBox(e,t,n,r){return Mi(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ei(this.bounds,e,t)}intersect(e){return Vi(this.bounds,e)}intersects(e){return Di(this.bounds,e)}containsPoint(e,t,n){return Li(this.bounds,e,t,n)}contains(e){return Di(this.bounds,e)}}var Fi={newInstance:function(e){const t=e&&e.bounds;return new Ni(t)},equals:ri,isValid:oi,setBounds:ai,reset:ii,addPoint:si,addPoints:li,addBounds:ci,setMinPoint:ui,setMaxPoint:di,inflate:pi,scale:fi,scaleAboutCenter:function(e,t,n,r){if(!oi(e))return!1;const o=gi(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],fi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:gi,getLength:mi,getLengths:hi,getMaxLength:bi,getDiagonalLength:xi,getMinPoint:Ci,getMaxPoint:Si,getXRange:vi,getYRange:Ti,getZRange:yi,getCorners:Ii,computeCornerPoints:wi,computeLocalBounds:Ri,transformBounds:Oi,computeScale3:Pi,cutWithPlane:Bi,intersectBox:Mi,intersectPlane:Ei,intersect:Vi,intersects:Di,containsPoint:Li,contains:function(e,t){return!!Di(e,t)&&!!Li(e,...Ci(t))&&!!Li(e,...Si(t))},INIT_BOUNDS:ni},_i={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Gi}=_i;function ki(e){return()=>Ht.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}const Ui={allocatedRenderTime:10,coordinateSystem:Gi.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function zi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ui,n),Ht.obj(e,t),Ht.get(e,t,["estimatedRenderTime","allocatedRenderTime"]),Ht.setGet(e,t,["_parentProp","coordinateSystem","dragable","pickable","renderTimeMultiplier","useBounds","visibility"]),Ht.moveToProtected(e,t,["parentProp"]),function(e,t){t.classHierarchy.push("vtkProp"),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=ki("pick"),e.hasKey=ki("hasKey"),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Gi.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Gi.DISPLAY)}(e,t)}var Wi={newInstance:Ht.newInstance(zi,"vtkProp"),extend:zi,..._i};const Hi={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[...Fi.INIT_BOUNDS],properties:[],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function ji(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hi,n),Wi.extend(e,t,n),t.matrixMTime={},Ht.obj(t.matrixMTime),Ht.get(e,t,["isIdentity"]),Ht.getArray(e,t,["orientation"]),Ht.setGetArray(e,t,["origin","position","scale"],3),Ht.setGet(e,t,["properties"]),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,function(e,t){t.classHierarchy.push("vtkProp3D"),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=Na();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[bo(r),n[0],n[1],n[2]]},e.getOrientationQuaternion=function(){return N(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t.rotation)},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,yo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,yo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,yo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=yo(n),s=Na();Fa(s,[r,o,a],i);const l=new Float64Array(16);G(l,s),y(t.rotation,t.rotation,l),e.modified()},e.rotateQuaternion=n=>{if(Math.abs(n[3])>=.999999)return;const r=G(new Float64Array(16),n);y(t.rotation,t.rotation,r),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!Yo(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&y(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),y(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getBoundsByReference=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n,t.bounds=[...Fi.INIT_BOUNDS],t.boundsMTime.modified(),n;if(!t.mapperBounds||!n.every(((e,r)=>n[r]===t.mapperBounds[r]))||e.getMTime()>t.boundsMTime.getMTime()){Ht.vtkDebugMacro("Recomputing bounds..."),t.mapperBounds=n,e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),Fi.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}return t.bounds},e.getBounds=()=>{const t=e.getBoundsByReference();try{return[...t]}catch{return t}},e.getCenter=()=>Fi.getCenter(t.bounds),e.getLength=()=>Fi.getLength(t.bounds),e.getXRange=()=>Fi.getXRange(t.bounds),e.getYRange=()=>Fi.getYRange(t.bounds),e.getZRange=()=>Fi.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()})),e.getProperty=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null==t.properties[n]&&(t.properties[n]=e.makeProperty?.()),t.properties[n]},e.setProperty=(e,n)=>{const r=Number.isInteger(e),[o,a]=r?[e,n]:[0,e];return t.properties[o]!==a&&(t.properties[o]=a,!0)},e.getMTime=()=>{let e=t.mtime;return t.properties.forEach((t=>{if(null!==t){const n=t.getMTime();e=n>e?n:e}})),e}}(e,t)}var Ki={newInstance:Ht.newInstance(ji,"vtkProp3D"),extend:ji};const $i={FLAT:0,GOURAUD:1,PHONG:2},qi={POINTS:0,WIREFRAME:1,SURFACE:2};var Xi={Shading:$i,Representation:qi,Interpolation:$i};const{Representation:Yi,Interpolation:Zi}=Xi;function Qi(e){return()=>Ht.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}const Ji={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:Zi.GOURAUD,representation:Yi.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null,ORMTexture:null,RMTexture:null};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),Ht.obj(e,t),Ht.setGet(e,t,["lighting","interpolation","ambient","diffuse","metallic","roughness","normalStrength","emission","baseIOR","specular","specularPower","opacity","edgeVisibility","lineWidth","pointSize","backfaceCulling","frontfaceCulling","representation","diffuseTexture","metallicTexture","roughnessTexture","normalTexture","ambientOcclusionTexture","emissionTexture","ORMTexture","RMTexture"]),Ht.setGetArray(e,t,["ambientColor","specularColor","diffuseColor","edgeColor"],3),function(e,t){t.classHierarchy.push("vtkProperty"),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=Qi("ComputeCompositeColor"),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=Qi("AddShaderVariable"),e.setInterpolationToFlat=()=>e.setInterpolation(Zi.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(Zi.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(Zi.PHONG),e.getInterpolationAsString=()=>Ht.enumToString(Zi,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(Yi.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(Yi.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(Yi.POINTS),e.getRepresentationAsString=()=>Ht.enumToString(Yi,t.representation)}(e,t)}var ts={newInstance:Ht.newInstance(es,"vtkProperty"),extend:es,...Xi};const ns={mapper:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1};function rs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ns,n),Ki.extend(e,t,n),t.boundsMTime={},Ht.obj(t.boundsMTime),Ht.setGet(e,t,["backfaceProperty","forceOpaque","forceTranslucent","mapper"]),function(e,t){t.classHierarchy.push("vtkActor");const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.properties[0]||e.getProperty();let n=t.properties[0].getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(t.properties[0]||e.getProperty(),!e.getIsOpaque()),e.makeProperty=ts.newInstance,e.getMTime=()=>{let e=n.getMTime();if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}(e,t)}var os={newInstance:Ht.newInstance(rs,"vtkActor"),extend:rs};const as={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},is={VOID:"",CHAR:"Int8Array",SIGNED_CHAR:"Int8Array",UNSIGNED_CHAR:"Uint8Array",UNSIGNED_CHAR_CLAMPED:"Uint8ClampedArray",SHORT:"Int16Array",UNSIGNED_SHORT:"Uint16Array",INT:"Int32Array",UNSIGNED_INT:"Uint32Array",FLOAT:"Float32Array",DOUBLE:"Float64Array"};var ss={DefaultDataType:is.FLOAT,DataTypeByteSize:as,VtkDataTypes:is};const{vtkErrorMacro:ls}=jt,{DefaultDataType:cs}=ss;function us(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function ds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return us(r,0,1)}return us(e,t<0?0:t,n)}function ps(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function fs(e){return Object.prototype.toString.call(e).slice(8,-1)}const gs={computeRange:ds,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get(){return{min:e,max:t,count:n,sum:r,mean:r/n}},getRange(){return{min:e,max:t}}}},fastComputeRange:us,getDataType:fs,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=_o(r,t);a>n&&(n=a)}return n}},ms={name:"",numberOfComponents:1,dataType:cs,rangeTuple:[0,0]};function hs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,ms,n),Array.isArray(n.values)&&void 0===n.dataType&&console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array"),!t.empty&&!t.values&&!t.size)throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");if(t.values?Array.isArray(t.values)&&(t.values=st(t.dataType,t.values)):t.values=it(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=fs(t.values)),vt(e,t),Ct(e,t,["name","numberOfComponents"]),t.size%t.numberOfComponents!=0)throw new RangeError("model.size is not a multiple of model.numberOfComponents");!function(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=it(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push("vtkDataArray"),e.dataChange=()=>{t.ranges=null,e.modified()},e.allocate=t=>{n(e.getNumberOfTuples()+t)},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=ps(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=ds(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=ps(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.getRanges=function(){if(arguments.length>0&&void 0!==arguments[0]&&!arguments[0])return structuredClone(t.ranges);const n=[];for(let r=0;r<t.numberOfComponents;r++){const[t,o]=e.getRange(r),a={min:t,max:o};n.push(a)}if(t.numberOfComponents>1){const[t,r]=e.getRange(-1),o={min:t,max:r};n.push(o)}return n},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e-6;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:1)*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>vs({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=fs(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),t.ranges=structuredClone(n.getRanges()),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||ls("numberOfComponents must match");const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}(e,t)}const vs=Et(hs,"vtkDataArray");var Ts={newInstance:vs,extend:hs,...gs,...ss};const ys={clippingPlanes:[]};var bs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ys,n),Ht.obj(e,t),Ht.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),function(e,t){t.classHierarchy.push("vtkAbstractMapper"),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA("vtkPlane")&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}Ht.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}(e,t)},xs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,(e=>({bounds:[...Fi.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e}))(n)),bs(e,t,n),Ht.setGet(e,t,["viewSpecificProperties"]),function(e,t){e.getBounds=()=>(Ht.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"),Ra()),e.getCenter=()=>{const n=e.getBounds();return t.center=Fi.isValid(n)?Fi.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return Fi.getDiagonalLength(t)}}(e,t)};const{vtkErrorMacro:Cs,vtkWarningMacro:Ss}=Ht,As={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function Is(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,As,n),Ht.obj(e,t),function(e,t){t.classHierarchy.push("vtkFieldData");const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>"number"==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():""},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else Cs("Unhandled case in passData");else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Ts.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:Ht.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Ss("Unexpected case in interpolateData")}else t.insertTuples(s.getTuples());else Cs("Unhandled case in interpolateData");else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Ts.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:Ht.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}(e,t)}var ws={newInstance:Ht.newInstance(Is,"vtkFieldData"),extend:Is};const Os={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ps={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:Os,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:"vtkGhostType"};const{AttributeTypes:Rs,AttributeCopyOperations:Ms}=Ps,{vtkWarningMacro:Es}=Ht,Vs={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function Ds(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vs,n),ws.extend(e,t,n),Ht.setGet(e,t,["activeScalars","activeNormals","activeTCoords","activeVectors","activeTensors","activeGlobalIds","activePedigreeIds"]),t.arrays||(t.arrays={}),function(e,t){const n=["Scalars","Vectors","Normals","TCoords","Tensors","GlobalIds","PedigreeIds"];function r(e){let t=n.find((t=>Rs[t.toUpperCase()]===e||"number"!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push("vtkDataSetAttributes");const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&"PEDIGREEIDS"===a.toUpperCase()&&!n.isA("vtkDataArray"))return Es(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Es(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if("PEDIGREEIDS"!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA("vtkDataArray"))return Es(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Es(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Ms.PASSDATA][Rs[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Ms.PASSDATA][Rs[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(Ms).filter((e=>"ALLCOPY"!==e)).forEach((e=>{t.copyAttributeFlags[Ms[e]]=Object.keys(Rs).filter((e=>"NUM_ATTRIBUTES"!==e)).reduce(((e,t)=>(e[Rs[t]]=!0,e)),[])})),t.copyAttributeFlags[Ms.COPYTUPLE][Rs.GLOBALIDS]=!1,t.copyAttributeFlags[Ms.INTERPOLATE][Rs.GLOBALIDS]=!1,t.copyAttributeFlags[Ms.COPYTUPLE][Rs.PEDIGREEIDS]=!1},e.initialize=Ht.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||"vtkDataArray"!==t.dataArrays[n].type||e.addArray(Ts.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}(e,t)}var Ls={newInstance:Ht.newInstance(Ds,"vtkDataSetAttributes"),extend:Ds,...Ps};const Bs=["pointData","cellData","fieldData"],Ns={};function Fs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ns,n),Ht.obj(e,t),Ht.setGet(e,t,Bs),function(e,t){t.classHierarchy.push("vtkDataSet"),Bs.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=Ls.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),Bs.forEach((n=>{t[n]=Ls.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}(e,t)}var _s={newInstance:Ht.newInstance(Fs,"vtkDataSet"),extend:Fs,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const Gs={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var ks={StructuredType:Gs};const{StructuredType:Us}=ks;var zs={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?Us.EMPTY:3===t?Us.XYZ_GRID:2===t?e[0]===e[1]?Us.YZ_PLANE:e[2]===e[3]?Us.XZ_PLANE:Us.XY_PLANE:1===t?e[0]<e[1]?Us.X_LINE:e[2]<e[3]?Us.Y_LINE:Us.Z_LINE:Us.SINGLE_POINT},...ks};const{vtkErrorMacro:Ws}=Ht,Hs={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:Gs.EMPTY};function js(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hs,n),_s.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),Ht.get(e,t,["indexToWorld","worldToIndex"]),Ht.setGetArray(e,t,["origin","spacing"],3),Ht.setGetArray(e,t,["direction"],9),Ht.getArray(e,t,["extent"],6),function(e,t){t.classHierarchy.push("vtkImageData"),e.setExtent=function(){if(t.deleted)return Ws("instance deleted - cannot call any method"),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=zs.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)Ws("instance deleted - cannot call any method");else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void Ws("Bad dimension specification");n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return Ws("Requesting a point from an empty image."),null;const o=new Float64Array(3);switch(t.dataDescription){case Gs.EMPTY:return null;case Gs.SINGLE_POINT:break;case Gs.X_LINE:o[0]=n;break;case Gs.Y_LINE:o[1]=n;break;case Gs.Z_LINE:o[2]=n;break;case Gs.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case Gs.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case Gs.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case Gs.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:Ws("Invalid dataDescription")}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>Fi.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>Fi.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return wn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return wn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Fi.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Fi.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>Fi.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];Fi.computeCornerPoints(r,o,a),ta(o,o),ta(a,a);const i=e.getDimensions();Ca(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Ca(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0;return{minimum:d,maximum:u,average:m,variance:h,sigma:Math.sqrt(h),count:g}},e.computeIncrements=function(e){const t=[];let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;for(let r=0;r<3;++r)t[r]=n,n*=e[2*r+1]-e[2*r]+1;return t},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return Ws(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return Ws(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}(e,t)}var Ks={newInstance:Ht.newInstance(js,"vtkImageData"),extend:js};const $s={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var qs={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:$s,Scale:{LINEAR:0,LOG10:1}},Xs={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:Ys,Scale:Zs,VectorMode:Qs}=qs,{VtkDataTypes:Js}=Ts,{ColorMode:el}=Xs,{vtkErrorMacro:tl}=Ht;function nl(e){return e}function rl(e){return Math.floor(255*e+.5)}const ol={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:Qs.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1,scale:Zs.LINEAR};function al(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ol,n),Ht.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],Ht.setGet(e,t,["vectorSize","vectorComponent","vectorMode","alpha","indexedLookup"]),Ht.setArray(e,t,["mappingRange"],2),Ht.getArray(e,t,["mappingRange"]),function(e,t){t.classHierarchy.push("vtkScalarsToColors"),e.setVectorModeToMagnitude=()=>e.setVectorMode(Qs.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(Qs.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(Qs.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)tl("Values and annotations do not have the same number of tuples so ignoring");else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===el.DEFAULT&&(t.getDataType()===Js.UNSIGNED_CHAR||t.getDataType()===Js.UNSIGNED_CHAR_CLAMPED)||n===el.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:"vtkDataArray",name:"temp",numberOfComponents:4,dataType:Js.UNSIGNED_CHAR},i=Ht.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Ts.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,Ys.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,Ys.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===Qs.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==Qs.MAGNITUDE||1!==c&&1!==s||(i=Qs.COMPONENT));let u=0;switch(l>0&&(u=l),i){case Qs.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case Qs.RGBCOLORS:break;case Qs.MAGNITUDE:default:{const o=Ts.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=rl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Js.UNSIGNED_CHAR)return n;const i=Ts.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Js.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=nl;switch(n.getDataType()!==Js.FLOAT&&n.getDataType()!==Js.DOUBLE||(s=rl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return tl("Cannot convert colors"),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==el.DEFAULT||n.getDataType()!==Js.UNSIGNED_CHAR)&&r!==el.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}(e,t)}var il={newInstance:Ht.newInstance(al,"vtkScalarsToColors"),extend:al,...qs};const{vtkErrorMacro:sl}=Ht,ll={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function cl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ll,n),il.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},Ht.obj(t.buildTime),t.opaqueFlagBuildTime={},Ht.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},Ht.obj(t.insertTime,{mtime:0}),Ht.get(e,t,["buildTime"]),Ht.setGet(e,t,["numberOfColors","useAboveRangeColor","useBelowRangeColor"]),Ht.setArray(e,t,["alphaRange","hueRange","saturationRange","valueRange"],2),Ht.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),Ht.getArray(e,t,["hueRange","saturationRange","valueRange","alphaRange","nanColor","belowRangeColor","aboveRangeColor"]),function(e,t){t.classHierarchy.push("vtkLookupTable"),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4-3,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=Pa(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===$s.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===$s.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,pa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return sl("Expected 4 components for RGBA colors"),!1;if(n.getDataType()!==is.UNSIGNED_CHAR)return sl("Expected unsigned char values for RGBA colors"),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}(e,t)}var ul={newInstance:Ht.newInstance(cl,"vtkLookupTable"),extend:cl};const dl={Off:0,PolygonOffset:1};let pl=dl.PolygonOffset,fl=dl.Off;const gl=["VTK_RESOLVE_OFF","VTK_RESOLVE_POLYGON_OFFSET"];function ml(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=fl===e;return fl=e,t}var hl={Resolve:dl,getResolveCoincidentTopologyAsString:function(){return gl[fl]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return pl},getResolveCoincidentTopology:function(){return fl},setResolveCoincidentTopology:ml,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){const t=pl===e;return pl=e,t},setResolveCoincidentTopologyToDefault:function(){return ml(dl.Off)},setResolveCoincidentTopologyToOff:function(){return ml(dl.Off)},setResolveCoincidentTopologyToPolygonOffset:function(){return ml(dl.PolygonOffset)}};function vl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=Ht.objectSetterMap.object(e,t,{name:n.key,params:["factor","offset"]})}))}const Tl=["Polygon","Line","Point"],yl={modified:()=>{}};vl(yl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},Tl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var bl={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),Ht.setGet(e,t,["resolveCoincidentTopology"]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(hl).forEach((t=>{e[t]=hl[t]})),Object.keys(yl).filter((e=>"modified"!==e)).forEach((t=>{e[t]=yl[t]})),vl(e,t.topologyOffset,Tl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=yl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=yl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=yl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:yl,otherStaticMethods:hl,CATEGORIES:Tl,Resolve:dl};const xl={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var Cl={PassTypes:xl};const{FieldAssociations:Sl}=_s,{staticOffsetAPI:Al,otherStaticMethods:Il}=bl,{ColorMode:wl,ScalarMode:Ol,GetArray:Pl}=Xs,{VectorMode:Rl}=qs,{VtkDataTypes:Ml}=Ts;function El(e){return()=>Ht.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function Vl(e,t){const n=e[1]%2==0?1:-1;if(e[0]+=n,e[0]>=t[0]||e[0]<0){const r=e[2]%2==0?1:-1;e[0]-=n,e[1]+=r,(e[1]>=t[1]||e[1]<0)&&(e[1]-=r,e[2]++)}}function Dl(e,t,n){const r=Math.floor(t),o=r%(2*n[0]);let a,i;o<n[0]?(e[0]=o,a=1,i=e[0]===n[0]-1):(e[0]=2*n[0]-1-o,a=-1,i=0===e[0]);const s=Math.floor(r/n[0]),l=s%(2*n[1]);let c,u;l<n[1]?(e[1]=l,c=1,u=e[1]===n[1]-1):(e[1]=2*n[1]-1-l,c=-1,u=0===e[1]),e[2]=Math.floor(s/n[1]);const d=t-r;i?u?e[2]+=d:e[1]+=c*d:e[0]+=a*d,e[0]=(e[0]+.5)/n[0],e[1]=(e[1]+.5)/n[1],e[2]=(e[2]+.5)/n[2]}const Ll=new WeakMap;const Bl={colorMapColors:null,areScalarsMappedFromCells:!1,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,numberOfColorsInRange:0,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function Nl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bl,n),xs(e,t,n),Ht.get(e,t,["areScalarsMappedFromCells","colorCoordinates","colorMapColors","colorTextureMap","numberOfColorsInRange","selectionWebGLIdsToVTKIds"]),Ht.setGet(e,t,["colorByArrayName","arrayAccessMode","colorMode","fieldDataTupleId","interpolateScalarsBeforeMapping","lookupTable","populateSelectionSettings","renderTime","scalarMode","scalarVisibility","static","useLookupTableScalarRange","customShaderAttributes"]),Ht.setGetArray(e,t,["scalarRange"],2),bl.implementCoincidentTopologyMethods(e,t),function(e,t){t.classHierarchy.push("vtkMapper"),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Ra(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=ul.newInstance()},e.getColorModeAsString=()=>Ht.enumToString(wl,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>Ht.enumToString(Ol,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFlag:!1};let i=null,s=!1;if(n===Ol.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===Ol.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===Ol.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===Ol.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===Pl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Ol.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===Pl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Ol.USE_FIELD_DATA){const t=e.getFieldData();i=r===Pl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const{scalars:o,cellFlag:a}=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName);if(t.areScalarsMappedFromCells=a,!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const i=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==i){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(o,a))t.mapScalarsToTexture(o,a,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},t.mapScalarsToTexture=(n,r,o)=>{const a=t.lookupTable.getRange(),i=t.lookupTable.usingLogScale(),s=t.lookupTable.getAlpha(),l=i?[Math.log10(a[0]),Math.log10(a[1])]:a;if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==o){t.lookupTable.setAlpha(o),t.colorTextureMap=null,t.lookupTable.build();const e=t.lookupTable.getNumberOfAvailableColors(),n=2048,a=2,d=r?n**3-3:4094;t.numberOfColorsInRange=Math.min(Math.max(e,a),d);const p=t.numberOfColorsInRange+3,f=t.numberOfColorsInRange+2,g=r?[Math.min(Math.ceil(p/n**0),n),Math.min(Math.ceil(p/n**1),n),Math.min(Math.ceil(p/n**2),n)]:[f,2,1],m=g[0]*g[1]*g[2],h=new Float64Array(m);h.fill(NaN);const v=t.numberOfColorsInRange,T=v+2,y=[0,0,0],b=l[0],x=l[1]-l[0];for(let e=0;e<T;++e){const t=b+x*(e-1)/(v-1),n=i?10**t:t;h[(u=g,(c=y)[0]+u[0]*(c[1]+u[1]*c[2]))]=n,Vl(y,g)}const C=Ts.newInstance({numberOfComponents:1,values:h}),S=t.lookupTable.mapScalars(C,t.colorMode,0);t.colorTextureMap=Ks.newInstance(),t.colorTextureMap.setDimensions(g),t.colorTextureMap.getPointData().setScalars(S),t.lookupTable.setAlpha(s)}var c,u;const d=t.lookupTable.getVectorMode()===Rl.MAGNITUDE&&n.getNumberOfComponents()>1?-1:t.lookupTable.getVectorComponent();t.colorCoordinates=function(e,t,n,r,o,a,i){const s=new Array(arguments.length);for(let e=0;e<arguments.length;++e){const t=arguments[e];s[e]=t.getMTime?.()??t}const l=s.join("/"),c=Ll.get(e);if(c&&c.stringHash===l)return c.textureCoordinates;const u=(n[1]-n[0])/(o-1),[d,p]=[n[0]-u,n[1]+u],f=d-.5*u,g=1/(p-d+u),m=d,h=(o+1)/(p-d),v=e.getData(),T=e.getNumberOfTuples(),y=e.getNumberOfComponents(),b=t<0||t>=y,x=a[2]<=1?2:3,C=Ts.newInstance({numberOfComponents:x,values:new Float32Array(T*x)}),S=C.getData(),A=[0,0,0];Dl(A,o+2,a);let I=0,w=0;const O=[.5,.5,.5];for(let e=0;e<T;++e){let e;if(b){let t=0;for(let e=0;e<y;++e){const n=v[I+e];t+=n*n}e=Math.sqrt(t)}else e=v[I+t];if(r&&(e=Math.log10(e)),I+=y,Pa(e))O[0]=A[0],O[1]=A[1],O[2]=A[2];else if(i){let t=(e-m)*h;t<1?t=0:t>o&&(t=o+1),Dl(O,t,a)}else{O[1]=.49;const t=(e-f)*g;O[0]=t>1e3?1e3:t<-1e3?-1e3:t}for(let e=0;e<x;++e)S[w++]=O[e]}return Ll.set(e,{stringHash:l,textureCoordinates:C}),C}(n,d,l,i,t.numberOfColorsInRange,t.colorTextureMap.getDimensions(),r)},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=(e,n)=>!((!n||t.colorMode===wl.DIRECT_SCALARS)&&(!t.interpolateScalarsBeforeMapping||t.lookupTable&&t.lookupTable.getIndexedLookup()||!e||t.colorMode===wl.DEFAULT&&e.getDataType()===Ml.UNSIGNED_CHAR||t.colorMode===wl.DIRECT_SCALARS)),e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=El("AcquireInvertibleLookupTable"),e.valueToColor=El("ValueToColor"),e.colorToValue=El("ColorToValue"),e.useInvertibleColorFor=El("UseInvertibleColorFor"),e.clearInvertibleColor=El("ClearInvertibleColor"),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer(xl.ID_LOW24),o=e.getRawPixelBuffer(xl.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Sl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Sl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===xl.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer(xl.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===xl.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n];e.getPixelBuffer(xl.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}(e,t)}var Fl={newInstance:Ht.newInstance(Nl,"vtkMapper"),extend:Nl,...Al,...Il,...Xs};const{isVtkObject:_l}=Ht;function Gl(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function kl(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const Ul={extractCellSizes:Gl,getNumberOfCells:kl};function zl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Ts.extend(e,t,function(e){return{empty:!0,numberOfComponents:1,dataType:is.UNSIGNED_INT,...e}}(n)),function(e,t){t.classHierarchy.push("vtkCellArray");const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=kl(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=Gl(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{let r;r=_l(n)?n.getPointsIds():n;const o=e.getNumberOfCells();return e.insertNextTuples([r.length,...r]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(r.length),o}}(e,t)}var Wl={newInstance:Ht.newInstance(zl,"vtkCellArray"),extend:zl,...Ul};const{vtkErrorMacro:Hl}=Ht,jl=[1,-1,1,-1,1,-1],Kl={empty:!0,numberOfComponents:3,dataType:is.FLOAT,bounds:[1,-1,1,-1,1,-1]};function $l(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kl,n),Ts.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkPoints"),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=Ht.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return Hl(`getBounds called on an array with components of\n        ${e.getNumberOfComponents()}`),jl;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}(e,t)}var ql={newInstance:Ht.newInstance($l,"vtkPoints"),extend:$l};const Xl={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function Yl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xl,n),Ht.obj(e,t),t.points||(t.points=ql.newInstance()),Ht.get(e,t,["points","pointsIds"]),function(e,t){t.classHierarchy.push("vtkCell"),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=Ht.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else ya(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{Ht.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.")}}(e,t)}var Zl={newInstance:Ht.newInstance(Yl,"vtkCell"),extend:Yl};const Ql={array:null,maxId:0,extend:0};function Jl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ql,n),Ht.obj(e,t),function(e,t){t.classHierarchy.push("vtkCellLinks"),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA("vtkPolyData")){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Zl.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Zl.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}(e,t)}var ec={newInstance:Ht.newInstance(Jl,"vtkCellLinks"),extend:Jl};const tc=0,nc=1,rc=2,oc=3,ac=4,ic=5,sc=6,lc=7,cc=9,uc=21,dc=41,pc=42,fc=["vtkEmptyCell","vtkVertex","vtkPolyVertex","vtkLine","vtkPolyLine","vtkTriangle","vtkTriangleStrip","vtkPolygon","vtkPixel","vtkQuad","vtkTetra","vtkVoxel","vtkHexahedron","vtkWedge","vtkPyramid","vtkPentagonalPrism","vtkHexagonalPrism","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkQuadraticEdge","vtkQuadraticTriangle","vtkQuadraticQuad","vtkQuadraticTetra","vtkQuadraticHexahedron","vtkQuadraticWedge","vtkQuadraticPyramid","vtkBiQuadraticQuad","vtkTriQuadraticHexahedron","vtkQuadraticLinearQuad","vtkQuadraticLinearWedge","vtkBiQuadraticQuadraticWedge","vtkBiQuadraticQuadraticHexahedron","vtkBiQuadraticTriangle","vtkCubicLine","vtkQuadraticPolygon","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkConvexPointSet","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkParametricCurve","vtkParametricSurface","vtkParametricTriSurface","vtkParametricQuadSurface","vtkParametricTetraRegion","vtkParametricHexRegion","UnknownClass","UnknownClass","UnknownClass","vtkHigherOrderEdge","vtkHigherOrderTriangle","vtkHigherOrderQuad","vtkHigherOrderPolygon","vtkHigherOrderTetrahedron","vtkHigherOrderWedge","vtkHigherOrderPyramid","vtkHigherOrderHexahedron"],gc={getClassNameFromTypeId:function(e){return e<fc.length?fc[e]:"UnknownClass"},getTypeIdFromClassName:function(e){return fc.findIndex(e)},isLinear:function(e){return e<uc||e===dc||e===pc},hasSubCells:function(e){return e===sc||e===ac||e===rc}},mc={size:0,maxId:-1,extend:1e3};function hc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mc,n),Ht.obj(e,t),Ht.get(e,t,["size","maxId","extend"]),Ht.getArray(e,t,["typeArray","locationArray"]),function(e,t){t.classHierarchy.push("vtkCellTypes"),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=tc},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}(e,t)}var vc={newInstance:Ht.newInstance(hc,"vtkCellTypes"),extend:hc,...gc},Tc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:yc}=Tc;function bc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=No(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Uo(i,e),o}function xc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Vo(t,e,i),Vo(r,n,s),Vo(n,e,l);const c=[No(i,i),-No(i,s),-No(i,s),No(s,s)],u=[];if(u[0]=No(i,l),u[1]=-No(s,l),0===la(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=bc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance,u.t);return yc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?yc.YES_INTERSECTION:yc.NO_INTERSECTION}const Cc={distanceToLine:bc,intersection:xc},Sc={orientations:null};function Ac(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sc,n),Zl.extend(e,t,n),Ht.setGet(e,t,["orientations"]),function(e,t){t.classHierarchy.push("vtkLine"),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=xc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===yc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Uo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=bc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=bc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=bc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=bc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}(e,t)}var Ic={newInstance:Ht.newInstance(Ac,"vtkLine"),extend:Ac,...Cc,...Tc};const wc={};function Oc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wc,n),_s.extend(e,t,n),Ht.setGet(e,t,["points"]),function(e,t){t.classHierarchy.push("vtkPointSet"),t.points?t.points=We(t.points):t.points=ql.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),t.points=ql.newInstance(),t.points.shallowCopy(e.getPoints())}}(e,t)}var Pc={newInstance:Ht.newInstance(Oc,"vtkPointSet"),extend:Oc};function Rc(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function Mc(e,t,n,r){Rc(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}function Ec(e){e[0]=-1,e[1]=1,e[2]=0,e[3]=-1,e[4]=0,e[5]=1}const Vc={computeNormalDirection:Rc,computeNormal:Mc,interpolationDerivs:Ec,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];Mc(e,t,n,d),Mc(r,o,a,p);const f=-No(d,e),g=-No(p,r),m=[No(p,e)+g,No(p,t)+g,No(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[No(d,r)+f,No(d,o)+f,No(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],T=[r,o,a],y=No(d,p),b=(f-g*y)/(y*y-1),x=(g-f*y)/(y*y-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Fo(d,p,[]);Go(S);let A=0,I=0;const w=[],O=[];let P,R,M=50,E=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ti.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=No(a.x,S)-No(C,S));const s=ti.intersectWithLine(T[n],T[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(E=I),O[I++]=No(s.x,S)-No(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=O[2];O[2]=O[E],O[E]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(O[0])||Number.isNaN(O[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(O[0]>O[1]){const e=O[1];O[1]=O[0],O[0]=e}return w[1]<O[0]||O[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<O[0]?w[1]<O[1]?(u[0]=2,u[1]=1,P=O[0],R=w[1]):(u[0]=2,u[1]=2,P=O[0],R=O[1]):w[1]<O[1]?(u[0]=1,u[1]=1,P=w[0],R=w[1]):(u[0]=1,u[1]=2,P=w[0],R=O[1]),Bo(C,S,P,l),Bo(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}},Dc={};function Lc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dc,n),Zl.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkTriangle"),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(Mc(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ti.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Uo(u,d),h=Uo(d,p),v=Uo(p,u);t.line||(t.line=Ic.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const T=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=T.betweenPoints,s.t=T.t,T.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=No(n,e)/v,i[1]=No(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const T=[];let y,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),Rc(l,c,u,d),ti.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(T[s++]=i);for(i=0;i<2;i++)f[i]=I[T[i]]-u[T[i]],g[i]=l[T[i]]-u[T[i]],m[i]=c[T[i]]-u[T[i]];if(h=Ho(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Ho(f,m)/h,r[1]=Ho(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Uo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(y=Uo(e,u),b=Ic.distanceToLine(e,l,u,t,S),x=Ic.distanceToLine(e,u,c,t,A),y<b?(a.dist2=y,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(y=Uo(e,l),b=Ic.distanceToLine(e,l,u,t,S),x=Ic.distanceToLine(e,l,c,t,A),y<b?(a.dist2=y,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(y=Uo(e,c),b=Ic.distanceToLine(e,c,u,t,S),x=Ic.distanceToLine(e,l,c,t,A),y<b?(a.dist2=y,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=Ic.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=Ic.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=Ic.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n},e.derivatives=(e,n,r,o,a)=>{const i=[],s=[],l=[];t.points.getPoint(0,i),t.points.getPoint(1,s),t.points.getPoint(2,l);const c=[],u=[],d=[],p=[];Mc(i,s,l,c);for(let e=0;e<3;e++)u[e]=s[e]-i[e],p[e]=l[e]-i[e];Fo(c,u,d);const f=Go(u);if(f<=0||Go(d)<=0){for(let e=0;e<o;e++)for(let t=0;t<3;t++)a[e*o+t]=0;return}const g=[0,0],m=[f,0],h=[No(p,u),No(p,d)],v=new Array(6);Ec(v);const T=[m[0]-g[0],m[1]-g[1],h[0]-g[0],h[1]-g[1]],y=new Array(4).fill(0);ca(T,y,2);for(let e=0;e<o;e++){let t=0,n=0;for(let a=0;a<3;a++)t+=v[a]*r[o*a+e],n+=v[3+a]*r[o*a+e];const i=t*y[0]+n*y[1],s=t*y[2]+n*y[3];a[3*e]=i*u[0]+s*d[0],a[3*e+1]=i*u[1]+s*d[1],a[3*e+2]=i*u[2]+s*d[2]}},e.cellBoundary=(e,n,r)=>{const o=n[0]-n[1],a=.5*(1-n[0])-n[1],i=2*n[0]+n[1]-1;return o>=0&&a>=0?(r[0]=t.pointsIds[0],r[1]=t.pointsIds[1]):a<0&&i>=0?(r[0]=t.pointsIds[1],r[1]=t.pointsIds[2]):(r[0]=t.pointsIds[2],r[1]=t.pointsIds[0]),!(n[0]<0||n[1]<0||n[0]>1||n[1]>1||1-n[0]-n[1]<0)}}(e,t)}var Bc={newInstance:Ht.newInstance(Lc,"vtkTriangle"),extend:Lc,...Vc};const Nc=["verts","lines","polys","strips"],{vtkWarningMacro:Fc}=Ht,_c={[oc]:Ic,[ac]:Ic,[ic]:Bc},Gc={};function kc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gc,n),Pc.extend(e,t,n),Ht.get(e,t,["cells","links"]),Ht.setGet(e,t,["verts","lines","polys","strips"]),function(e,t){t.classHierarchy.push("vtkPolyData"),Nc.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\w|[A-Z]|\b\w)/g,(e=>e.toUpperCase())).replace(/\s+/g,"")}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=Wl.newInstance()})),e.getNumberOfCells=()=>Nc.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),Nc.forEach((n=>{t[n]=Wl.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?rc:nc,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?ac:oc,1===t&&Fc("Building VTK_LINE ",n," with only one point, but VTK_LINE needs at least two points. Check the input."),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=ic;break;case 4:l[n]=cc;break;default:l[n]=lc}t<3&&Fc("Building VTK_TRIANGLE ",n," with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(sc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=vc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=ec.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case nc:case rc:o=t.verts;break;case oc:case ac:o=t.lines;break;case ic:case cc:case lc:o=t.polys;break;case sc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||_c[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}(e,t)}var Uc={newInstance:Ht.newInstance(kc,"vtkPolyData"),extend:kc};const zc={image:null,canvas:null,jsImageData:null,imageBitmap:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function Wc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zc,n),Ht.obj(e,t),Ht.algo(e,t,6,0),Ht.get(e,t,["canvas","image","jsImageData","imageBitmap","imageLoaded","resizable"]),Ht.setGet(e,t,["repeat","edgeClamp","interpolate","mipLevel"]),function(e,t){t.classHierarchy.push("vtkTexture"),e.imageLoaded=()=>{t.image.removeEventListener("load",e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null,t.imageBitmap=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setImageBitmap=n=>{t.imageBitmap!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null,t.jsImageData=null),t.imageBitmap=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.imageBitmap=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null,t.imageBitmap=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener("load",e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),t.imageBitmap&&(n=t.imageBitmap.width,r=t.imageBitmap.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData;if(t.imageBitmap)return t.imageBitmap;if(t.canvas)return t.canvas.getContext("2d").getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=t.image.width,n=t.image.height,r=new OffscreenCanvas(e,n).getContext("2d");return r.translate(0,n),r.scale(1,-1),r.drawImage(t.image,0,0,e,n),r.getImageData(0,0,e,n)}return null}}(e,t)}var Hc={newInstance:Ht.newInstance(Wc,"vtkTexture"),extend:Wc,generateMipmaps:(e,t,n)=>{const r=e.createShaderModule({code:"\n    @group(0) @binding(0) var inputTexture: texture_2d<f32>;\n    @group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;\n\n    @compute @workgroup_size(8, 8)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n      let texelCoord = vec2<i32>(global_id.xy);\n      let outputSize = textureDimensions(outputTexture);\n\n      if (texelCoord.x >= i32(outputSize.x) || texelCoord.y >= i32(outputSize.y)) {\n        return;\n      }\n\n      let inputSize = textureDimensions(inputTexture);\n      let scale = vec2<f32>(inputSize) / vec2<f32>(outputSize);\n\n      // Compute the floating-point source coordinate\n      let srcCoord = (vec2<f32>(texelCoord) + 0.5) * scale - 0.5;\n\n      // Get integer coordinates for the four surrounding texels\n      let x0 = i32(floor(srcCoord.x));\n      let x1 = min(x0 + 1, i32(inputSize.x) - 1);\n      let y0 = i32(floor(srcCoord.y));\n      let y1 = min(y0 + 1, i32(inputSize.y) - 1);\n\n      // Compute the weights\n      let wx = srcCoord.x - f32(x0);\n      let wy = srcCoord.y - f32(y0);\n\n      // Fetch the four texels\n      let c00 = textureLoad(inputTexture, vec2<i32>(x0, y0), 0);\n      let c10 = textureLoad(inputTexture, vec2<i32>(x1, y0), 0);\n      let c01 = textureLoad(inputTexture, vec2<i32>(x0, y1), 0);\n      let c11 = textureLoad(inputTexture, vec2<i32>(x1, y1), 0);\n\n      // Bilinear interpolation\n      let color = mix(\n        mix(c00, c10, wx),\n        mix(c01, c11, wx),\n        wy\n      );\n\n      textureStore(outputTexture, texelCoord, color);\n    }\n  "}),o=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",access:"write-only"}},{binding:2,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}}]}),a=e.createPipelineLayout({bindGroupLayouts:[o]}),i=e.createComputePipeline({label:"ComputeMipmapPipeline",layout:a,compute:{module:r,entryPoint:"main"}}),s=e.createSampler({magFilter:"linear",minFilter:"linear"});for(let r=1;r<n;r++){const n=t.createView({baseMipLevel:r-1,mipLevelCount:1}),o=t.createView({baseMipLevel:r,mipLevelCount:1}),a=e.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:n},{binding:1,resource:o},{binding:2,resource:s}]}),l=e.createCommandEncoder({label:"MipmapGenerateCommandEncoder"}),c=l.beginComputePass();c.setPipeline(i),c.setBindGroup(0,a);const u=Math.max(1,t.width>>r),d=Math.max(1,t.height>>r),p=Math.ceil(u/8),f=Math.ceil(d/8);c.dispatchWorkgroups(p,f),c.end(),e.queue.submit([l.finish()])}}};const jc=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],Kc=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],$c=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],qc=[0,1,0,1,0,1,0,1,2,2,2,2],Xc=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Yc=new Float64Array(3),Zc=new Float64Array(3),Qc=new Float64Array(3),Jc=new Float64Array(3),eu=new Float64Array(3),tu=new Float64Array(3),nu=new Float64Array(16);function ru(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function ou(e){const t=[],n=[];for(let r=0;r<3;r++){const o=oo().domain([e[2*r],e[2*r+1]]);t[r]=o.ticks(5);const a=o.tickFormat(5);n[r]=t[r].map(a)}return{ticks:t,tickStrings:n}}const au=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),Ht.obj(e,t),t.tmPolyData=Uc.newInstance(),t.tmMapper=Fl.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=os.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),Ht.setGet(e,t,["renderable"]),Ht.get(e,t,["lastSize","lastAspectRatio","axisTextStyle","tickTextStyle","tmActor","ticks"]),t.forceUpdate=!1,t.lastRedrawTime={},Ht.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},Ht.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],function(e,t){t.classHierarchy.push("vtkCubeAxesActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Yc[0]=c[3*n],Yc[1]=c[3*n+1],Yc[2]=c[3*n+2],wn(Qc,Yc,r),Qc[0]+=.1,wn(Zc,Qc,o),yn(eu,Zc,Yc),Qc[0]-=.1,Qc[1]+=.1,wn(Zc,Qc,o),yn(tu,Zc,Yc);for(let e=0;e<3;e++)eu[e]/=.05*u[0],tu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Yc[0]=c[3*n],Yc[1]=c[3*n+1],Yc[2]=c[3*n+2],a[0]<-.5?xn(Qc,eu,a[0]*i-l.width):a[0]>.5?xn(Qc,eu,a[0]*i):xn(Qc,eu,a[0]*i-l.width/2),Tn(Yc,Yc,Qc),xn(Qc,tu,a[1]*i-l.height/2),Tn(Yc,Yc,Qc),s.points[3*d]=Yc[0],s.points[3*d+1]=Yc[1],s.points[3*d+2]=Yc[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,xn(Qc,eu,l.width),Tn(Yc,Yc,Qc),s.points[3*d]=Yc[0],s.points[3*d+1]=Yc[1],s.points[3*d+2]=Yc[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,xn(Qc,tu,l.height),Tn(Yc,Yc,Qc),s.points[3*d]=Yc[0],s.points[3*d+1]=Yc[1],s.points[3*d+2]=Yc[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,xn(Qc,eu,l.width),yn(Yc,Yc,Qc),s.points[3*d]=Yc[0],s.points[3*d+1]=Yc[1],s.points[3*d+2]=Yc[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(nu,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Yc[0]=f[3*u],Yc[1]=f[3*u+1],Yc[2]=f[3*u+2],wn(Qc,Yc,n),Yc[0]=f[3*u+3],Yc[1]=f[3*u+4],Yc[2]=f[3*u+5],wn(Jc,Yc,n),yn(Qc,Qc,Jc);const r=[Qc[0],Qc[1]];Wo(r),e.createPolyDataForOneLabel(g[d],u,n,nu,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,nu,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Ts.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}(e,t)}),"vtkCubeAxesActorHelper");function iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};os.extend(e,t,function(e,t,n){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...Fi.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,tickLabelPixelOffset:12,generateTicks:ou,...n,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif",...n?.axisTextStyle},tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif",...n?.tickTextStyle}}}(0,0,n)),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=["X-Axis","Y-Axis","Z-Axis"],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.tmTexture=Hc.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=Fl.newInstance(),t.polyData=Uc.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=os.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=Uc.newInstance(),Ht.setGet(e,t,["axisTitlePixelOffset","boundsScaleFactor","faceVisibilityAngle","gridLines","tickLabelPixelOffset","generateTicks"]),Ht.setGetArray(e,t,["dataBounds"],6),Ht.setGetArray(e,t,["axisLabels"],3),Ht.get(e,t,["axisTextStyle","tickTextStyle","camera","tmTexture","textValues","textPolyData","tickCounts","gridActor"]),function(e,t){t.classHierarchy.push("vtkCubeAxesActor"),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=Fi.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Yc[s]=t.dataBounds[a]-.1*r*jc[a][s],Yc[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Yc[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),wn(Qc,Yc,e),Yc[s]=t.dataBounds[a],wn(Jc,Yc,e),yn(Qc,Jc,Qc),Sn(Qc,Qc),i=Qc[2]>o,t.camera.getParallelProjection()||(Sn(Jc,Jc),i=An(Jc,Qc)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Xc[t][0]].length+2*r[Xc[t][1]].length,a+=r[Xc[t][0]].length+r[Xc[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=$c[e][0],l[3*u+2]=$c[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Xc[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Xc[n][0]]=o[r],s[3*c+Xc[n][1]]=t.dataBounds[2*Xc[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Xc[n][0]]=o[r],s[3*c+Xc[n][1]]=t.dataBounds[2*Xc[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Xc[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Xc[n][1]]=o[r],s[3*c+Xc[n][0]]=t.dataBounds[2*Xc[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Xc[n][1]]=o[r],s[3*c+Xc[n][0]]=t.dataBounds[2*Xc[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[qc[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=Kc[a][e];if(1===n[d]){const e=qc[d],n=3*$c[d][0],p=3*$c[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Xc[a][0]]=.5*(t.dataBounds[2*Xc[a][0]]+t.dataBounds[2*Xc[a][0]+1]),s[3*l+Xc[a][1]]=.5*(t.dataBounds[2*Xc[a][1]]+t.dataBounds[2*Xc[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[Kc[e][t]]++;const a=t.generateTicks(t.dataBounds);e.updatePolyData(r,n,a.ticks),e.updateTextData(r,n,a.ticks,a.tickStrings),(o||t.forceUpdate)&&e.updateTextureAtlas(a.tickStrings)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){ru(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}ru(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=Po(n),r=Po(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{ru(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),Fi.setBounds(t.bounds,t.gridActor.getBounds()),Fi.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=Ht.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}(e,t)}var su={newInstance:Ht.newInstance(iu,"vtkCubeAxesActor"),extend:iu,newCubeAxesActorHelper:au,defaultGenerateTicks:ou};const lu={};const cu=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lu,n),Xt.extend(e,t,n),t.CubeAxesActorHelper=su.newCubeAxesActorHelper(),function(e,t){t.classHierarchy.push("vtkOpenGLCubeAxesActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}(e,t)}),"vtkOpenGLCubeAxesActor");en("vtkCubeAxesActor",cu);const uu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var du={ObjectType:uu};const{ObjectType:pu}=du,fu={objectType:pu.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function gu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fu,n),Ht.obj(e,t),Ht.get(e,t,["_openGLRenderWindow","allocatedGPUMemoryInBytes"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){function n(e){switch(e){case pu.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case pu.TEXTURE_BUFFER:if("TEXTURE_BUFFER"in t.context)return t.context.TEXTURE_BUFFER;case pu.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push("vtkOpenGLBufferObject");let r=null,o=null,a=!0,i="";e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i="Trying to upload array buffer to incompatible buffer.",!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}(e,t)}var mu={newInstance:Ht.newInstance(gu),extend:gu,...du};function hu(e){let t=0,n=0;for(let r=0;r<3;++r){const o=e.getRange(r),a=o[1]-o[0];t+=a*a;const i=.5*(o[1]+o[0]);n+=i*i}const r=t>0&&(Math.abs(n)/t>1e6||Math.abs(Math.log10(t))>3||0===t&&n>1e6);if(r){const t=new Float64Array(3),n=new Float64Array(3);for(let r=0;r<3;++r){const o=e.getRange(r),a=o[1]-o[0];t[r]=.5*(o[1]+o[0]),n[r]=a>0?1/a:1}return{useShiftAndScale:r,coordShift:t,coordScale:n}}return{useShiftAndScale:r,coordShift:new Float32Array([0,0,0]),coordScale:new Float32Array([1,1,1])}}const{vtkErrorMacro:vu}=Ht;const Tu={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function yu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tu,n),mu.extend(e,t,n),Ht.setGet(e,t,["colorBO","elementCount","stride","colorBOStride","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorOffset","colorComponents","customData"]),Ht.get(e,t,["coordShift","coordScale","coordShiftAndScaleEnabled","inverseShiftAndScaleMatrix"]),function(e,t){t.classHierarchy.push("vtkOpenGLCellArrayBufferObject"),e.setType(uu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=mu.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,T=0,y=0;const b={anythingToPoints(e,t,n,r){for(let o=0;o<e;++o)f(t[n+o],r)},linesToWireframe(e,t,n,r){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r)},polysToWireframe(e,t,n,r){if(e>2)for(let o=0;o<e;++o)f(t[n+o],r),f(t[n+(o+1)%e],r)},stripsToWireframe(e,t,n,r){if(e>2){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r);for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+2],r)}},polysToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+0],r),f(t[n+o+1],r),f(t[n+o+2],r)},stripsToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+1+o%2],r),f(t[n+o+1+(o+1)%2],r)}},x={anythingToPoints(e,t){return e},linesToWireframe(e,t){return e>1?2*(e-1):0},polysToWireframe(e,t){return e>2?2*e:0},stripsToWireframe(e,t){return e>2?4*e-6:0},polysToSurface(e,t){return e>2?3*(e-2):0},stripsToSurface(e,t,n){return e>2?3*(e-2):0}};let C=null,S=null;o===qi.POINTS||"verts"===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===qi.WIREFRAME||"lines"===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let O=null;const P=new Float32Array(w*t.blockSize);u&&(O=new Uint8Array(4*w));let R=0,M=0;const{useShiftAndScale:E,coordShift:V,coordScale:D}=hu(a.points);if(E?e.setCoordShiftAndScale(V,D):!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null),i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e,n){if(i&&(i.points[L]=e,i.cells[L]=y+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(P[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],P[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],P[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(P[R++]=s[g++],P[R++]=s[g++],P[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(y+a.cellOffset):3*e,P[R++]=l[m++],P[R++]=l[m++],P[R++]=l[m++]),t.customData.forEach((t=>{T=e*t.components;for(let e=0;e<t.components;++e)P[R++]=t.data[T++]})),null!==c){h=a.useTCoordsPerCell?n*p:e*p;for(let e=0;e<p;++e)P[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(y+a.cellOffset)*d:e*d,O[M++]=u[v++],O[M++]=u[v++],O[M++]=u[v++],O[M++]=4===d?u[v++]:255)};for(let e=0;e<I;e+=A[e]+1,y++)C(A[e],A,e+1,y+a.cellOffset);return t.elementCount=w,e.upload(P,uu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(O,uu.ARRAY_BUFFER)),y},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Rn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Rn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Pn(e,[0,0,0])&&Pn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Cn(n,t);const r=new Float64Array(16);return F(r,Na(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):vu("Wrong type for coordScale, expected vec3 or null"):vu("Wrong type for coordShift, expected vec3 or null")}}(e,t)}var bu={newInstance:Ht.newInstance(yu),extend:yu};const{vtkErrorMacro:xu}=Ht,Cu={shaderType:"Unknown",source:"",error:"",handle:0,dirty:!1,context:null};function Su(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cu,n),Ht.obj(e,t),Ht.setGet(e,t,["shaderType","source","error","handle","context"]),function(e,t){t.classHierarchy.push("vtkShader"),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||"Unknown"===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e="Fragment"===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return xu(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}(e,t)}var Au={newInstance:Ht.newInstance(Su,"vtkShader"),extend:Su};const{vtkErrorMacro:Iu}=Ht,wu={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:"",handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function Ou(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wu,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=Au.newInstance(),t.vertexShader.setShaderType("Vertex"),t.fragmentShader=Au.newInstance(),t.fragmentShader.setShaderType("Fragment"),t.geometryShader=Au.newInstance(),t.geometryShader.setShaderType("Geometry"),Ht.obj(e,t),Ht.get(e,t,["lastCameraMTime"]),Ht.setGet(e,t,["error","handle","compiled","bound","md5Hash","vertexShader","fragmentShader","geometryShader","linked"]),function(e,t){t.classHierarchy.push("vtkShaderProgram"),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(Iu(`Links failed: ${t.error}`),0):(Iu(t.error),0):(Iu(t.fragmentShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),Iu(t.fragmentShader.getError()),0):(Iu(t.vertexShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),Iu(t.vertexShader.getError()),0),e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error="Program has not been initialized, and/or does not have shaders.",!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return Iu(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(Iu("attempt to find uniform when the shader program is not linked"),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return Iu("attempt to find uniform when the shader program is not linked"),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error="Shader object was not initialized, cannot attach it.",!1;if("Unknown"===n.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error="Could not create shader program.",!1;t.handle=e,t.linked=!1}return"Vertex"===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),"Fragment"===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error="shader object was not initialized, cannot attach it.",!1;if("Unknown"===e.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;switch(0===t.handle&&(t.error="This shader program has not been initialized yet."),e.getShaderType()){case"Vertex":return t.vertexShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case"Fragment":return t.fragmentShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}(e,t)}var Pu={newInstance:Ht.newInstance(Ou,"vtkShaderProgram"),extend:Ou,substitute:function(e,t,n,r){const o="string"==typeof n?n:n.join("\n"),a=!1===r?t:new RegExp(t,"g"),i=e.replace(a,o);return{replace:i!==o,result:i}}};const Ru={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function Mu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ru,n),t.buffers=[],Ht.obj(e,t),Ht.get(e,t,["supported"]),Ht.setGet(e,t,["forceEmulation"]),function(e,t){t.classHierarchy.push("vtkOpenGLVertexArrayObject"),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension("ANGLE_instanced_arrays")),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension("OES_vertex_array_object"),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==uu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}(e,t)}var Eu={newInstance:Ht.newInstance(Mu,"vtkOpenGLVertexArrayObject"),extend:Mu};const Vu={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6},Du={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function Lu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Du,n),Ht.obj(e,t),t.shaderSourceTime={},Ht.obj(t.shaderSourceTime),t.attributeUpdateTime={},Ht.obj(t.attributeUpdateTime),Ht.setGet(e,t,["program","shaderSourceTime","VAO","attributeUpdateTime","CABO","primitiveType","pointPicking"]),t.program=Pu.newInstance(),t.VAO=Eu.newInstance(),t.CABO=bu.newInstance(),function(e,t){t.classHierarchy.push("vtkOpenGLHelper"),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===qi.POINTS||n===Vu.Points?t.context.POINTS:e===qi.WIREFRAME||n===Vu.Lines||n===Vu.TrisEdges||n===Vu.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f("viewportSize",o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf("lineWidthStepSize",t/Math.ceil(t)),e.getProgram().setUniformf("halfLineWidth",n)}t.primitiveType===Vu.Points||r.getProperty().getRepresentation()===qi.POINTS?e.getProgram().setUniformf("pointSize",r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf("pointSize",e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=Pu.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform float pointSize;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl","  gl_PointSize = pointSize;"],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=Pu.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform vec2 viewportSize;","uniform float lineWidthStepSize;","uniform float halfLineWidth;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl"," if (halfLineWidth > 0.0)","   {","   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;","   vec4 tmpPos = gl_Position;","   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;","   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];","   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];","   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);","   }"]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===Vu.Points?2:t.primitiveType===Vu.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}(e,t)}var Bu={newInstance:Ht.newInstance(Lu),extend:Lu,primTypes:Vu};const Nu={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},Fu={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var _u={Wrap:Nu,Filter:Fu};const Gu=new Float32Array(1),ku=new Int32Array(Gu.buffer);var Uu={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Gu[0]=e;const t=ku[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};let zu;const{Wrap:Wu,Filter:Hu}=_u,{VtkDataTypes:ju}=Ts,{vtkDebugMacro:Ku,vtkErrorMacro:$u,vtkWarningMacro:qu,requiredParam:Xu}=jt,{toHalf:Yu}=Uu;function Zu(e,t){function n(){return{internalFormat:t.internalFormat,format:t.format,openGLDataType:t.openGLDataType,width:t.width,height:t.height}}t.classHierarchy.push("vtkOpenGLTexture"),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow")),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(Hu.LINEAR),e.setMagnificationFilter(Hu.LINEAR)):(e.setMinificationFilter(Hu.NEAREST),e.setMagnificationFilter(Hu.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Wu.REPEAT),e.setWrapS(Wu.REPEAT),e.setWrapT(Wu.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImageBitmap()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR)),t.renderable.getImageBitmap()&&t.renderable.getImageLoaded()&&(e.create2DFromImageBitmap(t.renderable.getImageBitmap()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw({width:n.width,height:n.height,numComps:4,dataType:ju.UNSIGNED_CHAR,data:n,flip:!0}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw({width:n.width,height:n.height,numComps:4,dataType:ju.UNSIGNED_CHAR,data:n.data,flip:!0}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:a}):e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()};const r=()=>{if(t.minificationFilter!==Hu.LINEAR&&t.magnificationFilter!==Hu.LINEAR||(void 0===zu&&(zu=function(){try{const e=4,t=2,n=1,r=new Int16Array([0,32767]),o=[1,1],a=document.createElement("canvas");a.width=e,a.height=e;const i=a.getContext("webgl2");if(!i)return!1;const s=i.getExtension("EXT_texture_norm16");if(!s)return!1;const l=`#version 300 es\n    void main() {\n      gl_PointSize = ${e.toFixed(1)};\n      gl_Position = vec4(0, 0, 0, 1);\n    }\n  `,c="#version 300 es\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n\n    uniform sampler2D u_image;\n\n    out vec4 color;\n\n    void main() {\n        vec4 intColor = texture(u_image, gl_PointCoord.xy);\n        color = vec4(vec3(intColor.rrr), 1);\n    }\n    ",u=i.createShader(i.VERTEX_SHADER);if(i.shaderSource(u,l),i.compileShader(u),!i.getShaderParameter(u,i.COMPILE_STATUS))return!1;const d=i.createShader(i.FRAGMENT_SHADER);if(i.shaderSource(d,c),i.compileShader(d),!i.getShaderParameter(d,i.COMPILE_STATUS))return!1;const p=i.createProgram();if(i.attachShader(p,u),i.attachShader(p,d),i.linkProgram(p),!i.getProgramParameter(p,i.LINK_STATUS))return!1;const f=i.createTexture();i.bindTexture(i.TEXTURE_2D,f),i.texImage2D(i.TEXTURE_2D,0,s.R16_SNORM_EXT,t,n,0,i.RED,i.SHORT,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.useProgram(p),i.drawArrays(i.POINTS,0,1);const g=new Uint8Array(4);i.readPixels(o[0],o[1],1,1,i.RGBA,i.UNSIGNED_BYTE,g);const[m,h,v]=g,T=i.getExtension("WEBGL_lose_context");return T&&T.loseContext(),m===h&&h===v&&0!==m}catch(e){return!1}}()),zu))return t.oglNorm16Ext};function o(e){const[t,n,r,o,a,i]=e;return[n-t+1,o-r+1,i-a+1]}function a(e){const[t,n,r]=o(e);return t*n*r}function i(e,n){const r=new((arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)||e.constructor)(n.reduce(((e,t)=>e+a(t)),0)),o=[t.width,t.height,t.depth];let i=0;return n.forEach((t=>{!function(e,t,n,r,o){const[a,i,s,l,c,u]=n,[d,p]=t,f=d*p;let g=o;for(let t=c;t<=u;t++){const n=t*f;for(let t=s;t<=l;t++){const o=n+t*d;for(let t=o+a,n=o+i;t<=n;t++,g++)r[g]=e[t]}}}(e,o,t,r,i),i+=a(t)})),r}function s(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Ro(r)||!Ro(o))){const i=t.context.getExtension("OES_texture_half_float"),s=Po(r),l=Po(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Uu.toHalf(Uu.fromHalf(e[u][l+s+t])*h*(1-v)+Uu.fromHalf(e[u][l+p+t])*h*v+Uu.fromHalf(e[u][c+s+t])*m*(1-v)+Uu.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function l(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&r())||e!==ju.UNSIGNED_SHORT&&e!==ju.SHORT)))}function c(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);const i=function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a;let s=!1;if(t._openGLRenderWindow.getWebgl2())s=t.openGLDataType===t.context.FLOAT&&null===t.context.getExtension("OES_texture_float_linear")&&i||t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");s=e&&t.openGLDataType===e.HALF_FLOAT_OES}t.canUseHalfFloat=s&&i}(a,c.offset,c.scale,r),e.useHalfFloat()||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t._prevTexParams=null,t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t._prevTexParams=null,t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:qu("impossible case"),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Ku(`Unable to find suitable internal format for T=${n} NC= ${r}`),[t.context.R32F,t.context.RG32F,t.context.RGB32F,t.context.RGBA32F].includes(t.internalFormat)&&!t.context.getExtension("OES_texture_float_linear")&&qu("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."),t.internalFormat),e.getDefaultInternalFormat=(n,o)=>{let a=0;return a=t._openGLRenderWindow.getDefaultTextureInternalFormat(n,o,r(),e.useHalfFloat()),a||(a||(Ku("Unsupported internal texture type!"),Ku(`Unable to find suitable internal format for T=${n} NC= ${o}`)),a)},e.useHalfFloat=()=>t.enableUseHalfFloat&&t.canUseHalfFloat,e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t._prevTexParams=null,t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=n=>{const o=e.useHalfFloat();if(t._openGLRenderWindow.getWebgl2())switch(n){case ju.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case r()&&!o&&ju.SHORT:return t.context.SHORT;case r()&&!o&&ju.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case o&&ju.SHORT:case o&&ju.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case ju.FLOAT:case ju.VOID:default:return t.context.FLOAT}switch(n){case ju.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case ju.FLOAT:case ju.VOID:default:if(t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))return t.context.FLOAT;{const e=t.context.getExtension("OES_texture_half_float");if(e&&t.context.getExtension("OES_texture_half_float_linear"))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case Hu.NEAREST:return t.context.NEAREST;case Hu.LINEAR:return t.context.LINEAR;case Hu.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case Hu.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case Hu.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case Hu.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Wu.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Wu.REPEAT:return t.context.REPEAT;case Wu.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.updateArrayDataTypeForGL=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];const a=[];let s=t.width*t.height*t.components;r&&(s*=t.depth);const l=!!o.length;if(e!==ju.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e])if(l)a.push(i(n[e],o,Float32Array));else{const t=n[e].length>s?n[e].subarray(0,s):n[e];a.push(new Float32Array(t))}else a.push(null);if(e!==ju.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e])if(l)a.push(i(n[e],o,Uint8Array));else{const t=n[e].length>s?n[e].subarray(0,s):n[e];a.push(new Uint8Array(t))}else a.push(null);let c=!1;if(t._openGLRenderWindow.getWebgl2())c=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");c=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(c)for(let e=0;e<n.length;e++)if(n[e]){const t=l?i(n[e],o):n[e],r=new Uint16Array(l?t.length:s),c=r.length;for(let e=0;e<c;e++)r[e]=Yu(t[e]);a.push(r)}else a.push(null);if(0===a.length)for(let e=0;e<n.length;e++)a.push(l&&n[e]?i(n[e],o):n[e]);return a},e.create2DFromRaw=function(){let{width:n=Xu("width"),height:o=Xu("height"),numComps:a=Xu("numComps"),dataType:i=Xu("dataType"),data:c=Xu("data"),flip:u=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.getOpenGLDataType(i,!0),e.getInternalFormat(i,a),e.getFormat(i,a),!t.internalFormat||!t.format||!t.openGLDataType)return $u("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=a,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=s(e.updateArrayDataTypeForGL(i,d));return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(i)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=p[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,p[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,p[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*a*t._openGLRenderWindow.getDefaultTextureByteSize(i,r(),e.useHalfFloat()),e.deactivate(),!0},e.createCubeFromRaw=function(){let{width:n=Xu("width"),height:o=Xu("height"),numComps:a=Xu("numComps"),dataType:i=Xu("dataType"),data:c=Xu("data")}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.getOpenGLDataType(i),e.getInternalFormat(i,a),e.getFormat(i,a),!t.internalFormat||!t.format||!t.openGLDataType)return $u("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=a,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=s(e.updateArrayDataTypeForGL(i,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=it(i,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(i)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,o=t.height;for(;r>=1&&o>=1;){let a=null;n<=t.maxLevel&&(a=d[6*n+e]),l(i)?null!=a&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,o,t.format,t.openGLDataType,a):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,o,0,t.format,t.openGLDataType,a),n++,r/=2,o/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*a*t._openGLRenderWindow.getDefaultTextureByteSize(i,r(),e.useHalfFloat()),e.deactivate(),!0},e.createDepthFromRaw=function(){let{width:n=Xu("width"),height:o=Xu("height"),dataType:a=Xu("dataType"),data:i=Xu("data")}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.getOpenGLDataType(a),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?a===ju.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(a)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=i&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,i)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,i),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(a,r(),e.useHalfFloat()),e.deactivate(),!0):($u("Failed to determine texture parameters."),!1)},e.create2DFromImage=n=>{if(e.getOpenGLDataType(ju.UNSIGNED_CHAR),e.getInternalFormat(ju.UNSIGNED_CHAR,4),e.getFormat(ju.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return $u("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const o=!(t._openGLRenderWindow.getWebgl2()||Ro(n.width)&&Ro(n.height));let a=n,i=n.width,s=n.height,c=!0;const u=window.chrome;if(o||u){const e=new OffscreenCanvas(Po(n.width),Po(n.height));i=e.width,s=e.height;const t=e.getContext("2d");t.translate(0,e.height),t.scale(1,-1),t.drawImage(n,0,0,n.width,n.height,0,0,e.width,e.height),a=e,c=!1}return t.width=i,t.height=s,t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,c),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(ju.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,a)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,a),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(ju.UNSIGNED_CHAR,r(),e.useHalfFloat()),e.deactivate(),!0},e.create2DFromImageBitmap=n=>(e.getOpenGLDataType(ju.UNSIGNED_CHAR),e.getInternalFormat(ju.UNSIGNED_CHAR,4),e.getFormat(ju.UNSIGNED_CHAR,4),t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),t.width=n.width,t.height=n.height,l(ju.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,n)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,n),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(ju.UNSIGNED_CHAR,r(),e.useHalfFloat()),e.deactivate(),!0):($u("Failed to determine texture parameters."),!1)),e.create2DFilterableFromRaw=function(){let{width:t=Xu("width"),height:n=Xu("height"),numComps:r=Xu("numComps"),dataType:o=Xu("dataType"),data:a=Xu("data"),preferSizeOverAccuracy:i=!1,ranges:s}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.create2DFilterableFromDataArray({width:t,height:n,dataArray:Ts.newInstance({numComps:r,dataType:o,values:a,ranges:s}),preferSizeOverAccuracy:i})},e.create2DFilterableFromDataArray=function(){let{width:t=Xu("width"),height:n=Xu("height"),dataArray:r=Xu("dataArray"),preferSizeOverAccuracy:o=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{numComps:a,dataType:i,data:s}=c(r,o);e.create2DFromRaw({width:t,height:n,numComps:a,dataType:i,data:s})},e.updateVolumeInfoForGL=(n,o)=>{let a=!1;const i=e.useHalfFloat();t.volumeInfo?.scale&&t.volumeInfo?.offset||(t.volumeInfo={scale:new Array(o),offset:new Array(o)});for(let e=0;e<o;++e)t.volumeInfo.scale[e]=1,t.volumeInfo.offset[e]=0;if(r()&&!i&&n===ju.SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=32767;a=!0}if(r()&&!i&&n===ju.UNSIGNED_SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=65535;a=!0}if(n===ju.UNSIGNED_CHAR){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=255;a=!0}return(n===ju.FLOAT||i&&(n===ju.SHORT||n===ju.UNSIGNED_SHORT))&&(a=!0),a},e.create3DFromRaw=function(){let{width:i=Xu("width"),height:c=Xu("height"),depth:u=Xu("depth"),numComps:d=Xu("numComps"),dataType:p=Xu("dataType"),data:f=Xu("data"),updatedExtents:g=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},m=p,h=f;if(!e.updateVolumeInfoForGL(m,d)&&h){const e=i*c*u,n=structuredClone(t.volumeInfo),r=new Float32Array(e*d);t.volumeInfo.offset=n.offset,t.volumeInfo.scale=n.scale;let o=0;const a=n.scale.map((e=>1/e));for(let t=0;t<e;t++)for(let e=0;e<d;e++)r[o]=(h[o]-n.offset[e])*a[e],o++;m=ju.FLOAT,h=r}if(e.getOpenGLDataType(m),e.getInternalFormat(m,d),e.getFormat(m,d),!t.internalFormat||!t.format||!t.openGLDataType)return $u("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_3D,t.components=d,t.width=i,t.height=c,t.depth=u,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const v=g.length>0,T=!v||!Ge()(t._prevTexParams,n()),y=[h],b=s(e.updateArrayDataTypeForGL(m,y,!0,T?[]:g));if(t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),T)l(m)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=b[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,b[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,b[0]),t._prevTexParams=n();else if(v){const e=b[0];let n=0;for(let r=0;r<g.length;r++){const i=g[r],s=o(i),l=a(i),c=new e.constructor(e.buffer,n,l);n+=c.byteLength,t.context.texSubImage3D(t.target,0,i[0],i[2],i[4],s[0],s[1],s[2],t.format,t.openGLDataType,c)}}return t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(m,r(),e.useHalfFloat()),e.deactivate(),!0},e.create3DFilterableFromRaw=function(){let{width:t=Xu("width"),height:n=Xu("height"),depth:r=Xu("depth"),numComps:o=Xu("numComps"),dataType:a=Xu("dataType"),data:i=Xu("data"),preferSizeOverAccuracy:s=!1,ranges:l,updatedExtents:c=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.create3DFilterableFromDataArray({width:t,height:n,depth:r,dataArray:Ts.newInstance({numComps:o,dataType:a,values:i,ranges:l}),preferSizeOverAccuracy:s,updatedExtents:c})},e.create3DFilterableFromDataArray=function(){let{width:n=Xu("width"),height:r=Xu("height"),depth:o=Xu("depth"),dataArray:a=Xu("dataArray"),preferSizeOverAccuracy:i=!1,updatedExtents:s=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{numComps:u,dataType:d,data:p,scaleOffsets:f}=c(a,i),g=[],m=[];for(let e=0;e<u;++e)g[e]=0,m[e]=1;if(t.volumeInfo={scale:m,offset:g,dataComputedScale:f.scale,dataComputedOffset:f.offset,width:n,height:r,depth:o},t._openGLRenderWindow.getWebgl2())return e.create3DFromRaw({width:n,height:r,depth:o,numComps:u,dataType:d,data:p,updatedExtents:s});const h=n*r*o,v=structuredClone(f);let T=(e,t,n,r,o)=>{e[t]=n},y=ju.UNSIGNED_CHAR;if(d===ju.UNSIGNED_CHAR)for(let e=0;e<u;++e)v.offset[e]=0,v.scale[e]=255;else t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear")?(y=ju.FLOAT,T=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=ju.UNSIGNED_CHAR,T=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,u),e.getFormat(y,u),!t.internalFormat||!t.format||!t.openGLDataType)return $u("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=u,t.depth=1,t.numberOfDimensions=2;let b=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);b>4096&&(y===ju.FLOAT||u>=3)&&(b=4096);let x=1,C=1;h>b*b&&(x=Math.ceil(Math.sqrt(h/(b*b))),C=x);let S=Math.sqrt(h)/x;S=Po(S);const A=Math.floor(S*x/n),I=Math.ceil(o/A),w=Po(r*I/C);let O;t.width=S,t.height=w,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=A,t.volumeInfo.yreps=I,t.volumeInfo.xstride=x,t.volumeInfo.ystride=C,t.volumeInfo.offset=v.offset,t.volumeInfo.scale=v.scale;const P=S*w*u;O=y===ju.FLOAT?new Float32Array(P):new Uint8Array(P);let R=0;const M=Math.floor(n/x),E=Math.floor(r/C);for(let e=0;e<I;e++){const a=Math.min(A,o-e*A),i=u*(t.width-a*Math.floor(n/x));for(let t=0;t<E;t++){for(let o=0;o<a;o++){const a=u*((e*A+o)*n*r+C*t*n);for(let e=0;e<M;e++)for(let t=0;t<u;t++)T(O,R,p[a+x*e*u+t],v.offset[t],v.scale[t]),R++}R+=i}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=O&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,O)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,O),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1,e.enableUseHalfFloat=e=>{t.enableUseHalfFloat=e}}const Qu={_openGLRenderWindow:null,_forceInternalFormat:!1,_prevTexParams:null,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Wu.CLAMP_TO_EDGE,wrapT:Wu.CLAMP_TO_EDGE,wrapR:Wu.CLAMP_TO_EDGE,minificationFilter:Hu.NEAREST,magnificationFilter:Hu.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0,enableUseHalfFloat:!0,canUseHalfFloat:!1};function Ju(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qu,n),Xt.extend(e,t,n),t.sendParametersTime={},vt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},vt(t.textureBuildTime,{mtime:0}),Ct(e,t,["format","openGLDataType"]),St(e,t,["keyMatrixTime","minificationFilter","magnificationFilter","wrapS","wrapT","wrapR","generateMipmap","oglNorm16Ext"]),yt(e,t,["width","height","volumeInfo","components","handle","target","allocatedGPUMemoryInBytes"]),Ot(0,t,["openGLRenderWindow"]),Zu(e,t)}const ed=Et(Ju,"vtkOpenGLTexture");var td={newInstance:ed,extend:Ju,..._u};en("vtkTexture",ed);var nd="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n",rd="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",od=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=Pu.substitute(e,"//VTK::Coincident::Dec",["uniform float cfactor;","uniform float coffset;"]).result,t.context.getExtension("EXT_frag_depth")&&(0!==a.factor?(e=Pu.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=Pu.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=Pu.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=Pu.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=Pu.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=Pu.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result),n.Fragment=e}}},ad=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=Pu.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&""!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&""!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:id}=_s,{primTypes:sd}=Bu,{Representation:ld,Shading:cd}=ts,{ScalarMode:ud}=Fl,{Filter:dd,Wrap:pd}=td,{vtkErrorMacro:fd}=jt,gd={type:"StartEvent"},md={type:"EndEvent"},{CoordinateSystem:hd}=Wi;const vd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:xl.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function Td(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vd,n),Xt.extend(e,t,n),od(e,t,n),ad(e,t,n),t.primitives=[],t.primTypes=sd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=sd.Start;e<sd.End;e++)t.primitives[e]=Bu.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);St(e,t,["context"]),t.VBOBuildTime={},vt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},vt(t.selectionStateChanged,{mtime:0}),function(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push("vtkOpenGLPolyDataMapper"),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType("vtkOpenGLActor"),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=sd.Start;e<sd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=nd,e.Fragment=rd,e.Geometry=""},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName("lastLightComplexity");let l=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity","uniform vec3 ambientColorUniform;","uniform vec3 diffuseColorUniform;"];s&&(l=l.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let c=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];s&&(c=c.concat(["  vec3 specularColor;","  float specularPower;"])),c=c.concat(["  ambientColor = ambientColorUniform;","  diffuseColor = diffuseColorUniform;","  opacity = opacityUniform;"]),s&&(c=c.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat(["varying vec4 vertexColorVSOutput;"]),o=Pu.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=Pu.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=Pu.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=Pu.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?(t.renderable.getAreScalarsMappedFromCells()||t.renderable.getInterpolateScalarsBeforeMapping())&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=Pu.substitute(i,"//VTK::Color::Impl",c.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  ambientColor = texColor.rgb;","  opacity = opacity*texColor.a;"])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat(["uniform float opacityUniformBF; // the fragment opacity","uniform float ambientIntensityBF; // the material ambient","uniform float diffuseIntensityBF; // the material diffuse","uniform vec3 ambientColorUniformBF; // ambient material color","uniform vec3 diffuseColorUniformBF; // diffuse material color"]),s?(l=l.concat(["uniform float specularIntensityBF; // the material specular intensity","uniform vec3 specularColorUniformBF; // intensity weighted color","uniform float specularPowerUniformBF;"]),c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  specularColor = specularIntensityBF * specularColorUniformBF;","  specularPower = specularPowerUniformBF;","  opacity = opacityUniformBF; }"])):c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  opacity = opacityUniformBF; }"])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat(["uniform samplerBuffer texture1;"])),i=Pu.substitute(i,"//VTK::Color::Impl",c).result):i=Pu.substitute(i,"//VTK::Color::Impl",c.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result,i=Pu.substitute(i,"//VTK::Color::Dec",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity"),i=t.lastBoundBO.getReferenceByName("lastLightCount");let s=[];switch(a){case 0:o=Pu.substitute(o,"//VTK::Light::Impl",["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);","  //VTK::Light::Impl"],!1).result;break;case 1:o=Pu.substitute(o,"//VTK::Light::Impl",["  float df = max(0.0, normalVCVSOutput.z);","  float sf = pow(df, specularPower);","  vec3 diffuseL = df * diffuseColor;","  vec3 specularL = sf * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=Pu.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  float df;"];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,"    {",`    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=Pu.substitute(o,"//VTK::Light::Impl",s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=Pu.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  vec3 vertLightDirectionVC;","  float attenuation;","  float df;"];for(let e=0;e<i;++e)s=s.concat(["  attenuation = 1.0;",`  if (lightPositional${e} == 0)`,"    {",`      vertLightDirectionVC = lightDirectionVC${e};`,"    }","  else","    {",`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,"    float distanceVC = length(vertLightDirectionVC);","    vertLightDirectionVC = normalize(vertLightDirectionVC);","    attenuation = 1.0 /",`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,"    // per OpenGL standard cone angle is 90 or less for a spot light",`    if (lightConeAngle${e} <= 90.0)`,"      {",`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,"      // if inside the cone",`      if (coneDot >= cos(radians(lightConeAngle${e})))`,"        {",`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,"        }","      else","        {","        attenuation = 0.0;","        }","      }","    }","    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",`    diffuseL += ((df) * lightColor${e});`,"    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)","      {",`      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${e},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=Pu.substitute(o,"//VTK::Light::Impl",s,!1).result;break;default:fd("bad light complexity")}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=Pu.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=Pu.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * normalMC;"]).result,o=Pu.substitute(o,"//VTK::Normal::Dec",["in vec3 normalVCVSOutput[];","out vec3 normalVCGSOutput;"]).result,o=Pu.substitute(o,"//VTK::Normal::Impl",["normalVCGSOutput = normalVCVSOutput[i];"]).result,a=Pu.substitute(a,"//VTK::Normal::Dec",["varying vec3 normalVCVSOutput;"]).result,a=Pu.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalVCVSOutput);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.haveCellNormals?(a=Pu.substitute(a,"//VTK::Normal::Dec",["uniform mat3 normalMatrix;","uniform samplerBuffer textureN;"]).result,a=Pu.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalMatrix *","    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=Pu.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=Pu.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput;","  if (abs(fdx.x) > 0.0)","    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }","  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result):(a=Pu.substitute(a,"//VTK::Normal::Dec",["uniform int cameraParallel;"]).result,a=Pu.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=Pu.substitute(a,"//VTK::Normal::Impl",["  fdx = normalize(fdx);","  fdy = normalize(fdy);","  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));","  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }","  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(o=Pu.substitute(o,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,o=Pu.substitute(o,"//VTK::PositionVC::Impl",["vertexVCVSOutput = MCVCMatrix * vertexMC;","  gl_Position = MCPCMatrix * vertexMC;"]).result,o=Pu.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Dec",["in vec4 vertexVCVSOutput[];","out vec4 vertexVCGSOutput;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Impl",["vertexVCGSOutput = vertexVCVSOutput[i];"]).result,i=Pu.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=Pu.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;"]).result):(o=Pu.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,o=Pu.substitute(o,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=Pu.substitute(n,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=Pu.substitute(n,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result,r=Pu.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];","out vec2 tcoordVCGSOutput;"]).result,r=Pu.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=Pu.substitute(o,"//VTK::TCoord::Dec",["varying vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,a&&a.length>=1)switch(i){case 1:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}}else switch(n=Pu.substitute(n,"//VTK::TCoord::Dec","attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result,r=Pu.substitute(r,"//VTK::TCoord::Dec",["in vec3 tcoordVCVSOutput[];","out vec3 tcoordVCGSOutput;"]).result,r=Pu.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=Pu.substitute(o,"//VTK::TCoord::Dec",["varying vec3 tcoordVCVSOutput;","uniform samplerCube texture1;"]).result,i){case 1:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=Pu.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=Pu.substitute(o,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=Pu.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`varying float clipDistancesVSOutput[${e}];`]).result,a=Pu.substitute(a,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()==dl.PolygonOffset||o.getEdgeVisibility()&&o.getRepresentation()===ld.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===sd.Points||o.getRepresentation()===ld.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===sd.Lines||o.getRepresentation()===ld.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==sd.Tris&&e!==sd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==sd.TrisEdges&&e!==sd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===id.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=Pu.substitute(o,"//VTK::Picking::Dec",["uniform int picking;","//VTK::Picking::Dec"]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==xl.ID_LOW24&&t.lastSelectionState!==xl.ID_HIGH24||(a=Pu.substitute(a,"//VTK::Picking::Dec",["flat out int vertexIDVSOutput;\n","uniform int VertexIDOffset;\n"]).result,a=Pu.substitute(a,"//VTK::Picking::Impl","  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result,o=Pu.substitute(o,"//VTK::Picking::Dec","flat in int vertexIDVSOutput;\n").result,o=Pu.substitute(o,"//VTK::Picking::Impl",["  int idx = vertexIDVSOutput;","//VTK::Picking::Impl"]).result),t.lastSelectionState){case xl.ID_LOW24:o=Pu.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;break;case xl.ID_HIGH24:o=Pu.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;break;default:o=Pu.substitute(o,"//VTK::Picking::Dec","uniform vec3 mapperIndex;").result,o=Pu.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=Pu.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=Pu.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===cd.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName("lastLightComplexity"),h=t.lastBoundBO.getReferenceByName("lastLightCount");return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed("PrimitiveIDOffset")&&n.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),n.getProgram().isUniformUsed("VertexIDOffset")&&n.getProgram().setUniformi("VertexIDOffset",t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName("lastLightComplexity");n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||fd("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("normalMC")&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"normalMC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||fd("Error setting normalMC in shader VAO."):n.getVAO().removeAttributeArray("normalMC"),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||fd(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||fd("Error setting tcoordMC in shader VAO."):n.getVAO().removeAttributeArray("tcoordMC"),n.getProgram().isAttributeUsed("scalarColor")&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),"scalarColor",n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||fd("Error setting scalarColor in shader VAO."):n.getVAO().removeAttributeArray("scalarColor"),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),y(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",r)}t.internalColorTexture&&n.getProgram().isUniformUsed("texture1")&&n.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray("mapperIndex",i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi("picking",i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],Go(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],Go(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);wn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===hd.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,y(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix("MCPCMatrix",t.tmpMat4)}else s.setUniformMatrix("MCPCMatrix",n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed("MCVCMatrix")&&s.setUniformMatrix("MCVCMatrix",n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed("normalMatrix")&&s.setUniformMatrix3x3("normalMatrix",n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf("opacityUniform",i),o.setUniform3fArray("ambientColorUniform",s),o.setUniform3fArray("diffuseColorUniform",l),o.setUniformf("ambient",c),o.setUniformf("diffuse",u);const f=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray("specularColorUniform",g),o.setUniformf("specularPowerUniform",p),o.setUniformf("specular",d),o.isUniformUsed("ambientIntensityBF")){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf("ambientIntensityBF",c),o.setUniformf("diffuseIntensityBF",u),o.setUniformf("opacityUniformBF",i),o.setUniform3fArray("ambientColorUniformBF",s),o.setUniform3fArray("diffuseColorUniformBF",l),f<1)return;o.setUniformf("specularIntensityBF",d),o.setUniform3fArray("specularColorUniformBF",g),o.setUniformf("specularPowerUniformBF",p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===id.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():xl.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===ld.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===id.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===xl.ID_LOW24||t.lastSelectionState===xl.ID_HIGH24);for(let i=sd.Start;i<sd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===sd.TrisEdges||i===sd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(gd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(md),!t.currentInput)return void fd("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n),e.updateMaximumPointCellIds()},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==ud.USE_CELL_DATA&&a!==ud.USE_CELL_FIELD_DATA&&a!==ud.USE_FIELD_DATA&&r.getPointData().getScalars()||a===ud.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));let i=n.getProperty().getInterpolation()!==cd.FLAT?r.getPointData().getNormals():null;null===i&&r.getCellData().getNormals()&&(t.haveCellNormals=!0,i=r.getCellData().getNormals());const s=n.getProperty().getRepresentation();let l=r.getPointData().getTCoords();t.openGLActor.getActiveTextures()||(l=null);let c=!1;if(t.renderable.getColorCoordinates()){l=t.renderable.getColorCoordinates(),c=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=td.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(dd.NEAREST),e.setMagnificationFilter(dd.NEAREST),e.setWrapS(pd.CLAMP_TO_EDGE),e.setWrapT(pd.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),e.deactivate()}const u=`${r.getMTime()}A${s}B${r.getMTime()}C${i?i.getMTime():1}D${o?o.getMTime():1}E${n.getProperty().getEdgeVisibility()}F${l?l.getMTime():1}`;if(t.VBOBuildString!==u){const e={points:r.getPoints(),normals:i,tcoords:l,colors:o,cellOffset:0,vertexOffset:0,useTCoordsPerCell:c,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const a=[{inRep:"verts",cells:r.getVerts()},{inRep:"lines",cells:r.getLines()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()}],d=n.getProperty().getEdgeVisibility()&&s===ld.SURFACE;for(let n=sd.Start;n<sd.End;n++)n!==sd.TrisEdges&&n!==sd.TriStripsEdges?(e.cellOffset+=t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,s,e,t.selectionWebGLIdsToVTKIds),e.vertexOffset+=t.primitives[n].getCABO().getElementCount()):d?t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,ld.WIREFRAME,{...e,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[n].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),t.VBOBuildString=u}t.VBOBuildTime.modified()},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}(e,t)}const yd=Et(Td,"vtkOpenGLPolyDataMapper");var bd={newInstance:yd,extend:Td};en("vtkMapper",yd);const xd=1,{primTypes:Cd}=Bu,{Filter:Sd,Wrap:Ad}=td,{vtkErrorMacro:Id}=jt,wd={type:"StartEvent"},Od={type:"EndEvent"},Pd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const Rd=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pd,n),Xt.extend(e,t,n),od(e,t,n),ad(e,t,n),t.primitives=[],t.primTypes=Cd,t.tmpMat4=g(new Float64Array(16));for(let e=Cd.Start;e<Cd.End;e++)t.primitives[e]=Bu.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);St(e,t,["context"]),t.VBOBuildTime={},vt(t.VBOBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkOpenGLPolyDataMapper2D"),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType("vtkOpenGLActor2D"),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n",e.Geometry=""},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=Cd.Start;e<Cd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{if(e.invokeEvent(wd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Od),!t.currentInput)return void Id("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors(),a=n.getProperty().getRepresentation();let i=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(i=null);let s=!1;if(t.renderable.getColorCoordinates()){i=t.renderable.getColorCoordinates(),s=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=td.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(Sd.NEAREST),e.setMagnificationFilter(Sd.NEAREST),e.setWrapS(Ad.CLAMP_TO_EDGE),e.setWrapT(Ad.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),e.deactivate()}const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${a}B${r.getMTime()}C${o?o.getMTime():1}D${i?i.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=ql.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const c={points:n,tcoords:i,colors:o,cellOffset:0,useTCoordsPerCell:s,haveCellScalars:t.renderable.getAreScalarsMappedFromCells(),customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};c.cellOffset+=t.primitives[Cd.Points].getCABO().createVBO(r.getVerts(),"verts",a,c),c.cellOffset+=t.primitives[Cd.Lines].getCABO().createVBO(r.getLines(),"lines",a,c),c.cellOffset+=t.primitives[Cd.Tris].getCABO().createVBO(r.getPolys(),"polys",a,c),c.cellOffset+=t.primitives[Cd.TriStrips].getCABO().createVBO(r.getStrips(),"strips",a,c),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=Cd.Start;a<Cd.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment,s=["uniform vec3 diffuseColorUniform;","uniform float opacityUniform;"],l=["vec3 diffuseColor = diffuseColorUniform;","float opacity = opacityUniform;"];0!==t.lastBoundBO.getCABO().getColorComponents()?(s=s.concat(["varying vec4 vertexColorVSOutput;"]),o=Pu.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=Pu.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=Pu.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=Pu.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,i=Pu.substitute(i,"//VTK::Color::Impl",l.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result):t.renderable.getAreScalarsMappedFromCells()&&(l=l.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  opacity = opacity*texColor.a;"])),l=l.concat(["gl_FragData[0] = vec4(diffuseColor, opacity);"]),i=Pu.substitute(i,"//VTK::Color::Dec",s).result,i=Pu.substitute(i,"//VTK::Color::Impl",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=Pu.substitute(n,"//VTK::TCoord::Dec",["in float tcoordMC;","out float tcoordVCVSOutput;"]).result,n=Pu.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=Pu.substitute(r,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput[];\n","out float tcoordVCGSOutput;"]).result,r=Pu.substitute(r,["//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=Pu.substitute(o,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=Pu.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result):2===a&&(n=Pu.substitute(n,"//VTK::TCoord::Dec",["in vec2 tcoordMC;","out vec2 tcoordVCVSOutput;"]).result,n=Pu.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=Pu.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];\n","out vec2 tcoordVCGSOutput;"]).result,r=Pu.substitute(r,"//VTK::TCoord::Impl",["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=Pu.substitute(o,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=Pu.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result),t.renderable.getAreScalarsMappedFromCells()&&(r=Pu.substitute(r,"//VTK::PrimID::Impl",["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=Pu.substitute(r,"//VTK::Picking::Dec",["uniform vec3 mapperIndex;","uniform int picking;"]).result,r=Pu.substitute(r,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed("PrimitiveIDOffset")&&e.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),e.getProgram().isAttributeUsed("vertexWC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"vertexWC",e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||Id("Error setting vertexWC in shader VAO.")),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||Id(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed("tcoordMC")&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"tcoordMC",e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||Id("Error setting tcoordMC in shader VAO."):e.getVAO().removeAttributeArray("tcoordMC"),e.getProgram().isAttributeUsed("scalarColor")&&e.getCABO().getColorComponents()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"scalarColor",e.getCABO().getColorOffset(),e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||Id("Error setting scalarColor in shader VAO."):e.getVAO().removeAttributeArray("scalarColor"),t.internalColorTexture&&e.getProgram().isUniformUsed("texture1")&&t.internalColorTexture.getTextureUnit()>-1&&e.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray("mapperIndex",a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi("picking",a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity();t.setUniformf("opacityUniform",o);const a=n.getColor();t.setUniform3fArray("diffuseColorUniform",a)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=xo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=xo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=xo(c[0]-(d[0]-l[0])*p[0]),h=xo(c[1]-(d[1]-l[1])*p[1]),v=-f;let T=-f+s[0];const y=-h;let b=-h+s[1];v===T&&(T=v+1),y===b&&(b=y+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(T-v),x[5]=2/(b-y),x[3]=-1*(T+v)/(T-v),x[7]=-1*(b+y)/(b-y),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===xd?-1:1,x[15]=1,m(x,x),a.setUniformMatrix("WCVCMatrix",(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}(e,t)}),"vtkOpenGLPolyDataMapper2D");en("vtkMapper2D",Rd);const{VectorMode:Md}=il;function Ed(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Vd(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Dd(e,t){return e=>{const t=e.getLastTickBounds(),n=oo().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}const Ld=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),Ht.obj(e,t),Ht.setGet(e,t,["axisTitlePixelOffset","tickLabelPixelOffset","renderable","topTitle","ticks","tickStrings","tickPositions"]),Ht.get(e,t,["lastSize","lastAspectRatio","lastTickBounds","axisTextStyle","tickTextStyle","barActor","tmActor"]),Ht.getArray(e,t,["boxPosition","boxSize"]),Ht.setArray(e,t,["boxPosition","boxSize"],2),t.forceUpdate=!1,t.lastRebuildTime={},Ht.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.barMapper=Fl.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=Uc.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=os.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=Uc.newInstance(),t.tmMapper=Fl.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Hc.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=os.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],function(e,t){t.classHierarchy.push("vtkScalarBarActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left";const n={},r=new Map;let o=0,a=1;Ed(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,Ed(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),"NaN","Below","Above"];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=Po(o),a=Po(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{Ed(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s("NaN",[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s("Below",[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s("ticks",t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s("Above",[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p="vertical"===a?[1,0]:[0,1];"vertical"===a?(d[0]=l.width,d[1]=-l.height,"middle"===o[0]?n[1]-=l.width/2:"right"===o[0]&&(n[1]-=l.width),"middle"===o[1]?n[0]+=l.height/2:"top"===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,"middle"===o[0]?n[0]-=l.width/2:"right"===o[0]&&(n[0]-=l.width),"middle"===o[1]?n[1]-=l.height/2:"top"===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?["right","middle"]:["middle","bottom"];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","top"],"vertical",[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];"ticks"===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,"horizontal",g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),T=e.getTicks(),y=e.getTickStrings(),b=e.getTickPositions();for(let n=0;n<T.length;n++){const o=b?b[n]:(T[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(y[n],r,p,"horizontal",g,c)}const x=Ts.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(x),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Md.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Ts.newInstance({numberOfComponents:i,values:c,name:"Scalars"});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}(e,t)}),"vtkScalarBarActorHelper");function Bd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,function(e){return{automated:!0,autoLayout:null,axisLabel:"Scalar Value",barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif"},tickLabelPixelOffset:14,tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif"},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}(n)),t.autoLayout||(t.autoLayout=Vd(0,t)),t.generateTicks||(t.generateTicks=Dd()),os.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),Ht.setGet(e,t,["automated","autoLayout","axisTitlePixelOffset","axisLabel","scalarsToColors","tickLabelPixelOffset","generateTicks","drawNanAnnotation","drawBelowRangeSwatch","drawAboveRangeSwatch"]),Ht.get(e,t,["axisTextStyle","tickTextStyle"]),Ht.getArray(e,t,["barPosition","barSize","boxPosition","boxSize"]),Ht.setArray(e,t,["barPosition","barSize","boxPosition","boxSize"],2),function(e,t){t.classHierarchy.push("vtkScalarBarActor"),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(Vd(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Dd())}}(e,t)}var Nd={newInstance:Ht.newInstance(Bd,"vtkScalarBarActor"),extend:Bd,newScalarBarActorHelper:Ld};const Fd={};const _d=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fd,n),Xt.extend(e,t,n),t.scalarBarActorHelper=Nd.newScalarBarActorHelper(),function(e,t){t.classHierarchy.push("vtkOpenGLScalarBarActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}(e,t)}),"vtkOpenGLScalarBarActor");en("vtkScalarBarActor",_d);const{vtkErrorMacro:Gd}=jt,kd={context:null};const Ud=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kd,n),Xt.extend(e,t,n),t.openGLTexture=td.newInstance(),t.tris=Bu.newInstance(),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},St(e,t,["context"]),yt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLSkybox"),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi("sbtexture",n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix("IMCPCMatrix",a),"box"===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f("camPos",e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Ts.newInstance({numberOfComponents:3,values:e});n.setName("points");const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Ts.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,"polys",qi.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),"box"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }","")),"background"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }","")),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),"vertexMC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Gd("Error setting vertexMC in shader VAO."));const e=t.renderable.getTextures();e.length||Gd("vtkSkybox requires a texture map"),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}(e,t)}));en("vtkSkybox",Ud);const{FieldAssociations:zd}=_s,Wd={fieldAssociation:zd.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function Hd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wd,n),Ht.obj(e,t),Ht.setGet(e,t,["fieldAssociation","captureZValues"]),function(e,t){t.classHierarchy.push("vtkHardwareSelector"),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}(e,t)}var jd={newInstance:Ht.newInstance(Hd,"vtkHardwareSelector"),extend:Hd};const Kd={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function $d(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kd,n),vt(e,t),t.colorBuffers&&tt("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."),t.colorBuffers=[],At(e,t,["colorBuffers"]),function(e,t){t.classHierarchy.push("vtkFramebuffer"),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void tt("you must set the OpenGLRenderWindow before calling saveCurrentBindings");const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void tt("you must set the OpenGLRenderWindow before calling restorePreviousBindings");const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;null===n&&(n=t.context.FRAMEBUFFER),t.context.bindFramebuffer(n,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):tt("you must set the OpenGLRenderWindow before calling create")},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void tt("you must set the OpenGLRenderWindow before calling setColorBuffer");let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void tt("Using multiple framebuffer attachments requires WebGL 2");o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void tt("you must set the OpenGLRenderWindow before calling removeColorBuffer");let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void tt("Using multiple framebuffer attachments requires WebGL 2");r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else tt("Attaching depth buffer textures to fbo requires WebGL 2");else tt("you must set the OpenGLRenderWindow before calling setDepthBuffer")},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else tt("Attaching depth buffer textures to framebuffers requires WebGL 2");else tt("you must set the OpenGLRenderWindow before calling removeDepthBuffer")},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>null==t.glFramebuffer?null:[t.glFramebuffer.width,t.glFramebuffer.height],e.populateFramebuffer=()=>{if(!t.context)return void tt("you must set the OpenGLRenderWindow before calling populateFrameBuffer");e.bind();const n=t.context,r=td.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(Fu.LINEAR),r.setMagnificationFilter(Fu.LINEAR),r.create2DFromRaw({width:t.glFramebuffer.width,height:t.glFramebuffer.height,numComps:4,dataType:is.UNSIGNED_CHAR,data:null}),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}(e,t)}var qd={newInstance:Et($d,"vtkFramebuffer"),extend:$d};const Xd={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function Yd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xd,n),Ht.obj(e,t),t.properties={},Ht.setGet(e,t,["contentType","fieldType","properties","selectionList"]),function(e,t){t.classHierarchy.push("vtkSelectionNode"),e.getBounds=()=>t.points.getBounds()}(e,t)}var Zd={newInstance:Ht.newInstance(Yd,"vtkSelectionNode"),extend:Yd,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:Qd}=Cl,{SelectionContent:Jd,SelectionField:ep}=Zd,{FieldAssociations:tp}=_s,{vtkErrorMacro:np}=Ht;function rp(e){return`${e.propID} ${e.compositeID}`}function op(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function ap(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function ip(e,t){let n=t;return n<<=24,n|=e,n}function sp(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=ap(n[0],n[1],e.pixBuffer[Qd.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=ap(n[0],n[1],e.pixBuffer[Qd.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[Qd.ID_LOW24]&&0===op(n[0],n[1],e.pixBuffer[Qd.ID_LOW24],e.area))return a;const s=ap(n[0],n[1],e.pixBuffer[Qd.ID_LOW24],e.area),l=ap(n[0],n[1],e.pixBuffer[Qd.ID_HIGH24],e.area);return a.attributeID=ip(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=sp(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=sp(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=sp(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=sp(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=sp(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function lp(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=Zd.newInstance();switch(l.setContentType(Jd.INDICES),e){case tp.FIELD_ASSOCIATION_CELLS:l.setFieldType(ep.CELL);break;case tp.FIELD_ASSOCIATION_POINTS:l.setFieldType(ep.POINT);break;default:np("Unknown field association")}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}const cp={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function up(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cp,n),jd.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),Ht.setGetArray(e,t,["area"],4),Ht.setGet(e,t,["_renderer","currentPass","_openGLRenderWindow","maximumPointId","maximumCellId"]),Ht.setGetArray(e,t,["propColorValue"],3),Ht.moveToProtected(e,t,["renderer","openGLRenderWindow"]),Ht.event(e,t,"event"),function(e,t){t.classHierarchy.push("vtkOpenGLHardwareSelector"),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e&&e[0]===n[0]&&e[1]===n[1]?t.framebuffer.bind():(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer())}else t.framebuffer=qd.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===tp.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=sp(e,[n,t],0,u);if(r&&r.valid){const t=rp(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return lp(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return np("Renderer and view must be set before calling Select."),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:"StartEvent"}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();e.beginSelection();const r=[];for(t.currentPass=Qd.MIN_KNOWN_PASS;t.currentPass<=Qd.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===Qd.ACTOR_PASS&&"function"==typeof n[0].requestDepth&&"function"==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),r.push(t.currentPass));return r.forEach((n=>{t.currentPass=n,e.processPixelBuffers()})),t.currentPass=Qd.MAX_KNOWN_PASS,e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:"EndEvent"}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===Qd.ID_HIGH24){if(t.fieldAssociation===tp.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===tp.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===Qd.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if("function"==typeof e[0].requestDepth&&"function"==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=ap(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===Qd.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===Qd.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>Ht.enumToString(Qd,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=ap(e[0],e[1],t.pixBuffer[Qd.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=ap(e[0],e[1],t.pixBuffer[Qd.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[Qd.ID_LOW24]&&0===op(e[0],e[1],t.pixBuffer[Qd.ID_LOW24],t.area))return a;const s=ap(e[0],e[1],t.pixBuffer[Qd.ID_LOW24],t.area),l=ap(e[0],e[1],t.pixBuffer[Qd.ID_HIGH24],t.area);return a.attributeID=ip(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=rp(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return lp(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}(e,t)}var dp={newInstance:Ht.newInstance(up,"vtkOpenGLHardwareSelector"),extend:up,...Cl};const{vtkErrorMacro:pp}=jt,{Representation:fp}=ts,{ObjectType:gp}=mu,{PassTypes:mp}=dp,hp={type:"StartEvent"},vp={type:"EndEvent"},Tp={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const yp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tp,n),bd.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},vt(t.glyphBOBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkOpenGLGlyph3DMapper");const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(hp),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(vp),!t.currentInput)return void pp("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension("ANGLE_instanced_arrays"),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],T=t[14],y=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*T,e[3]=b*s+x*d+C*m+S*y,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*T,e[7]=b*s+x*d+C*m+S*y,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*T,e[11]=b*s+x*d+C*m+S*y,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*T,e[15]=b*s+x*d+C*m+S*y},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=Pu.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","attribute mat3 gNormal;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=Pu.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity"];a&&(i=i.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let s=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];a&&(s=s.concat(["  vec3 specularColor;","  float specularPower;"])),s=s.concat(["  opacity = opacityUniform;"]),a&&(s=s.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),t.drawingEdges||(i=i.concat(["varying vec4 vertexColorVSOutput;"]),n=Pu.substitute(n,"//VTK::Color::Dec",["attribute vec4 gColor;","varying vec4 vertexColorVSOutput;"]).result,n=Pu.substitute(n,"//VTK::Color::Impl",["vertexColorVSOutput = gColor;"]).result,r=Pu.substitute(r,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,r=Pu.substitute(r,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,s=s.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])),o=Pu.substitute(o,"//VTK::Color::Impl",s).result,o=Pu.substitute(o,"//VTK::Color::Dec",i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(n=Pu.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","vertexVCVSOutput = MCVCMatrix * gVertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result,n=Pu.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result):(n=Pu.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;"]).result,n=Pu.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=Pu.substitute(n,"//VTK::Picking::Dec",["attribute vec3 mapperIndexVS;","varying vec3 mapperIndexVSOutput;"]).result,n=Pu.substitute(n,"//VTK::Picking::Impl","  mapperIndexVSOutput = mapperIndexVS;").result,e.Vertex=n,t=Pu.substitute(t,"//VTK::Picking::Dec",["varying vec3 mapperIndexVSOutput;","uniform vec3 mapperIndex;","uniform int picking;"]).result,t=Pu.substitute(t,"//VTK::Picking::Impl",["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);","  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],T=n[r+1],y=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+T*d+y*g,o[1]=v*i+T*p+y*m,o[2]=v*c+T*f+y*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3("normalMatrix",t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix("MCPCMatrix",t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix("MCVCMatrix",t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray("ambientColorUniform",t.tmpColor),u.setUniform3fArray("diffuseColorUniform",t.tmpColor)}c&&u.setUniform3fArray("mapperIndex",c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===fp.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),y(t.mcpcMatrix,s.wcpc,l.mcwc),y(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===mp.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed("normalMatrix"),v=g.isUniformUsed("MCVCMatrix");if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed("gMatrix")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,"gMatrix",0,64,t.context.FLOAT,4,!1,1)||pp("Error setting gMatrix in shader VAO."):e.getVAO().removeAttributeArray("gMatrix"),e.getProgram().isAttributeUsed("gNormal")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,"gNormal",0,36,t.context.FLOAT,3,!1,1)||pp("Error setting gNormal in shader VAO."):e.getVAO().removeAttributeArray("gNormal"),e.getProgram().isAttributeUsed("gColor")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,"gColor",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pp("Error setting gColor in shader VAO."):e.getVAO().removeAttributeArray("gColor"),e.getProgram().isAttributeUsed("mapperIndexVS")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,"mapperIndexVS",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pp("Error setting mapperIndexVS in shader VAO."):e.getVAO().removeAttributeArray("mapperIndexVS"),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=mu.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=mu.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=mu.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=mu.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,gp.ARRAY_BUFFER),t.normalBuffer.upload(n,gp.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),gp.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,gp.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}(e,t)}),"vtkOpenGLGlyph3DMapper");en("vtkGlyph3DMapper",yp);const{vtkErrorMacro:bp}=Ht;class xp{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}const Cp={};function Sp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cp,n),Ht.obj(e,t),Ht.algo(e,t,1,1),function(e,t){t.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"),e.requestData=(e,t)=>{const n=e[0];if(!n)return void bp("Invalid or missing input");const r=Uc.newInstance();r.shallowCopy(n);const o=new xp,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(Wl.newInstance({values:c,name:"faces"})),t[0]=r}}(e,t)}var Ap={newInstance:Ht.newInstance(Sp,"vtkClosedPolyLineToSurfaceFilter"),extend:Sp};const{vtkErrorMacro:Ip}=jt;function wp(e,t){t.classHierarchy.push("vtkCutter");const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void Ip("Invalid or missing input");if(!t.cutFunction)return void Ip("Missing cut function");const o=Uc.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=e.getPointData(),i=r.getNumberOfPoints(),s=[],l=[],c=[],u={},d=a.getNumberOfArrays();for(let e=0;e<d;e++)u[a.getArrayName(e)]=[];(!t.cutScalars||t.cutScalars.length<i)&&(t.cutScalars=new Float32Array(i));let p=0,f=0;for(;p<o.length;)t.cutScalars[f++]=t.cutFunction.evaluateFunction(o[p++],o[p++],o[p++]);const g=[],m=new Array(3),h=new Array(3),v=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error("Iterator is done");r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)v[e]=t.cutScalars[n.cell[e++]];const e=v[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(v[t]>0!==e){r=!1;break}if(r)continue;const i=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,s=v[e]>0;if(v[r]>0===s)continue;let l=e,c=r,u=v[c]-v[l];u<=0&&(l=r,c=e,u*=-1);let p=0;0!==u&&(p=(t.cutValue-v[l])/u);const f=n.cell[l],g=n.cell[c];m[0]=o[3*f],m[1]=o[3*f+1],m[2]=o[3*f+2],h[0]=o[3*g],h[1]=o[3*g+1],h[2]=o[3*g+2];const T=[m[0]+p*(h[0]-m[0]),m[1]+p*(h[1]-m[1]),m[2]+p*(h[2]-m[2])],y={};for(let e=0;e<d;e++){const t=a.getArrayByIndex(e),n=a.getArrayName(e),r=t.getData(),o=t.getNumberOfComponents(),i=new Array(o);for(let e=0;e<o;e++){const t=r[o*f+e],n=r[o*g+e];i.push(t+p*(n-t))}y[n]=i}i.push({pointEdge1:f,pointEdge2:g,intersectedPoint:T,intersectedArrays:y,newPointID:-1})}for(let e=0;e<i.length;e++){const t=i[e];let n=!1;for(let r=0;r<g.length;r++){const o=g[r],a=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(a||s){n=!0,i[e].newPointID=g[r].newPointID;break}}n||(s.push(t.intersectedPoint[0]),s.push(t.intersectedPoint[1]),s.push(t.intersectedPoint[2]),Object.keys(t.intersectedArrays).forEach((e=>{u[e].push(...t.intersectedArrays[e])})),i[e].newPointID=s.length/3-1,g.push(i[e]))}const p=i.length;2===p?l.push(p,i[0].newPointID,i[1].newPointID):p>2&&(c.push(p),i.forEach((e=>{c.push(e.newPointID)})))}n.getPoints().setData(st(r.getDataType(),s),3);const T=n.getPointData();for(let e=0;e<d;e++){const t=a.getArrayName(e),n=Ts.newInstance({name:t,values:u[t],numberOfComponents:a.getArrayByIndex(e).getNumberOfComponents()});T.addArray(n)}0!==l.length&&n.getLines().setData(Uint16Array.from(l)),0!==c.length&&n.getPolys().setData(Uint16Array.from(c))})(r,o),n[0]=o}}const Op={cutFunction:null,cutScalars:null,cutValue:0};function Pp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Op,n),vt(e,t),Pt(e,t,1,1),St(e,t,["cutFunction","cutValue"]),wp(e,t)}var Rp={newInstance:Et(Pp,"vtkCutter"),extend:Pp};const Mp=e=>e,Ep=1e-6;class Vp{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:Mp}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);vn(n,e[0],e[1],e[2]),vn(r,t[0],t[1],t[2]),Sn(n,n),Sn(r,r);const a=An(n,r);return a>=1||(In(this.tmp,n,r),mn(this.tmp)<Ep&&(In(this.tmp,[1,0,0],e),mn(this.tmp)<Ep&&In(this.tmp,[0,1,0],e)),P(o,Math.acos(a),this.tmp),y(this.matrix,this.matrix,o)),this}rotate(e,t){return vn(this.tmp,...t),Sn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return vn(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return vn(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return y(this.matrix,this.matrix,e),this}multiply3x3(e){return y(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(Yo(so,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)vn(this.tmp,e[n],e[n+1],e[n+2]),wn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var Dp=function(){return new Vp(!0)},Lp=function(){return new Vp(!1)};const Bp=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],Np=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22],Fp={xLength:1,yLength:1,zLength:1,pointType:"Float64Array",generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function _p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fp,n),Ht.obj(e,t),Ht.setGet(e,t,["xLength","yLength","zLength","generate3DTextureCoordinates","generateFaces","generateLines"]),Ht.setGetArray(e,t,["center","rotations"],3),Ht.setGetArray(e,t,["matrix"],16),t._polys=Wl.newInstance({values:Uint16Array.from(Np)}),t._lineCells=Wl.newInstance({values:Uint16Array.from(Bp)}),Ht.moveToProtected(e,t,["polys","lineCells"]),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkCubeSource"),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=Uc.newInstance();n[0]=r;const o=Ht.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=Ht.newTypedArray(t.pointType,72),i=Ts.newInstance({name:"Normals",values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=Ht.newTypedArray(t.pointType,24*s),c=Ts.newInstance({name:"TextureCoordinates",values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&Dp().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Lp().translate(...t.center).apply(o),t.matrix){Lp().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Lp().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}(e,t)}var Gp={newInstance:Ht.newInstance(_p,"vtkCubeSource"),extend:_p};const{vtkErrorMacro:kp}=Ht,Up={};function zp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Up,n),Ht.obj(e,t),Ht.algo(e,t,1,1),t._cubeSource=Gp.newInstance(),Ht.moveToProtected(e,t,["cubeSource","tmpOut"]),function(e,t){t.classHierarchy.push("vtkImageDataOutlineFilter");const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA("vtkImageData"))return void kp("Invalid or missing input");const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):kp("Unable to fetch spatial extents of input image.")},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}(e,t)}var Wp={newInstance:Ht.newInstance(zp,"vtkImageDataOutlineFilter"),extend:zp};const{vtkWarningMacro:Hp}=Ht;let jp;const Kp={preMultiplyFlag:!1,matrix:[...so]};function $p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kp,n),Ht.obj(e,t),Ht.setGet(e,t,["preMultiplyFlag"]),Ht.setGetArray(e,t,["matrix"],16),function(e,t){t.classHierarchy.push("vtkAbstractTransform","vtkHomogeneousTransform","vtkTransform"),e.transformPoint=(e,n)=>(wn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],wn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?y(n,t.matrix,e):y(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>y(o,t.matrix,r):()=>y(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>jp({matrix:La.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag}),e.translate=(n,r,o)=>{if(0===n&&0===r&&0===o)return;const a=c();w(a,[n,r,o]),t.preMultiplyFlag?y(t.matrix,t.matrix,a):y(t.matrix,a,t.matrix),e.modified()},e.rotateWXYZ=(n,r,o,a)=>{if(0===r&&0===o&&0===a)return void Hp("No rotation applied, axis is zero vector.");if(0===n)return;const i=La.radiansFromDegrees(n),s=Na();Fa(s,[r,o,a],i);const l=new Float64Array(16);G(l,s),t.preMultiplyFlag?y(t.matrix,t.matrix,l):y(t.matrix,l,t.matrix),e.modified()},e.rotateX=t=>{e.rotateWXYZ(t,1,0,0)},e.rotateY=t=>{e.rotateWXYZ(t,0,1,0)},e.rotateZ=t=>{e.rotateWXYZ(t,0,0,1)},e.scale=(n,r,o)=>{if(1===n&&1===r&&1===o)return;const a=c();O(a,[n,r,o]),t.preMultiplyFlag?y(t.matrix,t.matrix,a):y(t.matrix,a,t.matrix),e.modified()},e.transformNormal=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const o=se(ie(),t.matrix),a=ie();ge(a,o);const i=ie();return fe(i,a),e.transformVector(n,r,i),La.normalize(r),r},e.transformNormals=(n,r)=>{const o=n.getData(),a=r.getData(),i=[0,0,0],s=se(ie(),t.matrix),l=ie();ge(l,s);const c=ie();fe(c,l);for(let t=0;t<o.length;t+=3)i[0]=o[t],i[1]=o[t+1],i[2]=o[t+2],e.transformVector(i,i,c),La.normalize(i),a[t]=i[0],a[t+1]=i[1],a[t+2]=i[2]},e.transformVector=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return On(n,e,(arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)||se(ie(),t.matrix)),n},e.transformVectors=(t,n)=>{const r=t.getData(),o=n.getData(),a=[0,0,0];for(let t=0;t<r.length;t+=3)a[0]=r[t],a[1]=r[t+1],a[2]=r[t+2],e.transformVector(a,a),La.normalize(a),o[t]=a[0],o[t+1]=a[1],o[t+2]=a[2]},e.transformPointsNormalsVectors=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;const c=t.getNumberOfPoints(),u=s?.length??0,d=new Float64Array(3),p=new Float64Array(3),f=new Float64Array(3),g=new Float64Array(3);let m=!1,h=!1,v=!1;const T=[];for(let y=0;y<c;y++){if(t.getPoint(y,d),p.set(d),e.transformPoint(d,d),n.setPoint(y,...d),La.areEquals(p,d)||(m=!0),a){const t=a.getData(),n=i.getData();d[0]=t[3*y],d[1]=t[3*y+1],d[2]=t[3*y+2],f.set(d),e.transformVector(d,d),n[3*y]=d[0],n[3*y+1]=d[1],n[3*y+2]=d[2],La.areEquals(f,d)||(h=!0)}if(r){const t=r.getData(),n=o.getData();d[0]=t[3*y],d[1]=t[3*y+1],d[2]=t[3*y+2],g.set(d),e.transformNormal(d,d),n[3*y]=d[0],n[3*y+1]=d[1],n[3*y+2]=d[2],La.areEquals(g,d)||(v=!0)}if(s)for(let t=0;t<u;t++){const n=s[t].getData(),r=l[t].getData();d[0]=n[3*y],d[1]=n[3*y+1],d[2]=n[3*y+2],f.set(d),e.transformVector(d,d),r[3*y]=d[0],r[3*y+1]=d[1],r[3*y+2]=d[2],La.arrayEqual(f,d)||T.includes(t)||T.push(t)}}m&&n.modified(),h&&i.modified(),v&&o.modified(),T.forEach((e=>l[e].modified()))}}(e,t)}jp=Ht.newInstance($p,"vtkTransform");var qp={newInstance:jp,extend:$p};function Xp(e,t,n){return e.length>0?`${e.map((e=>e?.getMTime()??"x")).join("/")}-${t}-${n}`:"0"}function Yp(e,t){return`${t.getMTime()}`}const Zp={NEAREST:0,LINEAR:1};var Qp={InterpolationType:Zp};const{vtkErrorMacro:Jp}=jt;function ef(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}const tf={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastNumberOfComponents:0,lastMultiTexturePerVolumeEnabled:!1,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,scalarTextures:[],_scalarTexturesCore:[],colorTexture:null,_colorTextureCore:null,pwfTexture:null,_pwfTextureCore:null,_externalOpenGLTexture:!1,resliceGeom:null,resliceGeomUpdateString:null,tris:null};const nf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tf,n),Xt.extend(e,t,n),od(e,t,n),ad(e,t,n),t.tris=Bu.newInstance(),t.scalarTextures=[],t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},vt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=Wp.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=Uc.newInstance(),t.cutter=Rp.newInstance(),t.lineToSurfaceFilter=Ap.newInstance(),t.transform=qp.newInstance(),yt(e,t,["scalarTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLImageResliceMapper");const n=new Map;function o(t,r,o){r!==o&&(function(t,r){if(!r)return;const o=(n.get(r)??0)-1;o<=0?(t.unregisterGraphicsResourceUser(r,e),n.delete(r)):n.set(r,o)}(t,r),function(t,r){if(!r)return;const o=n.get(r)??0,a=o+1;n.set(r,a),o<=0&&t.registerGraphicsResourceUser(r,e)}(t,o))}function a(t){[...n.keys()].forEach((n=>t.unregisterGraphicsResourceUser(n,e)))}e.buildPass=n=>{if(n){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const n=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera());const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&a(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==dl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update();const o=t.renderable.getNumberOfInputPorts();t.currentValidInputs=[];for(let e=0;e<o;++e){const n=t.renderable.getInputData(e);n&&!n.isDeleted()&&t.currentValidInputs.push({imageData:n,inputIndex:e})}const a=t.currentValidInputs.length;if(a<=0)return void Jp("No input!");const i=t.currentValidInputs[0].imageData.getPointData().getScalars();t.multiTexturePerVolumeEnabled=a>1,t.numberOfComponents=t.multiTexturePerVolumeEnabled?a:i.getNumberOfComponents(),e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:"EndEvent"})},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r);const o=r.getProperties();t.currentValidInputs.forEach((e=>{let{inputIndex:n}=e;const r=o[n].getInterpolationType(),a=t.scalarTextures[n];r===Zp.NEAREST?(a.setMinificationFilter(Fu.NEAREST),a.setMagnificationFilter(Fu.NEAREST)):(a.setMinificationFilter(Fu.LINEAR),a.setMagnificationFilter(Fu.LINEAR))}));const a=t.currentValidInputs[0];o[a.inputIndex].getInterpolationType()===Zp.NEAREST?(t.colorTexture.setMinificationFilter(Fu.NEAREST),t.colorTexture.setMagnificationFilter(Fu.NEAREST),t.pwfTexture.setMinificationFilter(Fu.NEAREST),t.pwfTexture.setMagnificationFilter(Fu.NEAREST)):(t.colorTexture.setMinificationFilter(Fu.LINEAR),t.colorTexture.setMagnificationFilter(Fu.LINEAR),t.pwfTexture.setMinificationFilter(Fu.LINEAR),t.pwfTexture.setMagnificationFilter(Fu.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context,a=[...t.scalarTextures,t.colorTexture,t.pwfTexture];a.forEach((e=>e.activate())),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),a.forEach((e=>e.deactivate()))},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty(t.currentValidInputs[0].inputIndex)?.getMTime()||t.currentValidInputs.some((e=>{let{imageData:n}=e;return t.VBOBuildTime.getMTime()<n.getMTime()}))||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime()||t.scalarTextures.length!==t.currentValidInputs.length||!t.scalarTextures.every((e=>!!e?.getHandle()))||!t.colorTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(e,n)=>{const r=n.getProperties();t.currentValidInputs.forEach(((e,n)=>{let{imageData:a}=e;const i=a.getPointData().getScalars(),s=t._openGLRenderWindow.getGraphicsResourceForObject(i),l=Yp(0,i),c=!s?.oglObject?.getHandle()||s?.hash!==l,u=r[n],d=u.getUpdatedExtents(),p=!!d.length;if(c&&!p){const e=td.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);const r=a.getDimensions();e.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),e.resetFormatAndType(),e.create3DFilterableFromDataArray({width:r[0],height:r[1],depth:r[2],dataArray:i}),t._openGLRenderWindow.setGraphicsResourceForObject(i,e,l),t.scalarTextures[n]=e}else t.scalarTextures[n]=s.oglObject;if(p){u.setUpdatedExtents([]);const e=a.getDimensions();t.scalarTextures[n].create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:i,updatedExtents:d})}o(t._openGLRenderWindow,t._scalarTexturesCore[n],i),t._scalarTexturesCore[n]=i}));const a=t.currentValidInputs[0],i=r[a.inputIndex],s=i.getIndependentComponents(),l=s?t.numberOfComponents:1,c=s?2*l:1,u=[];for(let e=0;e<l;++e)u.push(i.getRGBTransferFunction(e));const d=Xp(u,s,l),p=i.getRGBTransferFunction(),f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.oglObject?.getHandle()&&f?.hash===d)t.colorTexture=f.oglObject;else{let e=t.renderable.getColorTextureWidth();e<=0&&(e=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const n=new Uint8ClampedArray(e*c*3),r=td.newInstance();if(r.setOpenGLRenderWindow(t._openGLRenderWindow),p){const t=new Float32Array(3*e);for(let r=0;r<l;r++){const o=i.getRGBTransferFunction(r),a=o.getRange();if(o.getTable(a[0],a[1],e,t,1),s)for(let o=0;o<3*e;o++)n[r*e*6+o]=255*t[o],n[r*e*6+o+3*e]=255*t[o];else for(let o=0;o<3*e;o++)n[r*e*3+o]=255*t[o]}r.resetFormatAndType(),r.create2DFromRaw({width:e,height:c,numComps:3,dataType:is.UNSIGNED_CHAR,data:n})}else{for(let t=0;t<3*e;++t){const r=255*t/(3*(e-1));for(let o=0;o<c;++o)n[o*e*3+t+0]=r,n[o*e*3+t+1]=r,n[o*e*3+t+2]=r}r.resetFormatAndType(),r.create2DFromRaw({width:e,height:1,numComps:3,dataType:is.UNSIGNED_CHAR,data:n})}p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,r,d),t.colorTexture=r}o(t._openGLRenderWindow,t._colorTextureCore,p),t._colorTextureCore=p;const g=[];for(let e=0;e<l;++e)g.push(i.getPiecewiseFunction(e));const m=Xp(g,s,l),h=i.getPiecewiseFunction(),v=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(v?.oglObject?.getHandle()&&v?.hash===m)t.pwfTexture=v.oglObject;else{let e=t.renderable.getOpacityTextureWidth();e<=0&&(e=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const n=e*c,r=new Uint8ClampedArray(n),o=td.newInstance();if(o.setOpenGLRenderWindow(t._openGLRenderWindow),h){const t=new Float32Array(n),r=new Float32Array(e);for(let n=0;n<l;++n){const o=i.getPiecewiseFunction(n);if(null===o)t.fill(1);else{const a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),s)for(let o=0;o<e;o++)t[n*e*2+o]=r[o],t[n*e*2+o+e]=r[o];else for(let n=0;n<e;n++)t[n]=r[n]}}o.resetFormatAndType(),o.create2DFromRaw({width:e,height:c,numComps:1,dataType:is.FLOAT,data:t})}else r.fill(255),o.resetFormatAndType(),o.create2DFromRaw({width:e,height:c,numComps:1,dataType:is.UNSIGNED_CHAR,data:r});h&&t._openGLRenderWindow.setGraphicsResourceForObject(h,o,m),t.pwfTexture=o}o(t._openGLRenderWindow,t._pwfTextureCore,h),t._pwfTextureCore=h;const T=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==T){const e=Ts.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName("points");const n=Ts.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:Jp("Slab mode requested without normals")}t.tris.getCABO().createVBO(n,"polys",qi.SURFACE,r)}t.VBOBuildString=T,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.currentValidInputs[0].imageData;if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){t.scalarTextures.forEach(((e,t)=>{a.setUniformi(`volumeTexture[${t}]`,e.getTextureUnit())})),a.isAttributeUsed("vertexWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexWC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Jp("Error setting vertexWC in shader VAO.")),a.isAttributeUsed("normalWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"normalWC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Jp("Error setting normalWC in shader VAO.")),a.isUniformUsed("slabThickness")&&a.setUniformf("slabThickness",t.renderable.getSlabThickness()),a.isUniformUsed("spacing")&&a.setUniform3fv("spacing",i.getSpacing()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabTrapezoid")&&a.setUniformi("slabTrapezoid",t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed("WCTCMatrix")){const n=i.getDimensions();d(t.tmpMat4,i.getIndexToWorld()),b(t.tmpMat4,t.tmpMat4,[-.5,-.5,-.5]),x(t.tmpMat4,t.tmpMat4,n),h(t.tmpMat4,t.tmpMat4),e&&y(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix("WCTCMatrix",t.tmpMat4)}a.isUniformUsed("vboScaling")&&a.setUniform3fv("vboScaling",n.getCABO().getCoordScale()??[1,1,1]),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed("MCPCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCPCMatrix",ef([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed("MCVCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCVCMatrix",ef([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(t.currentValidInputs[0].inputIndex),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.numberOfComponents,l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));for(let e=0;e<s;e++){const n=t.multiTexturePerVolumeEnabled,r=n?e:0,i=n?0:e,s=t.scalarTextures[r].getVolumeInfo(),c=s.scale[i],u=s.offset[i],d=l?e:0;let p=a.getColorWindow(),f=a.getColorLevel();const g=a.getRGBTransferFunction(d);if(g&&a.getUseLookupTableScalarRange()){const e=g.getRange();p=e[1]-e[0],f=.5*(e[1]+e[0])}const m=c/p,h=(u-f)/p+.5;o.setUniformf(`cshift${e}`,h),o.setUniformf(`cscale${e}`,m);let v=1,T=0;const y=a.getPiecewiseFunction(d);if(y){const e=y.getRange(),t=e[1]-e[0];v=c/t,T=(u-.5*(e[0]+e[1]))/t+.5}o.setUniformf(`pwfshift${e}`,T),o.setUniformf(`pwfscale${e}`,v)}const c=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",u),o.setUniform4fv("backgroundColor",t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=r.getProperty(t.currentValidInputs[0].inputIndex).getIndependentComponents(),a=t.renderable.getSlabThickness(),i=t.renderable.getSlabType(),s=t.renderable.getSlabTrapezoidIntegration();let l=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(l=!0),!(!l&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&t.lastNumberOfComponents===t.numberOfComponents&&t.lastMultiTexturePerVolumeEnabled===t.multiTexturePerVolumeEnabled&&0!==e.getProgram()?.getHandle()&&t.lastIndependentComponents===o&&t.lastSlabThickness===a&&t.lastSlabType===i&&t.lastSlabTrapezoidIntegration===s||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastNumberOfComponents=t.numberOfComponents,t.lastMultiTexturePerVolumeEnabled=t.multiTexturePerVolumeEnabled,t.lastIndependentComponents=o,t.lastSlabThickness=a,t.lastSlabType=i,t.lastSlabTrapezoidIntegration=s,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=Pu.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=Pu.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=Pu.substitute(o,"//VTK::TCoord::Dec",["uniform mat4 WCTCMatrix;","out vec3 fragTexCoord;"]).result,o=Pu.substitute(o,"//VTK::TCoord::Impl",["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"]).result;const l=t.numberOfComponents,c=r.getProperty(t.currentValidInputs[0].inputIndex).getIndependentComponents();let u=["in vec3 fragTexCoord;",`uniform highp sampler3D volumeTexture[${t.scalarTextures.length}];`,"uniform mat4 WCTCMatrix;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;"];if(u.push("vec4 rawSampleTexture(vec3 pos) {"),t.multiTexturePerVolumeEnabled){u.push("vec4 rawSample;");for(let e=0;e<t.scalarTextures.length;++e)u.push(`rawSample[${e}] = texture(volumeTexture[${e}], pos)[0];`);u.push("return rawSample;","}")}else u.push("return texture(volumeTexture[0], pos);","}");if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:u=u.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Jp("Unsupported number of independent coordinates.")}}s>0&&(u=u.concat(["uniform vec3 spacing;","uniform float slabThickness;","uniform int slabType;","uniform int slabTrapezoid;","uniform vec3 vboScaling;"]),u=u.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)","{","  vec4 retVal = vec4(1.0);","  if (slabType == 0) // min","  {","    retVal = min(currVal, valToComp);","  }","  else if (slabType == 1) // max","  {","    retVal = max(currVal, valToComp);","  }","  else if (slabType == 3) // sum","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  else // mean","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  return retVal;","}"])),i=Pu.substitute(i,"//VTK::TCoord::Dec",u).result;let d=["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}","vec4 tvalue = rawSampleTexture(fragTexCoord);"];if(s>0&&(d=d.concat(["// Get the first and last samples","int numSlices = 1;","float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;","vec3 normalxspacing = scaling * normalWCVSOutput;","float distTraveled = length(normalxspacing);","int trapezoid = 0;","while (distTraveled < slabThickness * 0.5)","{","  distTraveled += length(normalxspacing);","  float fnumSlices = float(numSlices);","  if (distTraveled > slabThickness * 0.5)","  {","    // Before stepping outside the slab, sample at the boundaries","    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;","    trapezoid = slabTrapezoid;","  }","  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = rawSampleTexture(fragTCoordNeg);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = rawSampleTexture(fragTCoordPos);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","}","// Finally, if slab type is *mean*, divide the sum by the numSlices","if (slabType == 2)","{","  tvalue = tvalue / float(numSlices);","}"])),c){const e=["r","g","b","a"];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:d=d.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Jp("Unsupported number of independent coordinates.")}}else switch(l){case 1:d=d.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:d=d.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=Pu.substitute(i,"//VTK::TCoord::Impl",d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=["attribute vec4 vertexWC;"];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat(["attribute vec3 normalWC;","varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),a=Pu.substitute(a,"//VTK::PositionVC::Dec",c).result;let u=["gl_Position = MCPCMatrix * vertexWC;"];l>0&&(u=u.concat(["normalWCVSOutput = normalWC;","vertexWCVSOutput = vertexWC;"])),a=Pu.substitute(a,"//VTK::PositionVC::Impl",u).result,a=Pu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result;let d=[];l>0&&(d=d.concat(["varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),s=Pu.substitute(s,"//VTK::PositionVC::Dec",d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e="";const n=t.currentValidInputs[0].imageData,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`);const t=ie();n&&(e=e.concat(`Image${n.getMTime()}`),de(t,...n.getDirection()),ge(t,t));const r=[...s.getNormal()];On(r,r,t),[o,a]=function(e){La.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=La.dot(e,t);if(o<-.999999||o>.999999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ti.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=Uc.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getSpatialExtent();let l=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[l+a]=r[a],e[l+o[0]]=i[2*o[0]+n],e[l+o[1]]=i[2*o[1]+t],l+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const c=new Uint16Array(8);c[0]=3,c[1]=0,c[2]=1,c[3]=3,c[4]=3,c[5]=0,c[6]=3,c[7]=2;const u=s.getNormal();La.normalize(u);const d=new Float32Array(12);for(let e=0;e<4;++e)d[3*e]=u[0],d[3*e+1]=u[1],d[3*e+2]=u[2];t.resliceGeom||(t.resliceGeom=Uc.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(c,1);const p=Ts.newInstance({numberOfComponents:3,values:d,name:"Normals"});t.resliceGeom.getPointData().setNormals(p)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=Uc.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();La.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Ts.newInstance({numberOfComponents:3,values:a,name:"Normals"});t.resliceGeom.getPointData().setNormals(i)}else Jp("Something went wrong.","A default slice plane should have been created in the beginning of","updateResliceGeometry.");t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setScalarTextures=e=>{t.scalarTextures=[...e],t._externalOpenGLTexture=!0},e.delete=Vt((()=>{t._openGLRenderWindow&&a(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageResliceMapper");en("vtkImageResliceMapper",nf);var rf={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:of}=jt,{SlicingMode:af}=rf;function sf(e){const t=e.split("\n"),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}const lf={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineOpacityTexture:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0};const cf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lf,n),Xt.extend(e,t,n),od(e,t,n),ad(e,t,n),t.tris=Bu.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),St(e,t,[]),t.VBOBuildTime={},vt(t.VBOBuildTime),function(e,t){function n(n){t.openGLTexture.releaseGraphicsResources(n),[t._colorTransferFunc,t._pwFunc,t._labelOutlineThicknessArray,t._labelOutlineOpacity].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),t.renderable.isA("vtkImageMapper")&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(o.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==dl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=nd,e.Fragment=rd,e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=Pu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result,a=Pu.substitute(a,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result,a=Pu.substitute(a,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=["varying vec2 tcoordVCVSOutput;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D texture1;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;"];if(o.getProperty().getUseLabelOutline()&&(c=c.concat(["uniform sampler2D labelOutlineTexture1;","uniform sampler2D labelOutlineOpacityTexture1;"])),l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:c=c.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:of("Unsupported number of independent coordinates.")}}if(i=Pu.substitute(i,"//VTK::TCoord::Dec",c).result,!0===o.getProperty().getUseLabelOutline()&&(i=Pu.substitute(i,"//VTK::LabelOutline::Dec",["uniform float vpWidth;","uniform float vpHeight;","uniform float vpOffsetX;","uniform float vpOffsetY;","uniform mat4 PCWCMatrix;","uniform mat4 vWCtoIDX;","uniform ivec3 imageDimensions;","uniform int sliceAxis;"]).result,i=Pu.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result,i=Pu.substitute(i,"//VTK::LabelOutlineHelperFunction",["#ifdef vtkImageLabelOutlineOn","vec3 fragCoordToIndexSpace(vec4 fragCoord) {","  vec4 pcPos = vec4(","    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,","    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,","    (fragCoord.z - 0.5) * 2.0,","    1.0);","","  vec4 worldCoord = PCWCMatrix * pcPos;","  vec4 vertex = (worldCoord/worldCoord.w);","","  vec3 index = (vWCtoIDX * vertex).xyz;","","  // half voxel fix for labelmapOutline","  return (index + vec3(0.5)) / vec3(imageDimensions);","}","vec2 getSliceCoords(vec3 coord, int axis) {","  if (axis == 0) return coord.yz;","  if (axis == 1) return coord.xz;","  if (axis == 2) return coord.xy;","}","#endif"]).result),l){const e=["r","g","b","a"];let t=["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);break;case 2:t=t.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:of("Unsupported number of independent coordinates.")}i=Pu.substitute(i,"//VTK::TCoord::Impl",t).result}else switch(s){case 1:i=Pu.substitute(i,"//VTK::TCoord::Impl",[...sf("\n                #ifdef vtkImageLabelOutlineOn\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);\n                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;\n                  bool pixelOnBorder = false;\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\n                  float opacityToUse = scalarOpacity * opacity;\n                  int segmentIndex = int(centerValue * 255.0);\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\n                  float outlineOpacity = texture2D(labelOutlineOpacityTexture1, vec2(textureCoordinate, 0.5)).r;\n                  int actualThickness = int(textureValue * 255.0);\n\n                  if (segmentIndex == 0){\n                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);\n                    return;\n                  }\n\n                  for (int i = -actualThickness; i <= actualThickness; i++) {\n                    for (int j = -actualThickness; j <= actualThickness; j++) {\n                      if (i == 0 || j == 0) {\n                        continue;\n                      }\n                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n                        gl_FragCoord.y + float(j),\n                        gl_FragCoord.z, gl_FragCoord.w);\n                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;\n                      if (value != centerValue) {\n                        pixelOnBorder = true;\n                        break;\n                      }\n                    }\n                    if (pixelOnBorder == true) {\n                      break;\n                    }\n                  }\n                  if (pixelOnBorder == true) {\n                    gl_FragData[0] = vec4(tColor, outlineOpacity);\n                  }\n                  else {\n                    gl_FragData[0] = vec4(tColor, opacityToUse);\n                  }\n                #else\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\n                #endif\n                ")]).result;break;case 2:i=Pu.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","float intensity = tcolor.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;break;case 3:i=Pu.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;break;default:i=Pu.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result}t.haveSeenDepthRequest&&(i=Pu.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=Pu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(tt("OpenGL has a limit of 6 clipping planes"),e=6),o=Pu.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=Pu.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=Pu.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=Pu.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!!(i||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||0===e.getProgram()?.getHandle()||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<r.getProperty().getMTime()||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||of("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||of("Error setting tcoordMC in shader VAO.")),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi("texture1",a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();if(n.getProgram().setUniformi("pwfTexture1",u),o.getProperty().getUseLabelOutline()){const e=t.labelOutlineThicknessTexture.getTextureUnit();n.getProgram().setUniformi("labelOutlineTexture1",e);const r=t.labelOutlineOpacityTexture.getTextureUnit();n.getProgram().setUniformi("labelOutlineOpacityTexture1",r)}if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(tt("OpenGL has a limit of 6 clipping planes"),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),y(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),y(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",i)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();y(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(y(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();y(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix("MCPCMatrix",t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();let i=t.renderable.getClosestIJKAxis().ijkMode;i===af.NONE&&(i=af.K),a.setUniform3i("imageDimensions",o[0],o[1],o[2]),a.setUniformi("sliceAxis",i),a.setUniformMatrix("vWCtoIDX",n);const l=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,l.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const c=e.getRenderTargetSize();a.setUniformf("vpWidth",c[0]),a.setUniformf("vpHeight",c[1]);const u=e.getRenderTargetOffset();a.setUniformf("vpOffsetX",u[0]/c[0]),a.setUniformf("vpOffsetY",u[1]/c[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf("opacity",o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),r.getProperty().getUseLabelOutline()&&(t.labelOutlineThicknessTexture.activate(),t.labelOutlineOpacityTexture.activate()),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),r.getProperty().getUseLabelOutline()&&(t.labelOutlineThicknessTexture.deactivate(),t.labelOutlineOpacityTexture.deactivate()),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):of("No input!")},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||r.getProperty().getUseLabelOutline()&&(!t.labelOutlineThicknessTexture?.getHandle()||!t.labelOutlineOpacityTexture?.getHandle())||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=[];for(let e=0;e<d;++e)f.push(l.getRGBTransferFunction(e));const g=Xp(f,u,d),m=l.getRGBTransferFunction(),h=t._openGLRenderWindow.getGraphicsResourceForObject(m);if(h?.oglObject?.getHandle()&&h?.hash===g)t.colorTexture=h.oglObject;else{t.colorTexture=td.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(n*p*3);if(c===Zp.NEAREST?(t.colorTexture.setMinificationFilter(Fu.NEAREST),t.colorTexture.setMagnificationFilter(Fu.NEAREST)):(t.colorTexture.setMinificationFilter(Fu.LINEAR),t.colorTexture.setMagnificationFilter(Fu.LINEAR)),m){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:p,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.create2DFromRaw({width:n,height:1,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}m&&(t._openGLRenderWindow.setGraphicsResourceForObject(m,t.colorTexture,g),m!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(m,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=m)}const v=[];for(let e=0;e<d;++e)v.push(l.getPiecewiseFunction(e));const T=Xp(v,u,d),y=l.getPiecewiseFunction(),b=t._openGLRenderWindow.getGraphicsResourceForObject(y);if(b?.oglObject?.getHandle()&&b?.hash===T)t.pwfTexture=b.oglObject;else{let n=t.renderable.getOpacityTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=td.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),c===Zp.NEAREST?(t.pwfTexture.setMinificationFilter(Fu.NEAREST),t.pwfTexture.setMagnificationFilter(Fu.NEAREST)):(t.pwfTexture.setMinificationFilter(Fu.LINEAR),t.pwfTexture.setMagnificationFilter(Fu.LINEAR)),y){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=l.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:p,numComps:1,dataType:is.FLOAT,data:e})}else o.fill(255),t.pwfTexture.create2DFromRaw({width:n,height:1,numComps:1,dataType:is.UNSIGNED_CHAR,data:o});y&&(t._openGLRenderWindow.setGraphicsResourceForObject(y,t.pwfTexture,T),y!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(y,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=y)}r.getProperty().getUseLabelOutline()&&(e.updatelabelOutlineThicknessTexture(r),e.updateLabelOutlineOpacityTexture(r));const{ijkMode:x}=t.renderable.getClosestIJKAxis();let C=t.renderable.getSlice();x!==t.renderable.getSlicingMode()&&(C=t.renderable.getSliceAtPosition(C));const S=t.renderable.isA("vtkImageArrayMapper")?t.renderable.getSubSlice():Math.round(C),A=o.getExtent();let I;x===af.I&&(I=S-A[0]),x===af.J&&(I=S-A[2]),x!==af.K&&x!==af.NONE||(I=S-A[4]);const w=`${C}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==w){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=td.newInstance({resizable:!0})),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),c===Zp.NEAREST?(new Set([1,3,4]).has(s)&&i===is.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Fu.NEAREST)):t.openGLTexture.setMinificationFilter(Fu.NEAREST),t.openGLTexture.setMagnificationFilter(Fu.NEAREST)):(4!==s||i!==is.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(Fu.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Fu.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(Fu.LINEAR)),t.openGLTexture.setWrapS(Nu.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Nu.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[af.X,af.Y,af.Z].includes(t.renderable.getSlicingMode())?C:S,p=o.getSpatialExtent(),f=a.getData();let g=null;if(x===af.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(I+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(x===af.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+I*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else x===af.K||x===af.NONE?(g=f.subarray(I*n,(I+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):of("Reformat slicing not yet supported.");const m=a.getRanges();t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw({width:e[0],height:e[1],numComps:s,dataType:a.getDataType(),data:g,preferSizeOverAccuracy:!!t.renderable.getPreferSizeOverAccuracy?.(),ranges:m}),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const h=Ts.newInstance({numberOfComponents:3,values:r});h.setName("points");const v=Ts.newInstance({numberOfComponents:2,values:l});v.setName("tcoords");const T=new Uint16Array(8);T[0]=3,T[1]=0,T[2]=1,T[3]=3,T[4]=3,T[5]=0,T[6]=3,T[7]=2;const y=Ts.newInstance({numberOfComponents:1,values:T});t.tris.getCABO().createVBO(y,"polys",qi.SURFACE,{points:h,tcoords:v,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=w}},e.updateLabelOutlineOpacityTexture=n=>{let r=n.getProperty().getLabelOutlineOpacity();"number"==typeof r&&(r=t._cachedLabelOutlineOpacityObj?.[0]===r?t._cachedLabelOutlineOpacityObj:[r],t._cachedLabelOutlineOpacityObj=r);const o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineOpacityTexture=o.oglObject;else{let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const o=1,i=new Float32Array(n*o);for(let e=0;e<n;++e)i[e]=r[e]??r[0];t.labelOutlineOpacityTexture=td.newInstance({resizable:!1}),t.labelOutlineOpacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineOpacityTexture.resetFormatAndType(),t.labelOutlineOpacityTexture.setMinificationFilter(Fu.NEAREST),t.labelOutlineOpacityTexture.setMagnificationFilter(Fu.NEAREST),t.labelOutlineOpacityTexture.create2DFromRaw({width:n,height:o,numComps:1,dataType:is.FLOAT,data:i}),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineOpacityTexture,a),r!==t._labelOutlineOpacity&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineOpacity,e)),t._labelOutlineOpacity=r)}},e.updatelabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThicknessByReference(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture=td.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Fu.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Fu.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw({width:n,height:o,numComps:1,dataType:is.UNSIGNED_CHAR,data:i}),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageMapper");en("vtkAbstractImageMapper",cf);const uf=0,df=1,pf=2,{vtkErrorMacro:ff}=Ht,gf={currentRenderPass:null,volumeTexture:null,colorTexture:null,pwfTexture:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const mf=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gf,n),Xt.extend(e,t,n),od(e,t,n),Ht.algo(e,t,2,0),t.tris=Bu.newInstance(),t.volumeTexture=null,t.colorTexture=null,t.pwfTexture=null,t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},Ht.obj(t.VBOBuildTime,{mtime:0}),function(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageCPRMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()===dl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),e.invokeEvent({type:"EndEvent"}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(n,r)=>{e.getNeedToRebuildBufferObjects(n,r)&&e.buildBufferObjects(n,r),r.getProperty().getInterpolationType()===Zp.NEAREST?(t.volumeTexture.setMinificationFilter(Fu.NEAREST),t.volumeTexture.setMagnificationFilter(Fu.NEAREST),t.colorTexture.setMinificationFilter(Fu.NEAREST),t.colorTexture.setMagnificationFilter(Fu.NEAREST),t.pwfTexture.setMinificationFilter(Fu.NEAREST),t.pwfTexture.setMagnificationFilter(Fu.NEAREST)):(t.volumeTexture.setMinificationFilter(Fu.LINEAR),t.volumeTexture.setMagnificationFilter(Fu.LINEAR),t.colorTexture.setMinificationFilter(Fu.LINEAR),t.colorTexture.setMagnificationFilter(Fu.LINEAR),t.pwfTexture.setMinificationFilter(Fu.LINEAR),t.pwfTexture.setMagnificationFilter(Fu.LINEAR))},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()||!t.volumeTexture?.getHandle()},e.buildBufferObjects=(n,r)=>{const o=t.currentImageDataInput,a=t.currentCenterlineInput,i=r.getProperty(),s=o?.getPointData()?.getScalars();if(!s)return;const l=t._openGLRenderWindow.getGraphicsResourceForObject(s),c=Yp(0,s),u=!l?.oglObject?.getHandle()||l?.hash!==c,d=i.getUpdatedExtents(),p=!!d.length;if(u){t.volumeTexture=td.newInstance(),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.volumeTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromDataArray({width:n[0],height:n[1],depth:n[2],dataArray:s,preferSizeOverAccuracy:t.renderable.getPreferSizeOverAccuracy()}),t._openGLRenderWindow.setGraphicsResourceForObject(s,t.volumeTexture,c),s!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(s,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=s}else t.volumeTexture=l.oglObject;if(p){i.setUpdatedExtents([]);const e=o.getDimensions();t.volumeTexture.create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:s,updatedExtents:d})}const f=s.getNumberOfComponents(),g=r.getProperty(),m=g.getIndependentComponents(),h=m?f:1,v=m?2*h:1,T=[];for(let e=0;e<h;++e)T.push(g.getRGBTransferFunction(e));const y=Xp(T,m,h),b=g.getRGBTransferFunction(),x=t._openGLRenderWindow.getGraphicsResourceForObject(b);if(x?.oglObject?.getHandle()&&x?.hash===y)t.colorTexture=x.oglObject;else{let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(n*v*3);if(t.colorTexture=td.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),b){const e=new Float32Array(3*n);for(let t=0;t<h;t++){const o=g.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),m)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:v,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:1,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}b&&(t._openGLRenderWindow.setGraphicsResourceForObject(b,t.colorTexture,y),b!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(b,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=b)}const C=[];for(let e=0;e<h;++e)C.push(g.getPiecewiseFunction(e));const S=Xp(C,m,h),A=g.getPiecewiseFunction(),I=t._openGLRenderWindow.getGraphicsResourceForObject(A);if(I?.oglObject?.getHandle()&&I?.hash===S)t.pwfTexture=I.oglObject;else{let n=t.renderable.getOpacityTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=n*v,o=new Uint8ClampedArray(r);if(t.pwfTexture=td.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),A){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<h;++t){const r=g.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),m)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:v,numComps:1,dataType:is.FLOAT,data:e})}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:1,numComps:1,dataType:is.UNSIGNED_CHAR,data:o});A&&(t._openGLRenderWindow.setGraphicsResourceForObject(A,t.pwfTexture,S),A!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(A,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=A)}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<a.getMTime()){const e=a.getNumberOfPoints(),n=e<=1?0:e-1,r=a.getDistancesToFirstPoint(),o=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,o-r[e],0],t),t+=3,s.set([l,o-r[e],0],t),t+=3,s.set([l,o-r[e+1],0],t),t+=3,s.set([0,o-r[e+1],0],t),t+=3;const c=Ts.newInstance({numberOfComponents:3,values:s});c.setName("points");const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Ts.newInstance({numberOfComponents:1,values:u}),p=a.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Ts.newInstance({numberOfComponents:3,values:f,name:"centerlinePosition"}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const T=[h,Ts.newInstance({numberOfComponents:1,values:v,name:"quadIndex"})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getOrientedCenterline().getOrientations()??[],r=new Float32Array(4*i),o=new Float32Array(4*i);for(let t=0;t<n;++t){const n=e[t],a=e[t+1];for(let e=0;e<4;++e){const i=4*(e+4*t);r.set(n,i),o.set(a,i)}}const a=Ts.newInstance({numberOfComponents:4,values:r,name:"centerlineTopOrientation"}),s=Ts.newInstance({numberOfComponents:4,values:o,name:"centerlineBotOrientation"});T.push(a,s)}t.tris.getCABO().createVBO(d,"polys",qi.SURFACE,{points:c,customAttributes:T}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation(),l=t.renderable.isProjectionEnabled()&&t.renderable.getProjectionMode();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastProjectionMode!==l||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastProjectionMode=l,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;const s=["vec3 applyQuaternionToVec(vec4 q, vec3 v) {","  float uvx = q.y * v.z - q.z * v.y;","  float uvy = q.z * v.x - q.x * v.z;","  float uvz = q.x * v.y - q.y * v.x;","  float uuvx = q.y * uvz - q.z * uvy;","  float uuvy = q.z * uvx - q.x * uvz;","  float uuvz = q.x * uvy - q.y * uvx;","  float w2 = q.w * 2.0;","  uvx *= w2;","  uvy *= w2;","  uvz *= w2;","  uuvx *= 2.0;","  uuvy *= 2.0;","  uuvz *= 2.0;","  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);","}"];a=Pu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result;const l=["attribute vec3 centerlinePosition;","attribute float quadIndex;","uniform float width;","out vec2 quadOffsetVSOutput;","out vec3 centerlinePosVSOutput;"],c=t.renderable.isProjectionEnabled(),u=t.renderable.getUseUniformOrientation();u?(l.push("out vec3 samplingDirVSOutput;","uniform vec4 centerlineOrientation;","uniform vec3 tangentDirection;",...s),c&&l.push("out vec3 projectionDirVSOutput;","uniform vec3 bitangentDirection;")):l.push("out vec4 centerlineTopOrientationVSOutput;","out vec4 centerlineBotOrientationVSOutput;","attribute vec4 centerlineTopOrientation;","attribute vec4 centerlineBotOrientation;"),a=Pu.substitute(a,"//VTK::Color::Dec",l).result;const d=["quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);","centerlinePosVSOutput = centerlinePosition;"];u?(d.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);"),c&&d.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);")):d.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;","centerlineBotOrientationVSOutput = centerlineBotOrientation;"),a=Pu.substitute(a,"//VTK::Color::Impl",d).result;const p=t.volumeTexture.getComponents(),f=o.getProperty().getIndependentComponents();let g=["uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates","in vec2 quadOffsetVSOutput;","in vec3 centerlinePosVSOutput;","uniform highp sampler3D volumeTexture;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;"];c&&g.push("uniform vec3 volumeSizeMC;","uniform int projectionSlabNumberOfSamples;","uniform float projectionConstantOffset;","uniform float projectionStepLength;"),u?(g.push("in vec3 samplingDirVSOutput;"),c&&g.push("in vec3 projectionDirVSOutput;")):(g.push("uniform vec3 tangentDirection;","in vec4 centerlineTopOrientationVSOutput;","in vec4 centerlineBotOrientationVSOutput;",...s),c&&g.push("uniform vec3 bitangentDirection;"));const m=t.renderable.getCenterPoint();if(m&&g.push("uniform vec3 globalCenterPoint;"),f){for(let e=1;e<p;e++)g=g.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(p){case 1:g=g.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:g=g.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:ff("Unsupported number of independent coordinates.")}}i=Pu.substitute(i,"//VTK::TCoord::Dec",g).result;let h=[];if(u?(h.push("vec3 samplingDirection = samplingDirVSOutput;"),c&&h.push("vec3 projectionDirection = projectionDirVSOutput;")):(h.push("vec4 q0 = centerlineBotOrientationVSOutput;","vec4 q1 = centerlineTopOrientationVSOutput;","float qCosAngle = dot(q0, q1);","vec4 interpolatedOrientation;","if (qCosAngle > 0.999 || qCosAngle < -0.999) {","  // Use LERP instead of SLERP when the two quaternions are close or opposite","  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));","} else {","  float omega = acos(qCosAngle);","  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);","}","vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"),c&&h.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);")),m?h.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);","float horizontalOffset = quadOffsetVSOutput.x + baseOffset;"):h.push("float horizontalOffset = quadOffsetVSOutput.x;"),h.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;","vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;","if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}"),c){const e=t.renderable.getProjectionMode();switch(e===df?h.push("const vec4 initialProjectionTextureValue = vec4(1.0);"):h.push("const vec4 initialProjectionTextureValue = vec4(0.0);"),h.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;","vec3 projectionStep = projectionStepLength * projectionScaledDirection;","vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;","vec4 tvalue = initialProjectionTextureValue;","for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {","  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;","  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);"),e){case uf:h.push("  tvalue = max(tvalue, sampledTextureValue);");break;case df:h.push("  tvalue = min(tvalue, sampledTextureValue);");break;default:h.push("  tvalue = tvalue + sampledTextureValue;")}h.push("}"),e===pf&&h.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);")}else h.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");if(f){const e=["r","g","b","a"];for(let t=0;t<p;++t)h=h.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(p){case 1:h=h.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:h=h.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:ff("Unsupported number of independent coordinates.")}}else switch(p){case 1:h=h.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:h=h.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=Pu.substitute(i,"//VTK::TCoord::Impl",h).result,t.haveSeenDepthRequest&&(i=Pu.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=Pu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(Ht.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6),o=Pu.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=Pu.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=Pu.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=Pu.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=nd,e.Fragment=rd,e.Geometry=""},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=n.getCABO();i.getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(a,i,"vertexMC",i.getVertexOffset(),i.getStride(),t.context.FLOAT,3,t.context.FALSE)||ff("Error setting vertexMC in shader VAO.")),n.getCABO().getCustomData().forEach((e=>{e&&a.isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(a,i,e.name,e.offset,i.getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&ff(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const s=t.volumeTexture.getTextureUnit();if(a.setUniformi("volumeTexture",s),a.setUniformf("width",t.renderable.getWidth()),n.getProgram().setUniform4fv("backgroundColor",t.renderable.getBackgroundColor()),a.isUniformUsed("tangentDirection")){const e=t.renderable.getTangentDirection();n.getProgram().setUniform3fArray("tangentDirection",e)}if(a.isUniformUsed("bitangentDirection")){const e=t.renderable.getBitangentDirection();n.getProgram().setUniform3fArray("bitangentDirection",e)}if(a.isUniformUsed("centerlineOrientation")){const e=t.renderable.getUniformOrientation();n.getProgram().setUniform4fv("centerlineOrientation",e)}if(a.isUniformUsed("globalCenterPoint")){const e=t.renderable.getCenterPoint();a.setUniform3fArray("globalCenterPoint",e)}if(t.renderable.isProjectionEnabled()){const e=t.currentImageDataInput,n=e.getSpacing(),r=e.getDimensions(),o=t.renderable.getProjectionSlabThickness(),i=t.renderable.getProjectionSlabNumberOfSamples(),s=En([],n,r);a.setUniform3fArray("volumeSizeMC",s),a.setUniformi("projectionSlabNumberOfSamples",i);const l=-.5*o;a.setUniformf("projectionConstantOffset",l);const c=o/(i-1);a.setUniformf("projectionStepLength",c)}const l=t.currentImageDataInput,c=l.getWorldToIndex(),u=O(new Float32Array(16),Cn([],l.getDimensions())),p=oe(u,u,c);if(a.setUniformMatrix("MCTCMatrix",p),t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(Ht.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6);const n=i.getCoordShiftAndScaleEnabled()?i.getInverseShiftAndScaleMatrix():null,r=n?d(t.imagematinv,o.getMatrix()):o.getMatrix();n&&(m(r,r),y(r,r,n),m(r,r)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),y(t.imagematinv,r,t.imagemat);const s=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)s.push(e[t])}a.setUniformi("numClipPlanes",e),a.setUniform4fv("clipPlanes",s)}if(a.isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);a.setUniformf("coffset",t.offset),a.isUniformUsed("cfactor")&&a.setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(y(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();y(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix("MCPCMatrix",t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.delete=Ht.chain((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageCPRMapper");en("vtkImageCPRMapper",mf);const hf={context:null,keyMatrixTime:null,keyMatrices:null};const vf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hf,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},St(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLImageSlice"),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}(e,t)}),"vtkOpenGLImageSlice");en("vtkImageSlice",vf);const Tf={};const yf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),St(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLVolume"),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}(e,t)}),"vtkOpenGLVolume");en("vtkVolume",yf);const bf={NEAREST:0,LINEAR:1,FAST_LINEAR:2},xf={FRACTIONAL:0,PROPORTIONAL:1},Cf={DEFAULT:0,ADDITIVE:1,COLORIZE:2,CUSTOM:3};var Sf={InterpolationType:bf,OpacityMode:xf,ColorMixPreset:Cf,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const Af={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5,LABELMAP_EDGE_PROJECTION_BLEND:6};var If={BlendMode:Af};const{vtkWarningMacro:wf,vtkErrorMacro:Of}=jt,Pf={idxToView:g(new Float64Array(16)),vecISToVCMatrix:pe(new Float64Array(9)),modelToView:g(new Float64Array(16)),projectionToView:g(new Float64Array(16)),projectionToWorld:g(new Float64Array(16))};const Rf={context:null,VBOBuildTime:null,scalarTextures:[],_scalarTexturesCore:[],opacityTexture:null,_opacityTextureCore:null,colorTexture:null,_colorTextureCore:null,labelOutlineThicknessTexture:null,_labelOutlineThicknessTextureCore:null,jitterTexture:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,fullViewportTime:1,idxToView:null,vecISToVCMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0};const Mf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),Xt.extend(e,t,n),ad(e,t,n),t.VBOBuildTime={},vt(t.VBOBuildTime,{mtime:0}),t.tris=Bu.newInstance(),t.jitterTexture=td.newInstance(),t.jitterTexture.setWrapS(Nu.REPEAT),t.jitterTexture.setWrapT(Nu.REPEAT),t.framebuffer=qd.newInstance(),St(e,t,["context"]),function(e,t){function n(e){return e.getUseLabelOutline()||t.renderable.getBlendMode()===Af.LABELMAP_EDGE_PROJECTION_BLEND}t.classHierarchy.push("vtkOpenGLVolumeMapper");const r=new Map;function o(t,n,o){n!==o&&(function(t,n){if(!n)return;const o=(r.get(n)??0)-1;o<=0?(t.unregisterGraphicsResourceUser(n,e),r.delete(n)):r.set(n,o)}(t,n),function(t,n){if(!n)return;const o=r.get(n)??0,a=o+1;r.set(n,a),o<=0&&t.registerGraphicsResourceUser(n,e)}(t,o))}function a(t){[...r.keys()].forEach((n=>t.unregisterGraphicsResourceUser(n,e)))}e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(n,r)=>{if(n){const n=t._openGLRenderWindow;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),n&&!n.isDeleted()&&n!==t._openGLRenderWindow&&a(n),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType("vtkOpenGLVolume");const r=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),e.renderPiece(o,r)}},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\nconst float infinity = 3.402823466e38;\n\n// the output of this shader\n//VTK::Output::Dec\n\nin vec3 vertexVCVSOutput;\n\n// From Sources\\Rendering\\Core\\VolumeProperty\\Constants.js\n#define COMPOSITE_BLEND 0\n#define MAXIMUM_INTENSITY_BLEND 1\n#define MINIMUM_INTENSITY_BLEND 2\n#define AVERAGE_INTENSITY_BLEND 3\n#define ADDITIVE_INTENSITY_BLEND 4\n#define RADON_TRANSFORM_BLEND 5\n#define LABELMAP_EDGE_PROJECTION_BLEND 6\n\n#define vtkNumberOfLights //VTK::NumberOfLights\n#define vtkMaxLaoKernelSize //VTK::MaxLaoKernelSize\n#define vtkNumberOfComponents //VTK::NumberOfComponents\n#define vtkBlendMode //VTK::BlendMode\n#define vtkMaximumNumberOfSamples //VTK::MaximumNumberOfSamples\n\n//VTK::EnabledColorFunctions\n\n//VTK::EnabledLightings\n\n//VTK::EnabledMultiTexturePerVolume\n\n//VTK::EnabledGradientOpacity\n\n//VTK::EnabledIndependentComponents\n\n//VTK::vtkProportionalComponents\n\n//VTK::vtkForceNearestComponents\n\nuniform int twoSidedLighting;\n\n#if vtkMaxLaoKernelSize > 0\n  vec2 kernelSample[vtkMaxLaoKernelSize];\n#endif\n\n// Textures\n#ifdef EnabledMultiTexturePerVolume\n  #define vtkNumberOfVolumeTextures vtkNumberOfComponents\n#else\n  #define vtkNumberOfVolumeTextures 1\n#endif\nuniform highp sampler3D volumeTexture[vtkNumberOfVolumeTextures];\nuniform sampler2D colorTexture;\nuniform sampler2D opacityTexture;\nuniform sampler2D jtexture;\nuniform sampler2D labelOutlineThicknessTexture;\n\nstruct Volume {\n  // ---- Volume geometry settings ----\n\n  vec3 originVC;          // in VC\n  vec3 spacing;           // in VC per IC\n  vec3 inverseSpacing;    // 1/spacing\n  ivec3 dimensions;       // in IC\n  vec3 inverseDimensions; // 1/vec3(dimensions)\n  mat3 vecISToVCMatrix;   // convert from IS to VC without translation\n  mat3 vecVCToISMatrix;   // convert from VC to IS without translation\n  mat4 PCWCMatrix;\n  mat4 worldToIndex;\n  float diagonalLength; // in VC, this is: length(size)\n\n  // ---- Texture settings ----\n\n  // Texture shift and scale\n  vec4 colorTextureScale;\n  vec4 colorTextureShift;\n  vec4 opacityTextureScale;\n  vec4 opacityTextureShift;\n\n  // The heights defined below are the locations for the up to four components\n  // of the transfer functions. The transfer functions have a height of (2 *\n  // numberOfComponents) pixels so the values are computed to hit the middle of\n  // the two rows for that component\n  vec4 transferFunctionsSampleHeight;\n\n  // ---- Mode specific settings ----\n\n  // Independent component default preset settings per component\n  vec4 independentComponentMix;\n\n  // Additive / average blending mode settings\n  vec4 ipScalarRangeMin;\n  vec4 ipScalarRangeMax;\n\n  // ---- Rendering settings ----\n\n  // Lighting\n  float ambient;\n  float diffuse;\n  float specular;\n  float specularPower;\n  int computeNormalFromOpacity;\n\n  // Gradient opacity\n  vec4 gradientOpacityScale;\n  vec4 gradientOpacityShift;\n  vec4 gradientOpacityMin;\n  vec4 gradientOpacityMax;\n\n  // Volume shadow\n  float volumetricScatteringBlending;\n  float globalIlluminationReach;\n  float anisotropy;\n  float anisotropySquared;\n\n  // LAO\n  int kernelSize;\n  int kernelRadius;\n\n  // Label outline\n  float outlineOpacity;\n};\nuniform Volume volume;\n\nstruct Light {\n  vec3 color;\n  vec3 positionVC;\n  vec3 directionVC; // normalized\n  vec3 halfAngleVC;\n  vec3 attenuation;\n  float exponent;\n  float coneAngle;\n  int isPositional;\n};\n#if vtkNumberOfLights > 0\n  uniform Light lights[vtkNumberOfLights];\n#endif\n\nuniform float vpWidth;\nuniform float vpHeight;\nuniform float vpOffsetX;\nuniform float vpOffsetY;\n\n// Bitmasks for label outline\nconst int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\n#define MAX_SEGMENTS 256\n#define UINT_SIZE 32\n// We add UINT_SIZE - 1, as we want the ceil of the division instead of the\n// floor\n#define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\nuint labelOutlineBitmasks[BITMASK_SIZE];\n\n// Set the corresponding bit in the bitmask\nvoid setLabelOutlineBit(int segmentIndex) {\n  int arrayIndex = segmentIndex / UINT_SIZE;\n  int bitIndex = segmentIndex % UINT_SIZE;\n  labelOutlineBitmasks[arrayIndex] |= 1u << bitIndex;\n}\n\n// Check if a bit is set in the bitmask\nbool isLabelOutlineBitSet(int segmentIndex) {\n  int arrayIndex = segmentIndex / UINT_SIZE;\n  int bitIndex = segmentIndex % UINT_SIZE;\n  return ((labelOutlineBitmasks[arrayIndex] & (1u << bitIndex)) != 0u);\n}\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n//VTK::ClipPlane::Dec\n\n// A random number between 0 and 1 that only depends on the fragment\n// It uses the jtexture, so this random seed repeats by blocks of 32 fragments\n// in screen space\nfloat fragmentSeed;\n\n// sample texture is global\nuniform float sampleDistance;\nuniform float volumeShadowSampleDistance;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics\n// rendering module is complete)\nvec3 rayDirVC;\n\n#define INV4PI 0.0796\n#define EPSILON 0.001\n#define PI 3.1415\n#define PI2 9.8696\n\nvec4 rawSampleTexture(vec3 pos) {\n  #ifdef EnabledMultiTexturePerVolume\n    vec4 rawSample;\n    rawSample[0] = texture(volumeTexture[0], pos)[0];\n  #if vtkNumberOfComponents > 1\n    rawSample[1] = texture(volumeTexture[1], pos)[0];\n  #endif\n  #if vtkNumberOfComponents > 2\n    rawSample[2] = texture(volumeTexture[2], pos)[0];\n  #endif\n  #if vtkNumberOfComponents > 3\n    rawSample[3] = texture(volumeTexture[3], pos)[0];\n  #endif\n    return rawSample;\n  #else\n    return texture(volumeTexture[0], pos);\n  #endif\n}\n\nvec4 rawFetchTexture(ivec3 pos) {\n  #ifdef EnabledMultiTexturePerVolume\n    vec4 rawSample;\n    #if vtkNumberOfComponents > 0\n      rawSample[0] = texelFetch(volumeTexture[0], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 1\n      rawSample[1] = texelFetch(volumeTexture[1], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 2\n      rawSample[2] = texelFetch(volumeTexture[2], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 3\n      rawSample[3] = texelFetch(volumeTexture[3], pos, 0)[0];\n    #endif\n    return rawSample;\n  #else\n    return texelFetch(volumeTexture[0], pos, 0);\n  #endif\n}\n\nvec4 getTextureValue(vec3 pos) {\n  vec4 tmp = rawSampleTexture(pos);\n\n  // Force nearest\n  #if defined(vtkComponent0ForceNearest) || \\\n      defined(vtkComponent1ForceNearest) || \\\n      defined(vtkComponent2ForceNearest) || \\\n      defined(vtkComponent3ForceNearest)\n    vec3 nearestPos = (floor(pos * vec3(volume.dimensions)) + 0.5) *\n                      volume.inverseDimensions;\n    vec4 nearestValue = rawSampleTexture(nearestPos);\n    #ifdef vtkComponent0ForceNearest\n      tmp[0] = nearestValue[0];\n    #endif\n    #ifdef vtkComponent1ForceNearest\n      tmp[1] = nearestValue[1];\n    #endif\n    #ifdef vtkComponent2ForceNearest\n      tmp[2] = nearestValue[2];\n    #endif\n    #ifdef vtkComponent3ForceNearest\n      tmp[3] = nearestValue[3];\n    #endif\n  #endif\n\n  // Set alpha when using dependent components\n  #ifndef EnabledIndependentComponents\n    #if vtkNumberOfComponents == 1\n      tmp.a = tmp.r;\n    #endif\n    #if vtkNumberOfComponents == 2\n      tmp.a = tmp.g;\n    #endif\n    #if vtkNumberOfComponents == 3\n      tmp.a = length(tmp.rgb);\n    #endif\n  #endif\n\n  return tmp;\n}\n\n// `height` is usually `volume.transferFunctionsSampleHeight[component]`\n// when using independent component and `0.5` otherwise. Don't move the if\n// statement in these function, as the callers usually already knows if it is\n// using independent component or not\nfloat getOpacityFromTexture(float scalar, int component, float height) {\n  float scaledScalar = scalar * volume.opacityTextureScale[component] +\n                       volume.opacityTextureShift[component];\n  return texture2D(opacityTexture, vec2(scaledScalar, height)).r;\n}\nvec3 getColorFromTexture(float scalar, int component, float height) {\n  float scaledScalar = scalar * volume.colorTextureScale[component] +\n                       volume.colorTextureShift[component];\n  return texture2D(colorTexture, vec2(scaledScalar, height)).rgb;\n}\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\nvec3 posIStoVC(vec3 posIS) {\n  return volume.vecISToVCMatrix * posIS + volume.originVC;\n}\n\n// convert vector position from vc to idx\nvec3 posVCtoIS(vec3 posVC) {\n  return volume.vecVCToISMatrix * (posVC - volume.originVC);\n}\n\n// Rotate vector to view coordinate\nvec3 vecISToVC(vec3 dirIS) {\n  return volume.vecISToVCMatrix * dirIS;\n}\n\n// Rotate vector to idx coordinate\nvec3 vecVCToIS(vec3 dirVC) {\n  return volume.vecVCToISMatrix * dirVC;\n}\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(float normalMag, int component) {\n  float goscale = volume.gradientOpacityScale[component];\n  float goshift = volume.gradientOpacityShift[component];\n  float gomin = volume.gradientOpacityMin[component];\n  float gomax = volume.gradientOpacityMax[component];\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n}\n\n#ifdef vtkClippingPlanesOn\n  bool isPointClipped(vec3 posVC) {\n    for (int i = 0; i < clip_numPlanes; ++i) {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0) {\n        return true;\n      }\n    }\n    return false;\n  }\n#endif\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward\n// difference\n\n// The output normal is in VC\nvec4 computeDensityNormal(vec3 opacityUCoords[2], float opacityTextureHeight,\n                          float gradientOpacity, int component) {\n  // Pass the scalars through the opacity functions\n  vec4 opacityG;\n  opacityG.x += getOpacityFromTexture(opacityUCoords[0].x, component,\n                                      opacityTextureHeight);\n  opacityG.y += getOpacityFromTexture(opacityUCoords[0].y, component,\n                                      opacityTextureHeight);\n  opacityG.z += getOpacityFromTexture(opacityUCoords[0].z, component,\n                                      opacityTextureHeight);\n  opacityG.x -= getOpacityFromTexture(opacityUCoords[1].x, component,\n                                      opacityTextureHeight);\n  opacityG.y -= getOpacityFromTexture(opacityUCoords[1].y, component,\n                                      opacityTextureHeight);\n  opacityG.z -= getOpacityFromTexture(opacityUCoords[1].z, component,\n                                      opacityTextureHeight);\n\n  // Divide by spacing and convert to VC\n  opacityG.xyz *= gradientOpacity * volume.inverseSpacing;\n  opacityG.w = length(opacityG.xyz);\n  if (opacityG.w == 0.0) {\n    return vec4(0.0);\n  }\n\n  // Normalize\n  opacityG.xyz = normalize(vecISToVC(opacityG.xyz));\n\n  return opacityG;\n}\n\n// The output normal is in VC\nvec4 computeNormalForDensity(vec3 posIS, out vec3 scalarInterp[2],\n                             const int opacityComponent) {\n  vec3 offsetedPosIS;\n  for (int axis = 0; axis < 3; ++axis) {\n    // Positive direction\n    offsetedPosIS = posIS;\n    offsetedPosIS[axis] += volume.inverseDimensions[axis];\n    scalarInterp[0][axis] =\n        getTextureValue(offsetedPosIS)[opacityComponent];\n    #ifdef vtkClippingPlanesOn\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\n        scalarInterp[0][axis] = 0.0;\n      }\n    #endif\n\n    // Negative direction\n    offsetedPosIS = posIS;\n    offsetedPosIS[axis] -= volume.inverseDimensions[axis];\n    scalarInterp[1][axis] =\n        getTextureValue(offsetedPosIS)[opacityComponent];\n    #ifdef vtkClippingPlanesOn\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\n        scalarInterp[1][axis] = 0.0;\n      }\n    #endif\n  }\n\n  vec4 result;\n  result.xyz = (scalarInterp[0] - scalarInterp[1]) * volume.inverseSpacing;\n  result.w = length(result.xyz);\n  if (result.w == 0.0) {\n    return vec4(0.0);\n  }\n  result.xyz = normalize(vecISToVC(result.xyz));\n  return result;\n}\n\nvec4 fragCoordToPCPos(vec4 fragCoord) {\n  return vec4((fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n              (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n              (fragCoord.z - 0.5) * 2.0, 1.0);\n}\n\nvec4 pcPosToWorldCoord(vec4 pcPos) {\n  return volume.PCWCMatrix * pcPos;\n}\n\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\n  vec4 vertex = (worldCoord / worldCoord.w);\n\n  vec3 index = (volume.worldToIndex * vertex).xyz;\n\n  // half voxel fix for labelmapOutline\n  return (index + vec3(0.5)) * volume.inverseDimensions;\n}\n\nvec3 fragCoordToWorld(vec4 fragCoord) {\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\n  return worldCoord.xyz;\n}\n\n//=======================================================================\n// Compute the normals and gradient magnitudes for a position for independent\n// components The output normals are in VC\nmat4 computeMat4Normal(vec3 posIS, vec4 tValue) {\n  vec3 xvec = vec3(volume.inverseDimensions.x, 0.0, 0.0);\n  vec3 yvec = vec3(0.0, volume.inverseDimensions.y, 0.0);\n  vec3 zvec = vec3(0.0, 0.0, volume.inverseDimensions.z);\n\n  vec4 distX = getTextureValue(posIS + xvec) - getTextureValue(posIS - xvec);\n  vec4 distY = getTextureValue(posIS + yvec) - getTextureValue(posIS - yvec);\n  vec4 distZ = getTextureValue(posIS + zvec) - getTextureValue(posIS - zvec);\n\n  // divide by spacing\n  distX *= 0.5 * volume.inverseSpacing.x;\n  distY *= 0.5 * volume.inverseSpacing.y;\n  distZ *= 0.5 * volume.inverseSpacing.z;\n\n  mat4 result;\n\n  // optionally compute the 1st component\n  #if vtkNumberOfComponents > 0 && !defined(vtkComponent0Proportional)\n    {\n      const int component = 0;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 2nd component\n  #if vtkNumberOfComponents > 1 && !defined(vtkComponent1Proportional)\n    {\n      const int component = 1;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 3rd component\n  #if vtkNumberOfComponents > 2 && !defined(vtkComponent2Proportional)\n    {\n      const int component = 2;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 4th component\n  #if vtkNumberOfComponents > 3 && !defined(vtkComponent3Proportional)\n    {\n      const int component = 3;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n\n// henyey greenstein phase function\nfloat phaseFunction(float cos_angle) {\n  // divide by 2.0 instead of 4pi to increase intensity\n  float anisotropy = volume.anisotropy;\n  if (abs(anisotropy) <= EPSILON) {\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    return 0.5;\n  }\n  float anisotropy2 = volume.anisotropySquared;\n  return ((1.0 - anisotropy2) /\n          pow(1.0 + anisotropy2 - 2.0 * anisotropy * cos_angle, 1.5)) /\n         2.0;\n}\n\n// Compute the two intersection distances of the ray with the volume in VC\n// The entry point is `rayOriginVC + distanceMin * rayDirVC` and the exit point\n// is `rayOriginVC + distanceMax * rayDirVC` If distanceMin < distanceMax, the\n// volume is not intersected The ray origin is inside the box when distanceMin <\n// 0.0 < distanceMax\nvec2 rayIntersectVolumeDistances(vec3 rayOriginVC, vec3 rayDirVC) {\n  // Compute origin and direction in IS\n  vec3 rayOriginIS = posVCtoIS(rayOriginVC);\n  vec3 rayDirIS = vecVCToIS(rayDirVC);\n  // Don't check for infinity as the min/max combination afterward will always\n  // find an intersection before infinity\n  vec3 invDir = 1.0 / rayDirIS;\n\n  // We have: bound = origin + t * dir\n  // So: t = (1/dir) * (bound - origin)\n  vec3 distancesTo0 = invDir * (vec3(0.0) - rayOriginIS);\n  vec3 distancesTo1 = invDir * (vec3(1.0) - rayOriginIS);\n  // Min and max distances to plane intersection per plane\n  vec3 dMinPerAxis = min(distancesTo0, distancesTo1);\n  vec3 dMaxPerAxis = max(distancesTo0, distancesTo1);\n  // Overall first and last intersection\n  float distanceMin = max(dMinPerAxis.x, max(dMinPerAxis.y, dMinPerAxis.z));\n  float distanceMax = min(dMaxPerAxis.x, min(dMaxPerAxis.y, dMaxPerAxis.z));\n  return vec2(distanceMin, distanceMax);\n}\n\n//=======================================================================\n// local ambient occlusion\n#if vtkMaxLaoKernelSize > 0\n\n  // Return a random point on the unit sphere\n  vec3 sampleDirectionUniform(int rayIndex) {\n    // Each ray of each fragment should be different, two sources of randomness\n    // are used. Only depends on ray index\n    vec2 rayRandomness = kernelSample[rayIndex];\n    // Only depends on fragment\n    float fragmentRandomness = fragmentSeed;\n    // Merge both source of randomness in a single uniform random variable using\n    // the formula (x+y < 1 ? x+y : x+y-1). The simpler formula (x+y)/2 doesn't\n    // result in a uniform distribution\n    vec2 mergedRandom = rayRandomness + vec2(fragmentRandomness);\n    mergedRandom -= vec2(greaterThanEqual(mergedRandom, vec2(1.0)));\n\n    // Insipred by:\n    // https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/#better-choice-of-spherical-coordinates\n    float u = mergedRandom[0];\n    float v = mergedRandom[1];\n    float theta = u * 2.0 * PI;\n    float phi = acos(2.0 * v - 1.0);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    return vec3(sinPhi * cosTheta, sinPhi * sinTheta, cosPhi);\n  }\n\n  float computeLAO(vec3 posVC, vec4 normalVC, float originalOpacity) {\n    // apply LAO only at selected locations, otherwise return full brightness\n    if (normalVC.w <= 0.0 || originalOpacity <= 0.05) {\n      return 1.0;\n    }\n\n    #ifdef EnabledGradientOpacity\n      float gradientOpacityFactor = computeGradientOpacityFactor(normalVC.w, 0);\n    #endif\n\n    float visibilitySum = 0.0;\n    float weightSum = 0.0;\n    for (int i = 0; i < volume.kernelSize; i++) {\n      // Only sample on an hemisphere around the normalVC.xyz axis, so\n      // normalDotRay should be negative\n      vec3 rayDirectionVC = sampleDirectionUniform(i);\n      float normalDotRay = dot(normalVC.xyz, rayDirectionVC);\n      if (normalDotRay > 0.0) {\n        // Flip rayDirectionVC when it is in the wrong hemisphere\n        rayDirectionVC = -rayDirectionVC;\n        normalDotRay = -normalDotRay;\n      }\n\n      vec3 currPosIS = posVCtoIS(posVC);\n      float visibility = 1.0;\n      vec3 randomDirStepIS = vecVCToIS(rayDirectionVC * sampleDistance);\n      for (int j = 0; j < volume.kernelRadius; j++) {\n        currPosIS += randomDirStepIS;\n        // If out of the volume, we are done\n        if (any(lessThan(currPosIS, vec3(0.0))) ||\n            any(greaterThan(currPosIS, vec3(1.0)))) {\n          break;\n        }\n        float opacity = getOpacityFromTexture(getTextureValue(currPosIS).r, 0, 0.5);\n        #ifdef EnabledGradientOpacity\n          opacity *= gradientOpacityFactor;\n        #endif\n        visibility *= 1.0 - opacity;\n        // If visibility is less than EPSILON, consider it to be 0\n        if (visibility < EPSILON) {\n          visibility = 0.0;\n          break;\n        }\n      }\n      float rayWeight = -normalDotRay;\n      visibilitySum += visibility * rayWeight;\n      weightSum += rayWeight;\n    }\n\n    // If no sample, LAO factor is one\n    if (weightSum == 0.0) {\n      return 1.0;\n    }\n\n    // LAO factor is the average visibility:\n    // - visibility low => ambient low\n    // - visibility high => ambient high\n    float lao = visibilitySum / weightSum;\n\n    // Reduce variance by clamping\n    return clamp(lao, 0.3, 1.0);\n  }\n#endif\n\n//=======================================================================\n// Volume shadows\n#if vtkNumberOfLights > 0\n\n  // Non-memoised version\n  float computeVolumeShadowWithoutCache(vec3 posVC, vec3 lightDirNormVC) {\n    // modify sample distance with a random number between 1.5 and 3.0\n    float rayStepLength =\n        volumeShadowSampleDistance * mix(1.5, 3.0, fragmentSeed);\n\n    // in case the first sample near surface has a very tiled light ray, we need\n    // to offset start position\n    vec3 initialPosVC = posVC + rayStepLength * lightDirNormVC;\n\n    #ifdef vtkClippingPlanesOn\n      float clippingPlanesMaxDistance = infinity;\n      for (int i = 0; i < clip_numPlanes; ++i) {\n        // Find distance of intersection with the plane\n        // Points are clipped when:\n        // dot(planeOrigin - (rayOrigin + distance * rayDirection), planeNormal) > 0\n        // This is equivalent to:\n        // dot(planeOrigin - rayOrigin, planeNormal) - distance * dot(rayDirection,\n        // planeNormal) > 0.0\n        // We precompute the dot products, so we clip ray points when:\n        // dotOrigin - distance * dotDirection > 0.0\n        float dotOrigin =\n            dot(vClipPlaneOrigins[i] - initialPosVC, vClipPlaneNormals[i]);\n        if (dotOrigin > 0.0) {\n          // The initialPosVC is clipped by this plane\n          return 1.0;\n        }\n        float dotDirection = dot(lightDirNormVC, vClipPlaneNormals[i]);\n        if (dotDirection < 0.0) {\n          // We only hit the plane if dotDirection is negative, as (distance is\n          // positive)\n          float intersectionDistance =\n              dotOrigin / dotDirection; // negative divided by negative => positive\n          clippingPlanesMaxDistance =\n              min(clippingPlanesMaxDistance, intersectionDistance);\n        }\n      }\n    #endif\n\n    vec2 intersectionDistances =\n        rayIntersectVolumeDistances(initialPosVC, lightDirNormVC);\n\n    if (intersectionDistances[1] <= intersectionDistances[0] ||\n        intersectionDistances[1] <= 0.0) {\n      // Volume not hit or behind the ray\n      return 1.0;\n    }\n\n    // When globalIlluminationReach is 0, no sample at all\n    // When globalIlluminationReach is 1, the ray will go through the whole\n    // volume\n    float maxTravelDistance = mix(0.0, volume.diagonalLength,\n                                  volume.globalIlluminationReach);\n    float startDistance = max(intersectionDistances[0], 0.0);\n    float endDistance = min(intersectionDistances[1], startDistance + maxTravelDistance);\n    #ifdef vtkClippingPlanesOn\n      endDistance = min(endDistance, clippingPlanesMaxDistance);\n    #endif\n    if (endDistance - startDistance < 0.0) {\n      return 1.0;\n    }\n\n    // These two variables are used to compute posIS, without having to call\n    // VCtoIS at each step\n    vec3 initialPosIS = posVCtoIS(initialPosVC);\n    // The light dir is scaled and rotated, but not translated, as it is a\n    // vector (w = 0)\n    vec3 scaledLightDirIS = vecVCToIS(lightDirNormVC);\n\n    float shadow = 1.0;\n    for (float currentDistance = startDistance; currentDistance <= endDistance;\n          currentDistance += rayStepLength) {\n      vec3 posIS = initialPosIS + currentDistance * scaledLightDirIS;\n      vec4 scalar = getTextureValue(posIS);\n      float opacity = getOpacityFromTexture(scalar.r, 0, 0.5);\n      #if defined(EnabledGradientOpacity) && !defined(EnabledIndependentComponents)\n        vec3 scalarInterp[2];\n        vec4 normal = computeNormalForDensity(posIS, scalarInterp, 3);\n        float opacityFactor = computeGradientOpacityFactor(normal.w, 0);\n        opacity *= opacityFactor;\n      #endif\n      shadow *= 1.0 - opacity;\n\n      // Early termination if shadow coeff is near 0.0\n      if (shadow < EPSILON) {\n        return 0.0;\n      }\n    }\n    return shadow;\n  }\n\n  // Some cache for volume shadows\n  struct {\n    vec3 posVC;\n    float shadow;\n  } cachedShadows[vtkNumberOfLights];\n\n  // Memoised version\n  float computeVolumeShadow(vec3 posVC, vec3 lightDirNormVC, int lightIdx) {\n    if (posVC == cachedShadows[lightIdx].posVC) {\n      return cachedShadows[lightIdx].shadow;\n    }\n    float shadow = computeVolumeShadowWithoutCache(posVC, lightDirNormVC);\n    cachedShadows[lightIdx].posVC = posVC;\n    cachedShadows[lightIdx].shadow = shadow;\n    return shadow;\n  }\n\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkNumberOfLights > 0\n  vec3 applyLighting(vec3 tColor, vec4 normalVC) {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\n      float df = dot(normalVC.xyz, lights[lightIdx].directionVC);\n      if (df > 0.0) {\n        diffuse += df * lights[lightIdx].color;\n        float sf = dot(normalVC.xyz, -lights[lightIdx].halfAngleVC);\n        if (sf > 0.0) {\n          specular += pow(sf, volume.specularPower) * lights[lightIdx].color;\n        }\n      }\n    }\n    return tColor * (diffuse * volume.diffuse + volume.ambient) +\n          specular * volume.specular;\n  }\n\n  vec3 applySurfaceShadowLighting(vec3 tColor, float alpha, vec3 posVC,\n                                  vec4 normalVC) {\n    // everything in VC\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    for (int ligthIdx = 0; ligthIdx < vtkNumberOfLights; ligthIdx++) {\n      vec3 vertLightDirection;\n      float attenuation;\n      if (lights[ligthIdx].isPositional == 1) {\n        vertLightDirection = posVC - lights[ligthIdx].positionVC;\n        float lightDistance = length(vertLightDirection);\n        // Normalize with precomputed length\n        vertLightDirection = vertLightDirection / lightDistance;\n        // Base attenuation\n        vec3 attenuationPolynom = lights[ligthIdx].attenuation;\n        attenuation =\n            1.0 / (attenuationPolynom[0] +\n                  lightDistance * (attenuationPolynom[1] +\n                                    lightDistance * attenuationPolynom[2]));\n        // Cone attenuation\n        float coneDot = dot(vertLightDirection, lights[ligthIdx].directionVC);\n        // Per OpenGL standard cone angle is 90 or less for a spot light\n        if (lights[ligthIdx].coneAngle <= 90.0) {\n          if (coneDot >= cos(radians(lights[ligthIdx].coneAngle))) {\n            // Inside the cone\n            attenuation *= pow(coneDot, lights[ligthIdx].exponent);\n          } else {\n            // Outside the cone\n            attenuation = 0.0;\n          }\n        }\n      } else {\n        vertLightDirection = lights[ligthIdx].directionVC;\n        attenuation = 1.0;\n      }\n\n      float ndotL = dot(normalVC.xyz, vertLightDirection);\n      if (ndotL < 0.0 && twoSidedLighting == 1) {\n        ndotL = -ndotL;\n      }\n      if (ndotL > 0.0) {\n        // Diffuse\n        diffuse += ndotL * attenuation * lights[ligthIdx].color;\n        // Specular\n        float vdotR =\n            dot(-rayDirVC, normalize(vertLightDirection - 2.0 * ndotL * normalVC.xyz));\n        if (vdotR > 0.0) {\n          specular += pow(vdotR, volume.specularPower) * attenuation *\n                      lights[ligthIdx].color;\n        }\n      }\n    }\n    #if vtkMaxLaoKernelSize > 0\n      float laoFactor = computeLAO(posVC, normalVC, alpha);\n    #else\n      const float laoFactor = 1.0;\n    #endif\n    return tColor * (diffuse * volume.diffuse +\n                    volume.ambient * laoFactor) +\n          specular * volume.specular;\n  }\n\n  vec3 applyVolumeShadowLighting(vec3 tColor, vec3 posVC) {\n    // Here we have no effect of cones and no attenuation\n    vec3 diffuse = vec3(0.0);\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\n      vec3 lightDirVC = lights[lightIdx].isPositional == 1\n                            ? normalize(lights[lightIdx].positionVC - posVC)\n                            : -lights[lightIdx].directionVC;\n      float shadowCoeff = computeVolumeShadow(posVC, lightDirVC, lightIdx);\n      float phaseAttenuation = phaseFunction(dot(rayDirVC, lightDirVC));\n      diffuse += phaseAttenuation * shadowCoeff * lights[lightIdx].color;\n    }\n    return tColor * (diffuse * volume.diffuse + volume.ambient);\n  }\n#endif\n\n// LAO of surface shadows and volume shadows only work with dependent components\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posVC,\n                       vec4 surfaceNormalVC) {\n  #if vtkNumberOfLights > 0\n    // 0 <= volCoeff < EPSILON => only surface shadows\n    // EPSILON <= volCoeff < 1 - EPSILON => mix of surface and volume shadows\n    // 1 - EPSILON <= volCoeff => only volume shadows\n    float volCoeff = volume.volumetricScatteringBlending *\n                    (1.0 - alpha / 2.0) *\n                    (1.0 - atan(surfaceNormalVC.w) * INV4PI);\n\n    // Compute surface lighting if needed\n    vec3 surfaceShadedColor = tColor;\n    #ifdef EnableSurfaceLighting\n      if (volCoeff < 1.0 - EPSILON) {\n        surfaceShadedColor =\n            applySurfaceShadowLighting(tColor, alpha, posVC, surfaceNormalVC);\n      }\n    #endif\n\n    // Compute volume lighting if needed\n    vec3 volumeShadedColor = tColor;\n    #ifdef EnableVolumeLighting\n      if (volCoeff >= EPSILON) {\n        volumeShadedColor = applyVolumeShadowLighting(tColor, posVC);\n      }\n    #endif\n\n    // Return the right mix\n    if (volCoeff < EPSILON) {\n      // Surface shadows\n      return surfaceShadedColor;\n    }\n    if (volCoeff >= 1.0 - EPSILON) {\n      // Volume shadows\n      return volumeShadedColor;\n    }\n    // Mix of surface and volume shadows\n    return mix(surfaceShadedColor, volumeShadedColor, volCoeff);\n  #endif\n  return tColor;\n}\n\nvec4 getColorForLabelOutline() {\n  vec3 centerPosIS =\n      fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = vec4(getColorFromTexture(centerValue.r, 0, 0.5),\n                     getOpacityFromTexture(centerValue.r, 0, 0.5));\n\n  int segmentIndex = int(centerValue.r * 255.0);\n\n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue =\n      texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\n  int actualThickness = int(textureValue * 255.0);\n\n  // If it is the background (segment index 0), we should quickly bail out.\n  // Previously, this was determined by tColor.a, which was incorrect as it\n  // prevented the outline from appearing when the fill is 0.\n  if (segmentIndex == 0) {\n    return vec4(0, 0, 0, 0);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't\n  // invisible. Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  for (int i = -actualThickness; i <= actualThickness; i++) {\n    for (int j = -actualThickness; j <= actualThickness; j++) {\n      if (i == 0 || j == 0) {\n        continue;\n      }\n\n      vec4 neighborPixelCoord =\n          vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j),\n               gl_FragCoord.z, gl_FragCoord.w);\n\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n      vec4 value = getTextureValue(neighborPosIS);\n\n      // If any of my neighbours are not the same value as I\n      // am, this means I am on the border of the segment.\n      // We can break the loops\n      if (any(notEqual(value, centerValue))) {\n        pixelOnBorder = true;\n        break;\n      }\n    }\n\n    if (pixelOnBorder == true) {\n      break;\n    }\n  }\n\n  // If I am on the border, I am displayed at full opacity\n  if (pixelOnBorder == true) {\n    tColor.a = volume.outlineOpacity;\n  }\n\n  return tColor;\n}\n\nvec4 getColorForAdditivePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\n  // compute normals\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\n  vec4 normalLights[2];\n  normalLights[0] = normalMat[0];\n  normalLights[1] = normalMat[1];\n  #if vtkNumberOfLights > 0\n    if (volume.computeNormalFromOpacity == 1) {\n      for (int component = 0; component < 2; ++component) {\n        vec3 scalarInterp[2];\n        float height = volume.transferFunctionsSampleHeight[component];\n        computeNormalForDensity(posIS, scalarInterp, component);\n        normalLights[component] =\n            computeDensityNormal(scalarInterp, height, 1.0, component);\n      }\n    }\n  #endif\n\n  // compute opacities\n  float opacities[2];\n  opacities[0] = getOpacityFromTexture(\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\n  opacities[1] = getOpacityFromTexture(\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\n  #ifdef EnabledGradientOpacity\n    for (int component = 0; component < 2; ++component) {\n      opacities[component] *=\n          computeGradientOpacityFactor(normalMat[component].a, component);\n    }\n  #endif\n  float opacitySum = opacities[0] + opacities[1];\n  if (opacitySum <= 0.0) {\n    return vec4(0.0);\n  }\n\n  // mix the colors and opacities\n  vec3 colors[2];\n  for (int component = 0; component < 2; ++component) {\n    float sampleHeight = volume.transferFunctionsSampleHeight[component];\n    vec3 color = getColorFromTexture(tValue[component], component, sampleHeight);\n    color = applyAllLightning(color, opacities[component], posVC,\n                              normalLights[component]);\n    colors[component] = color;\n  }\n  vec3 mixedColor =\n      (opacities[0] * colors[0] + opacities[1] * colors[1]) / opacitySum;\n  return vec4(mixedColor, min(1.0, opacitySum));\n}\n\nvec4 getColorForColorizePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\n  // compute normals\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\n  vec4 normalLight = normalMat[0];\n  #if vtkNumberOfLights > 0\n    if (volume.computeNormalFromOpacity == 1) {\n      vec3 scalarInterp[2];\n      float height = volume.transferFunctionsSampleHeight[0];\n      computeNormalForDensity(posIS, scalarInterp, 0);\n      normalLight = computeDensityNormal(scalarInterp, height, 1.0, 0);\n    }\n  #endif\n\n  // compute opacities\n  float opacity = getOpacityFromTexture(\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\n  #ifdef EnabledGradientOpacity\n    opacity *= computeGradientOpacityFactor(normalMat[0].a, 0);\n  #endif\n\n  // colorizing component\n  vec3 colorizingColor = getColorFromTexture(\n      tValue[0], 1, volume.transferFunctionsSampleHeight[1]);\n  float colorizingOpacity = getOpacityFromTexture(\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\n\n  // mix the colors and opacities\n  vec3 color =\n      getColorFromTexture(tValue[0], 0,\n                          volume.transferFunctionsSampleHeight[0]) *\n      mix(vec3(1.0), colorizingColor, colorizingOpacity);\n  color = applyAllLightning(color, opacity, posVC, normalLight);\n  return vec4(color, opacity);\n}\n\nvec4 getColorForDefaultIndependentPreset(vec4 tValue, vec3 posIS) {\n\n  // compute the normal vectors as needed\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\n    mat4 normalMat = computeMat4Normal(posIS, tValue);\n  #endif\n\n  // process color and opacity for each component\n  // initial value of alpha is determined by wether the first component is\n  // proportional or not\n  #if defined(vtkComponent0Proportional)\n    // when it is proportional, it starts at 1 (neutral for multiplications)\n    float alpha = 1.0;\n  #else\n    // when it is not proportional, it starts at 0 (neutral for additions)\n    float alpha = 0.0;\n  #endif\n\n  vec3 mixedColor = vec3(0.0);\n  #if vtkNumberOfComponents > 0\n    {\n      const int component = 0;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent0Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 1\n    {\n      const int component = 1;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent1Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 2\n    {\n      const int component = 2;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent2Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 3\n    {\n      const int component = 3;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent3Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n\n  return vec4(mixedColor, alpha);\n}\n\nvec4 getColorForDependentComponents(vec4 tValue, vec3 posVC, vec3 posIS) {\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\n    // use component 3 of the opacity texture as getTextureValue() sets alpha to\n    // the opacity value\n    vec3 scalarInterp[2];\n    vec4 normal0 = computeNormalForDensity(posIS, scalarInterp, 3);\n    float gradientOpacity = computeGradientOpacityFactor(normal0.a, 0);\n  #endif\n\n  // get color and opacity\n  #if vtkNumberOfComponents == 1\n    vec3 tColor = getColorFromTexture(tValue.r, 0, 0.5);\n    float alpha = getOpacityFromTexture(tValue.r, 0, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 2\n    vec3 tColor = vec3(tValue.r * volume.colorTextureScale[0] +\n                  volume.colorTextureShift[0]);\n    float alpha = getOpacityFromTexture(tValue.a, 1, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 3\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\n              volume.colorTextureShift.rgb;\n      float alpha = getOpacityFromTexture(tValue.a, 0, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 4\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\n              volume.colorTextureShift.rgb;\n      float alpha = getOpacityFromTexture(tValue.a, 3, 0.5);\n  #endif\n\n  // Apply gradient opacity\n  #if defined(EnabledGradientOpacity)\n    alpha *= gradientOpacity;\n  #endif\n\n  #if vtkNumberOfComponents == 1\n    if (alpha < EPSILON) {\n      return vec4(0.0);\n    }\n  #endif\n\n  // lighting\n  #if vtkNumberOfLights > 0\n    vec4 normalLight;\n    if (volume.computeNormalFromOpacity == 1) {\n      if (normal0[3] != 0.0) {\n        normalLight =\n            computeDensityNormal(scalarInterp, 0.5, gradientOpacity, 0);\n        if (normalLight[3] == 0.0) {\n          normalLight = normal0;\n        }\n      }\n    } else {\n      normalLight = normal0;\n    }\n    tColor = applyAllLightning(tColor, alpha, posVC, normalLight);\n  #endif\n\n  return vec4(tColor, alpha);\n}\n\nvec4 getColorForValue(vec4 tValue, vec3 posVC, vec3 posIS) {\n  #ifdef EnableColorForValueFunctionId0\n    return getColorForDependentComponents(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId1\n    return getColorForAdditivePreset(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId2\n    return getColorForColorizePreset(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId3\n    /*\n      * Mix the color information from all the independent components to get a\n      * single rgba output. See other shader functions like\n      * `getColorForAdditivePreset` to learn how to create a custom color mix.\n      * The custom color mix should return a value, but if it doesn't, it will\n      * fallback on the default shading\n      */\n    //VTK::CustomColorMix\n  #endif\n\n  #if defined(EnableColorForValueFunctionId4) || defined(EnableColorForValueFunctionId3)\n    return getColorForDefaultIndependentPreset(tValue, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId5\n    return getColorForLabelOutline();\n  #endif\n}\n\nbool valueWithinScalarRange(vec4 val) {\n  #if vtkNumberOfComponents > 1 && !defined(EnabledIndependentComponents)\n    return false;\n  #endif\n  vec4 rangeMin = volume.ipScalarRangeMin;\n  vec4 rangeMax = volume.ipScalarRangeMax;\n  for (int component = 0; component < vtkNumberOfComponents; ++component) {\n    if (val[component] < rangeMin[component] ||\n        rangeMax[component] < val[component]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n#if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\n  bool checkOnEdgeForNeighbor(int xFragmentOffset, int yFragmentOffset,\n                              int segmentIndex, vec3 stepIS) {\n    vec3 volumeDimensions = vec3(volume.dimensions);\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(xFragmentOffset),\n                                  gl_FragCoord.y + float(yFragmentOffset),\n                                  gl_FragCoord.z, gl_FragCoord.w);\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n\n    vec3 neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\n      vec4 texValue = rawFetchTexture(texCoord);\n      if (int(texValue.g) == segmentIndex) {\n        // not on edge\n        return false;\n      }\n      neighborPosIS += stepIS;\n    }\n\n    neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\n      vec4 texValue = rawFetchTexture(texCoord);\n      if (int(texValue.g) == segmentIndex) {\n        // not on edge\n        return false;\n      }\n      neighborPosIS -= stepIS;\n    }\n\n    // onedge\n    float sampleHeight = volume.transferFunctionsSampleHeight[1];\n    vec3 tColorSegment =\n        getColorFromTexture(float(segmentIndex), 1, sampleHeight);\n    float pwfValueSegment =\n        getOpacityFromTexture(float(segmentIndex), 1, sampleHeight);\n    gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\n    return true;\n  }\n#endif\n\nvec4 getColorAtPos(vec3 posVC) {\n  vec3 posIS = posVCtoIS(posVC);\n  vec4 texValue = getTextureValue(posIS);\n  return getColorForValue(texValue, posVC, posIS);\n}\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 rayOriginVC, vec3 rayDirVC, float minDistance,\n                float maxDistance) {\n  // start slightly inside and apply some jitter\n  vec3 stepVC = rayDirVC * sampleDistance;\n  float raySteps = (maxDistance - minDistance) / sampleDistance;\n\n  // Avoid 0.0 jitter\n  float jitter = 0.01 + 0.99 * fragmentSeed;\n\n  #if vtkBlendMode == COMPOSITE_BLEND\n    // now map through opacity and color\n    vec3 firstPosVC = rayOriginVC + minDistance * rayDirVC;\n    vec4 firstColor = getColorAtPos(firstPosVC);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0) {\n      firstColor.a = 1.0 - pow(1.0 - firstColor.a, raySteps);\n      gl_FragData[0] = firstColor;\n      return;\n    }\n\n    // first color only counts for `jitter` factor of the step\n    firstColor.a = 1.0 - pow(1.0 - firstColor.a, jitter);\n    vec4 color = vec4(firstColor.rgb * firstColor.a, firstColor.a);\n    vec3 posVC = firstPosVC + jitter * stepVC;\n    float stepsTraveled = jitter;\n\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n      vec4 tColor = getColorAtPos(posVC);\n\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * (1.0 - color.a);\n      stepsTraveled++;\n      posVC += stepVC;\n      if (color.a > 0.99) {\n        color.a = 1.0;\n        break;\n      }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0) {\n      vec3 endPosVC = rayOriginVC + maxDistance * rayDirVC;\n      vec4 tColor = getColorAtPos(endPosVC);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb / color.a, color.a);\n  #endif\n\n  #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND ||                                 \\\n      vtkBlendMode == MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND\n      #define OP max\n    #else\n      #define OP min\n    #endif\n\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    // Find a value to initialize the selected variables\n    vec4 selectedValue;\n    vec3 selectedPosVC;\n    vec3 selectedPosIS;\n    {\n      vec3 posIS = posVCtoIS(posVC);\n      selectedValue = getTextureValue(posIS);\n      selectedPosVC = posVC;\n      selectedPosIS = posIS;\n    }\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\n      return;\n    }\n\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      // Get selected values\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 previousSelectedValue = selectedValue;\n      vec4 currentValue = getTextureValue(posIS);\n      selectedValue = OP(selectedValue, currentValue);\n      if (previousSelectedValue != selectedValue) {\n        selectedPosVC = posVC;\n        selectedPosIS = posIS;\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posVC += stepVC;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posVC = rayOriginVC + maxDistance * rayDirVC;\n    {\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 previousSelectedValue = selectedValue;\n      vec4 currentValue = getTextureValue(posIS);\n      selectedValue = OP(selectedValue, currentValue);\n      if (previousSelectedValue != selectedValue) {\n        selectedPosVC = posVC;\n        selectedPosIS = posIS;\n      }\n    }\n\n    gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\n  #endif\n\n  #if vtkBlendMode == ADDITIVE_INTENSITY_BLEND ||                                \\\n      vtkBlendMode == AVERAGE_INTENSITY_BLEND\n    vec4 sum = vec4(0.);\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n      float totalWeight = 0.0;\n    #endif\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    vec3 posIS = posVCtoIS(posVC);\n    vec4 value = getTextureValue(posIS);\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(value * raySteps, posVC, posIS);\n      return;\n    }\n\n    if (valueWithinScalarRange(value)) {\n      sum += value * jitter;\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n        totalWeight += jitter;\n      #endif\n    }\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      posIS = posVCtoIS(posVC);\n      value = getTextureValue(posIS);\n      // One can control the scalar range by setting the AverageIPScalarRange to\n      // disregard scalar values, not in the range of interest, from the average\n      // computation. Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(value)) {\n        sum += value;\n        #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n          totalWeight++;\n        #endif\n      }\n\n      stepsTraveled++;\n      posVC += stepVC;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posVC = rayOriginVC + maxDistance * rayDirVC;\n    posIS = posVCtoIS(posVC);\n    value = getTextureValue(posIS);\n    if (valueWithinScalarRange(value)) {\n      sum += value;\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n        totalWeight += raySteps - stepsTraveled;\n      #endif\n    }\n\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n      sum /= vec4(totalWeight, totalWeight, totalWeight, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posVC, posIS);\n  #endif\n\n  #if vtkBlendMode == RADON_TRANSFORM_BLEND\n    float normalizedRayIntensity = 1.0;\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0) {\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 tValue = getTextureValue(posIS);\n      normalizedRayIntensity -= raySteps * sampleDistance *\n                                getOpacityFromTexture(tValue.r, 0, 0.5);\n      gl_FragData[0] =\n          vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\n      return;\n    }\n\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 value = getTextureValue(posIS);\n      // Convert scalar value to normalizedRayIntensity coefficient and\n      // accumulate normalizedRayIntensity\n      normalizedRayIntensity -=\n          sampleDistance * getOpacityFromTexture(value.r, 0, 0.5);\n\n      posVC += stepVC;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] =\n        vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\n  #endif\n\n  #if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\n    // Only works with a single volume\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n    vec3 posIS = posVCtoIS(posVC);\n    vec4 tValue = getTextureValue(posIS);\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(tValue, posVC, posIS);\n      return;\n    }\n\n    vec3 stepIS = vecVCToIS(stepVC);\n    vec4 value = tValue;\n    posIS += jitter * stepIS;\n    stepsTraveled += jitter;\n    vec3 maxPosIS = posIS; // Store the position of the max value\n    int segmentIndex = int(value.g);\n    bool originalPosHasSeenNonZero = false;\n\n    if (segmentIndex != 0) {\n      // Tried using the segment index in an boolean array but reading\n      // from the array by dynamic indexing was horrondously slow\n      // so use bit masking instead and assign 1 to the bit corresponding to the\n      // segment index and later check if the bit is set via bit operations\n      setLabelOutlineBit(segmentIndex);\n    }\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n      segmentIndex = int(tValue.g);\n\n      if (segmentIndex != 0) {\n        originalPosHasSeenNonZero = true;\n        setLabelOutlineBit(segmentIndex);\n      }\n\n      if (tValue.r > value.r) {\n        value = tValue;   // Update the max value\n        maxPosIS = posIS; // Update the position where max occurred\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = posVCtoIS(rayOriginVC + maxDistance * rayDirVC);\n    tValue = getTextureValue(posIS);\n\n    if (tValue.r > value.r) {\n      value = tValue;   // Update the max value\n      maxPosIS = posIS; // Update the position where max occurred\n    }\n\n    // If we have not seen any non-zero segments, we can return early\n    // and grab color from the actual center value first component (image)\n    if (!originalPosHasSeenNonZero) {\n      vec3 maxPosVC = posIStoVC(maxPosIS);\n      gl_FragData[0] = getColorForValue(value, maxPosVC, maxPosIS);\n      return;\n    }\n\n    vec3 neighborRayStepsIS = stepIS;\n    float neighborRaySteps = raySteps;\n    bool shouldLookInAllNeighbors = false;\n\n    vec3 volumeSpacings = volume.spacing;\n    float minVoxelSpacing =\n        min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\n    vec4 base =\n        vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z,\n                          gl_FragCoord.w);\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z,\n                          gl_FragCoord.w);\n\n    vec3 baseWorld = fragCoordToWorld(base);\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\n\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\n\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\n\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\n      // bail out quickly if the segment index has not\n      // been seen by the center segment\n      if (!isLabelOutlineBitSet(s)) {\n        continue;\n      }\n\n      // Use texture sampling for outlineThickness so that we can have\n      // per segment thickness\n      float textureCoordinate = float(s - 1) / 1024.0;\n      float textureValue =\n          texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\n\n      int actualThickness = int(textureValue * 255.0);\n\n      // check the extreme points in the neighborhood since there is a better\n      // chance of finding the edge there, so that we can bail out\n      // faster if we find the edge\n      bool onEdge = checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(actualThickness, actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(actualThickness, -actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s,\n                                          stepIS);\n\n      if (onEdge) {\n        return;\n      }\n\n      // since the next step is computationally expensive, we need to perform\n      // some optimizations to avoid it if possible. One of the optimizations\n      // is to check the whether the minimum of the voxel spacing is greater than\n      // the 2 * the thickness of the outline segment. If that is the case\n      // then we can safely skip the next step since we can be sure that the\n      // the previous 4 checks on the extreme points would caught the entirety\n      // of the all the fragments inside. i.e., this happens when we zoom out,\n      if (minVoxelSpacing >\n          (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\n        continue;\n      }\n\n      // Loop through the rest, skipping the processed extremes and the center\n      for (int i = -actualThickness; i <= actualThickness; i++) {\n        for (int j = -actualThickness; j <= actualThickness; j++) {\n          if (i == 0 && j == 0)\n            continue; // Skip the center\n          if (abs(i) == actualThickness && abs(j) == actualThickness)\n            continue; // Skip corners\n          if (checkOnEdgeForNeighbor(i, j, s, stepIS)) {\n            return;\n          }\n        }\n      }\n    }\n\n    float sampleHeight = volume.transferFunctionsSampleHeight[0];\n    vec3 tColor0 = getColorFromTexture(value.r, 0, sampleHeight);\n    float pwfValue0 = getOpacityFromTexture(value.r, 0, sampleHeight);\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\n  #endif\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayOriginVC, vec3 rayDirVC) {\n  vec2 dists = rayIntersectVolumeDistances(rayOriginVC, rayDirVC);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0, dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick / rayDirVC.z;\n  dists.y = min(farDist, dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\nfloat getFragmentSeed() {\n  // This first noise has a diagonal pattern\n  float firstNoise =\n      fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n  // This second noise is made out of blocks of CPU generated noise\n  float secondNoise = texture2D(jtexture, gl_FragCoord.xy / 32.0).r;\n  // Combine the two sources of noise in a way that the distribution is uniform\n  // in [0,1[\n  float noiseSum = firstNoise + secondNoise;\n  return noiseSum < 1.0 ? noiseSum : noiseSum - 1.0;\n}\n\nvoid main() {\n  fragmentSeed = getFragmentSeed();\n\n  if (cameraParallel == 1) {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 rayOriginVC = vertexVCVSOutput;\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayOriginVC, rayDirVC);\n  if (rayStartEndDistancesVC[1] <= rayStartEndDistancesVC[0] ||\n      rayStartEndDistancesVC[1] <= 0.0) {\n    // Volume not hit or behind the ray\n    discard;\n  }\n\n  // Perform the blending operation along the ray\n  applyBlend(rayOriginVC, rayDirVC, rayStartEndDistancesVC[0], rayStartEndDistancesVC[1]);\n}\n",e.Geometry=""},e.replaceShaderValues=(e,n,r)=>{let o=e.Fragment;o=Pu.substitute(o,"//VTK::EnabledColorFunctions",`#define EnableColorForValueFunctionId${t.previousState.colorForValueFunctionId}`).result;const a=[];t.previousState.surfaceLightingEnabled&&a.push("Surface"),t.previousState.volumeLightingEnabled&&a.push("Volume"),o=Pu.substitute(o,"//VTK::EnabledLightings",a.map((e=>`#define Enable${e}Lighting`))).result,t.previousState.multiTexturePerVolumeEnabled&&(o=Pu.substitute(o,"//VTK::EnabledMultiTexturePerVolume","#define EnabledMultiTexturePerVolume").result),t.previousState.useIndependentComponents&&(o=Pu.substitute(o,"//VTK::EnabledIndependentComponents","#define EnabledIndependentComponents").result),t.previousState.gradientOpacityEnabled&&(o=Pu.substitute(o,"//VTK::EnabledGradientOpacity","#define EnabledGradientOpacity").result),o=Pu.substitute(o,"//VTK::vtkProportionalComponents",t.previousState.proportionalComponents.map((e=>`#define vtkComponent${e}Proportional`)).join("\n")).result,o=Pu.substitute(o,"//VTK::vtkForceNearestComponents",t.previousState.forceNearestComponents.map((e=>`#define vtkComponent${e}ForceNearest`)).join("\n")).result,t.previousState.hasZBufferTexture&&(o=Pu.substitute(o,"//VTK::ZBuffer::Dec",["uniform sampler2D zBufferTexture;","uniform float vpZWidth;","uniform float vpZHeight;"]).result,o=Pu.substitute(o,"//VTK::ZBuffer::Impl",["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));","float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;","zdepth = zdepth * 2.0 - 1.0;","if (cameraParallel == 0) {","zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}","else {","zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n","zdepth = -zdepth/rayDirVC.z;","dists.y = min(zdepth,dists.y);"]).result),o=Pu.substitute(o,"//VTK::BlendMode",`${t.previousState.blendMode}`).result,o=Pu.substitute(o,"//VTK::NumberOfLights",`${t.previousState.numberOfLights}`).result,o=Pu.substitute(o,"//VTK::MaxLaoKernelSize",`${t.previousState.maxLaoKernelSize}`).result,o=Pu.substitute(o,"//VTK::NumberOfComponents",`${t.previousState.numberOfComponents}`).result,o=Pu.substitute(o,"//VTK::MaximumNumberOfSamples",`${t.previousState.maximumNumberOfSamples}`).result,e.Fragment=o;const i=t.previousState.numberOfClippingPlanes;i>0&&(o=Pu.substitute(o,"//VTK::ClipPlane::Dec",["uniform vec3 vClipPlaneNormals[6];","uniform float vClipPlaneDistances[6];","uniform vec3 vClipPlaneOrigins[6];","uniform int clip_numPlanes;","//VTK::ClipPlane::Dec","#define vtkClippingPlanesOn"],!1).result,o=Pu.substitute(o,"//VTK::ClipPlane::Impl",[`for(int i = 0; i < ${i}; i++) {`,"  float rayDirRatio = dot(rayDirVC, vClipPlaneNormals[i]);","  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];","  if (rayDirRatio == 0.0)","  {","    if (equationResult < 0.0) dists.x = dists.y;","    continue;","  }","  float result = -1.0 * equationResult / rayDirRatio;","  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);","  else dists.x = max(dists.x, result);","}","//VTK::ClipPlane::Impl"],!1).result),e.Fragment=o},e.getNeedToRebuildShaders=(r,o,a)=>{const i=!!t.zBufferTexture,s=t.currentValidInputs.length,l=t.numberOfLights,c=t.numberOfComponents,u=t.useIndependentComponents,d=a.getProperties(),p=t.currentValidInputs[0],f=d[p.inputIndex],g=s>1,m=p.imageData.getBounds(),h=Fi.getDiagonalLength(m),v=Math.ceil(h/e.getCurrentSampleDistance(o));v>t.renderable.getMaximumSamplesPerRay()&&wf(`The number of steps required ${v} is larger than the specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\nPlease either change the volumeMapper sampleDistance or its maximum number of samples.`);const T=u?c:1;let y=!1;for(let e=0;e<T;++e)if(f.getUseGradientOpacity(e)){y=!0;break}let b=0;const x=f.getLAOKernelSize();x>b&&f.getLocalAmbientOcclusion()&&f.getAmbient()>0&&(b=x);const C=t.renderable.getClippingPlanes().length,S=t.renderable.getViewSpecificProperties().OpenGL?.ShaderReplacements,A=t.currentRenderPass?.getShaderReplacement(),I=t.renderable.getBlendMode(),w=(()=>{if(I!==Af.LABELMAP_EDGE_PROJECTION_BLEND&&n(f))return 5;if(u)switch(f.getColorMixPreset()){case Cf.ADDITIVE:return 1;case Cf.COLORIZE:return 2;case Cf.CUSTOM:return 3;default:return 4}return 0})(),O=f.getVolumetricScatteringBlending()<1,P=f.getVolumetricScatteringBlending()>0;let R=!1;for(let e=0;e<c;++e)if(f.getForceNearestInterpolation(e)){R=!0;break}const M=[],E=[];for(let e=0;e<c;e++)f.getOpacityMode(e)===xf.PROPORTIONAL&&M.push(e),f.getForceNearestInterpolation(e)&&E.push(e);const V={numberOfComponents:c,useIndependentComponents:u,proportionalComponents:M,forceNearestComponents:E,blendMode:I,numberOfLights:l,numberOfValidInputs:s,maximumNumberOfSamples:v,hasZBufferTexture:i,maxLaoKernelSize:b,numberOfClippingPlanes:C,mapperShaderReplacements:S,renderPassShaderReplacements:A,colorForValueFunctionId:w,surfaceLightingEnabled:O,volumeLightingEnabled:P,forceNearestInterpolationEnabled:R,multiTexturePerVolumeEnabled:g,gradientOpacityEnabled:y};return!(0!==r.getProgram()?.getHandle()&&t.previousState&&Ge()(t.previousState,V)||(t.previousState=V,0))},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexDC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexDC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Of("Error setting vertexDC in shader VAO.")),n.getAttributeUpdateTime().modified());const i=e.getCurrentSampleDistance(r);a.setUniformf("sampleDistance",i);const s=i*t.renderable.getVolumeShadowSamplingDistFactor();a.setUniformf("volumeShadowSampleDistance",s),t.scalarTextures.forEach(((e,t)=>{a.setUniformi(`volumeTexture[${t}]`,e.getTextureUnit())}));const l=o.getProperties()[t.currentValidInputs[0].inputIndex].getIpScalarRange(),c=new Float32Array(4),u=new Float32Array(4),d=(e,t,n)=>{t?.dataComputedScale?.length&&(c[e]=l[0]*t.dataComputedScale[n]+t.dataComputedOffset[n],u[e]=l[1]*t.dataComputedScale[n]+t.dataComputedOffset[n],c[e]=(c[e]-t.offset[n])/t.scale[n],u[e]=(u[e]-t.offset[n])/t.scale[n])};if(t.previousState.multiTexturePerVolumeEnabled)t.scalarTextures.forEach(((e,t)=>{const n=e.getVolumeInfo();d(t,n,0)}));else{const e=t.scalarTextures[0].getVolumeInfo();for(let t=0;t<4;++t)d(t,e,t)}const p="volume";if(a.setUniform4f(`${p}.ipScalarRangeMin`,c[0],c[1],c[2],c[3]),a.setUniform4f(`${p}.ipScalarRangeMax`,u[0],u[1],u[2],u[3]),null!==t.zBufferTexture){a.setUniformi("zBufferTexture",t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf("vpZWidth",e[0]),a.setUniformf("vpZHeight",e[1])}},e.setCameraShaderParameters=(r,o,a)=>{const{idxToView:i,vecISToVCMatrix:s,modelToView:l,projectionToView:c,projectionToWorld:u}=Pf,d=t.openGLCamera.getKeyMatrices(o),p=t.openGLVolume.getKeyMatrices();y(l,d.wcvc,p.mcwc);const f=r.getProgram(),g=t.openGLCamera.getRenderable(),m=g.getParallelProjection(),v=g.getClippingRange();f.setUniformf("camThick",v[1]-v[0]),f.setUniformf("camNear",v[0]),f.setUniformf("camFar",v[1]),f.setUniformi("cameraParallel",m);const T=t.currentValidInputs[0],b=T.imageData.getBounds(),x=Fi.getCorners(b,[]).map((e=>(wn(e,e,l),m||xn(e,e,-v[0]/(e[2]*mn(e))),wn(e,e,d.vcpc),e))),C=Fi.addPoints([...Fi.INIT_BOUNDS],x);f.setUniformf("dcxmin",C[0]),f.setUniformf("dcxmax",C[1]),f.setUniformf("dcymin",C[2]),f.setUniformf("dcymax",C[3]);const S=e.getRenderTargetSize();f.setUniformf("vpWidth",S[0]),f.setUniformf("vpHeight",S[1]);const A=e.getRenderTargetOffset();f.setUniformf("vpOffsetX",A[0]/S[0]),f.setUniformf("vpOffsetY",A[1]/S[1]),h(c,d.vcpc),f.setUniformMatrix("PCVCMatrix",c),f.setUniformi("twoSidedLighting",o.getTwoSidedLighting());const I=new Array(2*t.previousState.maxLaoKernelSize);for(let e=0;e<t.previousState.maxLaoKernelSize;e++)I[2*e]=Math.random(),I[2*e+1]=Math.random();if(f.setUniform2fv("kernelSample",I),t.numberOfLights>0){let e=0;o.getLights().forEach((t=>{if(t.getSwitch()>0){const n=`lights[${e}]`,r=xn([],t.getColor(),t.getIntensity());f.setUniform3fv(`${n}.color`,r);const o=t.getTransformedPosition();wn(o,o,l),f.setUniform3fv(`${n}.positionVC`,o);const a=[...t.getDirection()];On(a,a,d.normalMatrix),Sn(a,a),f.setUniform3fv(`${n}.directionVC`,a);const i=[-.5*a[0],-.5*a[1],-.5*(a[2]-1)];f.setUniform3fv(`${n}.halfAngleVC`,i);const s=t.getAttenuationValues();f.setUniform3fv(`${n}.attenuation`,s);const c=t.getExponent();f.setUniformf(`${n}.exponent`,c);const u=t.getConeAngle();f.setUniformf(`${n}.coneAngle`,u);const p=t.getPositional();f.setUniformi(`${n}.isPositional`,p),e++}}))}const w="volume",O=a.getProperties()[T.inputIndex],P=T.imageData,R=P.getSpatialExtent(),M=P.getSpacing(),E=P.getDimensions(),V=P.getIndexToWorld(),D=P.getWorldToIndex(),L=P.getDirectionByReference();y(i,l,V),f.setUniform3fv(`${w}.spacing`,M);const B=Cn([],M);f.setUniform3fv(`${w}.inverseSpacing`,B),f.setUniform3iv(`${w}.dimensions`,E),f.setUniform3fv(`${w}.inverseDimensions`,Cn([],E)),f.setUniformMatrix(`${w}.worldToIndex`,D),s.fill(0);const N=bn(new Float64Array(3),E,M);s[0]=N[0],s[4]=N[1],s[8]=N[2],ve(s,L,s),ve(s,p.normalMatrix,s),ve(s,d.normalMatrix,s),f.setUniformMatrix3x3(`${w}.vecISToVCMatrix`,s),f.setUniformMatrix3x3(`${w}.vecVCToISMatrix`,ge(new Float32Array(9),s));const F=hn(R[0],R[2],R[4]),_=wn(new Float64Array(3),F,i);f.setUniform3fv(`${w}.originVC`,_);const G=mn(N);if(f.setUniformf(`${w}.diagonalLength`,G),n(O)){const e=g.getDistance();g.setClippingRange(e,e+.1),h(u,t.openGLCamera.getKeyMatrices(o).wcpc),g.setClippingRange(v[0],v[1]),t.openGLCamera.getKeyMatrices(o),f.setUniformMatrix(`${w}.PCWCMatrix`,u)}if(O.getVolumetricScatteringBlending()>0&&(f.setUniformf(`${w}.globalIlluminationReach`,O.getGlobalIlluminationReach()),f.setUniformf(`${w}.volumetricScatteringBlending`,O.getVolumetricScatteringBlending()),f.setUniformf(`${w}.anisotropy`,O.getAnisotropy()),f.setUniformf(`${w}.anisotropySquared`,O.getAnisotropy()**2)),O.getLocalAmbientOcclusion()&&O.getAmbient()>0){const e=O.getLAOKernelSize();f.setUniformi(`${w}.kernelSize`,e);const t=O.getLAOKernelRadius();f.setUniformi(`${w}.kernelRadius`,t)}else f.setUniformi(`${w}.kernelSize`,0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();o.setUniformi("jtexture",t.jitterTexture.getTextureUnit());const a=r.getProperties();o.setUniformi("labelOutlineThicknessTexture",t.labelOutlineThicknessTexture.getTextureUnit()),o.setUniformi("opacityTexture",t.opacityTexture.getTextureUnit()),o.setUniformi("colorTexture",t.colorTexture.getTextureUnit());const i="volume",s=a[t.currentValidInputs[0].inputIndex],l=t.previousState.numberOfComponents,c=t.previousState.useIndependentComponents;if(c){const e=new Float32Array(4);for(let t=0;t<l;t++)e[t]=s.getComponentWeight(t);o.setUniform4fv(`${i}.independentComponentMix`,e);const t=new Float32Array(4),n=1/l;for(let e=0;e<l;++e)t[e]=(e+.5)*n;o.setUniform4fv(`${i}.transferFunctionsSampleHeight`,t)}const u=t.colorForValueFunctionId;o.setUniformi(`${i}.colorForValueFunctionId`,u);const d=s.getComputeNormalFromOpacity();o.setUniformi(`${i}.computeNormalFromOpacity`,d);const p=new Float32Array(4),f=new Float32Array(4),g=new Float32Array(4),m=new Float32Array(4);for(let e=0;e<l;e++){const n=t.previousState.multiTexturePerVolumeEnabled,r=n?e:0,o=n?0:e,a=t.scalarTextures[r].getVolumeInfo(),i=c?e:0,l=a.scale[o],u=s.getRGBTransferFunction(i).getRange();p[e]=l/(u[1]-u[0]),f[e]=(a.offset[o]-u[0])/(u[1]-u[0]);const d=s.getScalarOpacity(i).getRange();g[e]=l/(d[1]-d[0]),m[e]=(a.offset[o]-d[0])/(d[1]-d[0])}if(o.setUniform4fv(`${i}.colorTextureScale`,p),o.setUniform4fv(`${i}.colorTextureShift`,f),o.setUniform4fv(`${i}.opacityTextureScale`,g),o.setUniform4fv(`${i}.opacityTextureShift`,m),t.previousState.gradientOpacityEnabled){const e=new Array(4),n=new Array(4),r=new Array(4),a=new Array(4);if(c)for(let o=0;o<l;++o){const i=t.previousState.multiTexturePerVolumeEnabled,l=i?o:0,c=i?0:o,u=t.scalarTextures[l].getVolumeInfo().scale[c];if(s.getUseGradientOpacity(o)){const t=[s.getGradientOpacityMinimumOpacity(o),s.getGradientOpacityMaximumOpacity(o)],i=[s.getGradientOpacityMinimumValue(o),s.getGradientOpacityMaximumValue(o)];r[o]=t[0],a[o]=t[1],e[o]=u*(t[1]-t[0])/(i[1]-i[0]),n[o]=-i[0]*(t[1]-t[0])/(i[1]-i[0])+t[0]}else r[o]=1,a[o]=1,e[o]=0,n[o]=1}else{const o=l-1,i=t.previousState.multiTexturePerVolumeEnabled,c=i?o:0,u=i?0:o,d=t.scalarTextures[c].getVolumeInfo().scale[u],p=[s.getGradientOpacityMinimumOpacity(0),s.getGradientOpacityMaximumOpacity(0)],f=[s.getGradientOpacityMinimumValue(0),s.getGradientOpacityMaximumValue(0)];r[0]=p[0],a[0]=p[1],e[0]=d*(p[1]-p[0])/(f[1]-f[0]),n[0]=-f[0]*(p[1]-p[0])/(f[1]-f[0])+p[0]}o.setUniform4f(`${i}.gradientOpacityScale`,e),o.setUniform4f(`${i}.gradientOpacityShift`,n),o.setUniform4f(`${i}.gradientOpacityMin`,r),o.setUniform4f(`${i}.gradientOpacityMax`,a)}const h=s.getLabelOutlineOpacity();if(o.setUniformf(`${i}.outlineOpacity`,h),t.numberOfLights>0){o.setUniformf(`${i}.ambient`,s.getAmbient()),o.setUniformf(`${i}.diffuse`,s.getDiffuse()),o.setUniformf(`${i}.specular`,s.getSpecular());const e=s.getSpecularPower();o.setUniformf(`${i}.specularPower`,0===e?1:e)}},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();On(t,t,r.normalMatrix),wn(n,n,r.wcvc);const l=-1*An(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv("vClipPlaneNormals",o),c.setUniformfv("vClipPlaneDistances",a),c.setUniform3fv("vClipPlaneOrigins",i),c.setUniformi("clip_numPlanes",l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),(()=>{t._openGLRenderWindow&&a(t._openGLRenderWindow)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n&&n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r);const a=r.getProperties();t.currentValidInputs.forEach((e=>{let{inputIndex:n}=e;const r=a[n].getInterpolationType(),o=t.scalarTextures[n];r===bf.NEAREST?(o.setMinificationFilter(Fu.NEAREST),o.setMagnificationFilter(Fu.NEAREST)):(o.setMinificationFilter(Fu.LINEAR),o.setMagnificationFilter(Fu.LINEAR))})),null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context,a=[...t.scalarTextures,t.colorTexture,t.opacityTexture,t.labelOutlineThicknessTexture,t.jitterTexture];a.forEach((e=>e.activate())),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),a.forEach((e=>e.deactivate()))},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","uniform vec2 tfactor;","varying vec2 tcoord;","void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"),["//VTK::System::Dec","//VTK::Output::Dec","uniform sampler2D texture1;","varying vec2 tcoord;","void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"),"");const e=t.copyShader;t.copyVAO=Eu.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Of("Error setting vertexDC in copy shader VAO.")}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi("texture",n.getTextureUnit()),t.copyShader.setUniform2f("tfactor",t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update();const o=t.renderable.getNumberOfInputPorts();t.currentValidInputs=[];for(let e=0;e<o;++e){const n=t.renderable.getInputData(e);n&&!n.isDeleted()&&t.currentValidInputs.push({imageData:n,inputIndex:e})}let a=0;if(t.currentValidInputs.length>0){const e=r.getProperties(),o=t.currentValidInputs[0],i=o.imageData.getPointData().getScalars(),s=e[o.inputIndex];s.getShade()&&t.renderable.getBlendMode()===Af.COMPOSITE_BLEND&&n.getLights().forEach((e=>{e.getSwitch()>0&&a++}));const l=t.currentValidInputs.length,c=l>1;t.numberOfComponents=c?l:i.getNumberOfComponents(),t.useIndependentComponents=function(e,t){const n=e.getIndependentComponents(),r=e.getColorMixPreset();return n&&t>=2||!!r}(s,t.numberOfComponents)}a!==t.numberOfLights&&(t.numberOfLights=a,e.modified()),e.invokeEvent({type:"EndEvent"}),0!==t.currentValidInputs.length&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty(t.currentValidInputs[0].inputIndex)?.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.currentValidInputs.some((e=>{let{imageData:n}=e;return t.VBOBuildTime.getMTime()<n.getMTime()}))||t.scalarTextures.length!==t.currentValidInputs.length||!t.scalarTextures.every((e=>!!e?.getHandle()))||!t.colorTexture?.getHandle()||!t.opacityTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle()||!t.jitterTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{if(!t.jitterTexture.getHandle()){const e=new Float32Array(1024);for(let t=0;t<1024;++t)e[t]=Math.random();t.jitterTexture.setMinificationFilter(Fu.NEAREST),t.jitterTexture.setMagnificationFilter(Fu.NEAREST),t.jitterTexture.create2DFromRaw({width:32,height:32,numComps:1,dataType:is.FLOAT,data:e})}const a=r.getProperties(),i=t.currentValidInputs[0],s=a[i.inputIndex],l=t.numberOfComponents,c=t.useIndependentComponents,u=c?l:1,d=[];for(let e=0;e<u;++e)d.push(s.getScalarOpacity(e));const p=Xp(d,c,u),f=s.getScalarOpacity(),g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g.hash===p)t.opacityTexture=g.oglObject;else{const r=td.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow);let o=t.renderable.getOpacityTextureWidth();o<=0&&(o=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const a=2*o*u,i=new Float32Array(a),l=new Float32Array(o);for(let t=0;t<u;++t){const r=s.getScalarOpacity(t),a=e.getCurrentSampleDistance(n)/s.getScalarOpacityUnitDistance(t),c=r.getRange();r.getTable(c[0],c[1],o,l,1);for(let e=0;e<o;++e)i[t*o*2+e]=1-(1-l[e])**a,i[t*o*2+e+o]=i[t*o*2+e]}if(r.resetFormatAndType(),r.setMinificationFilter(Fu.LINEAR),r.setMagnificationFilter(Fu.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))r.create2DFromRaw({width:o,height:2*u,numComps:1,dataType:is.FLOAT,data:i});else{const e=new Uint8ClampedArray(a);for(let t=0;t<a;++t)e[t]=255*i[t];r.create2DFromRaw({width:o,height:2*u,numComps:1,dataType:is.UNSIGNED_CHAR,data:e})}f&&t._openGLRenderWindow.setGraphicsResourceForObject(f,r,p),t.opacityTexture=r}o(t._openGLRenderWindow,t._opacityTextureCore,f),t._opacityTextureCore=f;const m=[];for(let e=0;e<u;++e)m.push(s.getRGBTransferFunction(e));const h=Xp(m,c,u),v=s.getRGBTransferFunction(),T=t._openGLRenderWindow.getGraphicsResourceForObject(v);if(T?.oglObject?.getHandle()&&T?.hash===h)t.colorTexture=T.oglObject;else{const e=td.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(2*n*u*3),o=new Float32Array(3*n);for(let e=0;e<u;++e){const t=s.getRGBTransferFunction(e),a=t.getRange();t.getTable(a[0],a[1],n,o,1);for(let t=0;t<3*n;++t)r[e*n*6+t]=255*o[t],r[e*n*6+t+3*n]=255*o[t]}e.resetFormatAndType(),e.setMinificationFilter(Fu.LINEAR),e.setMagnificationFilter(Fu.LINEAR),e.create2DFromRaw({width:n,height:2*u,numComps:3,dataType:is.UNSIGNED_CHAR,data:r}),t._openGLRenderWindow.setGraphicsResourceForObject(v,e,h),t.colorTexture=e}o(t._openGLRenderWindow,t._colorTextureCore,v),t._colorTextureCore=v,t.currentValidInputs.forEach(((e,n)=>{let{imageData:r,inputIndex:i}=e;const s=a[i],l=r.getPointData().getScalars(),c=t._openGLRenderWindow.getGraphicsResourceForObject(l),u=Yp(0,l),d=!c?.oglObject?.getHandle()||c?.hash!==u,p=s.getUpdatedExtents(),f=!!p.length;if(d&&!f){const e=td.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);const o=r.getDimensions();e.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),e.resetFormatAndType(),e.create3DFilterableFromDataArray({width:o[0],height:o[1],depth:o[2],dataArray:l,preferSizeOverAccuracy:s.getPreferSizeOverAccuracy()}),t._openGLRenderWindow.setGraphicsResourceForObject(l,e,u),t.scalarTextures[n]=e}else t.scalarTextures[n]=c.oglObject;if(f){s.setUpdatedExtents([]);const e=r.getDimensions();t.scalarTextures[n].create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:l,updatedExtents:p})}o(t._openGLRenderWindow,t._scalarTexturesCore[n],l),t._scalarTexturesCore[n]=l}));const y=s.getLabelOutlineThickness(),b=t._openGLRenderWindow.getGraphicsResourceForObject(y),x=y.join("-");if(b?.oglObject?.getHandle()&&b?.hash===x)t.labelOutlineThicknessTexture=b.oglObject;else{const e=td.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=1,o=new Uint8Array(n*r);for(let e=0;e<n;++e){const t=void 0!==y[e]?y[e]:y[0];o[e]=t}e.resetFormatAndType(),e.setMinificationFilter(Fu.NEAREST),e.setMagnificationFilter(Fu.NEAREST),e.create2DFromRaw({width:n,height:r,numComps:1,dataType:is.UNSIGNED_CHAR,data:o}),y&&t._openGLRenderWindow.setGraphicsResourceForObject(y,e,x),t.labelOutlineThicknessTexture=e}if(o(t._openGLRenderWindow,t._labelOutlineThicknessTextureCore,y),t._labelOutlineThicknessTextureCore=y,!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Ts.newInstance({numberOfComponents:3,values:e});r.setName("points");const o=Ts.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,"polys",qi.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLVolumeMapper");en("vtkVolumeMapper",Mf);const{vtkDebugMacro:Ef}=jt,Vf={};const Df=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vf,n),Xt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():Ef("No framebuffer to save/restore");const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}(e,t)}),"vtkOpenGLPixelSpaceCallbackMapper");en("vtkPixelSpaceCallbackMapper",Df);var Lf="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtktextureObjectVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\nattribute vec2 tcoordDC;\nvarying vec2 tcoordVC;\n\nvoid main()\n{\n  tcoordVC = tcoordDC;\n  gl_Position = vertexDC;\n}\n";const{Representation:Bf}=ts;function Nf(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=td.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw({width:o,height:a,numComps:4,dataType:"Float32Array",data:null}),s.activate(),s.sendParameters(),s.deactivate(),s}function Ff(e,t){return Nf(e,t,td.Filter.NEAREST,td.Wrap.CLAMP_TO_EDGE)}const _f={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function Gf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_f,n),Ht.obj(e,t),Ht.get(e,t,["readIndex"]),Ht.setGet(e,t,["doEEPass","doVTPass","_openGLRenderWindow","vectorTexture","maskVectorTexture","noiseTexture","framebuffer","size"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkLICPingPongBufferManager"),t._openGLRenderWindow?(t.quad=function(e){const t=Bu.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ts.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ts.newInstance({numberOfComponents:1,values:o}),s=Ts.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",Bf.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=Ff(t._openGLRenderWindow,t.size),t.seedTexture0=Ff(t._openGLRenderWindow,t.size),t.licTexture1=Ff(t._openGLRenderWindow,t.size),t.seedTexture1=Ff(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?Nf(t._openGLRenderWindow,t.size,td.Filter.NEAREST,td.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?(n=t._openGLRenderWindow,r=t.size,Nf(n,r,td.Filter.LINEAR,td.Wrap.CLAMP_TO_EDGE)):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=Eu.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error("Wrong LIC pass number")}},e.deactivateNoiseTexture=function(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error("Wrong LIC pass number")}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error("Pass renderwindow to ping pong manager");var n,r}(e,t)}var kf={newInstance:Ht.newInstance(Gf,"vtkLICPingPongBufferManager"),extend:Gf};const Uf=0,zf=1,Wf=2,Hf=3,jf=1,Kf={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function $f(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kf,n),Ht.obj(e,t),Ht.setGet(e,t,["context","_openGLRenderWindow","nuberOfSteps","stepSize","normalizeVectors","maskThreshold","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","componentIds","isComposite"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){function n(e,t){e.setUniformi("texLIC",t.getLICTextureUnit()),e.setUniformi("texSeedPts",t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push("vtkLineIntegralConvolution2D"),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Lf,e,""),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=qd.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t="xyzw";return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n/**\nThis shader initializes the convolution for the LIC computation.\n*/\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texMaskVectors;\nuniform sampler2D texNoise;\nuniform sampler2D texLIC;\n\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the *whole* domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value. this\n// depends on the pass number.\nvec2 getNoiseTC(vec2 vectc)\n{\n  // in pass 1 : convert from vector tc to noise tc\n  // in pass 2 : use vector tc\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(vectc);\n    }\n  else\n    {\n    return vectc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the\n// need to convert to noise texture coordinates.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\nvoid main(void)\n{\n  vec2 vectc = tcoordVC.st;\n\n  // lic => (convolution, mask, 0, step count)\n  if (uStepNo == 0)\n    {\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\n    float maskFlag;\n    if (maskCriteria <= uMaskThreshold)\n      {\n      maskFlag = 1.0;\n      }\n    else\n      {\n      maskFlag = 0.0;\n      }\n    float noise = getNoise(vectc);\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\n    }\n  else\n    {\n    LICOutput = texture2D(texLIC, vectc);\n    }\n\n  // initial seed\n  SeedOutput = vec4(vectc, 0.0, 1.0);\n}\n");const n=Pu.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// move vector field to normalized image space\n// pre-processing for vtkLineIntegralConvolution2D\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Fragment shader used by the gaussian blur filter render pass.\n\nuniform sampler2D texVectors; // input texture\nuniform vec2      uTexSize;   // size of texture\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  //VTK::LICComponentSelection::Impl\n  V = V/uTexSize;\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\n}\n","//VTK::LICComponentSelection::Impl",`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=Pu.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D  texVectors;\nuniform sampler2D  texNoise;\nuniform sampler2D  texLIC;\nuniform sampler2D  texSeedPts;\n\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\nuniform float uStepSize;        // step size in parametric space\n\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n//VTK::LICVectorLookup::Impl\n\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\n// are very poorly supported in webgl\nvec2 clampToBorder(vec2 uv){\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n  {\n    return vec2(0.0, 0.0);\n  }\n  return getVector(uv);\n}\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the whole domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value.\n// in pass 1 repeatedly tile the noise texture across\n// the computational domain.\nvec2 getNoiseTC(vec2 tc)\n{\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(tc);\n    }\n  else\n    {\n    return tc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the need\n// to convert to either noise or lic texture coordinates in\n// pass 1 and 2 respectively.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\n// fourth-order Runge-Kutta streamline integration\n// no bounds checks are made, therefore it's essential\n// to have the entire texture initialized to 0\n// and set clamp to border and have border color 0\n// an integer is set if the step was taken, keeping\n// an accurate step count is necessary to prevent\n// boundary artifacts. Don't count the step if\n// all vector lookups are identically 0. This is\n// a proxy for \"stepped outside valid domain\"\nvec2 rk4(vec2 pt0, float dt, out bool count)\n{\n  count=true;\n  float dtHalf = dt * 0.5;\n  vec2 pt1;\n\n  vec2 v0 = clampToBorder(pt0);\n  pt1 = pt0 + v0 * dtHalf;\n\n  vec2 v1 = clampToBorder(pt1);\n  pt1 = pt0 + v1 * dtHalf;\n\n  vec2 v2 = clampToBorder(pt1);\n  pt1 = pt0 + v2 * dt;\n\n  vec2 v3 = clampToBorder(pt1);\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\n\n  if (vSum == vec2(0.0, 0.0))\n    {\n      count = false;\n    }\n\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\n\n return pt1;\n}\n\nvoid main(void)\n{\n  vec2 lictc = tcoordVC.st;\n  vec4 lic = texture2D(texLIC, lictc);\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\n\n  bool count;\n  vec2 pt1 = rk4(pt0, uStepSize, count);\n\n  if (count)\n    {\n    // accumulate lic step\n    // (lic, mask, 0, step count)\n    float noise = getNoise(pt1);\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\n    SeedOutput = vec4(pt1, 0.0, 1.0);\n    }\n  else\n    {\n    // keep existing values\n    LICOutput = lic;\n    SeedOutput = vec4(pt0, 0.0, 1.0);\n    }\n}\n","//VTK::LICVectorLookup::Impl",function(){return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?"\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      return texture2D( texVectors, vectc ).xy;\n\n      }\n\n    ":"\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      vec2 V = texture2D( texVectors, vectc ).xy;\n\n      // normalize if |V| not 0\n\n      float lenV = length( V );\n\n      if ( lenV > 1.0e-8 )\n\n        {\n\n        return V/lenV;\n\n        }\n\n      else\n\n        {\n\n        return vec2( 0.0, 0.0 );\n\n        }\n\n      }\n\n    "}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(" //VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n/**\nThis shader finalizes the convolution for the LIC computation\napplying the normalization. eg. if box kernel is used the this\nis the number of steps taken.\n*/\n\nuniform sampler2D texLIC;\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\n  conv.r = conv.r/conv.a;\n  // lic => (convolution, mask, 0, 1)\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.CEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// gray scale contrast enhance stage implemented via histogram stretching\n// if the min and max are tweaked it can generate out-of-range values\n// these will be clamped in 0 to 1\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n\nuniform sampler2D texLIC;  // most recent lic pass\nuniform float uMin;        // min gray scale color value\nuniform float uMaxMinDiff; // max-min\n\nin vec2 tcoordVC;\n\nvoid main( void )\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g!=0.0)\n    {\n    LICOutput = lic;\n    }\n  else\n    {\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\n    LICOutput = vec4(CElic, lic.gb, 1.0);\n    }\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.EEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\n// noise for pass2.\n\n// the output of this shader\nlayout(location = 0) out vec4 EEOutput;\n\nuniform sampler2D texLIC; // most recent lic pass\nuniform float     uDx;    // fragment size\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n// kernel for simple laplace edge enhancement.\n// p=Laplace(p)+p\nfloat K[9] = float[9](\n  -1.0, -1.0, -1.0,\n  -1.0,  9.0, -1.0,\n  -1.0, -1.0, -1.0\n  );\n\n// determine if the fragment was masked\nbool Masked(float val) { return val != 0.0; }\n\nvoid main(void)\n{\n  // tex coord neighbor offsets\n  vec2 fragDx[9] = vec2[9](\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\n    );\n\n  vec2 lictc = tcoordVC.st;\n\n  // compute the convolution but don't use convovled values if\n  // any masked fragments on the stencil. Fragments outside\n  // the valid domain are masked during initialization, and\n  // texture wrap parameters are clamp to border with border\n  // color that contains masked flag\n  float conv = 0.0;\n  bool dontUse = false;\n  for (int i=0; i<9; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    vec4 lic = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic.g);\n    conv = conv + K[i] * lic.r;\n    }\n\n  if (dontUse)\n    {\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\n    }\n  else\n    {\n    conv = clamp(conv, 0.0, 1.0);\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\n    }\n\n}\n"),t.AAHProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// horizontal pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDx;    // fragment size\n\nin vec2 tcoordVC;\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.AAVProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// vertical pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\n\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDy[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n")},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;const g=f?.getSize();f&&g&&o[0]===g&&o[1]===g||(f=qd.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=kf.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const m=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],h=1/o[0],v=1/o[1],T=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;T.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f("uTexSize",...o),e.setUniformi("texVectors",t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:y}=t;T.readyShaderProgram(y),y.setUniformi("uStepNo",0),y.setUniformi("uPassNo",0),y.setUniformf("uMaskThreshold",t.maskThreshold),y.setUniform2f("uNoiseBoundsPt1",...m),y.setUniformi("texMaskVectors",t.bufs.getMaskVectorTextureUnit()),y.setUniformi("texLIC",t.bufs.getLICTextureUnit()),y.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,y);const{LICIShaderProgram:b}=t;T.readyShaderProgram(b),b.setUniformi("uPassNo",0),b.setUniformf("uStepSize",-d),b.setUniform2f("uNoiseBoundsPt1",...m),b.setUniformi("texVectors",t.bufs.getImageVectorTextureUnit()),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);T.readyShaderProgram(y),y.setUniformi("uStepNo",1),n(y,t.bufs),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:x}=t;if(T.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),r(t.bufs,o,x),t.enhancedLIC){t.enhanceContrast!==zf&&t.enhanceContrast!==Hf||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;T.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDx",h),a.setUniformf("uDy",v),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),T.readyShaderProgram(y),y.setUniformi("uStepNo",0),y.setUniformi("uPassNo",1),n(y,t.bufs),y.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformi("uPassNo",1),b.setUniformf("uStepSize",-d),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);T.readyShaderProgram(y),y.setUniformi("uStepNo",1),n(y,t.bufs),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),T.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),x.setUniformi("texSeedPts",t.bufs.getSeedTextureUnit()),r(t.bufs,o,x)}if(t.antiAlias){const e=t.AAHProgram;T.readyShaderProgram(e),e.setUniformi("texLIC",t.bufs.getLICTextureUnit()),e.setUniformf("uDx",h);const a=t.AAVProgram;T.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDy",v);for(let i=0;i<t.antiAlias;++i)T.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),T.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==zf&&t.enhanceContrast!==Hf||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error("Invalid color range: ",i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi("texLIC",t.bufs.getLICTextureUnit()),c.setUniformf("uMin",i),c.setUniformf("uMaxMinDiff",l),r(t.bufs,o,c)}}(e,t)}var qf={newInstance:Ht.newInstance($f,"vtkLineIntegralConvolution2D"),extend:$f};const Xf={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:Uf,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:jf,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function Yf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xf,n),Ht.obj(e,t),Ht.setGet(e,t,["enableLIC","numberOfSteps","stepSize","normalizeVectors","transformVectors","maskOnSurface","maskThreshold","maskColor","maskIntensity","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor","antiAlias","colorMode","LICIntensity","mapModeBias","noiseTextureSize","noiseTextureType","noiseGrainSize","minNoiseValue","maxNoiseValue","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","noiseGeneratorSeed","viewPortScale","rebuildNoiseTexture"]),function(e,t){t.classHierarchy.push("vtkSurfaceLICInterface")}(0,t)}var Zf={newInstance:Ht.newInstance(Yf,"vtkSurfaceLICInterface"),extend:Yf};const{Representation:Qf}=ts;const Jf={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function eg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jf,n),Zf.extend(e,t,n),Ht.obj(e,t),Ht.setGet(e,t,["context","_openGLRenderWindow","reallocateTextures","licInterface","size"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICInterface"),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=Eu.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),io()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get("noiseTextureType","noiseGrainSize","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","minNoiseValue","maxNoiseValue");n=r===jf?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=td.newInstance({wrapS:td.Wrap.REPEAT,wrapT:td.Wrap.REPEAT,minificationFilter:td.Filter.NEAREST,magnificationFilter:td.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw({width:e,height:e,numComps:4,dataType:"Float32Array",data:d}),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Lf,e,""),e.allocateTextures=()=>{const n=td.Filter.NEAREST,r=td.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=td.newInstance({wrapS:td.Wrap.CLAMP_TO_EDGE,wrapT:td.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw({width:t.size[0],height:t.size[1],numComps:4,dataType:"Float32Array",data:null}),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=td.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw({width:t.size[0],height:t.size[1],dataType:"Float32Array",data:null}),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=qd.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader combines surface geometry, LIC, and  scalar colors.\n\n// the output of this shader\nlayout(location = 0) out vec4 RGBOutput;\nlayout(location = 1) out vec4 HSLOutput;\n\nuniform sampler2D texVectors;       // vectors, depth\nuniform sampler2D texGeomColors;    // scalar colors + lighting\nuniform sampler2D texLIC;           // image lic\nuniform int       uScalarColorMode; // select between blend, and map shader\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\nuniform float     uMaskIntensity;   // blending factor for mask color\nuniform vec3      uMaskColor;       // color for the masked out fragments\n\nin vec2 tcoordVC;\n\n/**\nConvert from RGB color space into HSL colorspace.\n*/\nvec3 RGBToHSL(vec3 RGB)\n{\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\n\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\n  float RGBMaxMinDiff = RGBMax - RGBMin;\n\n  HSL.z = (RGBMax + RGBMin) / 2.0;\n\n  if (RGBMaxMinDiff == 0.0)\n    {\n    // Gray scale\n    HSL.x = 0.0;\n    HSL.y = 0.0;\n    }\n  else\n    {\n    // Color\n    if (HSL.z < 0.5)\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\n    else\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\n\n    float dR\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dG\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dB\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n\n    if (RGB.r == RGBMax)\n      HSL.x = dB - dG;\n    else\n    if (RGB.g == RGBMax)\n      HSL.x = (1.0 / 3.0) + dR - dB;\n    else\n    if (RGB.b == RGBMax)\n      HSL.x = (2.0 / 3.0) + dG - dR;\n\n    if (HSL.x < 0.0)\n      HSL.x += 1.0;\n\n    if (HSL.x > 1.0)\n      HSL.x -= 1.0;\n    }\n\n  return HSL;\n}\n\n/**\nHelper for HSL to RGB conversion.\n*/\nfloat Util(float v1, float v2, float vH)\n{\n  if (vH < 0.0)\n    vH += 1.0;\n\n  if (vH > 1.0)\n     vH -= 1.0;\n\n  if ((6.0 * vH) < 1.0)\n    return (v1 + (v2 - v1) * 6.0 * vH);\n\n  if ((2.0 * vH) < 1.0)\n    return (v2);\n\n  if ((3.0 * vH) < 2.0)\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\n\n  return v1;\n}\n\n/**\nConvert from HSL space into RGB space.\n*/\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  if (HSL.y == 0.0)\n    {\n    // Gray\n    RGB.r = HSL.z;\n    RGB.g = HSL.z;\n    RGB.b = HSL.z;\n    }\n  else\n    {\n    // Chromatic\n    float v2;\n    if (HSL.z < 0.5)\n      v2 = HSL.z * (1.0 + HSL.y);\n    else\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\n\n    float v1 = 2.0 * HSL.z - v2;\n\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\n    RGB.g = Util(v1, v2, HSL.x);\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\n    }\n\n  return RGB.rgb;\n}\n\nvoid main()\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n\n  // depth is used to determine which fragment belong to us\n  // and we can change\n  float depth = texture2D(texVectors, tcoordVC.st).a;\n\n  vec3 fragColorRGB;\n  float valid;\n  if (depth > 1.0e-3)\n    {\n    // we own it\n    // shade LIC'ed geometry, or apply mask\n    if (lic.g!=0.0)\n      {\n      // it's masked\n      // apply fragment mask\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\n      valid = 0.0;\n      }\n    else\n      {\n      if (uScalarColorMode==0)\n        {\n        // blend with scalars\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\n        }\n      else\n        {\n        // multiply with scalars\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\n        }\n      if (lic.b != 0.0)\n        {\n        // didn't have the required guard pixels\n        // don't consider it in min max estimation\n        // for histpgram stretching\n        valid = 0.0;\n        }\n      else\n        {\n        // ok to use in min/max estimates for histogram\n        // stretching\n        valid = 1.0;\n        }\n      }\n    }\n  else\n    {\n    // we don't own it\n    // pass through scalars\n    fragColorRGB = geomColor.rgb;\n    valid = 0.0;\n    }\n\n  // if no further stages this texture is\n  // copied to the screen\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\n\n  // if further stages, move to hsl space for contrast\n  // enhancement. encoding validity saves moving a texture to the cpu\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\n  HSLOutput = vec4(fragColorHSL, valid);\n}\n"),t.licCopyPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader copies fragments and depths to the output buffer\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texDepth;     // z values from vertex shader\nuniform sampler2D texRGBColors; // final rgb LIC colors\n\nin vec2 tcoordVC;\n\nvoid main()\n{\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\n\n  // since we render a screen aligned quad\n  // we're going to be writing fragments\n  // not touched by the original geometry\n  // it's critical not to modify those\n  // fragments.\n  if (gl_FragDepth == 1.0)\n    {\n    discard;\n    }\n}\n"),t.enhanceContrastPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// color contrast enhance stage implemented via histogram stretching\n// on lightness channel. if the min and max are tweaked it can generate\n// out-of-range values these will be clamped in 0 to 1\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texGeomColors; // scalars + lighting\nuniform sampler2D texLIC;        // image lic, mask\nuniform sampler2D texHSLColors;  // hsla colors\n\nuniform float     uLMin;         // min lightness over all fragments\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\n\nin vec2 tcoordVC;\n\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  float v;\n  float h = HSL.x;\n  float sl = HSL.y;\n  float l = HSL.z;\n\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\n  if (v <= 0.0) {\n    RGB = vec3(0.0,0.0,0.0);\n  } else {\n    float m;\n    int sextant;\n    float fract, vsf, mid1, mid2;\n\n    m = l + l - v;\n    h *= 6.0;\n    sextant = int(h);\n    fract = h - float(sextant);\n\n    vsf = (v - m) * fract;\n    mid1 = m + vsf;\n    mid2 = v - vsf;\n    switch (sextant) {\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\n    }\n  }\n  return RGB;\n}\n\nvoid main()\n{\n  // lookup hsl color , mask\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\n\n  // don't modify masked fragments (masked => lic.g==1)\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g==0.0)\n    {\n    // normalize lightness channel\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\n    }\n\n  // back into rgb space\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\n\n  // add alpha\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n  fragColor.a = geomColor.a;\n\n  gl_FragData[0] = fragColor;\n}\n"),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=Bu.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ts.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ts.newInstance({numberOfComponents:1,values:o}),s=Ts.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",Qf.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=qf.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi("texDepth",t.depthTexture.getTextureUnit()),r.setUniformi("texRGBColors",t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi("texVectors",t.vectorImage.getTextureUnit()),o.setUniformi("texGeomColors",t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get("colorMode","LICIntensity","mapModeBias","maskIntensity","maskColor","enhanceContrast","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor");if(o.setUniformi("texLIC",t.LICImage.getTextureUnit()),o.setUniformi("uScalarColorMode",a),o.setUniformf("uLICIntensity",i),o.setUniformf("uMapBias",s),o.setUniformf("uMaskIntensity",l),o.setUniform3f("uMaskColor",...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===Wf||u===Hf){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi("texGeomColors",t.geometryImage.getTextureUnit()),s.setUniformi("texHSLColors",t.HSLColorImage.getTextureUnit()),s.setUniformi("texLIC",t.LICImage.getTextureUnit()),s.setUniformf("uLMin",o),s.setUniformf("uLMaxMinDiff",i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get("stepSize","numberOfSteps","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","normalizeVectors","maskThreshold","transformVectors"),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error("Failed to compute image LIC"),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}(e,t)}var tg={newInstance:Ht.newInstance(eg,"vtkSurfaceLICInterface"),extend:eg};const{vtkErrorMacro:ng}=jt,rg={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const og=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rg,n),bd.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICMapper");const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=Pu.substitute(s,"//VTK::Output::Dec",["//VTK::Output::Dec","layout(location = 2) out vec4 vectorTexture;","layout(location = 3) out vec4 maskVectorTexture;"]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=Pu.substitute(i,"//VTK::TCoord::Dec",[`attribute vec3 ${n};`,"out vec3 licOutput;","//VTK::TCoord::Dec"]).result,i=Pu.substitute(i,"//VTK::TCoord::Impl",[`licOutput = ${n};`,"//VTK::TCoord::Impl"]).result,s=Pu.substitute(s,"//VTK::TCoord::Dec",["uniform int uMaskOnSurface;","uniform mat3 normalMatrix;","in vec3 licOutput;","//VTK::TCoord::Dec"]).result,s=Pu.substitute(s,"//VTK::TCoord::Impl",["// projected vectors","  vec3 tcoordLIC = normalMatrix * licOutput;","  vec3 normN = normalize(normalVCVSOutput);","  float k = dot(tcoordLIC, normN);","  vec3 projected = (tcoordLIC - k*normN);","  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","// vectors for fragment masking","  if (uMaskOnSurface == 0)","    {","    maskVectorTexture = vec4(licOutput, 1.0);","    }","  else","    {","    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","    }","//VTK::TCoord::Impl"],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi("uMaskOnSurface",t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(ng("SurfaceLICMapper Requires WebGL 2"),a=!1),t.context.getExtension("EXT_color_buffer_float")&&t.context.getExtension("OES_texture_float_linear")||(ng("SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions."),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(ng("No input"),a=!1);let i=t.renderable.getLicInterface();i||(i=Zf.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=tg.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(ng("No vector input array"),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}(e,t),St(e,t,["openGLLicInterface"])}),"vtkOpenGLSurfaceLICMapper");en("vtkSurfaceLICMapper",og);const{vtkErrorMacro:ag}=jt,ig={};const sg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ig,n),bd.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLSphereMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=rd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=Pu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=Pu.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=Pu.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;\n"]).result,i=Pu.substitute(i,"//VTK::Normal::Dec",["uniform float invertedDepth;\n","uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=Pu.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float b = 2.0*dot(EyePos,EyeDir);\n","  float c = dot(EyePos,EyePos) - 1.0;\n","  float d = b*b - 4.0*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t = (-b - invertedDepth*sqrt(d))*0.5;\n","    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n","    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=Pu.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=Pu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"offsetMC",12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||ag("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isUniformUsed("invertedDepth")&&e.getProgram().setUniformf("invertedDepth",t.invert?-1:1),e.getProgram().isUniformUsed("scaleFactor")){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf("scaleFactor",t.renderable.getScaleFactor()):e.getProgram().setUniformf("scaleFactor",1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc);const s=new Float64Array(16);if(o.isUniformUsed("MCVCMatrix"))if(r.getIsIdentity())d(s,i.wcvc),e.getCABO().getCoordShiftAndScaleEnabled()&&y(s,s,e.getCABO().getInverseShiftAndScaleMatrix()),o.setUniformMatrix("MCVCMatrix",s);else{const n=t.openGLActor.getKeyMatrices();y(s,i.wcvc,n.mcwc),e.getCABO().getCoordShiftAndScaleEnabled()&&y(s,s,e.getCABO().getInverseShiftAndScaleMatrix()),o.setUniformMatrix("MCVCMatrix",s)}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(mu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(yo(30));let h=0,v=0;const{useShiftAndScale:T,coordShift:y,coordScale:b}=hu(s);T&&a.setCoordShiftAndScale(y,b);let x=0,C=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e;const r=(c[h++]-y[0])*b[0],o=(c[h++]-y[1])*b[1],a=(c[h++]-y[2])*b[2];g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=-2*n*m,g[x++]=-n,d&&(v=e*p,f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3]),g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=2*n*m,g[x++]=-n,d&&(f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3]),g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=0,g[x++]=2*n,d&&(f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3])}a.setElementCount(x/5),a.upload(g,uu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,uu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLSphereMapper");en("vtkSphereMapper",sg);const{vtkErrorMacro:lg}=jt,cg={};const ug=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cg,n),bd.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLStickMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=rd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=Pu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=Pu.substitute(i,"//VTK::PositionVC::Dec","varying vec4 vertexVCVSOutput;").result,i=Pu.substitute(i,"//VTK::PositionVC::Impl","  vec4 vertexVC = vertexVCVSOutput;\n").result,i=Pu.substitute(i,"//VTK::Normal::Dec",["uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 orientVCVSOutput;\n","varying float lengthVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=Pu.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  vec3 base1;\n","  if (abs(orientVCVSOutput.z) < 0.99) {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n","  else {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n","  vec3 base2 = cross(orientVCVSOutput,base1);\n","  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n","  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n","  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n","  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n","  float d = b*b - 4.0*a*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t =  (-b - sqrt(d))/(2.0*a);\n","    float tz = EyePos.z + t*EyeDir.z;\n","    vec3 iPoint = EyePos + t*EyeDir;\n","    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n","      float t2 = (-b + sqrt(d))/(2.0*a);\n","      float tz2 = EyePos.z + t2*EyeDir.z;\n","      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n","      else {\n","        normalVCVSOutput = orientVCVSOutput;\n","        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n","        iPoint = EyePos + t3*EyeDir;\n","        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","        }\n","      }\n","    else {\n","      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n","      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","      }\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=Pu.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=Pu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed("orientMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"orientMC",12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||lg("Error setting 'orientMC' in shader VAO.")),e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"offsetMC",0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||lg("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isAttributeUsed("radiusMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"radiusMC",24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||lg("Error setting 'radiusMC' in shader VAO."))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),r.getIsIdentity())o.isUniformUsed("MCVCMatrix")&&o.setUniformMatrix("MCVCMatrix",i.wcvc),o.isUniformUsed("normalMatrix")&&o.setUniformMatrix3x3("normalMatrix",i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed("MCVCMatrix")){const t=new Float64Array(16);y(t,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",t)}if(o.isUniformUsed("normalMatrix")){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3("normalMatrix",t)}}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(mu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():lg(["Error setting orientationArray.\n","You have to specify the stick orientation"]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let T=0,y=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)T=3*e,f[b++]=c[T++],f[b++]=c[T++],f[b++]=c[T++],T=3*e,f[b++]=h[T++]*n,f[b++]=h[T++]*n,f[b++]=h[T++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,y=e*p,d&&(g[x++]=d[y],g[x++]=d[y+1],g[x++]=d[y+2],g[x++]=d[y+3])}a.setElementCount(b/7),a.upload(f,uu.ARRAY_BUFFER),a.getColorBO().upload(g,uu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLStickMapper");en("vtkStickMapper",ug);const dg=[];dg["-".charCodeAt(0)]=62,dg["_".charCodeAt(0)]=63;const pg="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let e=0;e<64;e++)dg[pg.charCodeAt(e)]=e;function fg(e){return void 0!==dg[e.charCodeAt(0)]}function gg(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!fg(e[l]);)l++;for(c=dg[e.charCodeAt(l++)]<<18;!fg(e[l]);)l++;for(c|=dg[e.charCodeAt(l++)]<<12;!fg(e[l]);)l++;for(c|=dg[e.charCodeAt(l++)]<<6;!fg(e[l]);)l++;c|=dg[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!fg(e[l]);)l++;for(c=dg[e.charCodeAt(l++)]<<10;!fg(e[l]);)l++;for(c|=dg[e.charCodeAt(l++)]<<4;!fg(e[l]);)l++;c|=dg[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!fg(e[l]);)l++;for(c=dg[e.charCodeAt(l++)]<<2;!fg(e[l]);)l++;c|=dg[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error("BASE64: remain 1 should not happen")}return u}function mg(e,t,n){const r=(e<<16)+(t<<8)+n;return pg[r>>18]+pg[r>>12&63]+pg[r>>6&63]+pg[63&r]}function hg(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=mg(t[n],t[n+1],t[n+2])}if(n>0){const e=mg(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join("")}var vg={toArrayBuffer:function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)fg(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):"="===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=gg(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o},fromArrayBuffer:hg};const Tg={};function yg(e,t){Tg[e]=t}var bg={get:function(){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Tg[arguments.length>0&&void 0!==arguments[0]?arguments[0]:"http"](e)},has:function(e){return!!Tg[e]},registerType:yg},xg=Uint8Array,Cg=Uint16Array,Sg=Uint32Array,Ag=new xg([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Ig=new xg([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),wg=new xg([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Og=function(e,t){for(var n=new Cg(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new Sg(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},Pg=Og(Ag,2),Rg=Pg[0],Mg=Pg[1];Rg[28]=258,Mg[258]=28;for(var Eg=Og(Ig,0),Vg=Eg[0],Dg=(Eg[1],new Cg(32768)),Lg=0;Lg<32768;++Lg){var Bg=(43690&Lg)>>>1|(21845&Lg)<<1;Bg=(61680&(Bg=(52428&Bg)>>>2|(13107&Bg)<<2))>>>4|(3855&Bg)<<4,Dg[Lg]=((65280&Bg)>>>8|(255&Bg)<<8)>>>1}var Ng=function(e,t,n){for(var r=e.length,o=0,a=new Cg(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new Cg(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new Cg(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[Dg[d]>>>l]=c}else for(i=new Cg(r),o=0;o<r;++o)e[o]&&(i[o]=Dg[s[e[o]-1]++]>>>15-e[o]);return i},Fg=new xg(288);for(Lg=0;Lg<144;++Lg)Fg[Lg]=8;for(Lg=144;Lg<256;++Lg)Fg[Lg]=9;for(Lg=256;Lg<280;++Lg)Fg[Lg]=7;for(Lg=280;Lg<288;++Lg)Fg[Lg]=8;var _g=new xg(32);for(Lg=0;Lg<32;++Lg)_g[Lg]=5;var Gg=Ng(Fg,9,1),kg=Ng(_g,5,1),Ug=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},zg=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},Wg=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},Hg=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?Cg:4==e.BYTES_PER_ELEMENT?Sg:xg)(n-t);return r.set(e.subarray(t,n)),r},jg=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],Kg=function(e,t,n){var r=new Error(t||jg[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,Kg),!n)throw r;return r},$g=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new xg(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new xg(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new xg(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=zg(e,c,1);var h=zg(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(P=4+((i+7)/8|0))-4)]|e[P-3]<<8,T=P+v;if(T>r){a&&Kg(0);break}o&&s(u+v),t.set(e.subarray(P,T),u),n.b=u+=v,n.p=c=8*T,n.f=l;continue}if(1==h)d=Gg,p=kg,f=9,g=5;else if(2==h){var y=zg(e,c,31)+257,b=zg(e,c+10,15)+4,x=y+zg(e,c+5,31)+1;c+=14;for(var C=new xg(x),S=new xg(19),A=0;A<b;++A)S[wg[A]]=zg(e,c+3*A,7);c+=3*b;var I=Ug(S),w=(1<<I)-1,O=Ng(S,I,1);for(A=0;A<x;){var P,R=O[zg(e,c,w)];if(c+=15&R,(P=R>>>4)<16)C[A++]=P;else{var M=0,E=0;for(16==P?(E=3+zg(e,c,3),c+=2,M=C[A-1]):17==P?(E=3+zg(e,c,7),c+=3):18==P&&(E=11+zg(e,c,127),c+=7);E--;)C[A++]=M}}var V=C.subarray(0,y),D=C.subarray(y);f=Ug(V),g=Ug(D),d=Ng(V,f,1),p=Ng(D,g,1)}else Kg(1);if(c>m){a&&Kg(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var F=(M=d[Wg(e,c)&L])>>>4;if((c+=15&M)>m){a&&Kg(0);break}if(M||Kg(2),F<256)t[u++]=F;else{if(256==F){N=c,d=null;break}var _=F-254;if(F>264){var G=Ag[A=F-257];_=zg(e,c,(1<<G)-1)+Rg[A],c+=G}var k=p[Wg(e,c)&B],U=k>>>4;if(k||Kg(3),c+=15&k,D=Vg[U],U>3&&(G=Ig[U],D+=Wg(e,c)&(1<<G)-1,c+=G),c>m){a&&Kg(0);break}o&&s(u+131072);for(var z=u+_;u<z;u+=4)t[u]=t[u-D],t[u+1]=t[u+1-D],t[u+2]=t[u+2-D],t[u+3]=t[u+3-D];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:Hg(t,0,u)},qg=new xg(0),Xg=function(e,t){return e[t]|e[t+1]<<8},Yg=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},Zg=function(e,t){return Yg(e,t)+4294967296*Yg(e,t+4)};function Qg(e,t){return $g(e,t)}function Jg(e,t){return $g(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||Kg(6,"invalid gzip data");var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new xg((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function em(e,t){return $g(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&Kg(6,"invalid zlib data"),32&n[1]&&Kg(6,"invalid zlib data: preset dictionaries not supported"),e.subarray(2,-4)),t);var n}function tm(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?Jg(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?Qg(e,t):em(e,t)}var nm="undefined"!=typeof TextEncoder&&new TextEncoder,rm="undefined"!=typeof TextDecoder&&new TextDecoder;try{rm.decode(qg,{stream:!0})}catch(e){}function om(e,t){if(t){for(var n="",r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(rm)return rm.decode(e);var o=function(e){for(var t="",n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,Hg(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&Kg(8),a}var am=function(e,t){return t+30+Xg(e,t+26)+Xg(e,t+28)},im=function(e,t,n){var r=Xg(e,t+28),o=om(e.subarray(t+46,t+46+r),!(2048&Xg(e,t+8))),a=t+46+r,i=Yg(e,t+20),s=n&&4294967295==i?sm(e,a):[i,Yg(e,t+24),Yg(e,t+42)],l=s[0],c=s[1],u=s[2];return[Xg(e,t+10),l,c,o,a+Xg(e,t+30)+Xg(e,t+32),u]},sm=function(e,t){for(;1!=Xg(e,t);t+=4+Xg(e,t+2));return[Zg(e,t+12),Zg(e,t+4),Zg(e,t+20)]};function lm(e,t){for(var n={},r=e.length-22;101010256!=Yg(e,r);--r)(!r||e.length-r>65558)&&Kg(13);var o=Xg(e,r+8);if(!o)return{};var a=Yg(e,r+16),i=4294967295==a;i&&(r=Yg(e,r-12),101075792!=Yg(e,r)&&Kg(13),o=Yg(e,r+32),a=Yg(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=im(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=am(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=Qg(e.subarray(h,h+d),new xg(p)):Kg(14,"unknown compression type "+u):n[f]=Hg(e,h,h+d))}return n}function cm(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?"LittleEndian":2712847316===n[0]?"BigEndian":null}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;var um=cm(),dm=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:pm,vtkDebugMacro:fm}=Ht;let gm=0;function mm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener("progress",n.progressCallback),r}const hm={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/");const s=mm("GET",i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++gm&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=om(tm(new Uint8Array(n.buffer))):n.buffer=tm(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(um!==n.ref.encode&&um&&(fm(`Swap bytes of ${n.name}`),dm(n.buffer,as[n.dataType])),n.values=Ht.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&pm(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--gm&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||"string"!==n.dataType?"arraybuffer":"text",s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=mm("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++gm&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--gm&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(om(tm(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&"gz"!==n.compression&&(pm("Supported algorithms are: [gz]"),pm(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=mm("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++gm&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--gm&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(om(tm(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&"gz"!==t.compression&&(pm("Supported algorithms are: [gz]"),pm(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=mm("GET",e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(tm(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType="arraybuffer",o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};yg("http",(e=>hm));const{vtkDebugMacro:vm}=Ht,Tm={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function ym(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tm,n),Ht.obj(e,t),Ht.get(e,t,["distance"]),Ht.setGet(e,t,["parallelProjection","useHorizontalViewAngle","viewAngle","parallelScale","useOffAxisProjection","freezeFocalPoint","physicalScale"]),Ht.getArray(e,t,["directionOfProjection","viewPlaneNormal","position","focalPoint"]),Ht.setGetArray(e,t,["clippingRange","windowCenter"],2),Ht.setGetArray(e,t,["viewUp","screenBottomLeft","screenBottomRight","screenTopRight","physicalTranslation","physicalViewUp","physicalViewNorth"],3),function(e,t){t.classHierarchy.push("vtkCamera");const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function T(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,vm("Distance is set to minimum."));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,vm("Distance is set to minimum.");const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,T()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,yo(n),s),Ba(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,yo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),wn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,yo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),wn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,yo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),wn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,yo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),wn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Eo(t.position,a,t.position),Eo(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Ba(o,[...t.position,1],n),Ba(a,[...t.focalPoint,1],n),Ba(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,vm("Thickness is set to minimum.")),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,vm("Thickness is set to minimum.")),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),O(i,[t.distance,t.distance,t.distance]),y(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=Ga(e[0],e[1],e[2],e[3]),n=Na(),r=Ga(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],_a(r,t,r),_a(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Fo(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),vn(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),wn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),wn(l,r,a),yn(l,l,s),Sn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),wn(c,o,a),yn(c,c,s),Sn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),y(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return vn(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error("Off-Axis projection is not supported at this time");{const n=Math.tan(yo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return y(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,T()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Fo(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,yo(n),t.physicalViewUp),C(s,s,yo(r),i),C(s,s,yo(o),t.physicalViewNorth),C(s,s,yo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);wn(l,l,s),wn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=yo(t),i=Na();Fa(i,[n,r,o],e),G(a,i)}const i=new Float64Array(3);wn(i,[0,0,-1],a);const s=new Float64Array(3);wn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}(e,t)}var bm={newInstance:Ht.newInstance(ym,"vtkCamera"),extend:ym};const xm={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:"SceneLight",shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Cm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xm,n),Ht.obj(e,t),Ht.setGet(e,t,["intensity","switch","positional","exponent","coneAngle","coneFalloff","transformMatrix","lightType","shadowAttenuation","attenuationValues"]),Ht.setGetArray(e,t,["color","position","focalPoint","attenuationValues"],3),function(e,t){t.classHierarchy.push("vtkLight");const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?wn(n,t.position,t.transformMatrix):vn(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?wn(n,t.focalPoint,t.transformMatrix):vn(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(Mn(t.direction,t.focalPoint,t.position),Go(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);Mn(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=yo(t),o=yo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType("HeadLight")},e.setLightTypeToCameraLight=()=>{e.setLightType("CameraLight")},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType("SceneLight")},e.lightTypeIsHeadLight=()=>"HeadLight"===t.lightType,e.lightTypeIsSceneLight=()=>"SceneLight"===t.lightType,e.lightTypeIsCameraLight=()=>"CameraLight"===t.lightType}(e,t)}var Sm={newInstance:Ht.newInstance(Cm,"vtkLight"),extend:Cm,LIGHT_TYPES:["HeadLight","CameraLight","SceneLight"]};const{vtkErrorMacro:Am}=Ht;const Im={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function wm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Im,n),Ht.obj(e,t),Ht.event(e,t,"event"),Ht.setGetArray(e,t,["viewport"],4),Ht.setGetArray(e,t,["background","background2"],3),function(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push("vtkViewport"),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{let r=[];const o=e.getActors2D();o.sort(((e,t)=>e.getLayerNumber()-t.getLayerNumber()));const a=t.props.filter((e=>!o.includes(e)));for(let e=0;e<a.length;e++)n(a[e],r);return r=r.concat(o),r},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Am("call displayToView on your view instead"),e.viewToDisplay=()=>Am("callviewtodisplay on your view instead"),e.getSize=()=>Am("call getSize on your View instead"),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=()=>Am("vtkViewport::PickPropFrom - NOT IMPLEMENTED")}(e,t)}var Om={newInstance:Ht.newInstance(wm,"vtkViewport"),extend:wm};const{vtkDebugMacro:Pm,vtkErrorMacro:Rm,vtkWarningMacro:Mm}=jt;function Em(e){return()=>Rm(`vtkRenderer::${e} - NOT IMPLEMENTED`)}const Vm={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Ra(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function Dm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,Vm,n),Om.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),yt(e,t,["_renderWindow","allocatedRenderTime","timeFactor","lastRenderTimeInSeconds","numberOfPropsRendered","lastRenderingUsedDepthPeeling","selector"]),St(e,t,["twoSidedLighting","lightFollowCamera","automaticLightCreation","erase","draw","nearClippingPlaneTolerance","clippingRangeExpansion","backingStore","interactive","layer","preserveColorBuffer","preserveDepthBuffer","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","delegate","backgroundTexture","texturedBackground","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","useShadows","pass"]),At(e,t,["actors","volumes","lights"]),wt(e,t,["background"],4,1),Ot(0,t,["renderWindow"]),function(e,t){t.classHierarchy.push("vtkRenderer");const n={type:"ComputeVisiblePropBoundsEvent",renderer:e},r={type:"ResetCameraClippingRangeEvent",renderer:e},o={type:"ResetCameraEvent",renderer:e};e.updateCamera=()=>(t.activeCamera||(Pm("No cameras are on, creating one."),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):Rm("light has unknown light type",e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=Em("allocateTime"),e.updateGeometry=Em("updateGeometry"),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{Pm(e.getClassName(),e,"setting Layer to ",n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:"ActiveCameraEvent",camera:n}),!0),e.makeCamera=()=>{const t=bm.newInstance();return e.invokeEvent({type:"CreateCameraEvent",camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=Sm.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return Rm("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return wn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return Rm("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return wn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return Rm("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return wn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return Rm("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return wn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=Fi.INIT_BOUNDS[0],t.allBounds[1]=Fi.INIT_BOUNDS[1],t.allBounds[2]=Fi.INIT_BOUNDS[2],t.allBounds[3]=Fi.INIT_BOUNDS[3],t.allBounds[4]=Fi.INIT_BOUNDS[4],t.allBounds[5]=Fi.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&ba(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(ya(t.allBounds),Pm("Can't compute bounds, no 3D props are visible")),t.allBounds},e.resetCamera=function(){const n=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null)||e.computeVisiblePropBounds(),r=[0,0,0];if(!ba(n))return Pm("Cannot reset camera!"),!1;let a=null;if(!e.getActiveCamera())return Rm("Trying to reset non-existent camera"),!1;a=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),r[0]=(n[0]+n[1])/2,r[1]=(n[2]+n[3])/2,r[2]=(n[4]+n[5])/2;let i=n[1]-n[0],s=n[3]-n[2],l=n[5]-n[4];i*=i,s*=s,l*=l;let c=i+s+l;c=0===c?1:c,c=.5*Math.sqrt(c);const u=yo(t.activeCamera.getViewAngle()),d=c,p=c/Math.sin(.5*u),f=t.activeCamera.getViewUp();return Math.abs(No(f,a))>.999&&(Mm("Resetting view-up since view plane normal is parallel"),t.activeCamera.setViewUp(-f[2],f[0],f[1])),t.activeCamera.setFocalPoint(r[0],r[1],r[2]),t.activeCamera.setPosition(r[0]+p*a[0],r[1]+p*a[1],r[2]+p*a[2]),e.resetCameraClippingRange(n),t.activeCamera.setParallelScale(d),t.activeCamera.setPhysicalScale(c),t.activeCamera.setPhysicalTranslation(-r[0],-r[1],-r[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){const n=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null)||e.computeVisiblePropBounds();if(!ba(n))return Pm("Cannot reset camera clipping range!"),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return Rm("Trying to reset clipping range of non-existent camera"),!1;const o=t.activeCamera.computeClippingRange(n);let a=0;if(t.activeCamera.getParallelProjection())a=.2*t.activeCamera.getParallelScale();else{const e=yo(t.activeCamera.getViewAngle());a=.2*Math.tan(e/2)*o[1]}return o[1]-o[0]<a&&(a=a-o[1]+o[0],o[1]+=a/2,o[0]-=a/2),o[0]<0&&(o[0]=0),o[0]=.99*o[0]-(o[1]-o[0])*t.clippingRangeExpansion,o[1]=1.01*o[1]+(o[1]-o[0])*t.clippingRangeExpansion,o[0]=o[0]>=o[1]?.01*o[1]:o[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),o[0]<t.nearClippingPlaneTolerance*o[1]&&(o[0]=t.nearClippingPlaneTolerance*o[1]),t.activeCamera.setClippingRange(o[0],o[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}(e,t)}var Lm={newInstance:Et(Dm,"vtkRenderer"),extend:Dm};const Bm=Object.create(null);function Nm(e,t){Bm[e]=t}function Fm(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Bm[e]&&Bm[e](t)}const _m={defaultViewAPI:"WebGL",renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1,childRenderWindows:[]};function Gm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_m,n),Ht.obj(e,t),Ht.setGet(e,t,["interactor","numberOfLayers","_views","defaultViewAPI"]),Ht.get(e,t,["neverRendered"]),Ht.getArray(e,t,["renderers","childRenderWindows"]),Ht.moveToProtected(e,t,["views"]),Ht.event(e,t,"completion"),function(e,t){t.classHierarchy.push("vtkRenderWindow"),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Fm(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{t.getGraphicsMemoryInfo&&(e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6)})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){t.getAllocatedGPUMemoryInBytes&&(e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6);const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join("\n"),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Ht.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))},e.addRenderWindow=n=>!t.childRenderWindows.includes(n)&&(t.childRenderWindows.push(n),e.modified(),!0),e.removeRenderWindow=n=>{const r=t.childRenderWindows.findIndex((e=>e===n));return!(r<0||(t.childRenderWindows.splice(r,1),e.modified(),0))}}(e,t)}var km={newInstance:Ht.newInstance(Gm,"vtkRenderWindow"),extend:Gm,registerViewConstructor:Nm,listViewAPIs:function(){return Object.keys(Bm)},newAPISpecificView:Fm};const Um={Unknown:0,LeftController:1,RightController:2},zm={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var Wm={Device:Um,Input:zm,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4},MouseButton:{LeftButton:1,MiddleButton:2,RightButton:3}};const{Device:Hm,Input:jm}=Wm,{vtkWarningMacro:Km,vtkErrorMacro:$m,normalizeWheel:qm,vtkOnceErrorMacro:Xm}=Ht,Ym={ctrlKey:!1,altKey:!1,shiftKey:!1},Zm={"xr-standard":[jm.Trigger,jm.Grip,jm.TrackPad,jm.Thumbstick,jm.A,jm.B]},Qm=["StartAnimation","Animation","EndAnimation","PointerEnter","PointerLeave","MouseEnter","MouseLeave","StartMouseMove","MouseMove","EndMouseMove","LeftButtonPress","LeftButtonRelease","MiddleButtonPress","MiddleButtonRelease","RightButtonPress","RightButtonRelease","KeyPress","KeyDown","KeyUp","StartMouseWheel","MouseWheel","EndMouseWheel","StartPinch","Pinch","EndPinch","StartPan","Pan","EndPan","StartRotate","Rotate","EndRotate","Button3D","Move3D","StartPointerLock","EndPointerLock","StartInteraction","Interaction","EndInteraction","AnimationFrameRateUpdate"];function Jm(e){e.cancelable&&e.preventDefault()}function eh(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}const th={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:"Start",animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function nh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,th,n),Ht.obj(e,t),t._animationExtendedEnd=0,Ht.event(e,t,"RenderEvent"),Qm.forEach((n=>Ht.event(e,t,n))),Ht.get(e,t,["initialized","interactorStyle","lastFrameTime","recentAnimationFrameRate","_view"]),Ht.setGet(e,t,["container","lightFollowCamera","enabled","enableRender","recognizeGestures","desiredUpdateRate","stillUpdateRate","picker","preventDefaultOnPointerDown","preventDefaultOnPointerUp","mouseScrollDebounceByPass"]),Ht.moveToProtected(e,t,["view"]),function(e,t){t.classHierarchy.push("vtkRenderWindowInteractor");const n={...e},r=new Set,o=new Map;let a=1;function i(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{$m("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor")},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>Km("empty event loop"),e.getCurrentRenderer=()=>(t.currentRenderer||i(0,0),t.currentRenderer);const s=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),r=n.getBoundingClientRect(),a=n.width/r.width,s=n.height/r.height,l={x:a*(e.clientX-r.left),y:s*(r.height-e.clientY+r.top),z:0,movementX:a*e.movementX,movementY:s*e.movementY};return(o.size<=1||!t.currentRenderer)&&i(l.x,l.y),l};function l(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function c(e){const t=l(e);return{key:e.key,keyCode:e.charCode,...t}}function u(e){return e.pointerType||""}const d=()=>{if(null===t.container)return;const{container:n}=t;n.addEventListener("contextmenu",Jm),n.addEventListener("wheel",e.handleWheel),n.addEventListener("DOMMouseScroll",e.handleWheel),n.addEventListener("pointerenter",e.handlePointerEnter),n.addEventListener("pointerleave",e.handlePointerLeave),n.addEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.addEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.addEventListener("pointerup",e.handlePointerUp),n.addEventListener("pointercancel",e.handlePointerCancel),n.addEventListener("keypress",e.handleKeyPress),n.addEventListener("keydown",e.handleKeyDown),document.addEventListener("keyup",e.handleKeyUp),document.addEventListener("pointerlockchange",e.handlePointerLockChange),n.tabIndex=0,n.style.touchAction="none",n.style.userSelect="none",n.style.webkitTapHighlightColor="rgba(0,0,0,0)"};e.bindEvents=e=>{null!==e&&n.setContainer(e)&&d()};const p=()=>{clearTimeout(t.moveTimeoutID),clearTimeout(t.wheelTimeoutID),t.moveTimeoutID=0,t.wheelTimeoutID=0,a=1;const{container:n}=t;n&&(n.removeEventListener("contextmenu",Jm),n.removeEventListener("wheel",e.handleWheel),n.removeEventListener("DOMMouseScroll",e.handleWheel),n.removeEventListener("pointerenter",e.handlePointerEnter),n.removeEventListener("pointerleave",e.handlePointerLeave),n.removeEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.removeEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.removeEventListener("pointerup",e.handlePointerUp),n.removeEventListener("pointercancel",e.handlePointerCancel),n.removeEventListener("keypress",e.handleKeyPress),n.removeEventListener("keydown",e.handleKeyDown)),document.removeEventListener("keyup",e.handleKeyUp),document.removeEventListener("pointerlockchange",e.handlePointerLockChange),o.clear()};function f(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.unbindEvents=()=>{p(),n.setContainer(null)},e.handleKeyPress=t=>{const n=c(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=c(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=c(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerEnterEvent(n),"mouse"===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerLeaveEvent(n),"mouse"===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&Jm(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),o.has(n.pointerId)&&Km("[RenderWindowInteractor] duplicate pointerId detected"),o.set(n.pointerId,{pointerId:n.pointerId,position:s(n)}),n.pointerType){case"pen":case"touch":e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(o.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&Jm(n),o.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case"pen":case"touch":e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(o.has(t.pointerId))switch(o.delete(t.pointerId),t.pointerType){case"pen":case"touch":e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(o.has(t.pointerId)&&(o.get(t.pointerId).position=s(t)),t.pointerType){case"pen":case"touch":e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:$m(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=n=>{void 0!==n?r.has(n)?Km("requester is already registered for animating"):(r.add(n),t.animationRequest||1!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):$m("undefined requester, can not start animating")},e.extendAnimation=n=>{const o=Date.now()+n;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(n){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(r.has(n))r.delete(n),t.animationRequest&&0===r.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=n&&n.getClassName?n.getClassName():n;Km(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==r.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=null==n.gripSpace?null:r.getPose(n.targetRaySpace,o),s=n.gamepad,l=n.handedness;if(s){s.index in t.lastGamepadValues||(t.lastGamepadValues[s.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<s.buttons.length;++r)r in t.lastGamepadValues[s.index][l].buttons||(t.lastGamepadValues[s.index][l].buttons[r]=!1),t.lastGamepadValues[s.index][l].buttons[r]!==s.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,pressed:s.buttons[r].pressed,device:"left"===n.handedness?Hm.LeftController:Hm.RightController,input:Zm[s.mapping]&&Zm[s.mapping][r]?Zm[s.mapping][r]:jm.Trigger}),t.lastGamepadValues[s.index][l].buttons[r]=s.buttons[r].pressed),t.lastGamepadValues[s.index][l].buttons[r]&&null!=a&&e.move3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,device:"left"===n.handedness?Hm.LeftController:Hm.RightController})}}))},e.handleMouseMove=n=>{const r={...l(n),position:s(n),deviceType:u(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const n=Date.now();t._animationFrameCount++,n-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(n-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=n,t._animationFrameCount=1),e.animationEvent(),f(),r.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{Jm(n);const r={...qm(n),...l(n),position:s(n),deviceType:u(n)};0===t.wheelTimeoutID&&(a=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=a,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:$m(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=eh(o);if(2===r.length){const t={...l(Ym),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture("TouchStart",t)}else if(1===r.length){const t={...l(Ym),position:s(n),deviceType:u(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=eh(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Ym),position:r[0].position,deviceType:u(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const r=[...o.values()];if(t.recognizeGestures)if(0===r.length){const t={...l(Ym),position:s(n),deviceType:u(n)};e.leftButtonReleaseEvent(t)}else if(1===r.length){const t=eh(o);e.recognizeGesture("TouchEnd",t);const a={...l(Ym),position:r[0].position,deviceType:u(n)};e.leftButtonPressEvent(a)}else{const t=eh(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Ym),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||f()},Qm.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void Xm("\n          Can not forward events without a current renderer on the interactor.\n        ");const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),"TouchStart"===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture="Start");if("TouchEnd"===n)return"Pinch"===t.currentGesture&&(e.render(),e.endPinchEvent()),"Rotate"===t.currentGesture&&(e.render(),e.endRotateEvent()),"Pan"===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture="Start",void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=bo(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=bo(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,"TouchMove"===n)if("Start"===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture="Pinch";const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture="Rotate";const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture="Pan";const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if("Rotate"===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if("Pinch"===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if("Pan"===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e},e.setContainer=e=>{p();const t=n.setContainer(e??null);return t&&d(),t},e.delete=()=>{for(;r.size;)e.cancelAnimation(r.values().next().value);void 0!==document.hidden&&document.removeEventListener("visibilitychange",e.handleVisibilityChange),t.container&&e.setContainer(null),n.delete()},void 0!==document.hidden&&document.addEventListener("visibilitychange",e.handleVisibilityChange,!1)}(e,t)}var rh={newInstance:Ht.newInstance(nh,"vtkRenderWindowInteractor"),extend:nh,handledEvents:Qm,...Wm};const{vtkErrorMacro:oh,VOID:ah}=Ht,ih={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function sh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ih,n),Ht.obj(e,t),Ht.event(e,t,"InteractionEvent"),Ht.event(e,t,"StartInteractionEvent"),Ht.event(e,t,"EndInteractionEvent"),Ht.get(e,t,["_interactor","enabled"]),Ht.setGet(e,t,["priority","processEvents"]),Ht.moveToProtected(e,t,["interactor"]),function(e,t){t.classHierarchy.push("vtkInteractorObserver");const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){rh.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):ah),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():oh("\n          The interactor must be set before subscribing to events\n        ")),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}(e,t)}var lh={newInstance:Ht.newInstance(sh,"vtkInteractorObserver"),extend:sh,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},ch={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:uh}=ch,dh={Rotate:uh.IS_ROTATE,Pan:uh.IS_PAN,Spin:uh.IS_SPIN,Dolly:uh.IS_DOLLY,CameraPose:uh.IS_CAMERA_POSE,WindowLevel:uh.IS_WINDOW_LEVEL,Slice:uh.IS_SLICE},ph={state:uh.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function fh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ph,n),lh.extend(e,t,n),Ht.setGet(e,t,["focusedRenderer"]),function(e,t){t.classHierarchy.push("vtkInteractorStyle"),Object.keys(dh).forEach((n=>{Ht.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===uh.IS_NONE&&(t.state=dh[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:"StartInteractionEvent"}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},Ht.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===dh[n]&&(t.state=uh.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:"EndInteractionEvent"}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),t.getRenderer=e=>t.focusedRenderer||e.pokedRenderer,e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case"r":case"R":t.getRenderer(e).resetCamera(),n.render();break;case"w":case"W":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case"s":case"S":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case"v":case"V":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}(e,t)}var gh={newInstance:Ht.newInstance(fh,"vtkInteractorStyle"),extend:fh,...ch};const{States:mh}=ch,hh={motionFactor:10,zoomFactor:10};function vh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hh,n),gh.extend(e,t,n),Ht.setGet(e,t,["motionFactor","zoomFactor"]),function(e,t){t.classHierarchy.push("vtkInteractorStyleTrackballCamera"),e.handleMouseMove=n=>{const r=n.position,o=t.getRenderer(n);switch(t.state){case mh.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case mh.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case mh.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case mh.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:"InteractionEvent"})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==Um.RightController||n.input!==zm.Trigger&&n.input!==zm.TrackPad?!n||n.pressed||n.device!==Um.RightController||n.input!==zm.Trigger&&n.input!==zm.TrackPad||t.state!==mh.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===mh.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const n=t.getRenderer(e).getActiveCamera(),r=n.getPhysicalTranslation(),o=.025*n.getPhysicalScale(),a=n.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);n.setPhysicalTranslation(r[0]+a[0]*o,r[1]+a[1]*o,r[2]+a[2]*o)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case mh.IS_DOLLY:e.endDolly();break;case mh.IS_PAN:e.endPan();break;case mh.IS_SPIN:e.endSpin();break;case mh.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(t.getRenderer(n),n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=t.getRenderer(n).getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(t.getRenderer(n),o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(t.getRenderer(n),o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(t.getRenderer(n),o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&t.getRenderer(n).updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=t.getRenderer(e).getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=bo(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=bo(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(t.getRenderer(n),r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}(e,t)}var Th={newInstance:Ht.newInstance(vh,"vtkInteractorStyleTrackballCamera"),extend:vh};function yh(e){return e}function bh(e){return null===e||"null"===e?null:"true"===e||"false"!==e&&(void 0!==e&&"undefined"!==e?"["===e[0]&&"]"===e[e.length-1]?e.substring(1,e.length-1).split(",").map((e=>bh(e.trim()))):""===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var xh=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?bh:yh;return new URLSearchParams(t).forEach(((e,t)=>{t&&(n[t]=!e||r(e))})),n};const Ch={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function Sh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ch,n),Ht.obj(e,t),Ht.get(e,t,["currentOperation"]),Ht.setGet(e,t,["delegates","_currentParent","preDelegateOperations","postDelegateOperations"]),Ht.moveToProtected(e,t,["currentParent"]),function(e,t){t.classHierarchy.push("vtkRenderPass"),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${Ht.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}(e,t)}var Ah={newInstance:Ht.newInstance(Sh,"vtkRenderPass"),extend:Sh};const{Representation:Ih}=ts,{vtkErrorMacro:wh}=Ht;function Oh(e){const t=Pu.substitute(e.Fragment,"//VTK::RenderPassFragmentShader::Impl","\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\n      gl_FragData[1].r = weight;\n    ",!1);e.Fragment=t.result}const Ph={framebuffer:null,copyShader:null,tris:null};function Rh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ph,n),Ah.extend(e,t,n),t.VBOBuildTime={},Ht.obj(t.VBOBuildTime,{mtime:0}),t.tris=Bu.newInstance(),Ht.get(e,t,["framebuffer"]),function(e,t){t.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Ts.newInstance({numberOfComponents:3,values:e});o.setName("points");const a=Ts.newInstance({numberOfComponents:2,values:n});a.setName("tcoords");const i=Ts.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,"polys",Ih.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=qd.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=td.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw({width:n[0],height:n[1],numComps:4,dataType:"Float32Array",data:null}),t.translucentRTexture=td.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw({width:n[0],height:n[1],numComps:1,dataType:"Float32Array",data:null}),t.translucentZTexture=td.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw({width:n[0],height:n[1],dataType:"Float32Array",data:null}),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","attribute vec2 tcoordTC;","varying vec2 tcoord;","void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"),"//VTK::System::Dec\n\nin vec2 tcoord;\n\nuniform sampler2D translucentRTexture;\nuniform sampler2D translucentRGBATexture;\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\n  float t2Color = texture(translucentRTexture, tcoord).r;\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\n}\n","")},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||wh("Error setting vertexDC in copy shader VAO."),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"tcoordTC",t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||wh("Error setting vertexDC in copy shader VAO.")},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension("EXT_color_buffer_half_float")&&!i.getExtension("EXT_color_buffer_float"))return e.setCurrentOperation("translucentPass"),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation("opaqueZBufferPass"),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation("translucentPass"),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=Eu.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi("translucentRGBATexture",t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi("translucentRTexture",t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate();const s=r.getTiledSizeAndOrigin();i.scissor(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize),i.viewport(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize)},e.getShaderReplacement=()=>t._supported?Oh:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}(e,t)}var Mh={newInstance:Ht.newInstance(Rh,"vtkOpenGLOrderIndependentTranslucentPass"),extend:Rh};const Eh={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function Vh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Eh,n),Ah.extend(e,t,n),Ht.get(e,t,["framebuffer","opaqueActorCount","translucentActorCount","volumeCount"]),function(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getRenderable().getRenderersByReference();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getViewNodeFor(i);if(i.getDraw()&&i.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation("queryPass"),s.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=qd.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation("zBufferPass"),s.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation("cameraPass"),s.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation("opaquePass"),s.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Mh.newInstance()),t.translucentPass.traverse(n,s,e)),t.volumeCount>0&&(e.setCurrentOperation("volumePass"),s.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation("overlayPass"),s.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}(e,t)}var Dh={newInstance:Ht.newInstance(Vh,"vtkForwardPass"),extend:Vh},Lh=n(292),Bh=n.n(Lh);const Nh=["lastShaderProgramBound","context","_openGLRenderWindow"],Fh={lastShaderProgramBound:null,shaderPrograms:null,context:null};function _h(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fh,n),t.shaderPrograms={},Ht.obj(e,t),Ht.setGet(e,t,Nh),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkShaderCache"),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=Pu.substitute(o,"VSOut","GSOut").result);const a=t._openGLRenderWindow.getWebgl2();let i="\n",s="#version 100\n";a?s="#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n":(t.context.getExtension("OES_standard_derivatives"),t.context.getExtension("EXT_frag_depth")&&(i="#extension GL_EXT_frag_depth : enable\n"),t.context.getExtension("EXT_shader_texture_lod")&&(i+="#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT")),o=Pu.substitute(o,"//VTK::System::Dec",[`${s}\n`,a?"":"#extension GL_OES_standard_derivatives : enable\n",i,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;let l=Pu.substitute(e,"//VTK::System::Dec",[`${s}\n`,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;if(a){l=Pu.substitute(l,"varying","out").result,o=Pu.substitute(o,"varying","in").result;let e="",t=0;for(;o.includes(`gl_FragData[${t}]`);)o=Pu.substitute(o,`gl_FragData\\[${t}\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\n`,t++;o=Pu.substitute(o,"//VTK::Output::Dec",e).result}return{VSSource:l,FSSource:o,GSSource:Pu.substitute(r,"//VTK::System::Dec",s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=Bh().hash(o);if(!(a in t.shaderPrograms)){const o=Pu.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}(e,t)}var Gh={newInstance:Ht.newInstance(_h,"vtkShaderCache"),extend:_h};const{vtkErrorMacro:kh}=Ht,Uh={context:null,numberOfTextureUnits:0,textureUnits:0};function zh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Uh,n),Ht.obj(e,t),t.textureUnits=[],Ht.get(e,t,["numberOfTextureUnits"]),Ht.setGet(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLTextureUnitManager"),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&kh("some texture units  were not properly released");t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}(e,t)}var Wh={newInstance:Ht.newInstance(zh,"vtkOpenGLTextureUnitManager"),extend:zh};const Hh={size:void 0,selector:void 0};function jh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hh,n),t.size||(t.size=[300,300]),Ht.getArray(e,t,["size"],2),Ht.get(e,t,["selector"]),Xt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkRenderWindowViewNode"),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{Ht.vtkErrorMacro("not implemented")},e.getPixelData=(e,t,n,r)=>{Ht.vtkErrorMacro("not implemented")},e.createSelector=()=>{Ht.vtkErrorMacro("not implemented")}}(e,t)}var Kh={newInstance:Ht.newInstance(jh,"vtkRenderWindowViewNode"),extend:jh};const{vtkDebugMacro:$h,vtkErrorMacro:qh}=Ht,Xh={position:"absolute",top:0,left:0,width:"100%",height:"100%"},Yh=["activateTexture","deactivateTexture","disableCullFace","enableCullFace","get3DContext","getActiveFramebuffer","getContext","getDefaultTextureByteSize","getDefaultTextureInternalFormat","getDefaultToWebgl2","getGLInformations","getGraphicsMemoryInfo","getGraphicsResourceForObject","getHardwareMaximumLineWidth","getPixelData","getShaderCache","getTextureUnitForTexture","getTextureUnitManager","getWebgl2","makeCurrent","releaseGraphicsResources","registerGraphicsResourceUser","unregisterGraphicsResourceUser","restoreContext","setActiveFramebuffer","setContext","setDefaultToWebgl2","setGraphicsResourceForObject"];function Zh(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let Qh=0;const Jh=[];function ev(e){e.preventDefault()}function tv(e,t){let n;t.classHierarchy.push("vtkOpenGLRenderWindow"),e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener("webglcontextlost",ev,!1),t.canvas.addEventListener("webglcontextrestored",e.restoreContext,!1);const r=[0,0];let o;e.onModified((function(){t.renderable&&(t.size[0]===r[0]&&t.size[1]===r[1]||(r[0]=t.size[0],r[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.addMissingNodes(t.renderable.getChildRenderWindowsByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow?.(e)}))}},e.initialize=()=>{if(!t.initialized){if(t.rootOpenGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.rootOpenGLRenderWindow)t.context2D=e.get2DContext();else{t.context=e.get3DContext(),e.resizeFromChildRenderWindows(),t.context&&(Qh++,Jh.forEach((e=>e(Qh)))),t.textureUnitManager=Wh.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND)}t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&qh("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>{const e=t.activeFramebuffer?.getSize();return e||t.size},e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:"high-performance"},r=null;const o="undefined"!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(r=t.canvas.getContext("webgl2",e),r&&(t.webgl2=!0,$h("using webgl2"))),r||($h("using webgl1"),r=t.canvas.getContext("webgl",e)||t.canvas.getContext("experimental-webgl",e)),new Proxy(r,(n||(n=function(){const e=new Map,t={apply(t,n,r){return e.has(r[0])?e.get(r[0]):t.apply(n,r)}},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply(t,n,r){return e.set(a,r[0]),t.apply(n,r)}}));var a},{get(e,t,r){if("__getUnderlyingContext"===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}()),n))},e.get2DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.canvas.getContext("2d",e)},e.restoreContext=()=>{const t=Ah.newInstance();t.setCurrentOperation("Release"),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?qh("Hardware does not support the number of textures defined."):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case is.CHAR:case is.SIGNED_CHAR:case is.UNSIGNED_CHAR:return 1;case n:case r:case is.UNSIGNED_SHORT:case is.SHORT:case is.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case is.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&is.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&is.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return o?t.context.R16F:t.context.R32F;case 2:return o?t.context.RG16F:t.context.RG32F;case 3:return o?t.context.RGB16F:t.context.RGB32F;default:return o?t.context.RGBA16F:t.context.RGBA32F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Xh,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t.rootOpenGLRenderWindow?.resizeFromChildRenderWindows(),t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=o)return o;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return o=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension("OES_texture_float"),o=n.getExtension("OES_texture_half_float"),a=n.getExtension("WEBGL_debug_renderer_info"),i=n.getExtension("WEBGL_draw_buffers"),s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),l=[["Max Vertex Attributes","MAX_VERTEX_ATTRIBS",n.getParameter(n.MAX_VERTEX_ATTRIBS)],["Max Varying Vectors","MAX_VARYING_VECTORS",n.getParameter(n.MAX_VARYING_VECTORS)],["Max Vertex Uniform Vectors","MAX_VERTEX_UNIFORM_VECTORS",n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],["Max Fragment Uniform Vectors","MAX_FRAGMENT_UNIFORM_VECTORS",n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],["Max Fragment Texture Image Units","MAX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],["Max Vertex Texture Image Units","MAX_VERTEX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],["Max Combined Texture Image Units","MAX_COMBINED_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],["Max 2D Texture Size","MAX_TEXTURE_SIZE",n.getParameter(n.MAX_TEXTURE_SIZE)],["Max Cube Texture Size","MAX_CUBE_MAP_TEXTURE_SIZE",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],["Max Texture Anisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT",s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],["Point Size Range","ALIASED_POINT_SIZE_RANGE",n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(" - ")],["Line Width Range","ALIASED_LINE_WIDTH_RANGE",n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(" - ")],["Max Viewport Dimensions","MAX_VIEWPORT_DIMS",n.getParameter(n.MAX_VIEWPORT_DIMS).join(" - ")],["Max Renderbuffer Size","MAX_RENDERBUFFER_SIZE",n.getParameter(n.MAX_RENDERBUFFER_SIZE)],["Framebuffer Red Bits","RED_BITS",n.getParameter(n.RED_BITS)],["Framebuffer Green Bits","GREEN_BITS",n.getParameter(n.GREEN_BITS)],["Framebuffer Blue Bits","BLUE_BITS",n.getParameter(n.BLUE_BITS)],["Framebuffer Alpha Bits","ALPHA_BITS",n.getParameter(n.ALPHA_BITS)],["Framebuffer Depth Bits","DEPTH_BITS",n.getParameter(n.DEPTH_BITS)],["Framebuffer Stencil Bits","STENCIL_BITS",n.getParameter(n.STENCIL_BITS)],["Framebuffer Subpixel Bits","SUBPIXEL_BITS",n.getParameter(n.SUBPIXEL_BITS)],["MSAA Samples","SAMPLES",n.getParameter(n.SAMPLES)],["MSAA Sample Buffers","SAMPLE_BUFFERS",n.getParameter(n.SAMPLE_BUFFERS)],["Supported Formats for UByte Render Targets     ","UNSIGNED_BYTE RENDER TARGET FORMATS",[r&&Zh(n,n.RGBA,n.UNSIGNED_BYTE)?"RGBA":"",r&&Zh(n,n.RGB,n.UNSIGNED_BYTE)?"RGB":"",r&&Zh(n,n.LUMINANCE,n.UNSIGNED_BYTE)?"LUMINANCE":"",r&&Zh(n,n.ALPHA,n.UNSIGNED_BYTE)?"ALPHA":"",r&&Zh(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Half Float Render Targets","HALF FLOAT RENDER TARGET FORMATS",[o&&Zh(n,n.RGBA,o.HALF_FLOAT_OES)?"RGBA":"",o&&Zh(n,n.RGB,o.HALF_FLOAT_OES)?"RGB":"",o&&Zh(n,n.LUMINANCE,o.HALF_FLOAT_OES)?"LUMINANCE":"",o&&Zh(n,n.ALPHA,o.HALF_FLOAT_OES)?"ALPHA":"",o&&Zh(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Full Float Render Targets","FLOAT RENDER TARGET FORMATS",[r&&Zh(n,n.RGBA,n.FLOAT)?"RGBA":"",r&&Zh(n,n.RGB,n.FLOAT)?"RGB":"",r&&Zh(n,n.LUMINANCE,n.FLOAT)?"LUMINANCE":"",r&&Zh(n,n.ALPHA,n.FLOAT)?"ALPHA":"",r&&Zh(n,n.LUMINANCE_ALPHA,n.FLOAT)?"LUMINANCE_ALPHA":""].join(" ")],["Max Multiple Render Targets Buffers","MAX_DRAW_BUFFERS_WEBGL",i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],["High Float Precision in Vertex Shader","HIGH_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Vertex Shader","MEDIUM_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Vertex Shader","LOW_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Float Precision in Fragment Shader","HIGH_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Fragment Shader","MEDIUM_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Fragment Shader","LOW_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Int Precision in Vertex Shader","HIGH_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Vertex Shader","MEDIUM_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Vertex Shader","LOW_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["High Int Precision in Fragment Shader","HIGH_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Fragment Shader","MEDIUM_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Fragment Shader","LOW_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["Supported Extensions","EXTENSIONS",n.getSupportedExtensions().join("<br/>\t\t\t\t\t    ")],["WebGL Renderer","RENDERER",n.getParameter(n.RENDERER)],["WebGL Vendor","VENDOR",n.getParameter(n.VENDOR)],["WebGL Version","VERSION",n.getParameter(n.VERSION)],["Shading Language Version","SHADING_LANGUAGE_VERSION",n.getParameter(n.SHADING_LANGUAGE_VERSION)],["Unmasked Renderer","UNMASKED_RENDERER",a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],["Unmasked Vendor","UNMASKED_VENDOR",a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],["WebGL Version","WEBGL_VERSION",t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);e.copyParentContent(),t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect();t.renderable.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const i=r.toDataURL(n);r.remove(),e.invokeImageReady(i)}();const n=t.renderable.getChildRenderWindowsByReference();for(let t=0;t<n.length;++t)e.getViewNodeFor(n[t])?.traverseAllPasses()},e.copyParentContent=()=>{const e=t.rootOpenGLRenderWindow;if(!e||!t.context2D||t.children.some((e=>!!e.getSelector?.())))return;const n=e.getCanvas(),r=t.canvas;t.context2D.drawImage(n,0,n.height-r.height,r.width,r.height,0,0,r.width,r.height)},e.resizeFromChildRenderWindows=()=>{const n=t.renderable.getChildRenderWindowsByReference();if(n.length>0){const t=[0,0];for(let r=0;r<n.length;++r){const o=e.getViewNodeFor(n[r])?.getSize();o&&(t[0]=o[0]>t[0]?o[0]:t[0],t[1]=o[1]>t[1]?o[1]:t[1])}e.setSize(...t)}},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=dp.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=Ht.chain((()=>{t.context&&(Qh--,Jh.forEach((e=>e(Qh)))),e.setContainer(),e.setViewStream()}),(function(){t.canvas.removeEventListener("webglcontextlost",ev),t.canvas.removeEventListener("webglcontextrestored",e.restoreContext)}),e.delete),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const a=e.setSize;e.setSize=(t,n)=>{const r=a(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.registerGraphicsResourceUser=(n,r)=>{t._graphicsResources.has(n)||e.setGraphicsResourceForObject(n,null,null);const o=t._graphicsResources.get(n);o?.users.add(r)},e.unregisterGraphicsResourceUser=(n,r)=>{const o=t._graphicsResources.get(n);o&&(o.users.delete(r),o.users.size||(o.oglObject?.releaseGraphicsResources(e),t._graphicsResources.delete(n)))},e.getGraphicsResourceForObject=e=>t._graphicsResources.get(e),e.setGraphicsResourceForObject=(n,r,o)=>{if(!n)return;const a=t._graphicsResources.get(n);a?.oglObject?.releaseGraphicsResources(e),t._graphicsResources.set(n,{coreObject:n,oglObject:r,hash:o,users:a?.users??new Set})},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach((t=>{let{oglObject:n}=t;e+=n.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach((t=>{let{oglObject:n}=t;n.releaseGraphicsResources(e)})),t._graphicsResources.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{const n=e.getViewNodeFor(t);n?.releaseGraphicsResources()}))};const i={...e};Yh.forEach((n=>{e[n]=function(){return t.rootOpenGLRenderWindow?t.rootOpenGLRenderWindow[n](...arguments):i[n](...arguments)}}))}const nv={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,context2D:null,canvas:null,cursorVisibility:!0,cursor:"pointer",textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1};const rv=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nv,n),Kh.extend(e,t,n),t.canvas||(t.canvas=document.createElement("canvas"),t.canvas.style.width="100%"),t.selector||(t.selector=dp.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",t._textureResourceIds=new Map,t._graphicsResources=new Map,t._glInformation=null,t.myFactory=rn.newInstance(),t.shaderCache=Gh.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=Dh.newInstance(),Ht.get(e,t,["shaderCache","textureUnitManager","webgl2","useBackgroundImage","activeFramebuffer","rootOpenGLRenderWindow"]),Ht.setGet(e,t,["initialized","context","context2D","canvas","renderPasses","notifyStartCaptureImage","defaultToWebgl2","cursor","useOffScreen"]),Ht.setGetArray(e,t,["size"],2),Ht.event(e,t,"imageReady"),Ht.event(e,t,"windowResizeEvent"),tv(e,t)}),"vtkOpenGLRenderWindow");Nm("WebGL",rv),en("vtkRenderWindow",rv);const ov={device:null,handle:null};function av(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ov,n),Ht.obj(e,t),Ht.get(e,t,["lastCameraMTime"]),Ht.setGet(e,t,["device","handle"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderModule"),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}(e,t)}var iv={newInstance:Ht.newInstance(av,"vtkWebGPUShaderModule"),extend:av};const sv={shaderModules:null,device:null,window:null};function lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sv,n),t._shaderModules=new Map,Ht.obj(e,t),Ht.setGet(e,t,["device","window"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderCache"),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=iv.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}(e,t)}var cv={newInstance:Ht.newInstance(lv,"vtkWebGPUShaderCache"),extend:lv,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join("\n"):n;let a=!1;-1!==e.search(t)&&(a=!0);let i="";r&&(i="g");const s=new RegExp(t,i);return{replace:a,result:e.replace(s,o)}}};const uv={device:null,handle:null,label:null};function dv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uv,n),Ht.obj(e,t),t.bindables=[],t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),Ht.get(e,t,["bindGroupTime","handle","sizeInBytes","usage"]),Ht.setGet(e,t,["label","device","arrayInformation"]),function(e,t){t.classHierarchy.push("vtkWebGPUBindGroup"),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join("\n")}}(e,t)}var pv={newInstance:Ht.newInstance(dv),extend:dv};const fv={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fv,n),vt(e,t),t.layouts=[],t.shaderDescriptions=[],yt(e,t,["handle","pipelineDescription"]),St(e,t,["device","renderEncoder","topology","vertexState"]),function(e,t){t.classHierarchy.push("vtkWebGPUPipeline"),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);"vertex"===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint="main"),"fragment"===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint="main")}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}(e,t)}var mv={newInstance:Et(gv,"vtkWebGPUPipeline"),extend:gv};const hv={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function vv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hv,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],Ht.obj(e,t),Ht.setGet(e,t,["type","hash","code"]),Ht.getArray(e,t,["outputTypes","outputNames","outputInterpolations"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderDescription"),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push("};"),o=n,r[r.length-1]+=",",r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=cv.substitute(t.code,"//VTK::IOStructs::Input",r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push("};"),o=o.concat(e),t.code=cv.substitute(t.code,"//VTK::IOStructs::Output",[`-> ${t.type}Output`]).result}t.code=cv.substitute(t.code,"//VTK::IOStructs::Dec",o).result}}(e,t)}var Tv={newInstance:Ht.newInstance(vv,"vtkWebGPUShaderDescription"),extend:vv};const yv={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"float"},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"float"},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"sint"},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"uint"},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:"sint"},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:"float"},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"float"},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"float"},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"uint"},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"sint"},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:"uint"},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:"sint"},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"unfilterable-float"},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:"uint"},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:"sint"},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:"float"},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"rgba8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"float"},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"uint"},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"sint"},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"bgra8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:"float"},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:"uint"},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:"sint"},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:"unfilterable-float"},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:"uint"},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:"sint"},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:"float"},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:"uint"},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:"sint"},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:"unfilterable-float"},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"depth"},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:"depth"},"depth24plus-stencil8":{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:"mixed"},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"depth"}};var bv=function(e){return!e||e.length<6?0:e in yv==1?yv[e]:(tt(`unknown format ${e}`),null)},xv=function(e){if(!e||e.length<5)return 0;let t=1;"x"===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(tt(`unknown format ${e}`),0):t*(5-r/2)},Cv=function(e){if(!e||e.length<5)return 0;let t;if("f"===e[0])t="Float";else if("s"===e[0])t="Int";else{if("u"!==e[0])return void tt(`unknown format ${e}`);t="Uint"}const n=e.split("x")[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+="Array",t;tt(`unknown format ${e}`)},Sv=function(e){let t;if("f"===e[0]||"n"===e[1])t="f32";else if("s"===e[0]&&"i"===e[1])t="i32";else{if("u"!==e[0]||"i"!==e[1])return void tt(`unknown format ${e}`);t="u32"}let n=1;return"x"===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},Av=function(e){if(!e)return 0;let t=1;return"vec"===e.substring(0,3)?t=Number(e[3]):"mat"===e.substring(0,3)&&(t=e[3]*e[5]),4*t},Iv=function(e){if(e)return e.includes("f32")?"Float32Array":e.includes("i32")?"Int32Array":e.includes("u32")?"Uint32Array":void tt(`unknown format ${e}`)};function wv(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}const Ov={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function Pv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ov,n),vt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],St(e,t,["created","device","handle","indexBuffer"]),function(e,t){t.classHierarchy.push("vtkWebGPUVertexInput"),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"vertex",o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(wv(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e="",n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=Sv(a.format);n>0&&(e+=",\n"),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}(e,t)}var Rv={newInstance:Et(Pv,"vtkWebGPUVertexInput"),extend:Pv};const Mv={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:"triangle-list",UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function Ev(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mv,n),Xt.extend(e,t,n),t.textureViews=[],t.vertexInput=Rv.newInstance(),t.bindGroup=pv.newInstance({label:"mapperBG"}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||"\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n",t.vertexShaderTemplate=t.vertexShaderTemplate||"\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n",t.shaderReplacements=new Map,Ht.get(e,t,["pipeline","vertexInput"]),Ht.setGet(e,t,["additionalBindables","device","fragmentShaderTemplate","interpolate","numberOfInstances","numberOfVertices","pipelineHash","shaderReplacements","SSBO","textureViews","topology","UBO","vertexShaderTemplate","WebGPURenderer"]),function(e,t){t.classHierarchy.push("vtkWebGPUSimpleMapper"),e.generateShaderDescriptions=(n,r,o)=>{const a=Tv.newInstance({type:"vertex",hash:n,code:t.vertexShaderTemplate}),i=Tv.newInstance({type:"fragment",hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp("//VTK::[^:]*::","g"),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];"replaceShaderIOStructs"!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.replaceShaderCode(null,n),t.getShaderDescription("fragment").replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set("replaceShaderRenderEncoder",e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=cv.substitute(i,"//VTK::Renderer::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");i=s.getCode(),i=cv.substitute(i,"//VTK::Renderer::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderRenderer",e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=cv.substitute(i,"//VTK::Mapper::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");s.addBuiltinInput("bool","@builtin(front_facing) frontFacing"),i=s.getCode(),i=cv.substitute(i,"//VTK::Mapper::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderMapper",e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=cv.substitute(o,"//VTK::Position::Impl",["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription("vertex").addOutput("vec2<f32>","tcoordVS")},t.shaderReplacements.set("replaceShaderTCoord",e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=mv.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}(e,t)}var Vv={newInstance:Ht.newInstance(Ev,"vtkWebGPUSimpleMapper"),extend:Ev};const Dv={};function Lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dv,n),Vv.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkWebGPUFullScreenQuad"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position"),r.addOutput("vec4<f32>","vertexVC");let o=r.getCode();o=cv.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);","output.vertexVC = vec4<f32>(vertexBC, 1);"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,["vertexBC"]),t.numberOfVertices=6}}(e,t)}var Bv={newInstance:Ht.newInstance(Lv,"vtkWebGPUFullScreenQuad"),extend:Lv};const Nv=["setBindGroup","setIndexBuffer","setVertexBuffer","draw","drawIndexed"],Fv={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function _v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fv,n),vt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:"load",storeOp:"store"}],depthStencilAttachment:{view:void 0,depthLoadOp:"clear",depthClearValue:0,depthStoreOp:"store"}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = computedColor;"]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater-equal",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}},t.colorTextureViews=[],yt(e,t,["boundPipeline","colorTextureViews"]),St(e,t,["depthTextureView","description","handle","label","pipelineHash","pipelineSettings","replaceShaderCodeFunction"]),function(e,t){t.classHierarchy.push("vtkWebGPURenderEncoder"),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!("depthStencil"in n))console.log("mismatched depth attachments"),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\n${o}\n versus pipeline\n${a}\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<Nv.length;n++)e[Nv[n]]=function(){return t.handle[Nv[n]](...arguments)}}(e,t)}var Gv={newInstance:Et(_v,"vtkWebGPURenderEncoder"),extend:_v};const kv={device:null,handle:null,label:null,options:null};function Uv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),Ht.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),Ht.get(e,t,["bindGroupTime","handle","options"]),Ht.setGet(e,t,["bindGroupLayoutEntry","device","label"]),function(e,t){t.classHierarchy.push("vtkWebGPUSampler"),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:"clamp-to-edge",t.options.addressModeV=n.addressModeV?n.addressModeV:"clamp-to-edge",t.options.addressModeW=n.addressModeW?n.addressModeW:"clamp-to-edge",t.options.magFilter=n.magFilter?n.magFilter:"nearest",t.options.minFilter=n.minFilter?n.minFilter:"nearest",t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:"nearest",t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}(e,t)}var zv={newInstance:Ht.newInstance(Uv),extend:Uv};const Wv={texture:null,handle:null,sampler:null,label:null};function Hv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wv,n),Ht.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d"}},t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),Ht.get(e,t,["bindGroupTime","texture"]),Ht.setGet(e,t,["bindGroupLayoutEntry","label","sampler"]),function(e,t){t.classHierarchy.push("vtkWebGPUTextureView"),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=bv(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=bv(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r="f32";"sint"===t.bindGroupLayoutEntry.texture.sampleType?r="i32":"uint"===t.bindGroupLayoutEntry.texture.sampleType&&(r="u32");let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return"depth"===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=zv.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}(e,t)}var jv={newInstance:Ht.newInstance(Hv),extend:Hv};const Kv={device:null,handle:null,buffer:null,ready:!1,label:null};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),Ht.obj(e,t),Ht.get(e,t,["handle","ready","width","height","depth","format","usage"]),Ht.setGet(e,t,["device","label"]),function(e,t){t.classHierarchy.push("vtkWebGPUTexture"),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?"2d":"3d";t.format=n.format?n.format:"rgba8unorm",t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:"rgba8unorm",t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];const o=r=>{t.device.getHandle().queue.copyExternalImageToTexture({source:r,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0,mipLevel:0,origin:{x:0,y:0,z:0}},[r.width,r.height,t.depth]),3!==e.getDimensionality()&&t.mipLevel>0&&Hc.generateMipmaps(t.device.getHandle(),t.handle,t.mipLevel+1),t.ready=!0};if(n.canvas)return void o(n.canvas);if(n.imageBitmap)return n.width=n.imageBitmap.width,n.height=n.imageBitmap.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.imageBitmap);if(n.jsImageData)return n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.jsImageData);if(n.image)return n.width=n.image.width,n.height=n.image.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.image);const a=bv(t.format);let i=t.width*a.stride;n.nativeArray&&(r=n.nativeArray);const s=3===e.getDimensionality(),l=((e,t,n)=>{const r=2===a.elementSize&&"float"===a.sampleType,o=e.BYTES_PER_ELEMENT,i=e.length/(t*n)*o;if(!r&&i%256==0)return[e,i];const s=i/o,l=a.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=Ht.newTypedArray(r?"Uint16Array":e.constructor.name,u*t*n),p=t*n;if(r)for(let t=0;t<p;t++){const n=t*s,r=t*u;for(let t=0;t<s;t++)d[r+t]=Uu.toHalf(e[n+t])}else if(u===s)d.set(e);else for(let t=0;t<p;t++)d.set(e.subarray(t*s,(t+1)*s),t*u);return[d,c]})(r,t.height,s?t.depth:1);i=l[1];const c=l[0];t.device.getHandle().queue.writeTexture({texture:t.handle,mipLevel:0,origin:{x:0,y:0,z:0}},c,{offset:0,bytesPerRow:i,rowsPerImage:t.height},{width:t.width,height:t.height,depthOrArrayLayers:s?t.depth:1}),!s&&t.mipLevel>0&&Hc.generateMipmaps(t.device.getHandle(),t.handle,t.mipLevel+1),t.ready=!0},e.getScale=()=>{const e=bv(t.format);return 2===e.elementSize&&"float"===e.sampleType?1:255},e.getNumberOfComponents=()=>bv(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?"2d":"3d");const o=jv.newInstance({label:n});return o.create(e,r),o}}(e,t)}var qv={newInstance:Ht.newInstance($v),extend:$v};const Xv={renderEncoder:null,colorTexture:null,depthTexture:null};function Yv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xv,n),Ah.extend(e,t,n),Ht.get(e,t,["colorTexture","depthTexture"]),function(e,t){t.classHierarchy.push("vtkWebGPUOpaquePass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=qv.newInstance({label:"opaquePassColor"}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView("opaquePassColorTexture");t.renderEncoder.setColorTextureView(0,n),t.depthFormat="depth32float",t.depthTexture=qv.newInstance({label:"opaquePassDepth"}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("opaquePassDepthTexture");t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation("opaquePass"),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=Gv.newInstance({label:"OpaquePass"}),t.renderEncoder.setPipelineHash("op")}}(e,t)}var Zv={newInstance:Ht.newInstance(Yv,"vtkWebGPUOpaquePass"),extend:Yv};const Qv={colorTextureView:null,depthTextureView:null};function Jv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qv,n),Ah.extend(e,t,n),Ht.setGet(e,t,["colorTextureView","depthTextureView"]),function(e,t){t.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=qv.newInstance({label:"translucentPassColor"}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView("oitpColorTexture");t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=qv.newInstance({label:"translucentPassAccumulate"}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView("oitpAccumTexture");t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=Bv.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash("oitpfsq"),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\n  if (reveal == 1.0) { discard; }\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\n  var total: f32 = max(tcolor.a, 0.01);\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n")}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation("translucentPass"),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=Gv.newInstance({label:"translucentRender"});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:void 0,clearValue:[1,0,0,0],loadOp:"clear",storeOp:"store"}],e.depthStencilAttachment={view:void 0,depthLoadOp:"load",depthStoreOp:"store"},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addOutput("f32","outAccum"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);","output.outColor = vec4<f32>(computedColor.rgb*w, w);","output.outAccum = computedColor.a;"]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash("oitpr"),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!1,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one"},alpha:{srcFactor:"one",dstFactor:"one"}}},{format:"r16float",blend:{color:{srcFactor:"zero",dstFactor:"one-minus-src"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=Gv.newInstance({label:"translucentFinal"}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash("oitpf"),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})}}(e,t)}var eT={newInstance:Ht.newInstance(Jv,"vtkWebGPUOrderIndependentTranslucentPass"),extend:Jv},tT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const nT=["getMappedRange","mapAsync","unmap"];const rT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function oT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rT,n),Ht.obj(e,t),Ht.get(e,t,["handle","sizeInBytes","usage"]),Ht.setGet(e,t,["strideInBytes","device","arrayInformation","label","sourceTime"]),function(e,t){t.classHierarchy.push("vtkWebGPUBuffer"),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{const r=4*Math.ceil(e.byteLength/4);t.handle=t.device.getHandle().createBuffer({size:r,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=r,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<nT.length;n++)e[nT[n]]=function(){return t.handle[nT[n]](...arguments)}}(e,t)}var aT={newInstance:Ht.newInstance(oT),extend:oT,...tT};const{Representation:iT}=ts,{PrimitiveTypes:sT}=tT;class lT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function cT(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function uT(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=cT(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=cT(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=cT(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=cT(n,o,t),n.ibo[n.iboId++]=a}function dT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let pT;const fT=new Uint32Array(1),gT=new Uint32Array(2),mT=new Uint32Array(3),hT={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)fT[0]=t[n+a],pT(fT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)gT[0]=t[n+a],gT[1]=t[n+a+1],pT(gT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)gT[0]=t[n+a],gT[1]=t[n+(a+1)%e],pT(gT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)gT[0]=t[n+a],gT[1]=t[n+a+1],pT(gT,r,o);for(let a=0;a<e-2;a++)gT[0]=t[n+a],gT[1]=t[n+a+2],pT(gT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)mT[0]=t[n],mT[1]=t[n+a+1],mT[2]=t[n+a+2],pT(mT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)mT[0]=t[n+a],mT[1]=t[n+a+1+a%2],mT[2]=t[n+a+1+(a+1)%2],pT(mT,r,o)}};const vT={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function TT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vT,n),aT.extend(e,t,n),Ht.setGet(e,t,["flatIdToPointId","flatIdToCellId","flatSize","indexCount"]),function(e,t){t.classHierarchy.push("vtkWebGPUIndexBuffer"),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case sT.Points:return"points";case sT.Lines:return"lines";case sT.Triangles:case sT.TriangleEdges:return"polys";case sT.TriangleStripEdges:case sT.TriangleStrips:return"strips";default:return""}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new lT};let d=null;d=o===iT.POINTS||r===sT.Points?hT.anythingToPoints:o===iT.WIREFRAME||r===sT.Lines?hT[`${l}ToWireframe`]:hT[`${l}ToSurface`],pT=dT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format="uint16"):(u.ibo=new Uint32Array(u.iboSize),e.format="uint32"),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),pT=uT,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}(e,t)}var yT={newInstance:Ht.newInstance(TT),extend:TT,...tT};const{BufferUsage:bT}=tT,{vtkErrorMacro:xT}=jt,{VtkDataTypes:CT}=Ts;function ST(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,"packExtra")&&o.packExtra;let u,d=0;const p=it(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function AT(e,t,n,r){const o=[];return Fo([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),Go(o),o}const IT={device:null,fullScreenQuadBuffer:null};function wT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,IT,n),vt(e,t),St(e,t,["device"]),function(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===bT.Index&&(n=yT.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=aT.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===bT.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===bT.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===bT.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===bT.PointArray){r=GPUBufferUsage.VERTEX;const t=Cv(e.format),o=ST(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(xv(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?"flat":"perspective"}])}if(e.usage===bT.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=Cv(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=AT(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=ST(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(xv(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:"flat"}])}return e.usage===bT.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(xv(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push("vtkWebGPUBufferManager"),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case CT.UNSIGNED_CHAR:t="uint8";break;case CT.FLOAT:t="float32";break;case CT.UNSIGNED_INT:t="uint32";break;case CT.INT:t="sint32";break;case CT.DOUBLE:t="float32";break;case CT.UNSIGNED_SHORT:t="uint16";break;case CT.SHORT:t="sin16";break;default:t="float32"}switch(e.getNumberOfComponents()){case 2:t+="x2";break;case 3:t.includes("32")||xT(`unsupported x3 type for ${t}`),t+="x3";break;case 4:t+="x4"}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:bT.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=aT.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:"float32x3"}]),t.fullScreenQuadBuffer}}(e,t)}var OT={newInstance:Et(wT),extend:wT,...tT};const{BufferUsage:PT}=OT,{vtkErrorMacro:RT}=Ht,MT={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function ET(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),Ht.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"uniform"}},t.sendTime={},Ht.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,Ht.get(e,t,["binding","bindGroupTime"]),Ht.setGet(e,t,["bindGroupLayoutEntry","device","label","sizeInBytes"]),function(e,t){t.classHierarchy.push("vtkWebGPUUniformBuffer"),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?RT(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:Av(n),offset:-1,nativeType:Iv(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:PT.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=Ht.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void RT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void RT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join("\n")}}(e,t)}var VT={newInstance:Ht.newInstance(ET,"vtkWebGPUUniformBuffer"),extend:ET};const{BufferUsage:DT}=OT,{vtkErrorMacro:LT}=Ht,BT={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function NT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,BT,n),Ht.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},Ht.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"read-only-storage"}},Ht.get(e,t,["bindGroupTime"]),Ht.setGet(e,t,["device","bindGroupLayoutEntry","label","numberOfInstances","sizeInBytes"]),function(e,t){t.classHierarchy.push("vtkWebGPUStorageBuffer"),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void LT(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=Av(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:Iv(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:DT.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=Ht.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void LT(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void LT(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void LT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void LT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void LT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\n};\nstruct ${t.label}Struct\n{\n  values: array<${t.label}StructEntry>,\n};\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\n`),r.join("\n")},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}(e,t)}var FT={newInstance:Ht.newInstance(NT,"vtkWebGPUStorageBuffer"),extend:NT};const _T=new Float64Array(16),GT=new Float64Array(16),kT={volumes:null,rowLength:1024,lastVolumeLength:0};function UT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kT,n),Bv.extend(e,t,n),t.fragmentShaderTemplate="\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n",t.UBO=VT.newInstance({label:"mapperUBO"}),t.UBO.addEntry("SampleDistance","f32"),t.SSBO=FT.newInstance({label:"volumeSSBO"}),t.componentSSBO=FT.newInstance({label:"componentSSBO"}),t.lutBuildTime={},Ht.obj(t.lutBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkWebGPUVolumePassFSQ"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=cv.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);"]).result,r.setCode(o),t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription("fragment");let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===Af.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push("    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);")):(s.push(`  sampleColor = traverseVals[${e}];`),s.push("  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);"));a=cv.substitute(a,"//VTK::Volume::CompositeCalls",i).result,a=cv.substitute(a,"//VTK::Volume::TraverseCalls",s).result,a=cv.substitute(a,"//VTK::Volume::TraverseDec",[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===Af.COMPOSITE_BLEND?l=!0:n===Af.MAXIMUM_INTENSITY_BLEND?a=cv.substitute(a,"//VTK::Volume::Loop",[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===Af.MINIMUM_INTENSITY_BLEND?a=cv.substitute(a,"//VTK::Volume::Loop",[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===Af.AVERAGE_INTENSITY_BLEND?a=cv.substitute(a,"//VTK::Volume::Loop",[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===Af.ADDITIVE_INTENSITY_BLEND&&(a=cv.substitute(a,"//VTK::Volume::Loop",[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result)}l&&(a=cv.substitute(a,"//VTK::Volume::Loop",["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result),o.setCode(a)},t.shaderReplacements.set("replaceShaderVolume",e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8ClampedArray(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:"rgba8unorm"},r=n.getTextureManager().getTexture(e).createView("tfunTexture");t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:"r16float"},r=n.getTextureManager().getTexture(e).createView("ofunTexture");t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper().getInputData();g(_T),b(_T,_T,o);const d=n.getMatrix();m(GT,d),h(GT,GT),y(_T,GT,_T);const p=r.getWorldToIndex();y(_T,p,_T);const f=r.getDimensions();g(GT),x(GT,GT,[1/f[0],1/f[1],1/f[2]]),y(_T,GT,_T);for(let t=0;t<16;t++)a[16*e+t]=_T[t];h(_T,_T);for(let t=0;t<4;t++)i[16*e+4*t]=_T[4*t],i[16*e+4*t+1]=_T[4*t+1],i[16*e+4*t+2]=_T[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/f[0],s[4*e+1]=1/f[1],s[4*e+2]=1/f[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const v=r.getSpacing();c[4*e]=v[0],c[4*e+1]=v[1],c[4*e+2]=v[2],c[4*e+3]=1;const T=t.textureViews[e+4].getTexture().getScale(),C=n.getProperty().getIpScalarRange();u[4*e]=C[0]/T,u[4*e+1]=C[1]/T,u[4*e+2]=n.getProperty().getFilterMode()}t.SSBO.addEntry("SCTCMatrix","mat4x4<f32>"),t.SSBO.addEntry("planeNormals","mat4x4<f32>"),t.SSBO.addEntry("shade","vec4<f32>"),t.SSBO.addEntry("tstep","vec4<f32>"),t.SSBO.addEntry("spacing","vec4<f32>"),t.SSBO.addEntry("ipScalarRange","vec4<f32>"),t.SSBO.setAllInstancesFromArray("SCTCMatrix",a),t.SSBO.setAllInstancesFromArray("planeNormals",i),t.SSBO.setAllInstancesFromArray("shade",l),t.SSBO.setAllInstancesFromArray("tstep",s),t.SSBO.setAllInstancesFromArray("spacing",c),t.SSBO.setAllInstancesFromArray("ipScalarRange",u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),T=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=bv(l),u={scale:[255],offset:[0]};2===c.elementSize&&"float"===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);T[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else T[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry("cScale","f32"),t.componentSSBO.addEntry("cShift","f32"),t.componentSSBO.addEntry("oScale","f32"),t.componentSSBO.addEntry("oShift","f32"),t.componentSSBO.addEntry("goShift","f32"),t.componentSSBO.addEntry("goScale","f32"),t.componentSSBO.addEntry("gomin","f32"),t.componentSSBO.addEntry("gomax","f32"),t.componentSSBO.setAllInstancesFromArray("cScale",d),t.componentSSBO.setAllInstancesFromArray("cShift",p),t.componentSSBO.setAllInstancesFromArray("oScale",f),t.componentSSBO.setAllInstancesFromArray("oShift",v),t.componentSSBO.setAllInstancesFromArray("goScale",A),t.componentSSBO.setAllInstancesFromArray("goShift",S),t.componentSSBO.setAllInstancesFromArray("gomin",T),t.componentSSBO.setAllInstancesFromArray("gomax",C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue("SampleDistance",r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=zv.newInstance({label:"clampSampler"}),t.clampSampler.create(t.device,{minFilter:"linear",magFilter:"linear"}))},e.computePipelineHash=()=>{t.pipelineHash="volfsq";for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}(e,t)}var zT={newInstance:Ht.newInstance(UT,"vtkWebGPUVolumePassFSQ"),extend:UT};const{Representation:WT}=ts,{BufferUsage:HT,PrimitiveTypes:jT}=OT,KT=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],$T={colorTextureView:null,depthTextureView:null,volumes:null};function qT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$T,n),Ah.extend(e,t,n),t._mapper=Vv.newInstance(),t._mapper.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Select::Dec\n\n//VTK::VolumePass::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Select::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::VolumePass::Impl\n\n  // use the maximum (closest) of the current value and the zbuffer\n  // the blend func will then take the min to find the farthest stop value\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._mapper.getShaderReplacements().set("replaceShaderVolumePass",((e,t,n)=>{t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")})),t._boundsPoly=Uc.newInstance(),t._lastMTimes=[],Ht.setGet(e,t,["colorTextureView","depthTextureView"]),function(e,t){t.classHierarchy.push("vtkWebGPUVolumePass"),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=zT.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=Bv.newInstance(),t._volumeCopyQuad.setPipelineHash("volpassfsq"),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._copyUBO=VT.newInstance({label:"mapperUBO"}),t._copyUBO.addEntry("tscale","vec2<f32>"),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Uo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray("tscale",[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray("tscale",[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=Ht.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:HT.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:jT.Triangles,representation:WT.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:HT.PointArray,format:"float32x4",hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,["vertexBC"]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+KT[e][0],l[n++]=r+KT[e][1],l[n++]=r+KT[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation("volumeDepthRangePass"),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=Gv.newInstance({label:"VolumePass DepthRange"}),t._depthRangeEncoder.setPipelineHash("volr"),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor1"),t.addOutput("vec4<f32>","outColor2");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);","output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:null,clearValue:[1,1,1,1],loadOp:"clear",storeOp:"store"}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"max"},alpha:{srcFactor:"one",dstFactor:"one",operation:"max"}}},{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"min"},alpha:{srcFactor:"one",dstFactor:"one",operation:"min"}}}]}}),t._depthRangeTexture=qv.newInstance({label:"volumePassMaxDepth"}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView("maxTexture");t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=qv.newInstance({label:"volumePassDepthMin"}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView("minTexture");t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=qv.newInstance({label:"volumePassColor"}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView("volumePassColorTexture"),t._colorTextureView.addSampler(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._clearEncoder=Gv.newInstance({label:"VolumePass Clear"}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),t._clearEncoder.setPipelineHash("volpf"),t._clearEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=Gv.newInstance({label:"volumePassCopy"}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._copyEncoder.setPipelineHash("volcopypf"),t._copyEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=Gv.newInstance({label:"volumePassMerge"}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash("volpf"),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}(e,t)}var XT={newInstance:Ht.newInstance(qT,"vtkWebGPUVolumePass"),extend:qT};const YT={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function ZT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,YT,n),Ah.extend(e,t,n),Ht.setGet(e,t,["opaquePass","translucentPass","volumePass"]),function(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e),t.opaquePass||(t.opaquePass=Zv.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation("queryPass"),i.traverse(e),e.setCurrentOperation("cameraPass"),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=eT.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=XT.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=Gv.newInstance({label:"forwardPassBlit"}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._finalBlitEncoder.setPipelineHash("fpf"),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}}),t._fsqSampler=zv.newInstance({label:"finalPassSampler"}),t._fsqSampler.create(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._fullScreenQuad=Bv.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash("fpfsq"),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._finalBlitOutputTextureView=jv.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}(e,t)}var QT={newInstance:Ht.newInstance(ZT,"vtkForwardPass"),extend:ZT};const{VtkDataTypes:JT}=Ts,ey={handle:null,device:null};function ty(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ey,n),Ht.obj(e,t),Ht.setGet(e,t,["device"]),function(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format="r";break;case 2:e.format="rg";break;default:e.format="rgba"}switch(e.dataArray.getDataType()){case JT.UNSIGNED_CHAR:e.format+="8unorm";break;case JT.FLOAT:case JT.UNSIGNED_INT:case JT.INT:case JT.DOUBLE:case JT.UNSIGNED_SHORT:case JT.SHORT:default:e.format+="16float"}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.nativeArray=e.jsImageData.data,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.imageBitmap&&(e.width=e.imageBitmap.width,e.height=e.imageBitmap.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=qv.newInstance({label:e.label});return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas||e.imageBitmap)&&n.writeImageData(e),n}t.classHierarchy.push("vtkWebGPUTextureManager"),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;const o={time:e.getMTime(),label:r};return e.getInputData()?o.imageData=e.getInputData():e.getImage()?o.image=e.getImage():e.getJsImageData()?o.jsImageData=e.getJsImageData():e.getImageBitmap()?o.imageBitmap=e.getImageBitmap():e.getCanvas()&&(o.canvas=e.getCanvas()),n(o),o.mipLevel=e.getMipLevel(),o.hash=o.time+o.format+o.mipLevel,t.device.getTextureManager().getTexture(o)}}(e,t)}var ny={newInstance:Ht.newInstance(ty),extend:ty};class ry extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&"object"==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}const oy={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function ay(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oy,n),vt(e,t),St(e,t,["handle"]),yt(e,t,["bufferManager","shaderCache","textureManager"]),t.objectCache=new ry,t.shaderCache=cv.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=OT.newInstance(),t.bufferManager.setDevice(e),t.textureManager=ny.newInstance(),t.textureManager.setDevice(e),t.pipelines={},function(e,t){t.classHierarchy.push("vtkWebGPUDevice"),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro("layout not found"),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro("attempt to cache an object without a hash"),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}(e,t)}var iy={newInstance:Et(ay,"vtkWebGPUDevice"),extend:ay};const sy={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function ly(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sy,n),Ah.extend(e,t,n),Ht.get(e,t,["colorTexture","depthTexture"]),function(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelectionPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=qv.newInstance({label:"hardwareSelectorColor"}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"rgba32uint",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView("hardwareSelectColorTexture");t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=qv.newInstance({label:"hardwareSelectorDepth"}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("hardwareSelectDepthTexture");t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation("cameraPass"),r.traverse(e),e.setCurrentOperation("opaquePass"),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=Gv.newInstance({label:"HardwareSelectionPass"}),t.selectionRenderEncoder.setPipelineHash("sel"),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<u32>","outColor");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba32uint",blend:void 0}]}})}}(e,t)}var cy={newInstance:Ht.newInstance(ly,"vtkWebGPUHardwareSelectionPass"),extend:ly};const{SelectionContent:uy,SelectionField:dy}=Zd,{FieldAssociations:py}=_s,{vtkErrorMacro:fy}=Ht;function gy(e){return`${e.propID} ${e.compositeID}`}function my(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function hy(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=my(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=my(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=hy(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=hy(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=hy(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=hy(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=hy(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}const vy={};function Ty(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vy,n),jd.extend(e,t,n),t._selectionPass=cy.newInstance(),Ht.setGet(e,t,["_WebGPURenderWindow"]),Ht.moveToProtected(e,t,["WebGPURenderWindow"]),function(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelector"),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return fy("Renderer and view must be set before calling Select."),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=aT.newInstance({label:"hardwareSelectColorBuffer"});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=aT.newInstance({label:"hardwareSelectDepthBuffer"}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:"depth-only"},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=hy(e,[n,t],0,u);if(r){const t=gy(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=Zd.newInstance();switch(i.setContentType(uy.INDICES),e){case py.FIELD_ASSOCIATION_CELLS:i.setFieldType(dy.CELL);break;case py.FIELD_ASSOCIATION_POINTS:i.setFieldType(dy.POINT);break;default:fy("Unknown field association")}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}(e,t)}var yy={newInstance:Ht.newInstance(Ty,"vtkWebGPUHardwareSelector"),extend:Ty};const by=Object.create(null),xy={};function Cy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xy,n),t.overrides=by,Qt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkWebGPUViewNodeFactory")}(0,t)}var Sy={newInstance:Ht.newInstance(Cy,"vtkWebGPUViewNodeFactory"),extend:Cy};const{vtkErrorMacro:Ay}=Ht,Iy={position:"absolute",top:0,left:0,width:"100%",height:"100%"};const wy={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:"pointer",containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const Oy=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wy,n),t.canvas=document.createElement("canvas"),t.canvas.style.width="100%",t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",Kh.extend(e,t,n),t.myFactory=Sy.newInstance(),t.renderPasses[0]=QT.newInstance(),t.selector||(t.selector=yy.newInstance(),t.selector.setWebGPURenderWindow(e)),Ht.event(e,t,"imageReady"),Ht.event(e,t,"initialized"),Ht.get(e,t,["commandEncoder","device","presentationFormat","useBackgroundImage","xrSupported"]),Ht.setGet(e,t,["initialized","context","canvas","device","renderPasses","notifyStartCaptureImage","cursor","useOffScreen"]),Ht.setGetArray(e,t,["size"],2),Ht.event(e,t,"windowResizeEvent"),function(e,t){t.classHierarchy.push("vtkWebGPURenderWindow"),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Ay("WebGPU is not enabled.");e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Ay("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),t.deleted||(t.device=iy.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext("webgpu"))},e.releaseGraphicsResources=()=>{const n=Ah.newInstance();n.setCurrentOperation("Release"),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Iy,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect();t.renderable.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const l=r.toDataURL(n);r.remove(),e.invokeImageReady(l)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=aT.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Uu.fromHalf(r.colorValues[o]),s[n+1]=255*Uu.fromHalf(r.colorValues[o+1]),s[n+2]=255*Uu.fromHalf(r.colorValues[o+2]),s[n+3]=255*Uu.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=yy.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=Ht.chain(e.delete,e.setViewStream)}(e,t)}),"vtkWebGPURenderWindow");var Py;Nm("WebGPU",Oy),Py=Oy,by.vtkRenderWindow=Py;const Ry=xh(),My={margin:"0",padding:"0",position:"absolute",top:"0",left:"0",width:"100%",height:"100%",overflow:"hidden"},Ey={position:"absolute",left:"25px",top:"25px",backgroundColor:"white",borderRadius:"5px",listStyle:"none",padding:"5px 10px",margin:"0",display:"block",border:"solid 1px black",maxWidth:"calc(100% - 70px)",maxHeight:"calc(100% - 60px)",overflow:"auto"};function Vy(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}const Dy={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function Ly(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dy,n),Ht.obj(e,t),Ht.get(e,t,["renderWindow","renderer","apiSpecificRenderWindow","interactor","rootContainer","container","controlContainer"]),function(e,t){t.classHierarchy.push("vtkFullScreenRenderWindow");const n=document.querySelector("body");function r(t){"c"===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement("div"),Vy(t.container,t.containerStyle||My),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height="100%",n.style.height="100%",n.style.padding="0",n.style.margin="0"),t.renderWindow=km.newInstance(),t.renderer=Lm.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(Ry.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=rh.newInstance(),t.interactor.setInteractorStyle(Th.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?"block":"none")},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement("div"),Vy(t.controlContainer,t.controlPanelStyle||Ey),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener("keypress",r)},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=Ht.chain(e.setContainer,t.apiSpecificRenderWindow.delete,(()=>{t.rootContainer?.removeEventListener("keypress",r),window.removeEventListener("resize",e.resize)}),e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener("resize",e.resize),e.resize()}(e,t)}var By={newInstance:Ht.newInstance(Ly),extend:Ly},Ny={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:Fy,Scale:_y}=Ny,{ScalarMappingTarget:Gy}=il,{vtkDebugMacro:ky,vtkErrorMacro:Uy,vtkWarningMacro:zy}=Ht;function Wy(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function Hy(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function jy(e,t,n,r){const o=[],a=[];va(t,o),va(n,a);const i=[],s=[];Wy(o,i),Wy(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=Hy(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=Hy(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Ta(u,r)}const Ky={clamping:!0,colorSpace:Fy.RGB,hSVWrap:!0,scale:_y.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function $y(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ky,n),il.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},Ht.obj(t.buildTime),Ht.get(e,t,["buildTime","mappingRange"]),Ht.setGet(e,t,["useAboveRangeColor","useBelowRangeColor","discretize","numberOfValues",{type:"enum",name:"colorSpace",enum:Fy},{type:"enum",name:"scale",enum:_y}]),Ht.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),Ht.getArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"]),function(e,t){t.classHierarchy.push("vtkColorTransferFunction"),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return Uy("Midpoint outside range [0.0, 1.0]"),-1;if(s<0||s>1)return Uy("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[];return pa([n,r,o],s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];pa([n,r,o],u),pa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.logScaleEnabled=()=>t.scale===_y.LOG10,e.usingLogScale=()=>e.logScaleEnabled()&&t.mappingRange[0]>0,e.getTable=(n,r,o,a)=>{const i=e.usingLogScale(),s=i?Math.log10(Number(n)):Number(n),l=i?Math.log10(Number(r)):Number(r);if(Pa(s)||Pa(l)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let c=0;const u=t.nodes.length;let d=0,p=0,f=0;0!==u&&(d=t.nodes[u-1].r,p=t.nodes[u-1].g,f=t.nodes[u-1].b);let g=0,m=0,h=0;const v=[0,0,0],T=[0,0,0];let y=0,b=0;const x=[];let C=t.mappingRange;i&&(C=[Math.log10(t.mappingRange[0]),Math.log10(t.mappingRange[1])]);for(let n=0;n<o;n++){const r=3*n;if(g=o>1?s+n/(o-1)*(l-s):.5*(s+l),t.discretize){const e=C;if(g>=e[0]&&g<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)g=e[0]+r/2;else{const t=(g-e[0])/r,o=Co(n*t);g=e[0]+o/(n-1)*r}}}for(;c<u&&g>t.nodes[c].x;)c++,c<u&&(m=t.nodes[c-1].x,h=t.nodes[c].x,v[0]=t.nodes[c-1].r,T[0]=t.nodes[c].r,v[1]=t.nodes[c-1].g,T[1]=t.nodes[c].g,v[2]=t.nodes[c-1].b,T[2]=t.nodes[c].b,y=t.nodes[c-1].midpoint,b=t.nodes[c-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(g>C[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=d,a[r+1]=p,a[r+2]=f));else if(g<C[0]||Ia(g)&&g<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):u>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===c&&(Math.abs(g-s)<1e-6||t.discretize))u>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=(g-m)/(h-m),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),b>.99){if(e<.5){a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}a[r]=T[0],a[r+1]=T[1],a[r+2]=T[2];continue}if(b<.01){if(t.colorSpace===Fy.RGB)a[r]=(1-e)*v[0]+e*T[0],a[r+1]=(1-e)*v[1]+e*T[1],a[r+2]=(1-e)*v[2]+e*T[2];else if(t.colorSpace===Fy.HSV){const n=[],o=[];da(v,n),da(T,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],pa(i,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else if(t.colorSpace===Fy.LAB){const t=[],n=[];va(v,t),va(T,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Ta(o,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else t.colorSpace===Fy.DIVERGING?(jy(e,v,T,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]):Uy("ColorSpace set to invalid value.",t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*b):e>.5&&(e=1-.5*(2*(1-e))**(1+10*b));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===Fy.RGB)for(let e=0;e<3;e++)u=T[e]-v[e],d=(1-b)*u,a[r+e]=i*v[e]+s*T[e]+l*d+c*d;else if(t.colorSpace===Fy.HSV){const e=[],n=[];da(v,e),da(T,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-b)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);pa(o,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else if(t.colorSpace===Fy.LAB){const e=[],t=[];va(v,e),va(T,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-b)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Ta(n,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else t.colorSpace===Fy.DIVERGING?(jy(e,v,T,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]):Uy("ColorSpace set to invalid value.");for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return Uy("Attempting to lookup a value with no points in the function"),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(Uy("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return Uy("Index out of range!"),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>{if(t.indexedLookup&&e.getSize())return e.getSize();if(t.tableSize)return t.tableSize;const n=t.nodes?.length??0;return Math.max(4094,n)},e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=[n,r],i=e.getRange(),s=e.logScaleEnabled();if(i[1]===o[1]&&i[0]===o[0])return;if(o[1]===o[0])return void Uy("attempt to set zero width color range");s&&(o[0]<=0?console.warn("attempt to set log scale color range with non-positive minimum"):(a[0]=Math.log10(o[0]),a[1]=Math.log10(o[1])));const l=(a[1]-a[0])/(i[1]-i[0]),c=a[0]-i[0]*l;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*l+c;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):ky("Transfer Function Has No Points!")},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void zy("Transfer Function Has No Points!");const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===Gy.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===Gy.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===Gy.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===Gy.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=Fy[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(Uy(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=Fy.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}(e,t)}var qy={newInstance:Ht.newInstance($y,"vtkColorTransferFunction"),extend:$y,...Ny},Xy={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:Yy,ScaleModes:Zy}=Xy,{vtkErrorMacro:Qy}=Ht,Jy={orient:!0,orientationMode:Yy.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:Zy.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function eb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jy,n),Fl.extend(e,t,n),Ht.algo(e,t,2,0),t.buildTime={},Ht.obj(t.buildTime,{mtime:0}),t.boundsTime={},Ht.obj(t.boundsTime,{mtime:0}),Ht.setGet(e,t,["orient","orientationMode","orientationArray","scaleArray","scaleFactor","scaleMode","scaling"]),Ht.get(e,t,["colorArray","matrixArray","normalArray","buildTime"]),function(e,t){t.classHierarchy.push("vtkGlyph3DMapper"),e.getOrientationModeAsString=()=>Ht.enumToString(Yy,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(Yy.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(Yy.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(Yy.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>Ht.enumToString(Zy,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(Zy.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(Zy.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(Zy.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Ra()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===Zy.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(Qy("Cannot scale by components since scale array does not have 3 components."),a=null);const l=r.getBounds(),c=[];Fi.getCorners(l,c),t.bounds[0]=Fi.INIT_BOUNDS[0],t.bounds[1]=Fi.INIT_BOUNDS[1],t.bounds[2]=Fi.INIT_BOUNDS[2],t.bounds[3]=Fi.INIT_BOUNDS[3],t.bounds[4]=Fi.INIT_BOUNDS[4],t.bounds[5]=Fi.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const T=t.normalArray.buffer,w=[],O=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,O),t.orientationMode){case Yy.MATRIX:y(n,n,[...O.slice(0,3),0,...O.slice(3,6),0,...O.slice(6,9),0,0,0,0,1]);break;case Yy.ROTATION:I(n,n,O[2]),S(n,n,O[0]),A(n,n,O[1]);break;case Yy.DIRECTION:if(0===O[1]&&0===O[2])O[0]<0&&A(n,n,3.1415926);else{const e=_o(O),t=[];t[0]=(O[0]+e)/2,t[1]=O[1]/2,t[2]=O[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case Zy.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=_o(w,s),m[1]=m[0],m[2]=m[0];break;case Zy.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case Zy.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)wn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(T,36*e,9);se(r,n),ge(r,r),fe(r,r)}const P=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&P&&(R.build(),t.colorArray=R.mapScalars(P,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}(e,t)}var tb={newInstance:Ht.newInstance(eb,"vtkGlyph3DMapper"),extend:eb,...Xy};const{vtkErrorMacro:nb}=Ht,rb={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function ob(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rb,n),Ht.obj(e,t),t.nodes=[],Ht.setGet(e,t,["allowDuplicateScalars","clamping"]),Ht.setArray(e,t,["range"],2),Ht.getArray(e,t,["range"]),function(e,t){t.classHierarchy.push("vtkPiecewiseFunction"),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return"Constant";case 1:return"NonDecreasing";case 2:return"NonIncreasing";default:return"Varied"}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(nb("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return nb("Index out of range!"),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return nb("Midpoint outside range [0.0, 1.0]"),-1;if(a<0||a>1)return nb("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,T=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>T?T:o[v]}}}}(e,t)}var ab={newInstance:Ht.newInstance(ob,"vtkPiecewiseFunction"),extend:ob};const{InterpolationType:ib,OpacityMode:sb,FilterMode:lb,ColorMixPreset:cb}=Sf,{vtkErrorMacro:ub}=Ht;function db(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,(e=>({colorMixPreset:cb.DEFAULT,independentComponents:!0,interpolationType:ib.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1,ipScalarRange:[-1e6,1e6],filterMode:lb.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7,updatedExtents:[],...e}))(n)),Ht.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:sb.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1,forceNearestInterpolation:!1})}Ht.setGet(e,t,["colorMixPreset","independentComponents","interpolationType","shade","ambient","diffuse","specular","specularPower","useLabelOutline","labelOutlineOpacity","filterMode","preferSizeOverAccuracy","computeNormalFromOpacity","volumetricScatteringBlending","globalIlluminationReach","anisotropy","localAmbientOcclusion","LAOKernelSize","LAOKernelRadius","updatedExtents"]),Ht.setGetArray(e,t,["ipScalarRange"],2),Ht.setGetArray(e,t,["labelOutlineThickness"]),function(e,t){t.classHierarchy.push("vtkVolumeProperty");const n={...e};e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(ub("Bad index - must be between 0 and 3"),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=ab.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=qy.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=ab.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return ub("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(ub("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(ib.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(ib.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(ib.FAST_LINEAR),e.getInterpolationTypeAsString=()=>Ht.enumToString(ib,t.interpolationType),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=Ht.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=Ht.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]})),e.setAverageIPScalarRange=(t,n)=>{console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>Ht.enumToString(lb,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(lb.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(lb.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(lb.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(xa(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(xa(e,0,1)),e.setAnisotropy=e=>n.setAnisotropy(xa(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Co(xa(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}(e,t)}var pb={newInstance:Ht.newInstance(db,"vtkVolumeProperty"),extend:db,...Sf};const fb={mapper:null};function gb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fb,n),Ki.extend(e,t,n),t.boundsMTime={},Ht.obj(t.boundsMTime),Ht.setGet(e,t,["mapper"]),function(e,t){t.classHierarchy.push("vtkVolume"),e.getVolumes=()=>[e],e.makeProperty=pb.newInstance,e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}(e,t)}var mb={newInstance:Ht.newInstance(gb,"vtkVolume"),extend:gb};const{BlendMode:hb}=If,vb=["getAnisotropy","getComputeNormalFromOpacity","getFilterMode","getFilterModeAsString","getGlobalIlluminationReach","getIpScalarRange","getIpScalarRangeByReference","getLAOKernelRadius","getLAOKernelSize","getLocalAmbientOcclusion","getPreferSizeOverAccuracy","getVolumetricScatteringBlending","setAnisotropy","setAverageIPScalarRange","setComputeNormalFromOpacity","setFilterMode","setFilterModeToNormalized","setFilterModeToOff","setFilterModeToRaw","setGlobalIlluminationReach","setIpScalarRange","setIpScalarRangeFrom","setLAOKernelRadius","setLAOKernelSize","setLocalAmbientOcclusion","setPreferSizeOverAccuracy","setVolumetricScatteringBlending"],Tb={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=ab.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,(e=>({bounds:[...Fi.INIT_BOUNDS],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:hb.COMPOSITE_BLEND,volumeShadowSamplingDistFactor:5,colorTextureWidth:1024,opacityTextureWidth:1024,labelOutlineTextureWidth:1024,...e}))(n)),xs(e,t,n),Ht.setGet(e,t,["sampleDistance","imageSampleDistance","maximumSamplesPerRay","autoAdjustSampleDistances","initialInteractionScale","interactionSampleDistanceFactor","blendMode","volumeShadowSamplingDistFactor","colorTextureWidth","opacityTextureWidth","labelOutlineTextureWidth"]),Ht.event(e,t,"lightingActivated"),function(e,t){t.classHierarchy.push("vtkVolumeMapper");const n={...e};e.getBounds=()=>(t.static||e.update(),t.bounds=[...e.getInputData().getBounds()],t.bounds),e.setBlendModeToComposite=()=>{e.setBlendMode(hb.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(hb.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(hb.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(hb.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(hb.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(hb.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>Ht.enumToString(hb,t.blendMode),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),vb.forEach((t=>{e[t]=()=>{throw new Error(`The method "volumeMapper.${t}()" doesn't exist anymore. It is a rendering property that has been moved to the volume property. Replace your code with:\nvolumeActor.getProperty().${t}()\n`)}}))}(e,t)}var bb={newInstance:Ht.newInstance(yb,"vtkVolumeMapper"),extend:yb,...Tb};const{InterpolationType:xb}=Qp,{vtkErrorMacro:Cb}=Ht;function Sb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,(e=>({independentComponents:!1,interpolationType:xb.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1,updatedExtents:[],...e}))(n)),Ht.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}Ht.setGet(e,t,["independentComponents","interpolationType","colorWindow","colorLevel","ambient","diffuse","opacity","useLookupTableScalarRange","useLabelOutline","labelOutlineOpacity","updatedExtents"]),Ht.setGetArray(e,t,["labelOutlineThickness"]),function(e,t){t.classHierarchy.push("vtkImageProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(n)||(o=n,r=0),t.componentData[r].rGBTransferFunction!==o&&(t.componentData[r].rGBTransferFunction=o,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(n)||(o=n,r=0),t.componentData[r].piecewiseFunction!==o&&(t.componentData[r].piecewiseFunction=o,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(t)||(r=t,n=0),e.setPiecewiseFunction(n,r)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return Cb("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(Cb("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(xb.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(xb.LINEAR),e.getInterpolationTypeAsString=()=>Ht.enumToString(xb,t.interpolationType)}(e,t)}var Ab={newInstance:Ht.newInstance(Sb,"vtkImageProperty"),extend:Sb};const Ib={mapper:null,forceOpaque:!1,forceTranslucent:!1};function wb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ib,n),Ki.extend(e,t,n),t.boundsMTime={},Ht.obj(t.boundsMTime),Ht.setGet(e,t,["mapper","forceOpaque","forceTranslucent"]),function(e,t){t.classHierarchy.push("vtkImageSlice"),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.properties[0]||e.getProperty();let n=t.properties[0].getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=Ab.newInstance,e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!Fi.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),Fi.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return t.properties.forEach((t=>{e=Math.max(e,t.getMTime());const n=t.getRGBTransferFunction();null!==n&&(e=Math.max(e,n.getMTime()))})),e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}(e,t)}var Ob={newInstance:Ht.newInstance(wb,"vtkImageSlice"),extend:wb};const Pb={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1],colorTextureWidth:1024,opacityTextureWidth:1024,labelOutlineTextureWidth:1024};var Rb=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pb,n),xs(e,t,n),Ht.setGet(e,t,["slice","useCustomExtents","colorTextureWidth","opacityTextureWidth","labelOutlineTextureWidth"]),Ht.setGetArray(e,t,["customDisplayExtent"],6),Ht.setGetArray(e,t,["backgroundColor"],4),function(e,t){t.classHierarchy.push("vtkAbstractImageMapper"),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(Ht.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"),Ra())}(e,t)};function Mb(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA("vtkImageArrayMapper")?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Sn(c,c);const u=ti.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:Eb,otherStaticMethods:Vb}=bl,{SlicingMode:Db}=rf;const Lb={slicingMode:Db.NONE,closestIJKAxis:{ijkMode:Db.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function Bb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lb,n),Rb(e,t,n),Ht.get(e,t,["slicingMode"]),Ht.setGet(e,t,["closestIJKAxis","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy"]),bl.implementCoincidentTopologyMethods(e,t),function(e,t){function n(){let n;switch(t.slicingMode){case Db.X:n=0;break;case Db.Y:n=1;break;case Db.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=Ma(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push("vtkImageMapper"),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case Db.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case Db.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case Db.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case Db.I:l=xa(a[0],i[0],i[1]);break;case Db.J:l=xa(a[1],i[2],i[3]);break;case Db.K:l=xa(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case Db.I:case Db.J:case Db.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case Db.X:e.setSlice(r[0]);break;case Db.Y:e.setSlice(r[1]);break;case Db.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(Db.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(Db.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(Db.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(Db.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(Db.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(Db.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case Db.X:n[0]=1;break;case Db.Y:n[1]=1;break;case Db.Z:n[2]=1;break;case Db.I:jo(r,[1,0,0],n);break;case Db.J:jo(r,[0,1,0],n);break;case Db.K:jo(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==Db.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Ra();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case Db.I:r[0]=a,r[1]=a;break;case Db.J:r[2]=a,r[3]=a;break;case Db.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Ra();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case Db.I:a[0]=s-r,a[1]=s+r;break;case Db.J:a[2]=s-r,a[3]=s+r;break;case Db.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=Mb(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=Mb(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}(e,t)}var Nb={newInstance:Ht.newInstance(Bb,"vtkImageMapper"),extend:Bb,...Eb,...Vb,...rf};const{vtkErrorMacro:Fb}=Ht;function _b(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}const Gb={outputPointsPrecision:Os.DEFAULT};function kb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gb,n),Ht.setGet(e,t,["outputPointsPrecision"]),Ht.obj(e,t),Ht.algo(e,t,1,1),function(e,t){t.classHierarchy.push("vtkAppendPolyData"),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void Fb("No input specified.");if(1===o)return void(r[0]=n[0]);const a=Uc.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===Os.SINGLE?s=is.FLOAT:t.outputPointsPrecision===Os.DOUBLE&&(s=is.DOUBLE);const v=ql.newInstance({dataType:s});v.setNumberOfPoints(i);const T=v.getData(),y=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Ts.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Ts.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Ts.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];T.set(t.getPoints().getData(),3*i),_b(y,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),_b(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),_b(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),_b(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(y),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}(e,t)}var Ub={newInstance:Ht.newInstance(kb,"vtkAppendPolyData"),extend:kb};const zb={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:"Float64Array"};function Wb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zb,n),Ht.obj(e,t),Ht.setGet(e,t,["height","radius","resolution","capping"]),Ht.setGetArray(e,t,["center","direction"],3),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkConeSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=Ht.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Lp().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=Uc.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}(e,t)}var Hb={newInstance:Ht.newInstance(Wb,"vtkConeSource"),extend:Wb};const jb={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:"Float64Array"};function Kb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jb,n),Ht.obj(e,t),Ht.setGet(e,t,["height","initAngle","otherRadius","radius","resolution","capping"]),Ht.setGetArray(e,t,["center","direction"],3),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkCylinderSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=Ht.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Ts.newInstance({numberOfComponents:3,values:u,name:"Normals"}),p=new Float32Array(2*a),f=Ts.newInstance({numberOfComponents:2,values:p,name:"TCoords"}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],T=[0,0],y=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],T[0]=Math.abs(2*e/t.resolution-1),y[0]=T[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],T[1]=0,y[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=T[e],p[2*(n+1)+e]=y[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],T[0]=h[0],y[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],T[1]=h[2],y[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=T[e],p[2*r+e]=y[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Lp().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=Uc.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}(e,t)}var $b={newInstance:Ht.newInstance(Kb,"vtkCylinderSource"),extend:Kb};const qb={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:"Float64Array"};function Xb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qb,n),Ht.obj(e,t),Ht.setGet(e,t,["tipResolution","tipRadius","tipLength","shaftResolution","shaftRadius","invert"]),Ht.setGetArray(e,t,["direction"],3),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkArrowSource"),e.requestData=function(e,n){if(t.deleted)return;const r=$b.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();Dp().rotateZ(-90).apply(a).apply(i);const s=Hb.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Lp().translate(1-.5*t.tipLength,0,0).apply(c);const u=Ub.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Lp().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Lp().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Lp().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}(e,t)}var Yb={newInstance:Ht.newInstance(Xb,"vtkArrowSource"),extend:Xb};function Zb(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];Dp().translate(...n).apply(e.getPoints().getData())}function Qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=e.getPoints().getBounds(),o=[0,0,0];o[t]=n?-r[2*t+1]:-r[2*t],Dp().translate(...o).apply(e.getPoints().getData())}function Jb(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8ClampedArray(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Ts.newInstance({name:"color",numberOfComponents:3,values:a}))}function ex(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};os.extend(e,t,function(e){return{config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1,...e?.config},xConfig:{color:[255,0,0],invert:!1,...e?.xConfig},yConfig:{color:[255,255,0],invert:!1,...e?.yConfig},zConfig:{color:[0,128,0],invert:!1,...e?.zConfig}}}(n)),Ht.setGet(e,t,["config","xConfig","yConfig","zConfig"]),function(e,t){t.classHierarchy.push("vtkAxesActor");const n=Fl.newInstance();e.setMapper(n),e.update=()=>{let e={...t.config,...t.xConfig};const r=Yb.newInstance({direction:[1,0,0],...e}).getOutputData();t.config.recenter?Zb(r):Qb(r,0,e.invert),Jb(r,...e.color),e={...t.config,...t.yConfig};const o=Yb.newInstance({direction:[0,1,0],...e}).getOutputData();t.config.recenter?Zb(o):Qb(o,1,e.invert),Jb(o,...e.color),e={...t.config,...t.zConfig};const a=Yb.newInstance({direction:[0,0,1],...e}).getOutputData();t.config.recenter?Zb(a):Qb(a,2,e.invert),Jb(a,...e.color);const i=Ub.newInstance();i.setInputData(r),i.addInputData(o),i.addInputData(a),n.setInputConnection(i.getOutputPort())},e.update();const r=Ht.debounce(e.update,0);e.setXAxisColor=t=>e.setXConfig({...e.getXConfig(),color:t}),e.setYAxisColor=t=>e.setYConfig({...e.getYConfig(),color:t}),e.setZAxisColor=t=>e.setZConfig({...e.getZConfig(),color:t}),e.getXAxisColor=()=>t.getXConfig().color,e.getYAxisColor=()=>t.getYConfig().color,e.getZAxisColor=()=>t.getZConfig().color,t._onConfigChanged=r,t._onXConfigChanged=r,t._onYConfigChanged=r,t._onZConfigChanged=r}(e,t)}var tx={newInstance:Ht.newInstance(ex,"vtkAxesActor"),extend:ex};const nx="resetcamera",rx="orientation",ox={MODE_RESET_CAMERA:nx,MODE_ORIENTATION:rx,MODE_SAME:"same"};const ax={mode:rx,focalPoint:[0,0,0],distance:6.8,active:!0};function ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ax,n),vt(e,t),St(e,t,["mode","active","srcRenderer","dstRenderer","distance"]),wt(e,t,["focalPoint"],3,0),function(e,t){t.classHierarchy.push("vtkCameraSynchronizer");const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._onSrcRendererChanged=a,t._onDstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName("position"),s=e.getReferenceByName("focalPoint"),l=e.getReferenceByName("viewUp"),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===rx?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],Go(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===nx&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}(e,t)}var sx={newInstance:Et(ix,"vtkCameraSynchronizer"),extend:ix,SynchronizationMode:ox};const lx={},cx={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=sx.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:sx.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var ux=function(e,t,n){const r=e.get("synchronizedViewId").synchronizedViewId;if(!t.behaviors||!r)return;lx[r]||(lx[r]={});const o=lx[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=sx.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];cx[e.type]?o[r]=new cx[e.type](n,e):console.log("No mapping for",e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const dx={},px=/instance:\${([^}]+)}/,fx={},gx=[],mx={},hx={vtkPoints:ql,vtkCellArray:Wl,vtkDataArray:Ts};function vx(e){return e.map((e=>px.exec(e))).filter((e=>e)).map((e=>e[1]))}function Tx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),Tx(e,t)})),t}function yx(e,t,n,r){if(!t)return Promise.reject(new Error("No instance provided."));const o=dx[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function bx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=dx[e];return n&&n.build?n.build(t):(console.log("No builder for",e),null)}function xx(){Object.keys(dx).forEach((e=>{delete dx[e]}))}function Cx(e){if(1===e[1].length)return-1===gx.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===gx.indexOf(e[1][n]);return t}function Sx(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(mx[r]){const{key:n,value:o}=mx[r];if(!n||e.properties[n]===o)return void gx.push((e=>`instance:\${${e}}`)(t))}let o=n.getInstance(t);o||(o=bx(r,{managedInstanceId:t}),n.registerInstance(t,o)),yx(r,o,e,n)})),t.calls&&t.calls.filter(Cx).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=px.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:"addArray",a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:"vtkDataArray",l=hx[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log("Error fetching array",JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error("Error in array handling for state",JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function Ax(e,t,n){fx[t.id]||Sx(e,t,n),fx[t.id]=!0}function Ix(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function wx(e){const t=e.name?`_${e.name}`:"";return`${e.hash}_${e.dataType}${t}`}function Ox(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${lt(r)}`;const t=wx(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=wx(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),Ix(t.getPointData(),i.pointData),Ix(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=Sx(t,s,r);return r.end(),l}}const Px=Ox(["points","polys","verts","lines","strips"]),Rx=Ox([]);function Mx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Sx;bx||yx?dx[e]={build:t,update:n}:delete dx[e]}const Ex={vtkMapper:["vtkOpenGLPolyDataMapper","vtkCompositePolyDataMapper2","vtkDataSetMapper"],vtkProperty:["vtkOpenGLProperty"],vtkRenderer:["vtkOpenGLRenderer"],vtkCamera:["vtkOpenGLCamera"],vtkColorTransferFunction:["vtkPVDiscretizableColorTransferFunction"],vtkActor:["vtkOpenGLActor","vtkPVLODActor"],vtkLight:["vtkOpenGLLight","vtkPVLight"],vtkTexture:["vtkOpenGLTexture"],vtkImageMapper:["vtkOpenGLImageSliceMapper"],vtkVolumeMapper:["vtkFixedPointVolumeRayCastMapper"]},Vx={vtkAxesActor:{build:tx.newInstance,update:Sx},vtkRenderWindow:{build:km.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(Cx).filter((e=>"removeRenderer"===e[0])).forEach((e=>{vx(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),Sx(e,t,n),ux(e,t,n)}},vtkRenderer:{build:Lm.newInstance,update:function(e,t,n){Sx(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=Tx(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(Cx).filter((e=>"removeViewProp"===e[0])).forEach((e=>{vx(e[1]).forEach((e=>{const t=n.getInstance(e).get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:ul.newInstance,update:Sx},vtkCamera:{build:bm.newInstance,update:Ax},vtkPolyData:{build:Uc.newInstance,update:Px},vtkImageData:{build:Ks.newInstance,update:Rx},vtkMapper:{build:Fl.newInstance,update:Sx},vtkGlyph3DMapper:{build:tb.newInstance,update:Sx},vtkProperty:{build:ts.newInstance,update:Sx},vtkActor:{build:os.newInstance,update:Sx},vtkLight:{build:Sm.newInstance,update:Sx},vtkColorTransferFunction:{build:qy.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Hc.newInstance,update:Sx},vtkVolume:{build:mb.newInstance,update:Sx},vtkVolumeMapper:{build:bb.newInstance,update:Sx},vtkVolumeProperty:{build:pb.newInstance,update:Sx},vtkImageSlice:{build:Ob.newInstance,update:Sx},vtkImageMapper:{build:Nb.newInstance,update:Sx},vtkImageProperty:{build:Ab.newInstance,update:Sx},vtkPiecewiseFunction:{build:ab.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:su.newInstance,update:Sx},vtkScalarBarActor:{build:Nd.newInstance,update:Sx}};function Dx(){(!(arguments.length>0&&void 0!==arguments[0])||arguments[0])&&xx(),Object.keys(Vx).forEach((e=>{const t=Vx[e];Mx(e,t.build,t.update)}))}function Lx(){Object.keys(Ex).forEach((e=>{Ex[e].forEach((t=>{dx[t]=dx[e]}))}))}Dx(),Lx(),mx.vtkPVLight={};var Bx={build:bx,update:yx,genericUpdater:Sx,oneTimeGenericUpdater:Ax,setTypeMapping:Mx,clearTypeMapping:xx,getSupportedTypes:function(){return Object.keys(dx)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return void Object.keys(fx).forEach((e=>{delete fx[e]}));let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete fx[e]})),r},updateRenderWindow:function(e,t,n){return yx("vtkRenderWindow",e,t,n)},excludeInstance:function(e,t,n){mx[e]={key:t,value:n}},setDefaultMapping:Dx,applyDefaultAliases:Lx,alwaysUpdateCamera:function(){Mx("vtkCamera",bm.newInstance),Lx()}};const Nx={};function Fx(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if("string"==typeof t&&(i=vg.toArrayBuffer(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=it(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=it(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log("Error getting data array:"),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use "setArrayFetcher" to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function _x(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function Gx(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Mt(t,n,"progressEvent"),Mt(t,n,"progressDone"),t}function kx(){const e={};let t="default";return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function Ux(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"default",t=Nx[e];return t||(t={...Fx(),..._x(),...Gx(),...kx()},Nx[e]=t),t}function zx(e,t){let n=-1,r=100;const o=e=>e.get("managedInstanceId").managedInstanceId,a=()=>Lt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get("synchronizedViewId").synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),Bx.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){Bx.clearOneTimeUpdaters(a())}}}const Wx={synchronizerContextName:"default",synchronizerContext:null,synchronizedViewId:null};function Hx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wx,n),km.extend(e,t),yt(e,t,["synchronizerContext"]),function(e,t){t.classHierarchy.push("vtkSynchronizableRenderWindow"),t.synchronizerContext||(t.synchronizerContext=Ux(t.synchronizerContextName));const n=zx(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}(e,t)}var jx={newInstance:Et(Hx,"vtkSynchronizableRenderWindow"),extend:Hx,getSynchronizerContext:Ux,setSynchronizerContext:function(e,t){Nx[e]=t},clearSynchronizerContext:function(e){if(e&&Nx[e]&&delete Nx[e],!e){const e=Object.keys(Nx);for(let t=0;t<e.length;t++)delete Nx[e[t]]}},decorate:function(e){const t=zx(e,Ux(arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default"));return{...t,...e,delete:Vt(e.delete,t.delete)}},createInstanceMap:_x,createArrayHandler:Fx,createProgressHandler:Gx,createSceneMtimeHandler:kx,vtkObjectManager:Bx};const{vtkErrorMacro:Kx,vtkDebugMacro:$x}=Ht;let qx=0;function Xx(e){const t=document.querySelector(`.webResource[data-url="${e}"]`);return t?t.innerHTML:null}function Yx(e){return"/"===e[0]?e.substr(1):e}const Zx={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=Xx(Yx(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=Xx(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=Yx([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/")),s=Xx(i);if(null===s)a(new Error(`No such array ${i}`));else{if("string"===n.dataType){let e=atob(s);r.compression&&(e=om(tm(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(vg.toArrayBuffer(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=om(tm(new Uint8Array(n.buffer))):n.buffer=tm(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(um!==n.ref.encode&&um&&($x(`Swap bytes of ${n.name}`),dm(n.buffer,as[n.dataType])),n.values=Ht.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&Kx(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--qx&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url="${e}"]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};yg("html",(e=>Zx));const{vtkErrorMacro:Qx,vtkDebugMacro:Jx}=Ht;function eC(e){return function(e){return"/"===e[0]?e.substr(1):e}(function(e){return new URL(e,"http://any").pathname}(e))}const tC=function(e){let t=!1,n=0,r=null,o="";var a;return(a=e.zipContent,new Promise(((e,t)=>{"string"==typeof a?e(function(e,t){if(t){for(var n=new xg(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(nm)return nm.encode(e);var o=e.length,a=new xg(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new xg(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return Hg(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error("Invalid datatype to unpack."))}))).then((n=>{r=lm(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith("index.json")&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\.json$/,""),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||Qx("ERROR!!! zip not ready...");const u=eC([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join("/"));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if("string"!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&("string"===e.dataType||"JSON"===e.dataType?e.buffer=om(tm(new Uint8Array(e.buffer))):e.buffer=tm(new Uint8Array(e.buffer)).buffer),"JSON"===e.ref.encode?e.values=JSON.parse(e.buffer):(um!==e.ref.encode&&um&&(Jx(`Swap bytes of ${e.name}`),dm(e.buffer,as[e.dataType])),e.values=Ht.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&Qx(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(om(tm(r))):JSON.parse(r),n()}}(i,s.compression,d);e(om(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=eC(n);t||Qx("ERROR!!! zip not ready...");const s=r[`${o}${i}`];if(a.compression){if("gz"===a.compression){const e=om(tm(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error("Invalid compression"))}return Promise.resolve(JSON.parse(om(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=eC(n);t||Qx("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(om(lm(s))):Promise.reject(new Error("Invalid compression")):Promise.resolve(om(s))},fetchImage(e,n){const a=eC(n);t||Qx("ERROR!!! zip not ready...");const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=hg(i.buffer);n.src=`data:image/${function(e){const t=e.split(".").pop().toLowerCase();return"jpg"===t?"jpeg":t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=eC(n);t||Qx("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(tm(s).buffer):Promise.reject(new Error("Invalid compression")):Promise.resolve(s.buffer)}}};yg("zip",(e=>tC(e)));var nC=n(911),rC=n.n(nC),oC=n(893),aC=n.n(oC),iC=n(383),sC=n.n(iC),lC=n(884),cC=n.n(lC),uC=n(88),dC=n.n(uC),pC=n(997),fC=n.n(pC),gC=n(96),mC={};mC.styleTagTransform=fC(),mC.setAttributes=cC(),mC.insert=sC().bind(null,"head"),mC.domAPI=aC(),mC.insertStyleElement=dC(),rC()(gC.A,mC);var hC=gC.A&&gC.A.locals?gC.A.locals:void 0;let vC=!0;function TC(e){e.preventDefault(),e.stopPropagation()}function yC(e,t){vC=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=By.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:"100%",width:"100%",position:"absolute"}}).getRenderWindow(),o=jx.getSynchronizerContext(),a=jx.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement("div");n.setAttribute("class",hC.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=Ht.formatBytesToProperUnit(e.loaded)};t.fileURL?hm.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=bg.get("zip",{zipContent:t,callback:e=>{r.fetchJSON(null,"index.json").then(i)}})})):hm.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=bg.get("zip",{zipContent:t.file,callback:t=>{e.fetchJSON(null,"index.json").then(i)}})}else if(t.base64Str){const e=vg.toArrayBuffer(t.base64Str),n=bg.get("zip",{zipContent:e,callback:e=>{n.fetchJSON(null,"index.json").then(i)}})}}function bC(e){vC=!1;const t=document.querySelector(".content"),n=document.querySelector("body"),r=e||t||n;r!==e?(r.classList.add(hC.fullScreen),n.style.margin="0",n.style.padding="0"):(n.style.margin="0",n.style.padding="0");const o=document.createElement("div");o.innerHTML=`<div class="${hC.bigFileDrop}"/><input type="file" accept=".zip,.vtksz" style="display: none;"/>`,r.appendChild(o);const a=o.querySelector("input");function i(e){TC(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(".").slice(-1)[0];yC(r,{file:n[0],ext:e})}}a.addEventListener("change",i),o.addEventListener("drop",i),o.addEventListener("click",(e=>a.click())),o.addEventListener("dragover",TC)}const xC=xh();if(xC.url||xC.fileURL){const e=document.querySelector(".content"),t=document.querySelector("body"),n=e||t;n&&(n.classList.add(hC.fullScreen),t.style.margin="0",t.style.padding="0"),vC=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>yC(n,xC)))}setTimeout((()=>{vC&&bC()}),100),window.OfflineLocalView={initLocalFileLoader:bC,load:yC}},613:function(e){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,o,a){"string"==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=a),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),o&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=o):u[4]="".concat(o)),t.push(u))}},t}},336:function(e){"use strict";e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e):e}},20:function(e){"use strict";e.exports=function(e){return e[1]}},555:function(e,t,n){"use strict";var r=n(382),o="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,"x",{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||"function"==typeof(o=r)&&"[object Function]"===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},77:function(e,t,n){"use strict";e.exports=function(){if("object"==typeof globalThis)return globalThis;var e;try{e=this||new Function("return this")()}catch(e){if("object"==typeof window)return window;if("object"==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},730:function(e){"use strict";e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},979:function(e){"use strict";"undefined"!=typeof self?e.exports=self:"undefined"!=typeof window?e.exports=window:e.exports=Function("return this")()},59:function(e,t,n){"use strict";var r=n(555),o=n(979),a=n(920),i=n(482),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},920:function(e,t,n){"use strict";var r=n(979);e.exports=function(){return"object"==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},482:function(e,t,n){"use strict";var r=n(555),o=n(920);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,"globalThis");t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,"globalThis",{configurable:!0,enumerable:!1,value:e,writable:!0})}else"object"==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},982:function(e,t,n){"use strict";var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(642),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},"toString"),c=s.call((function(){}),"prototype"),u=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!p["$"+e]&&o.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&"object"==typeof e,n="[object Function]"===a.call(e),r=i(e),s=t&&"[object String]"===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError("Object.keys called on a non-object");var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&"prototype"===v||!o.call(e,v)||p.push(String(v));if(l)for(var T=function(e){if("undefined"==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),y=0;y<u.length;++y)T&&"constructor"===u[y]||!o.call(e,u[y])||p.push(u[y]);return p}}e.exports=r},382:function(e,t,n){"use strict";var r=Array.prototype.slice,o=n(642),a=Object.keys,i=a?function(e){return a(e)}:n(982),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},642:function(e){"use strict";var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r="[object Arguments]"===n;return r||(r="[object Array]"!==n&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Function]"===t.call(e.callee)),r}},318:function(e,t,n){var r=n(767),o=n(698),a=n(744),i=n(402),s=n(576),l=n(886),c=n(262);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},767:function(e,t,n){var r;!function(e,o){function a(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new a(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.alea=s}(0,e=n.nmd(e),n.amdD)},886:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.tychei=s}(0,e=n.nmd(e),n.amdD)},698:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xor128=s}(0,e=n.nmd(e),n.amdD)},576:function(e,t,n){var r;!function(e,o){function a(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xor4096=s}(0,e=n.nmd(e),n.amdD)},402:function(e,t,n){var r;!function(e,o){function a(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xorshift7=s}(0,e=n.nmd(e),n.amdD)},744:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xorwow=s}(0,e=n.nmd(e),n.amdD)},262:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,T(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),T(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,T(a)]}}():e,3),r),f=new g(r),y=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return y.int32=function(){return 0|f.g(4)},y.quick=function(){return f.g(4)/4294967296},y.double=y,v(T(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(y,p,"global"in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&"object"==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:"string"==o?e:e+"\0"}function v(e,t){for(var n,r=e+"",o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return T(t)}function T(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(1)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},292:function(e){e.exports=function(){"use strict";var e=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];function t(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function n(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function o(e){var r,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(r=64;r<=c;r+=64)t(u,n(e.substring(r-64,r)));for(o=(e=e.substring(r-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],r=0;r<o;r+=1)a[r>>2]|=e.charCodeAt(r)<<(r%4<<3);if(a[r>>2]|=128<<(r%4<<3),r>55)for(t(u,a),r=0;r<16;r+=1)a[r]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,t(u,a),u}function a(t){var n,r="";for(n=0;n<4;n+=1)r+=e[t>>8*n+4&15]+e[t>>8*n&15];return r}function i(e){var t;for(t=0;t<e.length;t+=1)e[t]=a(e[t]);return e.join("")}function s(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function l(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function c(){this.reset()}return i(o("hello")),"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),c.prototype.append=function(e){return this.appendBinary(s(e)),this},c.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var r,o=this._buff.length;for(r=64;r<=o;r+=64)t(this._hash,n(this._buff.substring(r-64,r)));return this._buff=this._buff.substring(r-64),this},c.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=i(this._hash),e&&(n=l(n)),this.reset(),n},c.prototype.reset=function(){return this._buff="",this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},c.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},c.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},c.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},c.prototype._finish=function(e,n){var r,o,a,i=n;if(e[i>>2]|=128<<(i%4<<3),i>55)for(t(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,t(this._hash,e)},c.hash=function(e,t){return c.hashBinary(s(e),t)},c.hashBinary=function(e,t){var n=i(o(e));return t?l(n):n},c.ArrayBuffer=function(){this.reset()},c.ArrayBuffer.prototype.append=function(e){var n,o,a,i,s,l=(o=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(o.byteLength+a.byteLength)).set(new Uint8Array(o)),s.set(new Uint8Array(a),o.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,n=64;n<=c;n+=64)t(this._hash,r(l.subarray(n-64,n)));return this._buff=n-64<c?new Uint8Array(l.buffer.slice(n-64)):new Uint8Array(0),this},c.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=i(this._hash),e&&(n=l(n)),this.reset(),n},c.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},c.ArrayBuffer.prototype.getState=function(){var e,t=c.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},c.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),c.prototype.setState.call(this,e)},c.ArrayBuffer.prototype.destroy=c.prototype.destroy,c.ArrayBuffer.prototype._finish=c.prototype._finish,c.ArrayBuffer.hash=function(e,n){var o=i(function(e){var n,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(n=64;n<=c;n+=64)t(u,r(e.subarray(n-64,n)));for(o=(e=n-64<c?e.subarray(n-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],n=0;n<o;n+=1)a[n>>2]|=e[n]<<(n%4<<3);if(a[n>>2]|=128<<(n%4<<3),n>55)for(t(u,a),n=0;n<16;n+=1)a[n]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,t(u,a),u}(new Uint8Array(e)));return n?l(o):o},c}()},96:function(e,t,n){"use strict";var r=n(20),o=n.n(r),a=n(613),i=n.n(a),s=n(336),l=n.n(s),c=new URL(n(183),n.b),u=i()(o()),d=l()(c);u.push([e.id,".viewer-module-fullScreen_bbk9Y {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  background: black;\n  margin: 0;\n  padding: 0;\n  z-index: -1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.viewer-module-fullParentSize_ETopO {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.viewer-module-bigFileDrop_aqCgh {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  background-image: url("+d+");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n  border-radius: 10px;\n  width: 50px;\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\n  cursor: pointer;\n}\n\n.viewer-module-progress_cYjQJ {\n  flex: none;\n  font-size: 50px;\n  color: black;\n  z-index: 1;\n  background: rgba(128,128,128,.5);\n  padding: 20px;\n  border-radius: 10px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n\nbody {\n  margin: 0;\n}\n\nhtml { \n  overflow: hidden; \n}\n",""]),u.locals={fullScreen:"viewer-module-fullScreen_bbk9Y",fullParentSize:"viewer-module-fullParentSize_ETopO",bigFileDrop:"viewer-module-bigFileDrop_aqCgh",progress:"viewer-module-progress_cYjQJ"},t.A=u},50:function(e,t,n){var r=n(975),o=n(77);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},911:function(e){"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d="".concat(c," ").concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},383:function(e){"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},88:function(e){"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},884:function(e,t,n){"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},893:function(e){"use strict";e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var o=void 0!==n.layer;o&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,o&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var a=n.sourceMap;a&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},997:function(e){"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},183:function(e,t,n){"use strict";e.exports=n.p+"138e7b1469f64156810a.jpg"},1:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p="",n.b=document.baseURI||self.location.href,n.nc=void 0,n(50)}();
</script>
<script>
var container = document.querySelector('.content');
var base64Str = "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";

OfflineLocalView.load(container, { base64Str });
</script>
</body>
</html>
