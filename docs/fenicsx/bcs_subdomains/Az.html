<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  </head>
  <body>
    <div class="content"></div>
<script type="text/javascript">
!function(){var e={346:function(){const e=document.querySelector("head");e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement("link");n.setAttribute("rel","icon"),n.setAttribute("href",`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute("sizes",`${t}x${t}`),n.setAttribute("type","image/png"),e.appendChild(n)}))},975:function(e,t,n){"use strict";n.r(t),n.d(t,{initLocalFileLoader:function(){return bC},load:function(){return yC}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return T},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return G},fromQuat2:function(){return D},fromRotation:function(){return P},fromRotationTranslation:function(){return V},fromRotationTranslationScale:function(){return F},fromRotationTranslationScaleOrigin:function(){return _},fromScaling:function(){return O},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return E},frustum:function(){return k},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return y},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return Ve},multiplyScalarAndAdd:function(){return De},normalFromMat4:function(){return we},projection:function(){return Oe},rotate:function(){return ye},scale:function(){return be},set:function(){return de},str:function(){return Pe},sub:function(){return Fe},subtract:function(){return Ee},translate:function(){return Te},transpose:function(){return fe}}),n(346);var a=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],T=n*s-r*i,y=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,O=d*h-p*m,P=d*v-f*m,R=p*v-f*h,M=T*R-y*P+b*O+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*P+c*O)*M,e[1]=(o*P-r*R-a*O)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*y)*M,e[7]=(u*S-p*b+f*y)*M,e[8]=(i*P-s*w+c*A)*M,e[9]=(r*w-n*P-a*A)*M,e[10]=(g*C-m*b+v*T)*M,e[11]=(d*b-u*C-f*T)*M,e[12]=(s*I-i*O-l*A)*M,e[13]=(n*O-r*I+o*A)*M,e[14]=(m*y-g*x-h*T)*M,e[15]=(u*x-d*y+p*T)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function T(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function y(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],T=t[15],y=n[0],b=n[1],x=n[2],C=n[3];return e[0]=y*r+b*s+x*d+C*m,e[1]=y*o+b*l+x*p+C*h,e[2]=y*a+b*c+x*f+C*v,e[3]=y*i+b*u+x*g+C*T,y=n[4],b=n[5],x=n[6],C=n[7],e[4]=y*r+b*s+x*d+C*m,e[5]=y*o+b*l+x*p+C*h,e[6]=y*a+b*c+x*f+C*v,e[7]=y*i+b*u+x*g+C*T,y=n[8],b=n[9],x=n[10],C=n[11],e[8]=y*r+b*s+x*d+C*m,e[9]=y*o+b*l+x*p+C*h,e[10]=y*a+b*c+x*f+C*v,e[11]=y*i+b*u+x*g+C*T,y=n[12],b=n[13],x=n[14],C=n[15],e[12]=y*r+b*s+x*d+C*m,e[13]=y*o+b*l+x*p+C*h,e[14]=y*a+b*c+x*f+C*v,e[15]=y*i+b*u+x*g+C*T,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,T,y,b,x,C,S,A,I,w,O,P,R=r[0],M=r[1],E=r[2],V=Math.hypot(R,M,E);return V<a?null:(R*=V=1/V,M*=V,E*=V,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],T=t[10],y=t[11],b=R*R*s+i,x=M*R*s+E*o,C=E*R*s-M*o,S=R*M*s-E*o,A=M*M*s+i,I=E*M*s+R*o,w=R*E*s+M*o,O=M*E*s-R*o,P=E*E*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+T*C,e[3]=d*b+m*x+y*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+T*I,e[7]=d*S+m*A+y*I,e[8]=l*w+p*O+h*P,e[9]=c*w+f*O+v*P,e[10]=u*w+g*O+T*P,e[11]=d*w+m*O+y*P,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function O(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function P(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function V(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,T=i*c;return e[0]=1-(f+m),e[1]=d+T,e[2]=p-v,e[3]=0,e[4]=d-T,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function D(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),V(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function F(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,T=s*c,y=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+y)*b,e[2]=(f-T)*b,e[3]=0,e[4]=(p-y)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+T)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function _(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,T=l*c,y=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],O=(1-(m+v))*x,P=(f+b)*x,R=(g-y)*x,M=(f-b)*C,E=(1-(p+v))*C,V=(h+T)*C,D=(g+y)*S,L=(h-T)*S,B=(1-(p+m))*S;return e[0]=O,e[1]=P,e[2]=R,e[3]=0,e[4]=M,e[5]=E,e[6]=V,e[7]=0,e[8]=D,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(O*A+M*I+D*w),e[13]=n[1]+I-(P*A+E*I+L*w),e[14]=n[2]+w-(R*A+V*I+B*w),e[15]=1,e}function G(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function k(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],T=t[2],y=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(T-A)<a?g(e):(d=h-C,p=v-S,f=T-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-y*f,s=y*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*T),e[13]=-(l*h+c*v+u*T),e[14]=-(d*h+p*v+f*T),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],T=e[15],y=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],O=t[8],P=t[9],R=t[10],M=t[11],E=t[12],V=t[13],D=t[14],L=t[15];return Math.abs(n-y)<=a*Math.max(1,Math.abs(n),Math.abs(y))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-O)<=a*Math.max(1,Math.abs(d),Math.abs(O))&&Math.abs(p-P)<=a*Math.max(1,Math.abs(p),Math.abs(P))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-E)<=a*Math.max(1,Math.abs(m),Math.abs(E))&&Math.abs(h-V)<=a*Math.max(1,Math.abs(h),Math.abs(V))&&Math.abs(v-D)<=a*Math.max(1,Math.abs(v),Math.abs(D))&&Math.abs(T-L)<=a*Math.max(1,Math.abs(T),Math.abs(L))}var oe=y,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],T=n[6],y=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=T*r+y*i+b*c,e[7]=T*o+y*s+b*u,e[8]=T*a+y*l+b*d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],T=n*s-r*i,y=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,O=d*h-p*m,P=d*v-f*m,R=p*v-f*h,M=T*R-y*P+b*O+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*P+c*O)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*P-s*w+c*A)*M,e[3]=(o*P-r*R-a*O)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*P-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*y)*M,e[8]=(g*C-m*b+v*T)*M,e):null}function Oe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Pe(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function Ee(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function Ve(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function De(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],T=t[6],y=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-T)<=a*Math.max(1,Math.abs(c),Math.abs(T))&&Math.abs(u-y)<=a*Math.max(1,Math.abs(u),Math.abs(y))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,Fe=Ee,_e=n(730),Ge=n.n(_e),ke=n(59);const Ue=n.n(ke)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error("Invalid VTK object"),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&"object"==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=e=>{throw new Error(`Named parameter '${e}' is missing`)},$e=Symbol("void"),qe={};function Xe(){}["log","debug","info","warn","error","time","timeEnd","group","groupEnd"].forEach((e=>{qe[e]=Xe})),Ue.console=console.hasOwnProperty("log")?console:qe;const Ye={debug:Xe,error:Ue.console.error||Xe,info:Ue.console.info||Xe,log:Ue.console.log||Xe,warn:Ue.console.warn||Xe};function Ze(e,t){Ye[e]&&(Ye[e]=t||Xe)}function Qe(){Ye.log(...arguments)}function Je(){Ye.info(...arguments)}function et(){Ye.debug(...arguments)}function tt(){Ye.error(...arguments)}function nt(){Ye.warn(...arguments)}const rt={};function ot(e){rt[e]||(Ye.error(e),rt[e]=!0)}const at=Object.create(null);at.Float32Array=Float32Array,at.Float64Array=Float64Array,at.Uint8Array=Uint8Array,at.Int8Array=Int8Array,at.Uint16Array=Uint16Array,at.Int16Array=Int16Array,at.Uint32Array=Uint32Array,at.Int32Array=Int32Array,at.Uint8ClampedArray=Uint8ClampedArray;try{at.BigInt64Array=BigInt64Array,at.BigUint64Array=BigUint64Array}catch{}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(at[e]||Float64Array)(...n)}function st(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(at[e]||Float64Array).from(...n)}function lt(e){return e.charAt(0).toUpperCase()+e.slice(1)}function ct(e){return lt("_"===e[0]?e.slice(1):e)}function ut(e){return e.charAt(0).toLowerCase()+e.slice(1)}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=["TB","GB","MB","KB"];let o=Number(e),a="B";for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function pt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:" ";const n=[];let r=e;for(;r>1e3;)n.push(("000"+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function ft(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function gt(e){return e&&e.isA?e.getState():e}function mt(e){setTimeout(e,0)}function ht(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function vt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};ft(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),"classHierarchy"in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He("vtkObject");function r(e){n[e]=null}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?tt("instance deleted - cannot call any method"):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return tt("instance deleted - cannot call any method"),null;const o=n.length;return n.push(e),function(e){return Object.freeze({unsubscribe:function(){r(e)}})}(o)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${lt(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==["mtime"].indexOf(i)||r||nt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||"_"===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(gt):function(e){return Object.values(at).some((t=>e instanceof t))}(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort();Object.keys(o).sort().forEach((e=>{const n=a.indexOf(e);-1===n?r&&et(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&et(`Untouched keys: ${a.join(", ")}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object(e,t,n){return function(){return{...t[n.name]}}}};function yt(e,t,n){n.forEach((n=>{if("object"==typeof n){const r=Tt[n.type];e[`get${ct(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${ct(n)}`]=()=>t[n]}))}const bt={enum(e,t,n){const r=`_on${ct(n.name)}Changed`;return o=>{if("string"==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw tt(`Set Enum with invalid argument ${n}, ${o}`),new RangeError("Set Enum with invalid string argument")}if("number"==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw tt(`Set Enum outside numeric range ${n}, ${o}`),new RangeError("Set Enum outside numeric range")}return!1}throw tt(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError("Set Enum with invalid argument (String/Number)")}},object(e,t,n){1===n.params?.length&&nt('Setter of type "object" with a single "param" field is not supported');const r=`_on${ct(n.name)}Changed`;return function(){for(var o=arguments.length,a=new Array(o),i=0;i<o;i++)a[i]=arguments[i];let s;if(s=a.length>1&&n.params?.length?n.params.reduce(((e,t,n)=>Object.assign(e,{[t]:a[n]})),{}):a[0],!Ge()(t[n.name],s)){const o=t[n.name];return t[n.name]=s,t[r]?.(e,t,s,o),e.modified(),!0}return!1}}};function xt(e){if("object"==typeof e){const t=bt[e.type];if(t)return(n,r)=>t(n,r,e);throw tt(`No setter for field ${e}`),new TypeError("No setter for field")}return function(t,n){const r=`_on${ct(e)}Changed`;return function(o){if(n.deleted)return tt("instance deleted - cannot call any method"),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function Ct(e,t,n){n.forEach((n=>{"object"==typeof n?e[`set${ct(n.name)}`]=xt(n)(e,t):e[`set${ct(n)}`]=xt(n)(e,t)}))}function St(e,t,n){yt(e,t,n),Ct(e,t,n)}function At(e,t,n){n.forEach((n=>{e[`get${ct(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${ct(n)}ByReference`]=()=>t[n]}))}function It(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${ct(n)}Changed`;e[`set${ct(n)}`]=function(){if(t.deleted)return tt("instance deleted - cannot call any method"),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${ct(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;At(e,t,n),It(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Pt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?tt("instance deleted - cannot call any method"):r>=t.numberOfInputs?tt(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)tt("instance deleted - cannot call any method");else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=" input ports. To add more input ports, use addInputConnection()",void tt(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(tt("instance deleted - cannot call any method"),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?tt("instance deleted - cannot call any method"):o(e,i())},e.addInputConnection=function(e){t.deleted?tt("instance deleted - cannot call any method"):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.requestData&&e.shouldUpdate()&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"Scalars";for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Rt=Symbol("Event abort");function Mt(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}e[`invoke${ct(n)}`]=function(){if(t.deleted)return void tt("instance deleted - cannot call any method");const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Rt)break}},e[`on${ct(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return tt("instance deleted - cannot call any method"),null;const s=a++;return r.push([s,e,o]),r.sort(((e,t)=>t[2]-e[2])),function(e){return Object.freeze({unsubscribe:function(){i(e)}})}(s)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Et(e,t){const n=function(){const t={};return e(t,{},arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}),Object.freeze(t)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Dt(e){return e&&e.isA&&e.isA("vtkObject")}function Lt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Dt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Lt(e,t,n,r)})):Lt(o,t,n,r)}))}return n}function Bt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=n&&!o;clearTimeout(o),o=setTimeout((()=>{o=null,n||e.apply(l,i)}),t),c&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function Nt(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let _t=1;const Gt="__root__";function kt(e,t){Ft(e,t);const n=e.delete;t.proxyId=""+_t++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),yt(e,t,["proxyId","proxyGroup","proxyName"]),St(e,t,["proxyManager"]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],a=t.proxyId,s=function(){return o[arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt]}(n)||[];for(let t=0;t<s.length;t++){const n=s[t],o=e[`get${ct(n)}`],l={id:a,name:n,value:o?o():void 0},c=i(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${ct(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${ct(c.propertyName)}`]();if(!function(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}const c={bind:function(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}},unbind:l,unsubscribe:function(){for(;o.length;)o.pop().subscription.unsubscribe()},persistent:n};return t.propertyLinkMap[e]=c,c},e.listPropertyNames=()=>i().map((e=>e.name)),e.getPropertyByName=e=>i().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:i()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,mt((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if("application"===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,"application"),n.bind(e,o,i)}}}))}function Ut(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=ct(l),d=ct(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function zt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${ct(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&yt(e,t,a)}function Wt(e){let t=0,n=0,r=0,o=0;return"detail"in e&&(n=e.detail),"wheelDelta"in e&&(n=-e.wheelDelta/120),"wheelDeltaY"in e&&(n=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(t=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,"deltaY"in e&&(o=e.deltaY),"deltaX"in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var Ht={algo:Pt,capitalize:lt,chain:Vt,debounce:Bt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Mt,EVENT_ABORT:Rt,formatBytesToProperUnit:dt,formatNumbersWithThousandSeparator:pt,get:yt,getArray:At,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:gt,isVtkObject:Dt,keystore:Ft,measurePromiseExecution:ht,moveToProtected:Ot,newInstance:Et,newTypedArray:it,newTypedArrayFrom:st,normalizeWheel:Wt,obj:vt,proxy:kt,proxyPropertyMapping:Ut,proxyPropertyState:zt,safeArrays:ft,set:Ct,setArray:It,setGet:St,setGetArray:wt,setImmediate:mt,setLoggerFunction:Ze,throttle:Nt,traverseInstanceTree:Lt,TYPED_ARRAYS:at,uncapitalize:ut,VOID:$e,vtkDebugMacro:et,vtkErrorMacro:tt,vtkInfoMacro:Je,vtkLogMacro:Qe,vtkOnceErrorMacro:ot,vtkWarningMacro:nt,objectSetterMap:bt,requiredParam:Ke},jt=Object.freeze({__proto__:null,requiredParam:Ke,VOID:$e,setLoggerFunction:Ze,vtkLogMacro:Qe,vtkInfoMacro:Je,vtkDebugMacro:et,vtkErrorMacro:tt,vtkWarningMacro:nt,vtkOnceErrorMacro:ot,TYPED_ARRAYS:at,newTypedArray:it,newTypedArrayFrom:st,capitalize:lt,_capitalize:ct,uncapitalize:ut,formatBytesToProperUnit:dt,formatNumbersWithThousandSeparator:pt,setImmediateVTK:mt,measurePromiseExecution:ht,obj:vt,get:yt,set:Ct,setGet:St,getArray:At,setArray:It,setGetArray:wt,moveToProtected:Ot,algo:Pt,EVENT_ABORT:Rt,event:Mt,newInstance:Et,chain:Vt,isVtkObject:Dt,traverseInstanceTree:Lt,debounce:Bt,throttle:Nt,keystore:Ft,proxy:kt,proxyPropertyMapping:Ut,proxyPropertyState:zt,normalizeWheel:Wt,default:Ht});const{vtkErrorMacro:Kt}=Ht,$t={renderable:null,myFactory:null,children:[],visited:!1};function qt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$t,n),Ht.obj(e,t),Ht.event(e,t,"event"),t._renderableChildMap=new Map,Ht.get(e,t,["visited"]),Ht.setGet(e,t,["_parent","renderable","myFactory"]),Ht.getArray(e,t,["children"]),Ht.moveToProtected(e,t,["parent"]),function(e,t){t.classHierarchy.push("vtkViewNode"),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.getLastAncestorOfType=e=>t._parent?t._parent.getLastAncestorOfType(e)||(t._parent.isA(e)?t._parent:null):null,e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)return r.setVisited(!0),r;const o=e.createViewNode(n);return o?(o.setParent(e),o.setVisited(!0),t._renderableChildMap.set(n,o),t.children.push(o),o):void 0},e.addMissingNodes=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n&&n.length)for(let o=0;o<n.length;++o){const a=n[o],i=e.addMissingNode(a);if(r&&void 0!==i&&t.children[o]!==i)for(let e=o+1;e<t.children.length;++e)if(t.children[e]===i){t.children.splice(e,1),t.children.splice(o,0,i);break}}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];if(-1===t.children.indexOf(o)){o.setParent(e),t.children.push(o);const n=o.getRenderable();n&&t._renderableChildMap.set(n,o)}o.setVisited(!0)}},e.removeNode=e=>{const n=t.children.findIndex((t=>t===e));if(n<0)return!1;const r=e.getRenderable();return r&&t._renderableChildMap.delete(r),e.delete(),t.children.splice(n,1),!0},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return Kt("Cannot create view nodes without my own factory"),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}(e,t)}var Xt={newInstance:Ht.newInstance(qt,"vtkViewNode"),extend:qt,PASS_TYPES:["Build","Render"]};const Yt={};function Zt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yt,n),Ht.obj(e,t),function(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push("vtkViewNodeFactory"),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s}}(e,t)}var Qt={newInstance:Ht.newInstance(Zt,"vtkViewNodeFactory"),extend:Zt};const Jt=Object.create(null);function en(e,t){Jt[e]=t}const tn={};function nn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tn,n),t.overrides=Jt,Qt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLViewNodeFactory")}(0,t)}var rn={newInstance:Ht.newInstance(nn,"vtkOpenGLViewNodeFactory"),extend:nn};const on={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const an=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,on,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},St(e,t,["context","keyMatrixTime"]),function(e,t){t.classHierarchy.push("vtkOpenGLCamera"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),y(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}(e,t)}));en("vtkCamera",an);const{vtkDebugMacro:sn}=jt,ln={context:null,_openGLRenderWindow:null,selector:null};const cn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ln,n),Xt.extend(e,t,n),yt(e,t,["shaderCache"]),St(e,t,["selector"]),Ot(0,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkOpenGLRenderer"),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps(),!0),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(sn("No lights are on, creating one."),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();r.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,r.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}(e,t)}),"vtkOpenGLRenderer");en("vtkRenderer",cn);const un={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const dn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},St(e,t,["context"]),yt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLActor"),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(t._openGLRenderer.getSelector()&&t.renderable.getNestedPickable()),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}(e,t)}));en("vtkActor",dn);const pn={context:null,activeTextures:null};const fn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pn,n),Xt.extend(e,t,n),St(e,t,["context"]),yt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLActor2D"),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}(e,t)}));function gn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function mn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function hn(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function vn(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function Tn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function yn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function bn(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}function xn(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Cn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Sn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function An(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function In(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function wn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function On(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Pn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Rn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}en("vtkActor2D",fn);var Mn=yn,En=bn,Vn=(gn(),Math.sqrt(50)),Dn=Math.sqrt(10),Ln=Math.sqrt(2);function Bn(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Vn?10:a>=Dn?5:a>=Ln?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Vn?10:a>=Dn?5:a>=Ln?2:1)}function Nn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Fn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=Nn,r=(t,n)=>Nn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const _n=Fn(Nn),Gn=_n.right;_n.left,Fn((function(e){return null===e?NaN:+e})).center;var kn=Gn;function Un(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function zn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Wn(){}var Hn=.7,jn=1/Hn,Kn="\\s*([+-]?\\d+)\\s*",$n="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",qn="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",Xn=/^#([0-9a-f]{3,8})$/,Yn=new RegExp(`^rgb\\(${Kn},${Kn},${Kn}\\)$`),Zn=new RegExp(`^rgb\\(${qn},${qn},${qn}\\)$`),Qn=new RegExp(`^rgba\\(${Kn},${Kn},${Kn},${$n}\\)$`),Jn=new RegExp(`^rgba\\(${qn},${qn},${qn},${$n}\\)$`),er=new RegExp(`^hsl\\(${$n},${qn},${qn}\\)$`),tr=new RegExp(`^hsla\\(${$n},${qn},${qn},${$n}\\)$`),nr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function rr(){return this.rgb().formatHex()}function or(){return this.rgb().formatRgb()}function ar(e){var t,n;return e=(e+"").trim().toLowerCase(),(t=Xn.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?ir(t):3===n?new cr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?sr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?sr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=Yn.exec(e))?new cr(t[1],t[2],t[3],1):(t=Zn.exec(e))?new cr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=Qn.exec(e))?sr(t[1],t[2],t[3],t[4]):(t=Jn.exec(e))?sr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=er.exec(e))?mr(t[1],t[2]/100,t[3]/100,1):(t=tr.exec(e))?mr(t[1],t[2]/100,t[3]/100,t[4]):nr.hasOwnProperty(e)?ir(nr[e]):"transparent"===e?new cr(NaN,NaN,NaN,0):null}function ir(e){return new cr(e>>16&255,e>>8&255,255&e,1)}function sr(e,t,n,r){return r<=0&&(e=t=n=NaN),new cr(e,t,n,r)}function lr(e,t,n,r){return 1===arguments.length?((o=e)instanceof Wn||(o=ar(o)),o?new cr((o=o.rgb()).r,o.g,o.b,o.opacity):new cr):new cr(e,t,n,null==r?1:r);var o}function cr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function ur(){return`#${gr(this.r)}${gr(this.g)}${gr(this.b)}`}function dr(){const e=pr(this.opacity);return`${1===e?"rgb(":"rgba("}${fr(this.r)}, ${fr(this.g)}, ${fr(this.b)}${1===e?")":`, ${e})`}`}function pr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function fr(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function gr(e){return((e=fr(e))<16?"0":"")+e.toString(16)}function mr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new vr(e,t,n,r)}function hr(e){if(e instanceof vr)return new vr(e.h,e.s,e.l,e.opacity);if(e instanceof Wn||(e=ar(e)),!e)return new vr;if(e instanceof vr)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new vr(i,s,l,e.opacity)}function vr(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Tr(e){return(e=(e||0)%360)<0?e+360:e}function yr(e){return Math.max(0,Math.min(1,e||0))}function br(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function xr(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}Un(Wn,ar,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:rr,formatHex:rr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return hr(this).formatHsl()},formatRgb:or,toString:or}),Un(cr,lr,zn(Wn,{brighter(e){return e=null==e?jn:Math.pow(jn,e),new cr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Hn:Math.pow(Hn,e),new cr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new cr(fr(this.r),fr(this.g),fr(this.b),pr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:ur,formatHex:ur,formatHex8:function(){return`#${gr(this.r)}${gr(this.g)}${gr(this.b)}${gr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:dr,toString:dr})),Un(vr,(function(e,t,n,r){return 1===arguments.length?hr(e):new vr(e,t,n,null==r?1:r)}),zn(Wn,{brighter(e){return e=null==e?jn:Math.pow(jn,e),new vr(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Hn:Math.pow(Hn,e),new vr(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new cr(br(e>=240?e-240:e+120,o,r),br(e,o,r),br(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new vr(Tr(this.h),yr(this.s),yr(this.l),pr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=pr(this.opacity);return`${1===e?"hsl(":"hsla("}${Tr(this.h)}, ${100*yr(this.s)}%, ${100*yr(this.l)}%${1===e?")":`, ${e})`}`}}));var Cr=e=>()=>e;function Sr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Cr(isNaN(e)?t:e)}var Ar=function e(t){var n=function(e){return 1==(e=+e)?Sr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Cr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=lr(e)).r,(t=lr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Sr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+""}}return r.gamma=e,r}(1);function Ir(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=lr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+""}}}function wr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Lr(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Or(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Pr(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Rr(e,t){var n,r={},o={};for(n in null!==e&&"object"==typeof e||(e={}),null!==t&&"object"==typeof t||(t={}),t)n in e?r[n]=Lr(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Ir((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return xr((n-r/t)*t,i,o,a,s)}})),Ir((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return xr((n-r/t)*t,o,a,i,s)}}));var Mr=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Er=new RegExp(Mr.source,"g");function Vr(e,t){var n,r,o,a=Mr.lastIndex=Er.lastIndex=0,i=-1,s=[],l=[];for(e+="",t+="";(n=Mr.exec(e))&&(r=Er.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Pr(n,r)})),a=Er.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+""}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join("")})}function Dr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Lr(e,t){var n,r=typeof t;return null==t||"boolean"===r?Cr(t):("number"===r?Pr:"string"===r?(n=ar(t))?(t=n,Ar):Vr:t instanceof ar?Ar:t instanceof Date?Or:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Dr:Array.isArray(t)?wr:"function"!=typeof t.valueOf&&"function"!=typeof t.toString||isNaN(t)?Rr:Pr)(e,t)}function Br(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Nr(e){return+e}var Fr=[0,1];function _r(e){return e}function Gr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function kr(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Gr(o,r),a=n(i,a)):(r=Gr(r,o),a=n(a,i)),function(e){return a(r(e))}}function Ur(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Gr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=kn(e,t,1,r)-1;return a[n](o[n](t))}}function zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Wr,Hr=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function jr(e){if(!(t=Hr.exec(e)))throw new Error("invalid format: "+e);var t;return new Kr({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function Kr(e){this.fill=void 0===e.fill?" ":e.fill+"",this.align=void 0===e.align?">":e.align+"",this.sign=void 0===e.sign?"-":e.sign+"",this.symbol=void 0===e.symbol?"":e.symbol+"",this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?"":e.type+""}function $r(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf("e"))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function qr(e){return(e=$r(Math.abs(e)))?e[1]:NaN}function Xr(e,t){var n=$r(e,t);if(!n)return e+"";var r=n[0],o=n[1];return o<0?"0."+new Array(-o).join("0")+r:r.length>o+1?r.slice(0,o+1)+"."+r.slice(o+1):r+new Array(o-r.length+2).join("0")}jr.prototype=Kr.prototype,Kr.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var Yr={"%":(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+"",d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>Xr(100*e,t),r:Xr,s:function(e,t){var n=$r(e,t);if(!n)return e+"";var r=n[0],o=n[1],a=o-(Wr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join("0"):a>0?r.slice(0,a)+"."+r.slice(a):"0."+new Array(1-a).join("0")+$r(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function Zr(e){return e}var Qr,Jr,eo,to=Array.prototype.map,no=["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];function ro(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Bn(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Vn?o*=10:a>=Dn?o*=5:a>=Ln&&(o*=2),t<e?-o:o}(e,t,n);switch((r=jr(null==r?",f":r)).type){case"s":var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(qr(t)/3)))-qr(Math.abs(e)))}(a,i))||(r.precision=o),eo(r,i);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,qr(t)-qr(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(o=function(e){return Math.max(0,-qr(Math.abs(e)))}(a))||(r.precision=o-2*("%"===r.type))}return Jr(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Bn(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function oo(){var e=function(){var e,t,n,r,o,a,i=Fr,s=Fr,l=Lr,c=_r;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==_r&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?Ur:kr,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Pr)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Nr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=Br,u()},d.clamp=function(e){return arguments.length?(c=!!e||_r,u()):c!==_r},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(_r,_r);return e.copy=function(){return t=e,oo().domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());var t},zr.apply(e,arguments),ro(e)}Qr=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?Zr:(t=to.call(e.grouping,Number),n=e.thousands+"",function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?"":e.currency[0]+"",a=void 0===e.currency?"":e.currency[1]+"",i=void 0===e.decimal?".":e.decimal+"",s=void 0===e.numerals?Zr:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(to.call(e.numerals,String)),l=void 0===e.percent?"%":e.percent+"",c=void 0===e.minus?"":e.minus+"",u=void 0===e.nan?"NaN":e.nan+"";function d(e){var t=(e=jr(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,T=e.type;"n"===T?(m=!0,T="g"):Yr[T]||(void 0===h&&(h=12),v=!0,T="g"),(f||"0"===t&&"="===n)&&(f=!0,t="0",n="=");var y="$"===p?o:"#"===p&&/[boxX]/.test(T)?"0"+T.toLowerCase():"",b="$"===p?a:/[%p]/.test(T)?l:"",x=Yr[T],C=/[defgprs%]/.test(T);function S(e){var o,a,l,p=y,S=b;if("c"===T)S=x(e)+S,e="";else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case".":o=t=r;break;case"0":0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&"+"!==d&&(A=!1),p=(A?"("===d?d:c:"-"===d||"("===d?"":d)+p,S=("s"===T?no[8+Wr/3]:"")+S+(A&&"("===d?")":""),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):"";switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=""),n){case"<":e=p+e+S+w;break;case"=":e=p+w+e+S;break;case"^":e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(T)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+""},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=jr(e)).type="f",e)),r=3*Math.max(-8,Math.min(8,Math.floor(qr(t)/3))),o=Math.pow(10,-r),a=no[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:",",grouping:[3],currency:["$",""]}),Jr=Qr.format,eo=Qr.formatPrefix;var ao=n(318),io=n.n(ao);const so=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],lo=[1,0,0,0,1,0,0,0,1],co=1e-6,uo=1e-12,{vtkErrorMacro:po,vtkWarningMacro:fo}=Ht;let go=0;function mo(e){return()=>po(`vtkMath::${e} - NOT IMPLEMENTED`)}function ho(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function vo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function To(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function yo(e){return e/180*Math.PI}function bo(e){return 180*e/Math.PI}const{round:xo,floor:Co,ceil:So,min:Ao,max:Io}=Math;const wo=mo("ceilLog2"),Oo=mo("factorial");function Po(e){let t=1;for(;t<e;)t*=2;return t}function Ro(e){return e===Po(e)}const Mo=mo("gaussian");function Eo(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Vo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function Do(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Lo(e,t){return e[0]*=t,e[1]*=t,e}function Bo(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function No(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Fo(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function _o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function Go(e){const t=_o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function ko(e,t){return e[0]*t[0]+e[1]*t[1]}function Uo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Wo(e){const t=zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Ho(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function jo(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function Ko(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function $o(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function qo(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function Xo(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:co;return e.length===t.length&&e.every((function(e,r){return Math.abs(e-t[r])<=n}))}const Yo=Xo;function Zo(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function Qo(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function Jo(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ea(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes("e"))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split("e");let r="";return+n[1]+t>0&&(r="+"),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ta(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ea(e[0],n),t[1]=ea(e[1],n),t[2]=ea(e[2],n),t}function na(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,T,y;const b=To(t),x=To(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(Qo(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),T=1/Math.sqrt(1+p*p),m=p*T,f=m/(1+T),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return fo("vtkMath::Jacobi: Error extracting eigenfunctions"),0;for(a=0;a<t-1;a++){for(i=a,y=n[i],o=a+1;o<t;o++)(n[o]>=y||Math.abs(n[o]-y)<uo)&&(i=o,y=n[i]);i!==a&&(n[i]=n[a],n[a]=y,vo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function ra(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];na([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function oa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=To(3),r=To(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(vo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,vo(t,3,1,2)),r[2]=2;let u=0;if(qo(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=To(4);if(ra(t,d),Jo(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&vo(t,3,r[1],1),0!==r[0]&&vo(t,3,r[0],0)}function aa(e,t,n){let r,o,a,i,s,l;if(na([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for($o(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,ho(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Fo([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);Go(e);const c=Fo(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void $o(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,ho(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,ho(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);qo(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),$o(n,n)}else Zo(n)}function ia(e,t,n){let r,o,a,i,s,l,c,u=0;const d=To(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return fo("Unable to factor linear system"),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=uo)return fo("Unable to factor linear system"),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function sa(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function la(e,t,n){if(2===n){const n=To(2),r=Ho(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=To(n);return 0===ia(e,r,n)?0:(sa(e,r,t,n),1)}function ca(e,t,n){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const o=(arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)||To(n),a=r||To(n);if(0===ia(e,o,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)a[e]=0;a[r]=1,sa(e,o,a,n);for(let e=0;e<n;e++)t[e*n+r]=a[e]}return t}function ua(e,t,n,r){if(e<n)return fo("Insufficient number of samples. Underdetermined."),0;let o,a,i;const s=To(n*n),l=To(n),c=To(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(na(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function da(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?1/3+s*(i-o)/(l-c):2/3+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function pa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function fa(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function ga(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function ma(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function ha(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function va(e,t){const n=[0,0,0];ha(e,n),ga(n,t)}function Ta(e,t){const n=[0,0,0];fa(e,n),ma(n,t)}function ya(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function ba(e){return!(e[1]-e[0]<0)}function xa(e,t,n){return e<t?t:e>n?n:e}function Ca(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=xa(e[0],t[0],n[0]),r[1]=xa(e[1],t[1],n[1]),r[2]=xa(e[2],t[2],n[2]),r}const Sa=mo("GetScalarTypeFittingRange"),Aa=mo("GetAdjustedScalarRange");const Ia=e=>!Number.isFinite(e),{isFinite:wa,isNaN:Oa}=Number,Pa=Oa;function Ra(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function Ma(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ea(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Va(e){return Math.round(255*e)}var Da,La={Pi:()=>Math.PI,ldexp:function(e,t){return t>1023?e*2**1023*2**(t-1023):t<-1074?5e-324*e*2**(t+1074):e*2**t},radiansFromDegrees:yo,degreesFromRadians:bo,round:xo,floor:Co,ceil:So,ceilLog2:wo,min:Ao,max:Io,arrayMin:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=1/0;for(let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=e.length;r<o;r+=t)e[r]<n&&(n=e[r]);return n},arrayMax:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=-1/0;for(let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=e.length;r<o;r+=t)n<e[r]&&(n=e[r]);return n},arrayRange:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=1/0,r=-1/0;for(let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=e.length;o<a;o+=t)e[o]<n&&(n=e[o]),r<e[o]&&(r=e[o]);return[n,r]},isPowerOfTwo:Ro,nearestPowerOfTwo:Po,factorial:Oo,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=To(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){io()(`${e}`,{global:!0}),go=e},getSeed:function(){return go},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e+((arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)-e)*Math.random()},gaussian:Mo,add:Eo,subtract:Vo,multiplyScalar:Do,multiplyScalar2D:Lo,multiplyAccumulate:Bo,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:No,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Fo,norm:_o,normalize:Go,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=No(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=No(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return Do(n,o),!0},projectVector2D:function(e,t,n){const r=ko(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=ko(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Lo(n,o),!0},distance2BetweenPoints:Uo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Fo(e,t,n),Math.atan2(_o(n),No(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:ko,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:zo,normalize2D:Wo,determinant2x2:Ho,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(ho(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,ho(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Ho(s,u,l,d),f=-Ho(i,c,l,d),g=+Ho(i,c,s,u),m=-Ho(o,u,a,d),h=+Ho(r,c,a,d),v=-Ho(r,c,o,u),T=+Ho(o,s,a,l),y=-Ho(r,i,a,l),b=+Ho(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+T*t[2],S=f*t[0]+h*t[1]+y*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:jo,multiply3x3_mat3:Ko,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&po("Number of columns of A must match number of rows of B.");const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:$o,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Ho(i,c,s,u),p=-Ho(a,l,s,u),f=+Ho(a,l,i,c),g=-Ho(r,c,o,u),m=+Ho(n,l,o,u),h=-Ho(n,l,r,c),v=+Ho(r,i,o,s),T=-Ho(n,a,o,s),y=+Ho(n,a,r,i),b=n*d+r*p+o*f;0===b&&fo("Matrix has 0 determinant"),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=T/b,t[8]=y/b},identity3x3:Zo,identity:Qo,isIdentity:function(e){return Yo(e,so,arguments.length>1&&void 0!==arguments[1]?arguments[1]:co)},isIdentity3x3:function(e){return Yo(e,lo,arguments.length>1&&void 0!==arguments[1]?arguments[1]:co)},determinant3x3:qo,quaternionToMatrix3x3:Jo,areEquals:Xo,areMatricesEqual:Yo,roundNumber:ea,roundVector:ta,matrix3x3ToQuaternion:ra,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],T=e[3]*t[3];n[0]=r-l-f-T,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:oa,diagonalize3x3:aa,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=qo(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];oa(a,t),$o(a,a),Ko(a,t,r),aa(r,n,r),Ko(t,r,t),$o(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:la,invertMatrix:ca,luFactorLinearSystem:ia,luSolveLinearSystem:sa,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return na(e,3,t,n)},jacobiN:na,solveHomogeneousLeastSquares:ua,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return fo("Insufficient number of samples. Underdetermined."),0;const s=To(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>uo&&(p=0,s[u]=0);if(p&&1===o)return fo("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"),ua(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=To(n),f=ua(e,t,n,l));const m=To(n*n),h=To(n*n),v=To(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const T=ca(m,h,n);if(T)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&T:T},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:da,hsv2rgb:pa,lab2xyz:fa,xyz2lab:ga,xyz2rgb:ma,rgb2xyz:ha,rgb2lab:va,lab2rgb:Ta,uninitializeBounds:ya,areBoundsInitialized:ba,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:xa,clampVector:Ca,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Sa,getAdjustedScalarRange:Aa,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=To(3),a=To(3),i=To(3),s=To(3),l=To(3),c=To(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=_o(s),d=_o(l),p=_o(i),f=To(3);Fo(o,a,f);const g=_o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*No(o,c)/h,T=p*p*No(s,a)/h,y=u*u*No(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+T*t[o]+y*n[o];return m},inf:1/0,negInf:-1/0,isInf:Ia,isNan:Oa,isNaN:Oa,isFinite:wa,createUninitializedBounds:Ra,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:Ma,floatToHex2:Ea,floatRGB2HexCode:function(e){return`${arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#"}${e.map(Ea).join("")}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Va).join(", ")})`:`rgba(${Va(e[0]||0)}, ${Va(e[1]||0)}, ${Va(e[2]||0)}, ${e[3]||0})`}};function Ba(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function Na(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function Fa(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function _a(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}Da=new i(4),i!=Float32Array&&(Da[0]=0,Da[1]=0,Da[2]=0,Da[3]=0);var Ga=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};gn(),hn(1,0,0),hn(0,1,0),Na(),Na(),ie();const ka={};function Ua(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ka,n),Ht.obj(e,t),Ht.setGet(e,t,["transform"]),function(e,t){t.classHierarchy.push("vtkImplicitFunction"),e.functionValue=n=>{if(!t.transform)return e.evaluateFunction(n);const r=[];return t.transform.transformPoint(n,r),e.evaluateFunction(r)},e.evaluateFunction=e=>{Ht.vtkErrorMacro("not implemented")}}(e,t)}var za={newInstance:Ht.newInstance(Ua,"vtkImplicitFunction"),extend:Ua};const Wa=1e-6,Ha="coincide",ja="disjoint";function Ka(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function $a(e,t,n,r){const o=[];Vo(e,t,o);const a=No(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function qa(e,t,n){const r=No(e,t);let o=No(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Xa(e,t,n,r){const o=[];Vo(e,t,o);const a=No(n,o),i=No(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function Ya(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Vo(t,e,a),Vo(n,e,i);const s=No(r,i),l=No(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*Wa:s*Wa,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function Za(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Fo(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<Wa){const r=[];return Vo(e,n,r),0===No(t,r)?o.error=Ha:o.error=ja,o}let s;s=i[0]>i[1]&&i[0]>i[2]?"x":i[1]>i[2]?"y":"z";const l=[],c=-No(t,e),u=-No(r,n);switch(s){case"x":l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case"y":l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case"z":l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Eo(l,a,o.l1),o.intersection=!0,o}const Qa={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ka,projectPoint:$a,projectVector:qa,generalizedProjectPoint:Xa,intersectWithLine:Ya,intersectWithPlane:Za,DISJOINT:ja,COINCIDE:Ha},Ja={normal:[0,0,1],origin:[0,0,0]};function ei(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ja,n),za.extend(e,t,n),Ht.setGetArray(e,t,["normal","origin"],3),function(e,t){t.classHierarchy.push("vtkPlane"),e.distanceToPlane=e=>Ka(e,t.origin,t.normal),e.projectPoint=(e,n)=>{$a(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Xa(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>Ya(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>Za(e,n,t.origin,t.normal)}(e,t)}var ti={newInstance:Ht.newInstance(ei,"vtkPlane"),extend:ei,...Qa};const ni=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function ri(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function oi(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ai(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function ii(e){return ai(e,ni)}function si(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function li(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)si(e,...t[n]);else for(let n=0;n<t.length;n+=3)si(e,...t.slice(n,n+3));return e}function ci(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function ui(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function di(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function pi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function fi(e,t,n,r){return!!oi(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function gi(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function mi(e,t){return e[2*t+1]-e[2*t]}function hi(e){return[mi(e,0),mi(e,1),mi(e,2)]}function vi(e){return e.slice(0,2)}function Ti(e){return e.slice(2,4)}function yi(e){return e.slice(4,6)}function bi(e){const t=hi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function xi(e){if(oi(e)){const t=hi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Ci(e){return[e[0],e[2],e[4]]}function Si(e){return[e[1],e[3],e[5]]}function Ai(e,t){return e<=0&&t>=0||e>=0&&t<=0}function Ii(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function wi(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Oi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=Ii(e,[]);for(let e=0;e<r.length;++e)wn(r[e],r[e],t);return ii(n),li(n,r)}function Pi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Ri(e,t,n,r){const o=[].concat(ni),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=No(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=No(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=No(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Mi(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ei(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ti.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function Vi(e,t){if(!oi(e)||!oi(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Di(e,t){if(!oi(e)||!oi(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function Li(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Bi(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ti.evaluate(n,t,l)}let i=2;for(;i--&&!(Ai(o[r[i][0]],o[r[i][4]])&&Ai(o[r[i][1]],o[r[i][5]])&&Ai(o[r[i][2]],o[r[i][6]])&&Ai(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class Ni{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(ni))}getBounds(){return this.bounds}equals(e){return ri(this.bounds,e)}isValid(){return oi(this.bounds)}setBounds(e){return ai(this.bounds,e)}reset(){return ii(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return si(this.bounds,...t)}addPoints(e){return li(this.bounds,e)}addBounds(e,t,n,r,o,a){return ci(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return ui(this.bounds,e,t,n)}setMaxPoint(e,t,n){return di(this.bounds,e,t,n)}inflate(e){return pi(this.bounds,e)}scale(e,t,n){return fi(this.bounds,e,t,n)}getCenter(){return gi(this.bounds)}getLength(e){return mi(this.bounds,e)}getLengths(){return hi(this.bounds)}getMaxLength(){return bi(this.bounds)}getDiagonalLength(){return xi(this.bounds)}getMinPoint(){return Ci(this.bounds)}getMaxPoint(){return Si(this.bounds)}getXRange(){return vi(this.bounds)}getYRange(){return Ti(this.bounds)}getZRange(){return yi(this.bounds)}getCorners(e){return Ii(this.bounds,e)}computeCornerPoints(e,t){return wi(this.bounds,e,t)}computeLocalBounds(e,t,n){return Ri(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Oi(this.bounds,e,t)}computeScale3(e){return Pi(this.bounds,e)}cutWithPlane(e,t){return Bi(this.bounds,e,t)}intersectBox(e,t,n,r){return Mi(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ei(this.bounds,e,t)}intersect(e){return Vi(this.bounds,e)}intersects(e){return Di(this.bounds,e)}containsPoint(e,t,n){return Li(this.bounds,e,t,n)}contains(e){return Di(this.bounds,e)}}var Fi={newInstance:function(e){const t=e&&e.bounds;return new Ni(t)},equals:ri,isValid:oi,setBounds:ai,reset:ii,addPoint:si,addPoints:li,addBounds:ci,setMinPoint:ui,setMaxPoint:di,inflate:pi,scale:fi,scaleAboutCenter:function(e,t,n,r){if(!oi(e))return!1;const o=gi(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],fi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:gi,getLength:mi,getLengths:hi,getMaxLength:bi,getDiagonalLength:xi,getMinPoint:Ci,getMaxPoint:Si,getXRange:vi,getYRange:Ti,getZRange:yi,getCorners:Ii,computeCornerPoints:wi,computeLocalBounds:Ri,transformBounds:Oi,computeScale3:Pi,cutWithPlane:Bi,intersectBox:Mi,intersectPlane:Ei,intersect:Vi,intersects:Di,containsPoint:Li,contains:function(e,t){return!!Di(e,t)&&!!Li(e,...Ci(t))&&!!Li(e,...Si(t))},INIT_BOUNDS:ni},_i={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Gi}=_i;function ki(e){return()=>Ht.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}const Ui={allocatedRenderTime:10,coordinateSystem:Gi.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function zi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ui,n),Ht.obj(e,t),Ht.get(e,t,["estimatedRenderTime","allocatedRenderTime"]),Ht.setGet(e,t,["_parentProp","coordinateSystem","dragable","pickable","renderTimeMultiplier","useBounds","visibility"]),Ht.moveToProtected(e,t,["parentProp"]),function(e,t){t.classHierarchy.push("vtkProp"),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=ki("pick"),e.hasKey=ki("hasKey"),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Gi.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Gi.DISPLAY)}(e,t)}var Wi={newInstance:Ht.newInstance(zi,"vtkProp"),extend:zi,..._i};const Hi={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[...Fi.INIT_BOUNDS],properties:[],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function ji(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hi,n),Wi.extend(e,t,n),t.matrixMTime={},Ht.obj(t.matrixMTime),Ht.get(e,t,["isIdentity"]),Ht.getArray(e,t,["orientation"]),Ht.setGetArray(e,t,["origin","position","scale"],3),Ht.setGet(e,t,["properties"]),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,function(e,t){t.classHierarchy.push("vtkProp3D"),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=Na();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[bo(r),n[0],n[1],n[2]]},e.getOrientationQuaternion=function(){return N(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t.rotation)},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,yo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,yo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,yo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=yo(n),s=Na();Fa(s,[r,o,a],i);const l=new Float64Array(16);G(l,s),y(t.rotation,t.rotation,l),e.modified()},e.rotateQuaternion=n=>{if(Math.abs(n[3])>=.999999)return;const r=G(new Float64Array(16),n);y(t.rotation,t.rotation,r),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!Yo(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&y(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),y(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getBoundsByReference=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n,t.bounds=[...Fi.INIT_BOUNDS],t.boundsMTime.modified(),n;if(!t.mapperBounds||!n.every(((e,r)=>n[r]===t.mapperBounds[r]))||e.getMTime()>t.boundsMTime.getMTime()){Ht.vtkDebugMacro("Recomputing bounds..."),t.mapperBounds=n,e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),Fi.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}return t.bounds},e.getBounds=()=>{const t=e.getBoundsByReference();try{return[...t]}catch{return t}},e.getCenter=()=>Fi.getCenter(t.bounds),e.getLength=()=>Fi.getLength(t.bounds),e.getXRange=()=>Fi.getXRange(t.bounds),e.getYRange=()=>Fi.getYRange(t.bounds),e.getZRange=()=>Fi.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()})),e.getProperty=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null==t.properties[n]&&(t.properties[n]=e.makeProperty?.()),t.properties[n]},e.setProperty=(e,n)=>{const r=Number.isInteger(e),[o,a]=r?[e,n]:[0,e];return t.properties[o]!==a&&(t.properties[o]=a,!0)},e.getMTime=()=>{let e=t.mtime;return t.properties.forEach((t=>{if(null!==t){const n=t.getMTime();e=n>e?n:e}})),e}}(e,t)}var Ki={newInstance:Ht.newInstance(ji,"vtkProp3D"),extend:ji};const $i={FLAT:0,GOURAUD:1,PHONG:2},qi={POINTS:0,WIREFRAME:1,SURFACE:2};var Xi={Shading:$i,Representation:qi,Interpolation:$i};const{Representation:Yi,Interpolation:Zi}=Xi;function Qi(e){return()=>Ht.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}const Ji={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:Zi.GOURAUD,representation:Yi.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null,ORMTexture:null,RMTexture:null};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),Ht.obj(e,t),Ht.setGet(e,t,["lighting","interpolation","ambient","diffuse","metallic","roughness","normalStrength","emission","baseIOR","specular","specularPower","opacity","edgeVisibility","lineWidth","pointSize","backfaceCulling","frontfaceCulling","representation","diffuseTexture","metallicTexture","roughnessTexture","normalTexture","ambientOcclusionTexture","emissionTexture","ORMTexture","RMTexture"]),Ht.setGetArray(e,t,["ambientColor","specularColor","diffuseColor","edgeColor"],3),function(e,t){t.classHierarchy.push("vtkProperty"),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=Qi("ComputeCompositeColor"),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=Qi("AddShaderVariable"),e.setInterpolationToFlat=()=>e.setInterpolation(Zi.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(Zi.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(Zi.PHONG),e.getInterpolationAsString=()=>Ht.enumToString(Zi,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(Yi.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(Yi.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(Yi.POINTS),e.getRepresentationAsString=()=>Ht.enumToString(Yi,t.representation)}(e,t)}var ts={newInstance:Ht.newInstance(es,"vtkProperty"),extend:es,...Xi};const ns={mapper:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1};function rs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ns,n),Ki.extend(e,t,n),t.boundsMTime={},Ht.obj(t.boundsMTime),Ht.setGet(e,t,["backfaceProperty","forceOpaque","forceTranslucent","mapper"]),function(e,t){t.classHierarchy.push("vtkActor");const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.properties[0]||e.getProperty();let n=t.properties[0].getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(t.properties[0]||e.getProperty(),!e.getIsOpaque()),e.makeProperty=ts.newInstance,e.getMTime=()=>{let e=n.getMTime();if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}(e,t)}var os={newInstance:Ht.newInstance(rs,"vtkActor"),extend:rs};const as={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},is={VOID:"",CHAR:"Int8Array",SIGNED_CHAR:"Int8Array",UNSIGNED_CHAR:"Uint8Array",UNSIGNED_CHAR_CLAMPED:"Uint8ClampedArray",SHORT:"Int16Array",UNSIGNED_SHORT:"Uint16Array",INT:"Int32Array",UNSIGNED_INT:"Uint32Array",FLOAT:"Float32Array",DOUBLE:"Float64Array"};var ss={DefaultDataType:is.FLOAT,DataTypeByteSize:as,VtkDataTypes:is};const{vtkErrorMacro:ls}=jt,{DefaultDataType:cs}=ss;function us(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function ds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return us(r,0,1)}return us(e,t<0?0:t,n)}function ps(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function fs(e){return Object.prototype.toString.call(e).slice(8,-1)}const gs={computeRange:ds,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get(){return{min:e,max:t,count:n,sum:r,mean:r/n}},getRange(){return{min:e,max:t}}}},fastComputeRange:us,getDataType:fs,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=_o(r,t);a>n&&(n=a)}return n}},ms={name:"",numberOfComponents:1,dataType:cs,rangeTuple:[0,0]};function hs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,ms,n),Array.isArray(n.values)&&void 0===n.dataType&&console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array"),!t.empty&&!t.values&&!t.size)throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");if(t.values?Array.isArray(t.values)&&(t.values=st(t.dataType,t.values)):t.values=it(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=fs(t.values)),vt(e,t),Ct(e,t,["name","numberOfComponents"]),t.size%t.numberOfComponents!=0)throw new RangeError("model.size is not a multiple of model.numberOfComponents");!function(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=it(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push("vtkDataArray"),e.dataChange=()=>{t.ranges=null,e.modified()},e.allocate=t=>{n(e.getNumberOfTuples()+t)},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=ps(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=ds(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=ps(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.getRanges=function(){if(arguments.length>0&&void 0!==arguments[0]&&!arguments[0])return structuredClone(t.ranges);const n=[];for(let r=0;r<t.numberOfComponents;r++){const[t,o]=e.getRange(r),a={min:t,max:o};n.push(a)}if(t.numberOfComponents>1){const[t,r]=e.getRange(-1),o={min:t,max:r};n.push(o)}return n},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e-6;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:1)*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>vs({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=fs(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),t.ranges=structuredClone(n.getRanges()),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||ls("numberOfComponents must match");const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}(e,t)}const vs=Et(hs,"vtkDataArray");var Ts={newInstance:vs,extend:hs,...gs,...ss};const ys={clippingPlanes:[]};var bs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ys,n),Ht.obj(e,t),Ht.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),function(e,t){t.classHierarchy.push("vtkAbstractMapper"),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA("vtkPlane")&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}Ht.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}(e,t)},xs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,(e=>({bounds:[...Fi.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e}))(n)),bs(e,t,n),Ht.setGet(e,t,["viewSpecificProperties"]),function(e,t){e.getBounds=()=>(Ht.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"),Ra()),e.getCenter=()=>{const n=e.getBounds();return t.center=Fi.isValid(n)?Fi.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return Fi.getDiagonalLength(t)}}(e,t)};const{vtkErrorMacro:Cs,vtkWarningMacro:Ss}=Ht,As={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function Is(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,As,n),Ht.obj(e,t),function(e,t){t.classHierarchy.push("vtkFieldData");const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>"number"==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():""},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else Cs("Unhandled case in passData");else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Ts.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:Ht.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Ss("Unexpected case in interpolateData")}else t.insertTuples(s.getTuples());else Cs("Unhandled case in interpolateData");else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Ts.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:Ht.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}(e,t)}var ws={newInstance:Ht.newInstance(Is,"vtkFieldData"),extend:Is};const Os={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ps={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:Os,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:"vtkGhostType"};const{AttributeTypes:Rs,AttributeCopyOperations:Ms}=Ps,{vtkWarningMacro:Es}=Ht,Vs={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function Ds(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vs,n),ws.extend(e,t,n),Ht.setGet(e,t,["activeScalars","activeNormals","activeTCoords","activeVectors","activeTensors","activeGlobalIds","activePedigreeIds"]),t.arrays||(t.arrays={}),function(e,t){const n=["Scalars","Vectors","Normals","TCoords","Tensors","GlobalIds","PedigreeIds"];function r(e){let t=n.find((t=>Rs[t.toUpperCase()]===e||"number"!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push("vtkDataSetAttributes");const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&"PEDIGREEIDS"===a.toUpperCase()&&!n.isA("vtkDataArray"))return Es(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Es(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if("PEDIGREEIDS"!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA("vtkDataArray"))return Es(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Es(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Ms.PASSDATA][Rs[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Ms.PASSDATA][Rs[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(Ms).filter((e=>"ALLCOPY"!==e)).forEach((e=>{t.copyAttributeFlags[Ms[e]]=Object.keys(Rs).filter((e=>"NUM_ATTRIBUTES"!==e)).reduce(((e,t)=>(e[Rs[t]]=!0,e)),[])})),t.copyAttributeFlags[Ms.COPYTUPLE][Rs.GLOBALIDS]=!1,t.copyAttributeFlags[Ms.INTERPOLATE][Rs.GLOBALIDS]=!1,t.copyAttributeFlags[Ms.COPYTUPLE][Rs.PEDIGREEIDS]=!1},e.initialize=Ht.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||"vtkDataArray"!==t.dataArrays[n].type||e.addArray(Ts.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}(e,t)}var Ls={newInstance:Ht.newInstance(Ds,"vtkDataSetAttributes"),extend:Ds,...Ps};const Bs=["pointData","cellData","fieldData"],Ns={};function Fs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ns,n),Ht.obj(e,t),Ht.setGet(e,t,Bs),function(e,t){t.classHierarchy.push("vtkDataSet"),Bs.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=Ls.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),Bs.forEach((n=>{t[n]=Ls.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}(e,t)}var _s={newInstance:Ht.newInstance(Fs,"vtkDataSet"),extend:Fs,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const Gs={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var ks={StructuredType:Gs};const{StructuredType:Us}=ks;var zs={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?Us.EMPTY:3===t?Us.XYZ_GRID:2===t?e[0]===e[1]?Us.YZ_PLANE:e[2]===e[3]?Us.XZ_PLANE:Us.XY_PLANE:1===t?e[0]<e[1]?Us.X_LINE:e[2]<e[3]?Us.Y_LINE:Us.Z_LINE:Us.SINGLE_POINT},...ks};const{vtkErrorMacro:Ws}=Ht,Hs={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:Gs.EMPTY};function js(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hs,n),_s.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),Ht.get(e,t,["indexToWorld","worldToIndex"]),Ht.setGetArray(e,t,["origin","spacing"],3),Ht.setGetArray(e,t,["direction"],9),Ht.getArray(e,t,["extent"],6),function(e,t){t.classHierarchy.push("vtkImageData"),e.setExtent=function(){if(t.deleted)return Ws("instance deleted - cannot call any method"),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=zs.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)Ws("instance deleted - cannot call any method");else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void Ws("Bad dimension specification");n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return Ws("Requesting a point from an empty image."),null;const o=new Float64Array(3);switch(t.dataDescription){case Gs.EMPTY:return null;case Gs.SINGLE_POINT:break;case Gs.X_LINE:o[0]=n;break;case Gs.Y_LINE:o[1]=n;break;case Gs.Z_LINE:o[2]=n;break;case Gs.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case Gs.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case Gs.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case Gs.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:Ws("Invalid dataDescription")}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>Fi.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>Fi.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return wn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return wn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Fi.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Fi.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>Fi.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];Fi.computeCornerPoints(r,o,a),ta(o,o),ta(a,a);const i=e.getDimensions();Ca(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Ca(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0;return{minimum:d,maximum:u,average:m,variance:h,sigma:Math.sqrt(h),count:g}},e.computeIncrements=function(e){const t=[];let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;for(let r=0;r<3;++r)t[r]=n,n*=e[2*r+1]-e[2*r]+1;return t},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return Ws(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return Ws(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}(e,t)}var Ks={newInstance:Ht.newInstance(js,"vtkImageData"),extend:js};const $s={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var qs={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:$s,Scale:{LINEAR:0,LOG10:1}},Xs={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:Ys,Scale:Zs,VectorMode:Qs}=qs,{VtkDataTypes:Js}=Ts,{ColorMode:el}=Xs,{vtkErrorMacro:tl}=Ht;function nl(e){return e}function rl(e){return Math.floor(255*e+.5)}const ol={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:Qs.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1,scale:Zs.LINEAR};function al(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ol,n),Ht.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],Ht.setGet(e,t,["vectorSize","vectorComponent","vectorMode","alpha","indexedLookup"]),Ht.setArray(e,t,["mappingRange"],2),Ht.getArray(e,t,["mappingRange"]),function(e,t){t.classHierarchy.push("vtkScalarsToColors"),e.setVectorModeToMagnitude=()=>e.setVectorMode(Qs.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(Qs.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(Qs.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)tl("Values and annotations do not have the same number of tuples so ignoring");else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===el.DEFAULT&&(t.getDataType()===Js.UNSIGNED_CHAR||t.getDataType()===Js.UNSIGNED_CHAR_CLAMPED)||n===el.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:"vtkDataArray",name:"temp",numberOfComponents:4,dataType:Js.UNSIGNED_CHAR},i=Ht.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Ts.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,Ys.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,Ys.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===Qs.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==Qs.MAGNITUDE||1!==c&&1!==s||(i=Qs.COMPONENT));let u=0;switch(l>0&&(u=l),i){case Qs.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case Qs.RGBCOLORS:break;case Qs.MAGNITUDE:default:{const o=Ts.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=rl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Js.UNSIGNED_CHAR)return n;const i=Ts.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Js.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=nl;switch(n.getDataType()!==Js.FLOAT&&n.getDataType()!==Js.DOUBLE||(s=rl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return tl("Cannot convert colors"),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==el.DEFAULT||n.getDataType()!==Js.UNSIGNED_CHAR)&&r!==el.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}(e,t)}var il={newInstance:Ht.newInstance(al,"vtkScalarsToColors"),extend:al,...qs};const{vtkErrorMacro:sl}=Ht,ll={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function cl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ll,n),il.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},Ht.obj(t.buildTime),t.opaqueFlagBuildTime={},Ht.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},Ht.obj(t.insertTime,{mtime:0}),Ht.get(e,t,["buildTime"]),Ht.setGet(e,t,["numberOfColors","useAboveRangeColor","useBelowRangeColor"]),Ht.setArray(e,t,["alphaRange","hueRange","saturationRange","valueRange"],2),Ht.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),Ht.getArray(e,t,["hueRange","saturationRange","valueRange","alphaRange","nanColor","belowRangeColor","aboveRangeColor"]),function(e,t){t.classHierarchy.push("vtkLookupTable"),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4-3,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=Pa(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===$s.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===$s.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,pa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return sl("Expected 4 components for RGBA colors"),!1;if(n.getDataType()!==is.UNSIGNED_CHAR)return sl("Expected unsigned char values for RGBA colors"),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}(e,t)}var ul={newInstance:Ht.newInstance(cl,"vtkLookupTable"),extend:cl};const dl={Off:0,PolygonOffset:1};let pl=dl.PolygonOffset,fl=dl.Off;const gl=["VTK_RESOLVE_OFF","VTK_RESOLVE_POLYGON_OFFSET"];function ml(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=fl===e;return fl=e,t}var hl={Resolve:dl,getResolveCoincidentTopologyAsString:function(){return gl[fl]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return pl},getResolveCoincidentTopology:function(){return fl},setResolveCoincidentTopology:ml,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){const t=pl===e;return pl=e,t},setResolveCoincidentTopologyToDefault:function(){return ml(dl.Off)},setResolveCoincidentTopologyToOff:function(){return ml(dl.Off)},setResolveCoincidentTopologyToPolygonOffset:function(){return ml(dl.PolygonOffset)}};function vl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=Ht.objectSetterMap.object(e,t,{name:n.key,params:["factor","offset"]})}))}const Tl=["Polygon","Line","Point"],yl={modified:()=>{}};vl(yl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},Tl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var bl={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),Ht.setGet(e,t,["resolveCoincidentTopology"]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(hl).forEach((t=>{e[t]=hl[t]})),Object.keys(yl).filter((e=>"modified"!==e)).forEach((t=>{e[t]=yl[t]})),vl(e,t.topologyOffset,Tl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=yl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=yl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=yl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:yl,otherStaticMethods:hl,CATEGORIES:Tl,Resolve:dl};const xl={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var Cl={PassTypes:xl};const{FieldAssociations:Sl}=_s,{staticOffsetAPI:Al,otherStaticMethods:Il}=bl,{ColorMode:wl,ScalarMode:Ol,GetArray:Pl}=Xs,{VectorMode:Rl}=qs,{VtkDataTypes:Ml}=Ts;function El(e){return()=>Ht.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function Vl(e,t){const n=e[1]%2==0?1:-1;if(e[0]+=n,e[0]>=t[0]||e[0]<0){const r=e[2]%2==0?1:-1;e[0]-=n,e[1]+=r,(e[1]>=t[1]||e[1]<0)&&(e[1]-=r,e[2]++)}}function Dl(e,t,n){const r=Math.floor(t),o=r%(2*n[0]);let a,i;o<n[0]?(e[0]=o,a=1,i=e[0]===n[0]-1):(e[0]=2*n[0]-1-o,a=-1,i=0===e[0]);const s=Math.floor(r/n[0]),l=s%(2*n[1]);let c,u;l<n[1]?(e[1]=l,c=1,u=e[1]===n[1]-1):(e[1]=2*n[1]-1-l,c=-1,u=0===e[1]),e[2]=Math.floor(s/n[1]);const d=t-r;i?u?e[2]+=d:e[1]+=c*d:e[0]+=a*d,e[0]=(e[0]+.5)/n[0],e[1]=(e[1]+.5)/n[1],e[2]=(e[2]+.5)/n[2]}const Ll=new WeakMap;const Bl={colorMapColors:null,areScalarsMappedFromCells:!1,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,numberOfColorsInRange:0,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function Nl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bl,n),xs(e,t,n),Ht.get(e,t,["areScalarsMappedFromCells","colorCoordinates","colorMapColors","colorTextureMap","numberOfColorsInRange","selectionWebGLIdsToVTKIds"]),Ht.setGet(e,t,["colorByArrayName","arrayAccessMode","colorMode","fieldDataTupleId","interpolateScalarsBeforeMapping","lookupTable","populateSelectionSettings","renderTime","scalarMode","scalarVisibility","static","useLookupTableScalarRange","customShaderAttributes"]),Ht.setGetArray(e,t,["scalarRange"],2),bl.implementCoincidentTopologyMethods(e,t),function(e,t){t.classHierarchy.push("vtkMapper"),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Ra(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=ul.newInstance()},e.getColorModeAsString=()=>Ht.enumToString(wl,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>Ht.enumToString(Ol,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFlag:!1};let i=null,s=!1;if(n===Ol.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===Ol.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===Ol.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===Ol.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===Pl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Ol.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===Pl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Ol.USE_FIELD_DATA){const t=e.getFieldData();i=r===Pl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const{scalars:o,cellFlag:a}=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName);if(t.areScalarsMappedFromCells=a,!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const i=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==i){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(o,a))t.mapScalarsToTexture(o,a,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},t.mapScalarsToTexture=(n,r,o)=>{const a=t.lookupTable.getRange(),i=t.lookupTable.usingLogScale(),s=t.lookupTable.getAlpha(),l=i?[Math.log10(a[0]),Math.log10(a[1])]:a;if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==o){t.lookupTable.setAlpha(o),t.colorTextureMap=null,t.lookupTable.build();const e=t.lookupTable.getNumberOfAvailableColors(),n=2048,a=2,d=r?n**3-3:4094;t.numberOfColorsInRange=Math.min(Math.max(e,a),d);const p=t.numberOfColorsInRange+3,f=t.numberOfColorsInRange+2,g=r?[Math.min(Math.ceil(p/n**0),n),Math.min(Math.ceil(p/n**1),n),Math.min(Math.ceil(p/n**2),n)]:[f,2,1],m=g[0]*g[1]*g[2],h=new Float64Array(m);h.fill(NaN);const v=t.numberOfColorsInRange,T=v+2,y=[0,0,0],b=l[0],x=l[1]-l[0];for(let e=0;e<T;++e){const t=b+x*(e-1)/(v-1),n=i?10**t:t;h[(u=g,(c=y)[0]+u[0]*(c[1]+u[1]*c[2]))]=n,Vl(y,g)}const C=Ts.newInstance({numberOfComponents:1,values:h}),S=t.lookupTable.mapScalars(C,t.colorMode,0);t.colorTextureMap=Ks.newInstance(),t.colorTextureMap.setDimensions(g),t.colorTextureMap.getPointData().setScalars(S),t.lookupTable.setAlpha(s)}var c,u;const d=t.lookupTable.getVectorMode()===Rl.MAGNITUDE&&n.getNumberOfComponents()>1?-1:t.lookupTable.getVectorComponent();t.colorCoordinates=function(e,t,n,r,o,a,i){const s=new Array(arguments.length);for(let e=0;e<arguments.length;++e){const t=arguments[e];s[e]=t.getMTime?.()??t}const l=s.join("/"),c=Ll.get(e);if(c&&c.stringHash===l)return c.textureCoordinates;const u=(n[1]-n[0])/(o-1),[d,p]=[n[0]-u,n[1]+u],f=d-.5*u,g=1/(p-d+u),m=d,h=(o+1)/(p-d),v=e.getData(),T=e.getNumberOfTuples(),y=e.getNumberOfComponents(),b=t<0||t>=y,x=a[2]<=1?2:3,C=Ts.newInstance({numberOfComponents:x,values:new Float32Array(T*x)}),S=C.getData(),A=[0,0,0];Dl(A,o+2,a);let I=0,w=0;const O=[.5,.5,.5];for(let e=0;e<T;++e){let e;if(b){let t=0;for(let e=0;e<y;++e){const n=v[I+e];t+=n*n}e=Math.sqrt(t)}else e=v[I+t];if(r&&(e=Math.log10(e)),I+=y,Pa(e))O[0]=A[0],O[1]=A[1],O[2]=A[2];else if(i){let t=(e-m)*h;t<1?t=0:t>o&&(t=o+1),Dl(O,t,a)}else{O[1]=.49;const t=(e-f)*g;O[0]=t>1e3?1e3:t<-1e3?-1e3:t}for(let e=0;e<x;++e)S[w++]=O[e]}return Ll.set(e,{stringHash:l,textureCoordinates:C}),C}(n,d,l,i,t.numberOfColorsInRange,t.colorTextureMap.getDimensions(),r)},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=(e,n)=>!((!n||t.colorMode===wl.DIRECT_SCALARS)&&(!t.interpolateScalarsBeforeMapping||t.lookupTable&&t.lookupTable.getIndexedLookup()||!e||t.colorMode===wl.DEFAULT&&e.getDataType()===Ml.UNSIGNED_CHAR||t.colorMode===wl.DIRECT_SCALARS)),e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=El("AcquireInvertibleLookupTable"),e.valueToColor=El("ValueToColor"),e.colorToValue=El("ColorToValue"),e.useInvertibleColorFor=El("UseInvertibleColorFor"),e.clearInvertibleColor=El("ClearInvertibleColor"),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer(xl.ID_LOW24),o=e.getRawPixelBuffer(xl.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Sl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Sl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===xl.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer(xl.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===xl.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n];e.getPixelBuffer(xl.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}(e,t)}var Fl={newInstance:Ht.newInstance(Nl,"vtkMapper"),extend:Nl,...Al,...Il,...Xs};const{isVtkObject:_l}=Ht;function Gl(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function kl(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const Ul={extractCellSizes:Gl,getNumberOfCells:kl};function zl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Ts.extend(e,t,function(e){return{empty:!0,numberOfComponents:1,dataType:is.UNSIGNED_INT,...e}}(n)),function(e,t){t.classHierarchy.push("vtkCellArray");const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=kl(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=Gl(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{let r;r=_l(n)?n.getPointsIds():n;const o=e.getNumberOfCells();return e.insertNextTuples([r.length,...r]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(r.length),o}}(e,t)}var Wl={newInstance:Ht.newInstance(zl,"vtkCellArray"),extend:zl,...Ul};const{vtkErrorMacro:Hl}=Ht,jl=[1,-1,1,-1,1,-1],Kl={empty:!0,numberOfComponents:3,dataType:is.FLOAT,bounds:[1,-1,1,-1,1,-1]};function $l(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kl,n),Ts.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkPoints"),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=Ht.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return Hl(`getBounds called on an array with components of\n        ${e.getNumberOfComponents()}`),jl;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}(e,t)}var ql={newInstance:Ht.newInstance($l,"vtkPoints"),extend:$l};const Xl={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function Yl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xl,n),Ht.obj(e,t),t.points||(t.points=ql.newInstance()),Ht.get(e,t,["points","pointsIds"]),function(e,t){t.classHierarchy.push("vtkCell"),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=Ht.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else ya(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{Ht.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.")}}(e,t)}var Zl={newInstance:Ht.newInstance(Yl,"vtkCell"),extend:Yl};const Ql={array:null,maxId:0,extend:0};function Jl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ql,n),Ht.obj(e,t),function(e,t){t.classHierarchy.push("vtkCellLinks"),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA("vtkPolyData")){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Zl.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Zl.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}(e,t)}var ec={newInstance:Ht.newInstance(Jl,"vtkCellLinks"),extend:Jl};const tc=0,nc=1,rc=2,oc=3,ac=4,ic=5,sc=6,lc=7,cc=9,uc=21,dc=41,pc=42,fc=["vtkEmptyCell","vtkVertex","vtkPolyVertex","vtkLine","vtkPolyLine","vtkTriangle","vtkTriangleStrip","vtkPolygon","vtkPixel","vtkQuad","vtkTetra","vtkVoxel","vtkHexahedron","vtkWedge","vtkPyramid","vtkPentagonalPrism","vtkHexagonalPrism","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkQuadraticEdge","vtkQuadraticTriangle","vtkQuadraticQuad","vtkQuadraticTetra","vtkQuadraticHexahedron","vtkQuadraticWedge","vtkQuadraticPyramid","vtkBiQuadraticQuad","vtkTriQuadraticHexahedron","vtkQuadraticLinearQuad","vtkQuadraticLinearWedge","vtkBiQuadraticQuadraticWedge","vtkBiQuadraticQuadraticHexahedron","vtkBiQuadraticTriangle","vtkCubicLine","vtkQuadraticPolygon","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkConvexPointSet","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkParametricCurve","vtkParametricSurface","vtkParametricTriSurface","vtkParametricQuadSurface","vtkParametricTetraRegion","vtkParametricHexRegion","UnknownClass","UnknownClass","UnknownClass","vtkHigherOrderEdge","vtkHigherOrderTriangle","vtkHigherOrderQuad","vtkHigherOrderPolygon","vtkHigherOrderTetrahedron","vtkHigherOrderWedge","vtkHigherOrderPyramid","vtkHigherOrderHexahedron"],gc={getClassNameFromTypeId:function(e){return e<fc.length?fc[e]:"UnknownClass"},getTypeIdFromClassName:function(e){return fc.findIndex(e)},isLinear:function(e){return e<uc||e===dc||e===pc},hasSubCells:function(e){return e===sc||e===ac||e===rc}},mc={size:0,maxId:-1,extend:1e3};function hc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mc,n),Ht.obj(e,t),Ht.get(e,t,["size","maxId","extend"]),Ht.getArray(e,t,["typeArray","locationArray"]),function(e,t){t.classHierarchy.push("vtkCellTypes"),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=tc},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}(e,t)}var vc={newInstance:Ht.newInstance(hc,"vtkCellTypes"),extend:hc,...gc},Tc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:yc}=Tc;function bc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=No(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Uo(i,e),o}function xc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Vo(t,e,i),Vo(r,n,s),Vo(n,e,l);const c=[No(i,i),-No(i,s),-No(i,s),No(s,s)],u=[];if(u[0]=No(i,l),u[1]=-No(s,l),0===la(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=bc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance,u.t);return yc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?yc.YES_INTERSECTION:yc.NO_INTERSECTION}const Cc={distanceToLine:bc,intersection:xc},Sc={orientations:null};function Ac(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sc,n),Zl.extend(e,t,n),Ht.setGet(e,t,["orientations"]),function(e,t){t.classHierarchy.push("vtkLine"),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=xc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===yc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Uo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=bc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=bc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=bc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=bc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}(e,t)}var Ic={newInstance:Ht.newInstance(Ac,"vtkLine"),extend:Ac,...Cc,...Tc};const wc={};function Oc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wc,n),_s.extend(e,t,n),Ht.setGet(e,t,["points"]),function(e,t){t.classHierarchy.push("vtkPointSet"),t.points?t.points=We(t.points):t.points=ql.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),t.points=ql.newInstance(),t.points.shallowCopy(e.getPoints())}}(e,t)}var Pc={newInstance:Ht.newInstance(Oc,"vtkPointSet"),extend:Oc};function Rc(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function Mc(e,t,n,r){Rc(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}function Ec(e){e[0]=-1,e[1]=1,e[2]=0,e[3]=-1,e[4]=0,e[5]=1}const Vc={computeNormalDirection:Rc,computeNormal:Mc,interpolationDerivs:Ec,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];Mc(e,t,n,d),Mc(r,o,a,p);const f=-No(d,e),g=-No(p,r),m=[No(p,e)+g,No(p,t)+g,No(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[No(d,r)+f,No(d,o)+f,No(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],T=[r,o,a],y=No(d,p),b=(f-g*y)/(y*y-1),x=(g-f*y)/(y*y-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Fo(d,p,[]);Go(S);let A=0,I=0;const w=[],O=[];let P,R,M=50,E=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ti.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=No(a.x,S)-No(C,S));const s=ti.intersectWithLine(T[n],T[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(E=I),O[I++]=No(s.x,S)-No(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=O[2];O[2]=O[E],O[E]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(O[0])||Number.isNaN(O[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(O[0]>O[1]){const e=O[1];O[1]=O[0],O[0]=e}return w[1]<O[0]||O[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<O[0]?w[1]<O[1]?(u[0]=2,u[1]=1,P=O[0],R=w[1]):(u[0]=2,u[1]=2,P=O[0],R=O[1]):w[1]<O[1]?(u[0]=1,u[1]=1,P=w[0],R=w[1]):(u[0]=1,u[1]=2,P=w[0],R=O[1]),Bo(C,S,P,l),Bo(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}},Dc={};function Lc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dc,n),Zl.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkTriangle"),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(Mc(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ti.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Uo(u,d),h=Uo(d,p),v=Uo(p,u);t.line||(t.line=Ic.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const T=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=T.betweenPoints,s.t=T.t,T.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=No(n,e)/v,i[1]=No(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const T=[];let y,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),Rc(l,c,u,d),ti.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(T[s++]=i);for(i=0;i<2;i++)f[i]=I[T[i]]-u[T[i]],g[i]=l[T[i]]-u[T[i]],m[i]=c[T[i]]-u[T[i]];if(h=Ho(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Ho(f,m)/h,r[1]=Ho(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Uo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(y=Uo(e,u),b=Ic.distanceToLine(e,l,u,t,S),x=Ic.distanceToLine(e,u,c,t,A),y<b?(a.dist2=y,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(y=Uo(e,l),b=Ic.distanceToLine(e,l,u,t,S),x=Ic.distanceToLine(e,l,c,t,A),y<b?(a.dist2=y,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(y=Uo(e,c),b=Ic.distanceToLine(e,c,u,t,S),x=Ic.distanceToLine(e,l,c,t,A),y<b?(a.dist2=y,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=Ic.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=Ic.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=Ic.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n},e.derivatives=(e,n,r,o,a)=>{const i=[],s=[],l=[];t.points.getPoint(0,i),t.points.getPoint(1,s),t.points.getPoint(2,l);const c=[],u=[],d=[],p=[];Mc(i,s,l,c);for(let e=0;e<3;e++)u[e]=s[e]-i[e],p[e]=l[e]-i[e];Fo(c,u,d);const f=Go(u);if(f<=0||Go(d)<=0){for(let e=0;e<o;e++)for(let t=0;t<3;t++)a[e*o+t]=0;return}const g=[0,0],m=[f,0],h=[No(p,u),No(p,d)],v=new Array(6);Ec(v);const T=[m[0]-g[0],m[1]-g[1],h[0]-g[0],h[1]-g[1]],y=new Array(4).fill(0);ca(T,y,2);for(let e=0;e<o;e++){let t=0,n=0;for(let a=0;a<3;a++)t+=v[a]*r[o*a+e],n+=v[3+a]*r[o*a+e];const i=t*y[0]+n*y[1],s=t*y[2]+n*y[3];a[3*e]=i*u[0]+s*d[0],a[3*e+1]=i*u[1]+s*d[1],a[3*e+2]=i*u[2]+s*d[2]}},e.cellBoundary=(e,n,r)=>{const o=n[0]-n[1],a=.5*(1-n[0])-n[1],i=2*n[0]+n[1]-1;return o>=0&&a>=0?(r[0]=t.pointsIds[0],r[1]=t.pointsIds[1]):a<0&&i>=0?(r[0]=t.pointsIds[1],r[1]=t.pointsIds[2]):(r[0]=t.pointsIds[2],r[1]=t.pointsIds[0]),!(n[0]<0||n[1]<0||n[0]>1||n[1]>1||1-n[0]-n[1]<0)}}(e,t)}var Bc={newInstance:Ht.newInstance(Lc,"vtkTriangle"),extend:Lc,...Vc};const Nc=["verts","lines","polys","strips"],{vtkWarningMacro:Fc}=Ht,_c={[oc]:Ic,[ac]:Ic,[ic]:Bc},Gc={};function kc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gc,n),Pc.extend(e,t,n),Ht.get(e,t,["cells","links"]),Ht.setGet(e,t,["verts","lines","polys","strips"]),function(e,t){t.classHierarchy.push("vtkPolyData"),Nc.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\w|[A-Z]|\b\w)/g,(e=>e.toUpperCase())).replace(/\s+/g,"")}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=Wl.newInstance()})),e.getNumberOfCells=()=>Nc.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),Nc.forEach((n=>{t[n]=Wl.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?rc:nc,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?ac:oc,1===t&&Fc("Building VTK_LINE ",n," with only one point, but VTK_LINE needs at least two points. Check the input."),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=ic;break;case 4:l[n]=cc;break;default:l[n]=lc}t<3&&Fc("Building VTK_TRIANGLE ",n," with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(sc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=vc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=ec.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case nc:case rc:o=t.verts;break;case oc:case ac:o=t.lines;break;case ic:case cc:case lc:o=t.polys;break;case sc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||_c[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}(e,t)}var Uc={newInstance:Ht.newInstance(kc,"vtkPolyData"),extend:kc};const zc={image:null,canvas:null,jsImageData:null,imageBitmap:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function Wc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zc,n),Ht.obj(e,t),Ht.algo(e,t,6,0),Ht.get(e,t,["canvas","image","jsImageData","imageBitmap","imageLoaded","resizable"]),Ht.setGet(e,t,["repeat","edgeClamp","interpolate","mipLevel"]),function(e,t){t.classHierarchy.push("vtkTexture"),e.imageLoaded=()=>{t.image.removeEventListener("load",e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null,t.imageBitmap=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setImageBitmap=n=>{t.imageBitmap!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null,t.jsImageData=null),t.imageBitmap=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.imageBitmap=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null,t.imageBitmap=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener("load",e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),t.imageBitmap&&(n=t.imageBitmap.width,r=t.imageBitmap.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData;if(t.imageBitmap)return t.imageBitmap;if(t.canvas)return t.canvas.getContext("2d").getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=t.image.width,n=t.image.height,r=new OffscreenCanvas(e,n).getContext("2d");return r.translate(0,n),r.scale(1,-1),r.drawImage(t.image,0,0,e,n),r.getImageData(0,0,e,n)}return null}}(e,t)}var Hc={newInstance:Ht.newInstance(Wc,"vtkTexture"),extend:Wc,generateMipmaps:(e,t,n)=>{const r=e.createShaderModule({code:"\n    @group(0) @binding(0) var inputTexture: texture_2d<f32>;\n    @group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;\n\n    @compute @workgroup_size(8, 8)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n      let texelCoord = vec2<i32>(global_id.xy);\n      let outputSize = textureDimensions(outputTexture);\n\n      if (texelCoord.x >= i32(outputSize.x) || texelCoord.y >= i32(outputSize.y)) {\n        return;\n      }\n\n      let inputSize = textureDimensions(inputTexture);\n      let scale = vec2<f32>(inputSize) / vec2<f32>(outputSize);\n\n      // Compute the floating-point source coordinate\n      let srcCoord = (vec2<f32>(texelCoord) + 0.5) * scale - 0.5;\n\n      // Get integer coordinates for the four surrounding texels\n      let x0 = i32(floor(srcCoord.x));\n      let x1 = min(x0 + 1, i32(inputSize.x) - 1);\n      let y0 = i32(floor(srcCoord.y));\n      let y1 = min(y0 + 1, i32(inputSize.y) - 1);\n\n      // Compute the weights\n      let wx = srcCoord.x - f32(x0);\n      let wy = srcCoord.y - f32(y0);\n\n      // Fetch the four texels\n      let c00 = textureLoad(inputTexture, vec2<i32>(x0, y0), 0);\n      let c10 = textureLoad(inputTexture, vec2<i32>(x1, y0), 0);\n      let c01 = textureLoad(inputTexture, vec2<i32>(x0, y1), 0);\n      let c11 = textureLoad(inputTexture, vec2<i32>(x1, y1), 0);\n\n      // Bilinear interpolation\n      let color = mix(\n        mix(c00, c10, wx),\n        mix(c01, c11, wx),\n        wy\n      );\n\n      textureStore(outputTexture, texelCoord, color);\n    }\n  "}),o=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",access:"write-only"}},{binding:2,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}}]}),a=e.createPipelineLayout({bindGroupLayouts:[o]}),i=e.createComputePipeline({label:"ComputeMipmapPipeline",layout:a,compute:{module:r,entryPoint:"main"}}),s=e.createSampler({magFilter:"linear",minFilter:"linear"});for(let r=1;r<n;r++){const n=t.createView({baseMipLevel:r-1,mipLevelCount:1}),o=t.createView({baseMipLevel:r,mipLevelCount:1}),a=e.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:n},{binding:1,resource:o},{binding:2,resource:s}]}),l=e.createCommandEncoder({label:"MipmapGenerateCommandEncoder"}),c=l.beginComputePass();c.setPipeline(i),c.setBindGroup(0,a);const u=Math.max(1,t.width>>r),d=Math.max(1,t.height>>r),p=Math.ceil(u/8),f=Math.ceil(d/8);c.dispatchWorkgroups(p,f),c.end(),e.queue.submit([l.finish()])}}};const jc=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],Kc=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],$c=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],qc=[0,1,0,1,0,1,0,1,2,2,2,2],Xc=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Yc=new Float64Array(3),Zc=new Float64Array(3),Qc=new Float64Array(3),Jc=new Float64Array(3),eu=new Float64Array(3),tu=new Float64Array(3),nu=new Float64Array(16);function ru(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function ou(e){const t=[],n=[];for(let r=0;r<3;r++){const o=oo().domain([e[2*r],e[2*r+1]]);t[r]=o.ticks(5);const a=o.tickFormat(5);n[r]=t[r].map(a)}return{ticks:t,tickStrings:n}}const au=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),Ht.obj(e,t),t.tmPolyData=Uc.newInstance(),t.tmMapper=Fl.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=os.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),Ht.setGet(e,t,["renderable"]),Ht.get(e,t,["lastSize","lastAspectRatio","axisTextStyle","tickTextStyle","tmActor","ticks"]),t.forceUpdate=!1,t.lastRedrawTime={},Ht.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},Ht.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],function(e,t){t.classHierarchy.push("vtkCubeAxesActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Yc[0]=c[3*n],Yc[1]=c[3*n+1],Yc[2]=c[3*n+2],wn(Qc,Yc,r),Qc[0]+=.1,wn(Zc,Qc,o),yn(eu,Zc,Yc),Qc[0]-=.1,Qc[1]+=.1,wn(Zc,Qc,o),yn(tu,Zc,Yc);for(let e=0;e<3;e++)eu[e]/=.05*u[0],tu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Yc[0]=c[3*n],Yc[1]=c[3*n+1],Yc[2]=c[3*n+2],a[0]<-.5?xn(Qc,eu,a[0]*i-l.width):a[0]>.5?xn(Qc,eu,a[0]*i):xn(Qc,eu,a[0]*i-l.width/2),Tn(Yc,Yc,Qc),xn(Qc,tu,a[1]*i-l.height/2),Tn(Yc,Yc,Qc),s.points[3*d]=Yc[0],s.points[3*d+1]=Yc[1],s.points[3*d+2]=Yc[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,xn(Qc,eu,l.width),Tn(Yc,Yc,Qc),s.points[3*d]=Yc[0],s.points[3*d+1]=Yc[1],s.points[3*d+2]=Yc[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,xn(Qc,tu,l.height),Tn(Yc,Yc,Qc),s.points[3*d]=Yc[0],s.points[3*d+1]=Yc[1],s.points[3*d+2]=Yc[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,xn(Qc,eu,l.width),yn(Yc,Yc,Qc),s.points[3*d]=Yc[0],s.points[3*d+1]=Yc[1],s.points[3*d+2]=Yc[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(nu,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Yc[0]=f[3*u],Yc[1]=f[3*u+1],Yc[2]=f[3*u+2],wn(Qc,Yc,n),Yc[0]=f[3*u+3],Yc[1]=f[3*u+4],Yc[2]=f[3*u+5],wn(Jc,Yc,n),yn(Qc,Qc,Jc);const r=[Qc[0],Qc[1]];Wo(r),e.createPolyDataForOneLabel(g[d],u,n,nu,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,nu,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Ts.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}(e,t)}),"vtkCubeAxesActorHelper");function iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};os.extend(e,t,function(e,t,n){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...Fi.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,tickLabelPixelOffset:12,generateTicks:ou,...n,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif",...n?.axisTextStyle},tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif",...n?.tickTextStyle}}}(0,0,n)),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=["X-Axis","Y-Axis","Z-Axis"],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.tmTexture=Hc.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=Fl.newInstance(),t.polyData=Uc.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=os.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=Uc.newInstance(),Ht.setGet(e,t,["axisTitlePixelOffset","boundsScaleFactor","faceVisibilityAngle","gridLines","tickLabelPixelOffset","generateTicks"]),Ht.setGetArray(e,t,["dataBounds"],6),Ht.setGetArray(e,t,["axisLabels"],3),Ht.get(e,t,["axisTextStyle","tickTextStyle","camera","tmTexture","textValues","textPolyData","tickCounts","gridActor"]),function(e,t){t.classHierarchy.push("vtkCubeAxesActor"),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=Fi.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Yc[s]=t.dataBounds[a]-.1*r*jc[a][s],Yc[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Yc[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),wn(Qc,Yc,e),Yc[s]=t.dataBounds[a],wn(Jc,Yc,e),yn(Qc,Jc,Qc),Sn(Qc,Qc),i=Qc[2]>o,t.camera.getParallelProjection()||(Sn(Jc,Jc),i=An(Jc,Qc)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Xc[t][0]].length+2*r[Xc[t][1]].length,a+=r[Xc[t][0]].length+r[Xc[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=$c[e][0],l[3*u+2]=$c[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Xc[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Xc[n][0]]=o[r],s[3*c+Xc[n][1]]=t.dataBounds[2*Xc[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Xc[n][0]]=o[r],s[3*c+Xc[n][1]]=t.dataBounds[2*Xc[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Xc[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Xc[n][1]]=o[r],s[3*c+Xc[n][0]]=t.dataBounds[2*Xc[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Xc[n][1]]=o[r],s[3*c+Xc[n][0]]=t.dataBounds[2*Xc[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[qc[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=Kc[a][e];if(1===n[d]){const e=qc[d],n=3*$c[d][0],p=3*$c[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Xc[a][0]]=.5*(t.dataBounds[2*Xc[a][0]]+t.dataBounds[2*Xc[a][0]+1]),s[3*l+Xc[a][1]]=.5*(t.dataBounds[2*Xc[a][1]]+t.dataBounds[2*Xc[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[Kc[e][t]]++;const a=t.generateTicks(t.dataBounds);e.updatePolyData(r,n,a.ticks),e.updateTextData(r,n,a.ticks,a.tickStrings),(o||t.forceUpdate)&&e.updateTextureAtlas(a.tickStrings)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){ru(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}ru(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=Po(n),r=Po(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{ru(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),Fi.setBounds(t.bounds,t.gridActor.getBounds()),Fi.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=Ht.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}(e,t)}var su={newInstance:Ht.newInstance(iu,"vtkCubeAxesActor"),extend:iu,newCubeAxesActorHelper:au,defaultGenerateTicks:ou};const lu={};const cu=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lu,n),Xt.extend(e,t,n),t.CubeAxesActorHelper=su.newCubeAxesActorHelper(),function(e,t){t.classHierarchy.push("vtkOpenGLCubeAxesActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}(e,t)}),"vtkOpenGLCubeAxesActor");en("vtkCubeAxesActor",cu);const uu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var du={ObjectType:uu};const{ObjectType:pu}=du,fu={objectType:pu.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function gu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fu,n),Ht.obj(e,t),Ht.get(e,t,["_openGLRenderWindow","allocatedGPUMemoryInBytes"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){function n(e){switch(e){case pu.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case pu.TEXTURE_BUFFER:if("TEXTURE_BUFFER"in t.context)return t.context.TEXTURE_BUFFER;case pu.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push("vtkOpenGLBufferObject");let r=null,o=null,a=!0,i="";e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i="Trying to upload array buffer to incompatible buffer.",!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}(e,t)}var mu={newInstance:Ht.newInstance(gu),extend:gu,...du};function hu(e){let t=0,n=0;for(let r=0;r<3;++r){const o=e.getRange(r),a=o[1]-o[0];t+=a*a;const i=.5*(o[1]+o[0]);n+=i*i}const r=t>0&&(Math.abs(n)/t>1e6||Math.abs(Math.log10(t))>3||0===t&&n>1e6);if(r){const t=new Float64Array(3),n=new Float64Array(3);for(let r=0;r<3;++r){const o=e.getRange(r),a=o[1]-o[0];t[r]=.5*(o[1]+o[0]),n[r]=a>0?1/a:1}return{useShiftAndScale:r,coordShift:t,coordScale:n}}return{useShiftAndScale:r,coordShift:new Float32Array([0,0,0]),coordScale:new Float32Array([1,1,1])}}const{vtkErrorMacro:vu}=Ht;const Tu={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function yu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tu,n),mu.extend(e,t,n),Ht.setGet(e,t,["colorBO","elementCount","stride","colorBOStride","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorOffset","colorComponents","customData"]),Ht.get(e,t,["coordShift","coordScale","coordShiftAndScaleEnabled","inverseShiftAndScaleMatrix"]),function(e,t){t.classHierarchy.push("vtkOpenGLCellArrayBufferObject"),e.setType(uu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=mu.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,T=0,y=0;const b={anythingToPoints(e,t,n,r){for(let o=0;o<e;++o)f(t[n+o],r)},linesToWireframe(e,t,n,r){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r)},polysToWireframe(e,t,n,r){if(e>2)for(let o=0;o<e;++o)f(t[n+o],r),f(t[n+(o+1)%e],r)},stripsToWireframe(e,t,n,r){if(e>2){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r);for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+2],r)}},polysToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+0],r),f(t[n+o+1],r),f(t[n+o+2],r)},stripsToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+1+o%2],r),f(t[n+o+1+(o+1)%2],r)}},x={anythingToPoints(e,t){return e},linesToWireframe(e,t){return e>1?2*(e-1):0},polysToWireframe(e,t){return e>2?2*e:0},stripsToWireframe(e,t){return e>2?4*e-6:0},polysToSurface(e,t){return e>2?3*(e-2):0},stripsToSurface(e,t,n){return e>2?3*(e-2):0}};let C=null,S=null;o===qi.POINTS||"verts"===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===qi.WIREFRAME||"lines"===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let O=null;const P=new Float32Array(w*t.blockSize);u&&(O=new Uint8Array(4*w));let R=0,M=0;const{useShiftAndScale:E,coordShift:V,coordScale:D}=hu(a.points);if(E?e.setCoordShiftAndScale(V,D):!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null),i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e,n){if(i&&(i.points[L]=e,i.cells[L]=y+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(P[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],P[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],P[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(P[R++]=s[g++],P[R++]=s[g++],P[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(y+a.cellOffset):3*e,P[R++]=l[m++],P[R++]=l[m++],P[R++]=l[m++]),t.customData.forEach((t=>{T=e*t.components;for(let e=0;e<t.components;++e)P[R++]=t.data[T++]})),null!==c){h=a.useTCoordsPerCell?n*p:e*p;for(let e=0;e<p;++e)P[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(y+a.cellOffset)*d:e*d,O[M++]=u[v++],O[M++]=u[v++],O[M++]=u[v++],O[M++]=4===d?u[v++]:255)};for(let e=0;e<I;e+=A[e]+1,y++)C(A[e],A,e+1,y+a.cellOffset);return t.elementCount=w,e.upload(P,uu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(O,uu.ARRAY_BUFFER)),y},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Rn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Rn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Pn(e,[0,0,0])&&Pn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Cn(n,t);const r=new Float64Array(16);return F(r,Na(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):vu("Wrong type for coordScale, expected vec3 or null"):vu("Wrong type for coordShift, expected vec3 or null")}}(e,t)}var bu={newInstance:Ht.newInstance(yu),extend:yu};const{vtkErrorMacro:xu}=Ht,Cu={shaderType:"Unknown",source:"",error:"",handle:0,dirty:!1,context:null};function Su(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cu,n),Ht.obj(e,t),Ht.setGet(e,t,["shaderType","source","error","handle","context"]),function(e,t){t.classHierarchy.push("vtkShader"),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||"Unknown"===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e="Fragment"===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return xu(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}(e,t)}var Au={newInstance:Ht.newInstance(Su,"vtkShader"),extend:Su};const{vtkErrorMacro:Iu}=Ht,wu={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:"",handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function Ou(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wu,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=Au.newInstance(),t.vertexShader.setShaderType("Vertex"),t.fragmentShader=Au.newInstance(),t.fragmentShader.setShaderType("Fragment"),t.geometryShader=Au.newInstance(),t.geometryShader.setShaderType("Geometry"),Ht.obj(e,t),Ht.get(e,t,["lastCameraMTime"]),Ht.setGet(e,t,["error","handle","compiled","bound","md5Hash","vertexShader","fragmentShader","geometryShader","linked"]),function(e,t){t.classHierarchy.push("vtkShaderProgram"),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(Iu(`Links failed: ${t.error}`),0):(Iu(t.error),0):(Iu(t.fragmentShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),Iu(t.fragmentShader.getError()),0):(Iu(t.vertexShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),Iu(t.vertexShader.getError()),0),e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error="Program has not been initialized, and/or does not have shaders.",!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return Iu(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(Iu("attempt to find uniform when the shader program is not linked"),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return Iu("attempt to find uniform when the shader program is not linked"),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error="Shader object was not initialized, cannot attach it.",!1;if("Unknown"===n.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error="Could not create shader program.",!1;t.handle=e,t.linked=!1}return"Vertex"===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),"Fragment"===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error="shader object was not initialized, cannot attach it.",!1;if("Unknown"===e.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;switch(0===t.handle&&(t.error="This shader program has not been initialized yet."),e.getShaderType()){case"Vertex":return t.vertexShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case"Fragment":return t.fragmentShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}(e,t)}var Pu={newInstance:Ht.newInstance(Ou,"vtkShaderProgram"),extend:Ou,substitute:function(e,t,n,r){const o="string"==typeof n?n:n.join("\n"),a=!1===r?t:new RegExp(t,"g"),i=e.replace(a,o);return{replace:i!==o,result:i}}};const Ru={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function Mu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ru,n),t.buffers=[],Ht.obj(e,t),Ht.get(e,t,["supported"]),Ht.setGet(e,t,["forceEmulation"]),function(e,t){t.classHierarchy.push("vtkOpenGLVertexArrayObject"),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension("ANGLE_instanced_arrays")),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension("OES_vertex_array_object"),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==uu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}(e,t)}var Eu={newInstance:Ht.newInstance(Mu,"vtkOpenGLVertexArrayObject"),extend:Mu};const Vu={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6},Du={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function Lu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Du,n),Ht.obj(e,t),t.shaderSourceTime={},Ht.obj(t.shaderSourceTime),t.attributeUpdateTime={},Ht.obj(t.attributeUpdateTime),Ht.setGet(e,t,["program","shaderSourceTime","VAO","attributeUpdateTime","CABO","primitiveType","pointPicking"]),t.program=Pu.newInstance(),t.VAO=Eu.newInstance(),t.CABO=bu.newInstance(),function(e,t){t.classHierarchy.push("vtkOpenGLHelper"),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===qi.POINTS||n===Vu.Points?t.context.POINTS:e===qi.WIREFRAME||n===Vu.Lines||n===Vu.TrisEdges||n===Vu.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f("viewportSize",o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf("lineWidthStepSize",t/Math.ceil(t)),e.getProgram().setUniformf("halfLineWidth",n)}t.primitiveType===Vu.Points||r.getProperty().getRepresentation()===qi.POINTS?e.getProgram().setUniformf("pointSize",r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf("pointSize",e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=Pu.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform float pointSize;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl","  gl_PointSize = pointSize;"],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=Pu.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform vec2 viewportSize;","uniform float lineWidthStepSize;","uniform float halfLineWidth;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl"," if (halfLineWidth > 0.0)","   {","   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;","   vec4 tmpPos = gl_Position;","   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;","   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];","   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];","   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);","   }"]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===Vu.Points?2:t.primitiveType===Vu.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}(e,t)}var Bu={newInstance:Ht.newInstance(Lu),extend:Lu,primTypes:Vu};const Nu={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},Fu={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var _u={Wrap:Nu,Filter:Fu};const Gu=new Float32Array(1),ku=new Int32Array(Gu.buffer);var Uu={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Gu[0]=e;const t=ku[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};let zu;const{Wrap:Wu,Filter:Hu}=_u,{VtkDataTypes:ju}=Ts,{vtkDebugMacro:Ku,vtkErrorMacro:$u,vtkWarningMacro:qu,requiredParam:Xu}=jt,{toHalf:Yu}=Uu;function Zu(e,t){function n(){return{internalFormat:t.internalFormat,format:t.format,openGLDataType:t.openGLDataType,width:t.width,height:t.height}}t.classHierarchy.push("vtkOpenGLTexture"),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow")),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(Hu.LINEAR),e.setMagnificationFilter(Hu.LINEAR)):(e.setMinificationFilter(Hu.NEAREST),e.setMagnificationFilter(Hu.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Wu.REPEAT),e.setWrapS(Wu.REPEAT),e.setWrapT(Wu.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImageBitmap()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR)),t.renderable.getImageBitmap()&&t.renderable.getImageLoaded()&&(e.create2DFromImageBitmap(t.renderable.getImageBitmap()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw({width:n.width,height:n.height,numComps:4,dataType:ju.UNSIGNED_CHAR,data:n,flip:!0}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw({width:n.width,height:n.height,numComps:4,dataType:ju.UNSIGNED_CHAR,data:n.data,flip:!0}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:a}):e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()};const r=()=>{if(t.minificationFilter!==Hu.LINEAR&&t.magnificationFilter!==Hu.LINEAR||(void 0===zu&&(zu=function(){try{const e=4,t=2,n=1,r=new Int16Array([0,32767]),o=[1,1],a=document.createElement("canvas");a.width=e,a.height=e;const i=a.getContext("webgl2");if(!i)return!1;const s=i.getExtension("EXT_texture_norm16");if(!s)return!1;const l=`#version 300 es\n    void main() {\n      gl_PointSize = ${e.toFixed(1)};\n      gl_Position = vec4(0, 0, 0, 1);\n    }\n  `,c="#version 300 es\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n\n    uniform sampler2D u_image;\n\n    out vec4 color;\n\n    void main() {\n        vec4 intColor = texture(u_image, gl_PointCoord.xy);\n        color = vec4(vec3(intColor.rrr), 1);\n    }\n    ",u=i.createShader(i.VERTEX_SHADER);if(i.shaderSource(u,l),i.compileShader(u),!i.getShaderParameter(u,i.COMPILE_STATUS))return!1;const d=i.createShader(i.FRAGMENT_SHADER);if(i.shaderSource(d,c),i.compileShader(d),!i.getShaderParameter(d,i.COMPILE_STATUS))return!1;const p=i.createProgram();if(i.attachShader(p,u),i.attachShader(p,d),i.linkProgram(p),!i.getProgramParameter(p,i.LINK_STATUS))return!1;const f=i.createTexture();i.bindTexture(i.TEXTURE_2D,f),i.texImage2D(i.TEXTURE_2D,0,s.R16_SNORM_EXT,t,n,0,i.RED,i.SHORT,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.useProgram(p),i.drawArrays(i.POINTS,0,1);const g=new Uint8Array(4);i.readPixels(o[0],o[1],1,1,i.RGBA,i.UNSIGNED_BYTE,g);const[m,h,v]=g,T=i.getExtension("WEBGL_lose_context");return T&&T.loseContext(),m===h&&h===v&&0!==m}catch(e){return!1}}()),zu))return t.oglNorm16Ext};function o(e){const[t,n,r,o,a,i]=e;return[n-t+1,o-r+1,i-a+1]}function a(e){const[t,n,r]=o(e);return t*n*r}function i(e,n){const r=new((arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)||e.constructor)(n.reduce(((e,t)=>e+a(t)),0)),o=[t.width,t.height,t.depth];let i=0;return n.forEach((t=>{!function(e,t,n,r,o){const[a,i,s,l,c,u]=n,[d,p]=t,f=d*p;let g=o;for(let t=c;t<=u;t++){const n=t*f;for(let t=s;t<=l;t++){const o=n+t*d;for(let t=o+a,n=o+i;t<=n;t++,g++)r[g]=e[t]}}}(e,o,t,r,i),i+=a(t)})),r}function s(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Ro(r)||!Ro(o))){const i=t.context.getExtension("OES_texture_half_float"),s=Po(r),l=Po(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Uu.toHalf(Uu.fromHalf(e[u][l+s+t])*h*(1-v)+Uu.fromHalf(e[u][l+p+t])*h*v+Uu.fromHalf(e[u][c+s+t])*m*(1-v)+Uu.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function l(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&r())||e!==ju.UNSIGNED_SHORT&&e!==ju.SHORT)))}function c(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);const i=function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a;let s=!1;if(t._openGLRenderWindow.getWebgl2())s=t.openGLDataType===t.context.FLOAT&&null===t.context.getExtension("OES_texture_float_linear")&&i||t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");s=e&&t.openGLDataType===e.HALF_FLOAT_OES}t.canUseHalfFloat=s&&i}(a,c.offset,c.scale,r),e.useHalfFloat()||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t._prevTexParams=null,t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t._prevTexParams=null,t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:qu("impossible case"),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Ku(`Unable to find suitable internal format for T=${n} NC= ${r}`),[t.context.R32F,t.context.RG32F,t.context.RGB32F,t.context.RGBA32F].includes(t.internalFormat)&&!t.context.getExtension("OES_texture_float_linear")&&qu("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."),t.internalFormat),e.getDefaultInternalFormat=(n,o)=>{let a=0;return a=t._openGLRenderWindow.getDefaultTextureInternalFormat(n,o,r(),e.useHalfFloat()),a||(a||(Ku("Unsupported internal texture type!"),Ku(`Unable to find suitable internal format for T=${n} NC= ${o}`)),a)},e.useHalfFloat=()=>t.enableUseHalfFloat&&t.canUseHalfFloat,e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t._prevTexParams=null,t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=n=>{const o=e.useHalfFloat();if(t._openGLRenderWindow.getWebgl2())switch(n){case ju.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case r()&&!o&&ju.SHORT:return t.context.SHORT;case r()&&!o&&ju.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case o&&ju.SHORT:case o&&ju.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case ju.FLOAT:case ju.VOID:default:return t.context.FLOAT}switch(n){case ju.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case ju.FLOAT:case ju.VOID:default:if(t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))return t.context.FLOAT;{const e=t.context.getExtension("OES_texture_half_float");if(e&&t.context.getExtension("OES_texture_half_float_linear"))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case Hu.NEAREST:return t.context.NEAREST;case Hu.LINEAR:return t.context.LINEAR;case Hu.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case Hu.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case Hu.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case Hu.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Wu.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Wu.REPEAT:return t.context.REPEAT;case Wu.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.updateArrayDataTypeForGL=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];const a=[];let s=t.width*t.height*t.components;r&&(s*=t.depth);const l=!!o.length;if(e!==ju.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e])if(l)a.push(i(n[e],o,Float32Array));else{const t=n[e].length>s?n[e].subarray(0,s):n[e];a.push(new Float32Array(t))}else a.push(null);if(e!==ju.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e])if(l)a.push(i(n[e],o,Uint8Array));else{const t=n[e].length>s?n[e].subarray(0,s):n[e];a.push(new Uint8Array(t))}else a.push(null);let c=!1;if(t._openGLRenderWindow.getWebgl2())c=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");c=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(c)for(let e=0;e<n.length;e++)if(n[e]){const t=l?i(n[e],o):n[e],r=new Uint16Array(l?t.length:s),c=r.length;for(let e=0;e<c;e++)r[e]=Yu(t[e]);a.push(r)}else a.push(null);if(0===a.length)for(let e=0;e<n.length;e++)a.push(l&&n[e]?i(n[e],o):n[e]);return a},e.create2DFromRaw=function(){let{width:n=Xu("width"),height:o=Xu("height"),numComps:a=Xu("numComps"),dataType:i=Xu("dataType"),data:c=Xu("data"),flip:u=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.getOpenGLDataType(i,!0),e.getInternalFormat(i,a),e.getFormat(i,a),!t.internalFormat||!t.format||!t.openGLDataType)return $u("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=a,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=s(e.updateArrayDataTypeForGL(i,d));return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(i)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=p[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,p[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,p[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*a*t._openGLRenderWindow.getDefaultTextureByteSize(i,r(),e.useHalfFloat()),e.deactivate(),!0},e.createCubeFromRaw=function(){let{width:n=Xu("width"),height:o=Xu("height"),numComps:a=Xu("numComps"),dataType:i=Xu("dataType"),data:c=Xu("data")}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.getOpenGLDataType(i),e.getInternalFormat(i,a),e.getFormat(i,a),!t.internalFormat||!t.format||!t.openGLDataType)return $u("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=a,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=s(e.updateArrayDataTypeForGL(i,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=it(i,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(i)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,o=t.height;for(;r>=1&&o>=1;){let a=null;n<=t.maxLevel&&(a=d[6*n+e]),l(i)?null!=a&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,o,t.format,t.openGLDataType,a):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,o,0,t.format,t.openGLDataType,a),n++,r/=2,o/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*a*t._openGLRenderWindow.getDefaultTextureByteSize(i,r(),e.useHalfFloat()),e.deactivate(),!0},e.createDepthFromRaw=function(){let{width:n=Xu("width"),height:o=Xu("height"),dataType:a=Xu("dataType"),data:i=Xu("data")}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.getOpenGLDataType(a),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?a===ju.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(a)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=i&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,i)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,i),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(a,r(),e.useHalfFloat()),e.deactivate(),!0):($u("Failed to determine texture parameters."),!1)},e.create2DFromImage=n=>{if(e.getOpenGLDataType(ju.UNSIGNED_CHAR),e.getInternalFormat(ju.UNSIGNED_CHAR,4),e.getFormat(ju.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return $u("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const o=!(t._openGLRenderWindow.getWebgl2()||Ro(n.width)&&Ro(n.height));let a=n,i=n.width,s=n.height,c=!0;const u=window.chrome;if(o||u){const e=new OffscreenCanvas(Po(n.width),Po(n.height));i=e.width,s=e.height;const t=e.getContext("2d");t.translate(0,e.height),t.scale(1,-1),t.drawImage(n,0,0,n.width,n.height,0,0,e.width,e.height),a=e,c=!1}return t.width=i,t.height=s,t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,c),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(ju.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,a)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,a),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(ju.UNSIGNED_CHAR,r(),e.useHalfFloat()),e.deactivate(),!0},e.create2DFromImageBitmap=n=>(e.getOpenGLDataType(ju.UNSIGNED_CHAR),e.getInternalFormat(ju.UNSIGNED_CHAR,4),e.getFormat(ju.UNSIGNED_CHAR,4),t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),t.width=n.width,t.height=n.height,l(ju.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,n)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,n),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(ju.UNSIGNED_CHAR,r(),e.useHalfFloat()),e.deactivate(),!0):($u("Failed to determine texture parameters."),!1)),e.create2DFilterableFromRaw=function(){let{width:t=Xu("width"),height:n=Xu("height"),numComps:r=Xu("numComps"),dataType:o=Xu("dataType"),data:a=Xu("data"),preferSizeOverAccuracy:i=!1,ranges:s}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.create2DFilterableFromDataArray({width:t,height:n,dataArray:Ts.newInstance({numComps:r,dataType:o,values:a,ranges:s}),preferSizeOverAccuracy:i})},e.create2DFilterableFromDataArray=function(){let{width:t=Xu("width"),height:n=Xu("height"),dataArray:r=Xu("dataArray"),preferSizeOverAccuracy:o=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{numComps:a,dataType:i,data:s}=c(r,o);e.create2DFromRaw({width:t,height:n,numComps:a,dataType:i,data:s})},e.updateVolumeInfoForGL=(n,o)=>{let a=!1;const i=e.useHalfFloat();t.volumeInfo?.scale&&t.volumeInfo?.offset||(t.volumeInfo={scale:new Array(o),offset:new Array(o)});for(let e=0;e<o;++e)t.volumeInfo.scale[e]=1,t.volumeInfo.offset[e]=0;if(r()&&!i&&n===ju.SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=32767;a=!0}if(r()&&!i&&n===ju.UNSIGNED_SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=65535;a=!0}if(n===ju.UNSIGNED_CHAR){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=255;a=!0}return(n===ju.FLOAT||i&&(n===ju.SHORT||n===ju.UNSIGNED_SHORT))&&(a=!0),a},e.create3DFromRaw=function(){let{width:i=Xu("width"),height:c=Xu("height"),depth:u=Xu("depth"),numComps:d=Xu("numComps"),dataType:p=Xu("dataType"),data:f=Xu("data"),updatedExtents:g=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},m=p,h=f;if(!e.updateVolumeInfoForGL(m,d)&&h){const e=i*c*u,n=structuredClone(t.volumeInfo),r=new Float32Array(e*d);t.volumeInfo.offset=n.offset,t.volumeInfo.scale=n.scale;let o=0;const a=n.scale.map((e=>1/e));for(let t=0;t<e;t++)for(let e=0;e<d;e++)r[o]=(h[o]-n.offset[e])*a[e],o++;m=ju.FLOAT,h=r}if(e.getOpenGLDataType(m),e.getInternalFormat(m,d),e.getFormat(m,d),!t.internalFormat||!t.format||!t.openGLDataType)return $u("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_3D,t.components=d,t.width=i,t.height=c,t.depth=u,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const v=g.length>0,T=!v||!Ge()(t._prevTexParams,n()),y=[h],b=s(e.updateArrayDataTypeForGL(m,y,!0,T?[]:g));if(t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),T)l(m)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=b[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,b[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,b[0]),t._prevTexParams=n();else if(v){const e=b[0];let n=0;for(let r=0;r<g.length;r++){const i=g[r],s=o(i),l=a(i),c=new e.constructor(e.buffer,n,l);n+=c.byteLength,t.context.texSubImage3D(t.target,0,i[0],i[2],i[4],s[0],s[1],s[2],t.format,t.openGLDataType,c)}}return t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(m,r(),e.useHalfFloat()),e.deactivate(),!0},e.create3DFilterableFromRaw=function(){let{width:t=Xu("width"),height:n=Xu("height"),depth:r=Xu("depth"),numComps:o=Xu("numComps"),dataType:a=Xu("dataType"),data:i=Xu("data"),preferSizeOverAccuracy:s=!1,ranges:l,updatedExtents:c=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.create3DFilterableFromDataArray({width:t,height:n,depth:r,dataArray:Ts.newInstance({numComps:o,dataType:a,values:i,ranges:l}),preferSizeOverAccuracy:s,updatedExtents:c})},e.create3DFilterableFromDataArray=function(){let{width:n=Xu("width"),height:r=Xu("height"),depth:o=Xu("depth"),dataArray:a=Xu("dataArray"),preferSizeOverAccuracy:i=!1,updatedExtents:s=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{numComps:u,dataType:d,data:p,scaleOffsets:f}=c(a,i),g=[],m=[];for(let e=0;e<u;++e)g[e]=0,m[e]=1;if(t.volumeInfo={scale:m,offset:g,dataComputedScale:f.scale,dataComputedOffset:f.offset,width:n,height:r,depth:o},t._openGLRenderWindow.getWebgl2())return e.create3DFromRaw({width:n,height:r,depth:o,numComps:u,dataType:d,data:p,updatedExtents:s});const h=n*r*o,v=structuredClone(f);let T=(e,t,n,r,o)=>{e[t]=n},y=ju.UNSIGNED_CHAR;if(d===ju.UNSIGNED_CHAR)for(let e=0;e<u;++e)v.offset[e]=0,v.scale[e]=255;else t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear")?(y=ju.FLOAT,T=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=ju.UNSIGNED_CHAR,T=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,u),e.getFormat(y,u),!t.internalFormat||!t.format||!t.openGLDataType)return $u("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=u,t.depth=1,t.numberOfDimensions=2;let b=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);b>4096&&(y===ju.FLOAT||u>=3)&&(b=4096);let x=1,C=1;h>b*b&&(x=Math.ceil(Math.sqrt(h/(b*b))),C=x);let S=Math.sqrt(h)/x;S=Po(S);const A=Math.floor(S*x/n),I=Math.ceil(o/A),w=Po(r*I/C);let O;t.width=S,t.height=w,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=A,t.volumeInfo.yreps=I,t.volumeInfo.xstride=x,t.volumeInfo.ystride=C,t.volumeInfo.offset=v.offset,t.volumeInfo.scale=v.scale;const P=S*w*u;O=y===ju.FLOAT?new Float32Array(P):new Uint8Array(P);let R=0;const M=Math.floor(n/x),E=Math.floor(r/C);for(let e=0;e<I;e++){const a=Math.min(A,o-e*A),i=u*(t.width-a*Math.floor(n/x));for(let t=0;t<E;t++){for(let o=0;o<a;o++){const a=u*((e*A+o)*n*r+C*t*n);for(let e=0;e<M;e++)for(let t=0;t<u;t++)T(O,R,p[a+x*e*u+t],v.offset[t],v.scale[t]),R++}R+=i}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=O&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,O)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,O),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1,e.enableUseHalfFloat=e=>{t.enableUseHalfFloat=e}}const Qu={_openGLRenderWindow:null,_forceInternalFormat:!1,_prevTexParams:null,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Wu.CLAMP_TO_EDGE,wrapT:Wu.CLAMP_TO_EDGE,wrapR:Wu.CLAMP_TO_EDGE,minificationFilter:Hu.NEAREST,magnificationFilter:Hu.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0,enableUseHalfFloat:!0,canUseHalfFloat:!1};function Ju(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qu,n),Xt.extend(e,t,n),t.sendParametersTime={},vt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},vt(t.textureBuildTime,{mtime:0}),Ct(e,t,["format","openGLDataType"]),St(e,t,["keyMatrixTime","minificationFilter","magnificationFilter","wrapS","wrapT","wrapR","generateMipmap","oglNorm16Ext"]),yt(e,t,["width","height","volumeInfo","components","handle","target","allocatedGPUMemoryInBytes"]),Ot(0,t,["openGLRenderWindow"]),Zu(e,t)}const ed=Et(Ju,"vtkOpenGLTexture");var td={newInstance:ed,extend:Ju,..._u};en("vtkTexture",ed);var nd="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n",rd="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",od=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=Pu.substitute(e,"//VTK::Coincident::Dec",["uniform float cfactor;","uniform float coffset;"]).result,t.context.getExtension("EXT_frag_depth")&&(0!==a.factor?(e=Pu.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=Pu.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=Pu.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=Pu.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=Pu.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=Pu.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result),n.Fragment=e}}},ad=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=Pu.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&""!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&""!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:id}=_s,{primTypes:sd}=Bu,{Representation:ld,Shading:cd}=ts,{ScalarMode:ud}=Fl,{Filter:dd,Wrap:pd}=td,{vtkErrorMacro:fd}=jt,gd={type:"StartEvent"},md={type:"EndEvent"},{CoordinateSystem:hd}=Wi;const vd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:xl.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function Td(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vd,n),Xt.extend(e,t,n),od(e,t,n),ad(e,t,n),t.primitives=[],t.primTypes=sd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=sd.Start;e<sd.End;e++)t.primitives[e]=Bu.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);St(e,t,["context"]),t.VBOBuildTime={},vt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},vt(t.selectionStateChanged,{mtime:0}),function(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push("vtkOpenGLPolyDataMapper"),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType("vtkOpenGLActor"),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=sd.Start;e<sd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=nd,e.Fragment=rd,e.Geometry=""},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName("lastLightComplexity");let l=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity","uniform vec3 ambientColorUniform;","uniform vec3 diffuseColorUniform;"];s&&(l=l.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let c=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];s&&(c=c.concat(["  vec3 specularColor;","  float specularPower;"])),c=c.concat(["  ambientColor = ambientColorUniform;","  diffuseColor = diffuseColorUniform;","  opacity = opacityUniform;"]),s&&(c=c.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat(["varying vec4 vertexColorVSOutput;"]),o=Pu.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=Pu.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=Pu.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=Pu.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?(t.renderable.getAreScalarsMappedFromCells()||t.renderable.getInterpolateScalarsBeforeMapping())&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=Pu.substitute(i,"//VTK::Color::Impl",c.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  ambientColor = texColor.rgb;","  opacity = opacity*texColor.a;"])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat(["uniform float opacityUniformBF; // the fragment opacity","uniform float ambientIntensityBF; // the material ambient","uniform float diffuseIntensityBF; // the material diffuse","uniform vec3 ambientColorUniformBF; // ambient material color","uniform vec3 diffuseColorUniformBF; // diffuse material color"]),s?(l=l.concat(["uniform float specularIntensityBF; // the material specular intensity","uniform vec3 specularColorUniformBF; // intensity weighted color","uniform float specularPowerUniformBF;"]),c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  specularColor = specularIntensityBF * specularColorUniformBF;","  specularPower = specularPowerUniformBF;","  opacity = opacityUniformBF; }"])):c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  opacity = opacityUniformBF; }"])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat(["uniform samplerBuffer texture1;"])),i=Pu.substitute(i,"//VTK::Color::Impl",c).result):i=Pu.substitute(i,"//VTK::Color::Impl",c.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result,i=Pu.substitute(i,"//VTK::Color::Dec",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity"),i=t.lastBoundBO.getReferenceByName("lastLightCount");let s=[];switch(a){case 0:o=Pu.substitute(o,"//VTK::Light::Impl",["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);","  //VTK::Light::Impl"],!1).result;break;case 1:o=Pu.substitute(o,"//VTK::Light::Impl",["  float df = max(0.0, normalVCVSOutput.z);","  float sf = pow(df, specularPower);","  vec3 diffuseL = df * diffuseColor;","  vec3 specularL = sf * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=Pu.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  float df;"];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,"    {",`    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=Pu.substitute(o,"//VTK::Light::Impl",s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=Pu.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  vec3 vertLightDirectionVC;","  float attenuation;","  float df;"];for(let e=0;e<i;++e)s=s.concat(["  attenuation = 1.0;",`  if (lightPositional${e} == 0)`,"    {",`      vertLightDirectionVC = lightDirectionVC${e};`,"    }","  else","    {",`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,"    float distanceVC = length(vertLightDirectionVC);","    vertLightDirectionVC = normalize(vertLightDirectionVC);","    attenuation = 1.0 /",`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,"    // per OpenGL standard cone angle is 90 or less for a spot light",`    if (lightConeAngle${e} <= 90.0)`,"      {",`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,"      // if inside the cone",`      if (coneDot >= cos(radians(lightConeAngle${e})))`,"        {",`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,"        }","      else","        {","        attenuation = 0.0;","        }","      }","    }","    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",`    diffuseL += ((df) * lightColor${e});`,"    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)","      {",`      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${e},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=Pu.substitute(o,"//VTK::Light::Impl",s,!1).result;break;default:fd("bad light complexity")}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=Pu.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=Pu.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * normalMC;"]).result,o=Pu.substitute(o,"//VTK::Normal::Dec",["in vec3 normalVCVSOutput[];","out vec3 normalVCGSOutput;"]).result,o=Pu.substitute(o,"//VTK::Normal::Impl",["normalVCGSOutput = normalVCVSOutput[i];"]).result,a=Pu.substitute(a,"//VTK::Normal::Dec",["varying vec3 normalVCVSOutput;"]).result,a=Pu.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalVCVSOutput);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.haveCellNormals?(a=Pu.substitute(a,"//VTK::Normal::Dec",["uniform mat3 normalMatrix;","uniform samplerBuffer textureN;"]).result,a=Pu.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalMatrix *","    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=Pu.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=Pu.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput;","  if (abs(fdx.x) > 0.0)","    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }","  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result):(a=Pu.substitute(a,"//VTK::Normal::Dec",["uniform int cameraParallel;"]).result,a=Pu.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=Pu.substitute(a,"//VTK::Normal::Impl",["  fdx = normalize(fdx);","  fdy = normalize(fdy);","  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));","  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }","  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(o=Pu.substitute(o,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,o=Pu.substitute(o,"//VTK::PositionVC::Impl",["vertexVCVSOutput = MCVCMatrix * vertexMC;","  gl_Position = MCPCMatrix * vertexMC;"]).result,o=Pu.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Dec",["in vec4 vertexVCVSOutput[];","out vec4 vertexVCGSOutput;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Impl",["vertexVCGSOutput = vertexVCVSOutput[i];"]).result,i=Pu.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=Pu.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;"]).result):(o=Pu.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,o=Pu.substitute(o,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=Pu.substitute(n,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=Pu.substitute(n,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result,r=Pu.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];","out vec2 tcoordVCGSOutput;"]).result,r=Pu.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=Pu.substitute(o,"//VTK::TCoord::Dec",["varying vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,a&&a.length>=1)switch(i){case 1:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}}else switch(n=Pu.substitute(n,"//VTK::TCoord::Dec","attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result,r=Pu.substitute(r,"//VTK::TCoord::Dec",["in vec3 tcoordVCVSOutput[];","out vec3 tcoordVCGSOutput;"]).result,r=Pu.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=Pu.substitute(o,"//VTK::TCoord::Dec",["varying vec3 tcoordVCVSOutput;","uniform samplerCube texture1;"]).result,i){case 1:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=Pu.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=Pu.substitute(o,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=Pu.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`varying float clipDistancesVSOutput[${e}];`]).result,a=Pu.substitute(a,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()==dl.PolygonOffset||o.getEdgeVisibility()&&o.getRepresentation()===ld.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===sd.Points||o.getRepresentation()===ld.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===sd.Lines||o.getRepresentation()===ld.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==sd.Tris&&e!==sd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==sd.TrisEdges&&e!==sd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===id.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=Pu.substitute(o,"//VTK::Picking::Dec",["uniform int picking;","//VTK::Picking::Dec"]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==xl.ID_LOW24&&t.lastSelectionState!==xl.ID_HIGH24||(a=Pu.substitute(a,"//VTK::Picking::Dec",["flat out int vertexIDVSOutput;\n","uniform int VertexIDOffset;\n"]).result,a=Pu.substitute(a,"//VTK::Picking::Impl","  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result,o=Pu.substitute(o,"//VTK::Picking::Dec","flat in int vertexIDVSOutput;\n").result,o=Pu.substitute(o,"//VTK::Picking::Impl",["  int idx = vertexIDVSOutput;","//VTK::Picking::Impl"]).result),t.lastSelectionState){case xl.ID_LOW24:o=Pu.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;break;case xl.ID_HIGH24:o=Pu.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;break;default:o=Pu.substitute(o,"//VTK::Picking::Dec","uniform vec3 mapperIndex;").result,o=Pu.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=Pu.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=Pu.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===cd.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName("lastLightComplexity"),h=t.lastBoundBO.getReferenceByName("lastLightCount");return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed("PrimitiveIDOffset")&&n.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),n.getProgram().isUniformUsed("VertexIDOffset")&&n.getProgram().setUniformi("VertexIDOffset",t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName("lastLightComplexity");n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||fd("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("normalMC")&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"normalMC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||fd("Error setting normalMC in shader VAO."):n.getVAO().removeAttributeArray("normalMC"),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||fd(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||fd("Error setting tcoordMC in shader VAO."):n.getVAO().removeAttributeArray("tcoordMC"),n.getProgram().isAttributeUsed("scalarColor")&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),"scalarColor",n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||fd("Error setting scalarColor in shader VAO."):n.getVAO().removeAttributeArray("scalarColor"),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),y(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",r)}t.internalColorTexture&&n.getProgram().isUniformUsed("texture1")&&n.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray("mapperIndex",i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi("picking",i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],Go(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],Go(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);wn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===hd.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,y(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix("MCPCMatrix",t.tmpMat4)}else s.setUniformMatrix("MCPCMatrix",n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed("MCVCMatrix")&&s.setUniformMatrix("MCVCMatrix",n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed("normalMatrix")&&s.setUniformMatrix3x3("normalMatrix",n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf("opacityUniform",i),o.setUniform3fArray("ambientColorUniform",s),o.setUniform3fArray("diffuseColorUniform",l),o.setUniformf("ambient",c),o.setUniformf("diffuse",u);const f=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray("specularColorUniform",g),o.setUniformf("specularPowerUniform",p),o.setUniformf("specular",d),o.isUniformUsed("ambientIntensityBF")){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf("ambientIntensityBF",c),o.setUniformf("diffuseIntensityBF",u),o.setUniformf("opacityUniformBF",i),o.setUniform3fArray("ambientColorUniformBF",s),o.setUniform3fArray("diffuseColorUniformBF",l),f<1)return;o.setUniformf("specularIntensityBF",d),o.setUniform3fArray("specularColorUniformBF",g),o.setUniformf("specularPowerUniformBF",p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===id.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():xl.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===ld.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===id.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===xl.ID_LOW24||t.lastSelectionState===xl.ID_HIGH24);for(let i=sd.Start;i<sd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===sd.TrisEdges||i===sd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(gd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(md),!t.currentInput)return void fd("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n),e.updateMaximumPointCellIds()},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==ud.USE_CELL_DATA&&a!==ud.USE_CELL_FIELD_DATA&&a!==ud.USE_FIELD_DATA&&r.getPointData().getScalars()||a===ud.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));let i=n.getProperty().getInterpolation()!==cd.FLAT?r.getPointData().getNormals():null;null===i&&r.getCellData().getNormals()&&(t.haveCellNormals=!0,i=r.getCellData().getNormals());const s=n.getProperty().getRepresentation();let l=r.getPointData().getTCoords();t.openGLActor.getActiveTextures()||(l=null);let c=!1;if(t.renderable.getColorCoordinates()){l=t.renderable.getColorCoordinates(),c=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=td.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(dd.NEAREST),e.setMagnificationFilter(dd.NEAREST),e.setWrapS(pd.CLAMP_TO_EDGE),e.setWrapT(pd.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),e.deactivate()}const u=`${r.getMTime()}A${s}B${r.getMTime()}C${i?i.getMTime():1}D${o?o.getMTime():1}E${n.getProperty().getEdgeVisibility()}F${l?l.getMTime():1}`;if(t.VBOBuildString!==u){const e={points:r.getPoints(),normals:i,tcoords:l,colors:o,cellOffset:0,vertexOffset:0,useTCoordsPerCell:c,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const a=[{inRep:"verts",cells:r.getVerts()},{inRep:"lines",cells:r.getLines()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()}],d=n.getProperty().getEdgeVisibility()&&s===ld.SURFACE;for(let n=sd.Start;n<sd.End;n++)n!==sd.TrisEdges&&n!==sd.TriStripsEdges?(e.cellOffset+=t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,s,e,t.selectionWebGLIdsToVTKIds),e.vertexOffset+=t.primitives[n].getCABO().getElementCount()):d?t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,ld.WIREFRAME,{...e,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[n].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),t.VBOBuildString=u}t.VBOBuildTime.modified()},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}(e,t)}const yd=Et(Td,"vtkOpenGLPolyDataMapper");var bd={newInstance:yd,extend:Td};en("vtkMapper",yd);const xd=1,{primTypes:Cd}=Bu,{Filter:Sd,Wrap:Ad}=td,{vtkErrorMacro:Id}=jt,wd={type:"StartEvent"},Od={type:"EndEvent"},Pd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const Rd=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pd,n),Xt.extend(e,t,n),od(e,t,n),ad(e,t,n),t.primitives=[],t.primTypes=Cd,t.tmpMat4=g(new Float64Array(16));for(let e=Cd.Start;e<Cd.End;e++)t.primitives[e]=Bu.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);St(e,t,["context"]),t.VBOBuildTime={},vt(t.VBOBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkOpenGLPolyDataMapper2D"),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType("vtkOpenGLActor2D"),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n",e.Geometry=""},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=Cd.Start;e<Cd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{if(e.invokeEvent(wd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Od),!t.currentInput)return void Id("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors(),a=n.getProperty().getRepresentation();let i=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(i=null);let s=!1;if(t.renderable.getColorCoordinates()){i=t.renderable.getColorCoordinates(),s=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=td.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(Sd.NEAREST),e.setMagnificationFilter(Sd.NEAREST),e.setWrapS(Ad.CLAMP_TO_EDGE),e.setWrapT(Ad.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),e.deactivate()}const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${a}B${r.getMTime()}C${o?o.getMTime():1}D${i?i.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=ql.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const c={points:n,tcoords:i,colors:o,cellOffset:0,useTCoordsPerCell:s,haveCellScalars:t.renderable.getAreScalarsMappedFromCells(),customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};c.cellOffset+=t.primitives[Cd.Points].getCABO().createVBO(r.getVerts(),"verts",a,c),c.cellOffset+=t.primitives[Cd.Lines].getCABO().createVBO(r.getLines(),"lines",a,c),c.cellOffset+=t.primitives[Cd.Tris].getCABO().createVBO(r.getPolys(),"polys",a,c),c.cellOffset+=t.primitives[Cd.TriStrips].getCABO().createVBO(r.getStrips(),"strips",a,c),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=Cd.Start;a<Cd.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment,s=["uniform vec3 diffuseColorUniform;","uniform float opacityUniform;"],l=["vec3 diffuseColor = diffuseColorUniform;","float opacity = opacityUniform;"];0!==t.lastBoundBO.getCABO().getColorComponents()?(s=s.concat(["varying vec4 vertexColorVSOutput;"]),o=Pu.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=Pu.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=Pu.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=Pu.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,i=Pu.substitute(i,"//VTK::Color::Impl",l.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result):t.renderable.getAreScalarsMappedFromCells()&&(l=l.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  opacity = opacity*texColor.a;"])),l=l.concat(["gl_FragData[0] = vec4(diffuseColor, opacity);"]),i=Pu.substitute(i,"//VTK::Color::Dec",s).result,i=Pu.substitute(i,"//VTK::Color::Impl",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=Pu.substitute(n,"//VTK::TCoord::Dec",["in float tcoordMC;","out float tcoordVCVSOutput;"]).result,n=Pu.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=Pu.substitute(r,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput[];\n","out float tcoordVCGSOutput;"]).result,r=Pu.substitute(r,["//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=Pu.substitute(o,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=Pu.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result):2===a&&(n=Pu.substitute(n,"//VTK::TCoord::Dec",["in vec2 tcoordMC;","out vec2 tcoordVCVSOutput;"]).result,n=Pu.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=Pu.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];\n","out vec2 tcoordVCGSOutput;"]).result,r=Pu.substitute(r,"//VTK::TCoord::Impl",["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=Pu.substitute(o,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=Pu.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result),t.renderable.getAreScalarsMappedFromCells()&&(r=Pu.substitute(r,"//VTK::PrimID::Impl",["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=Pu.substitute(r,"//VTK::Picking::Dec",["uniform vec3 mapperIndex;","uniform int picking;"]).result,r=Pu.substitute(r,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed("PrimitiveIDOffset")&&e.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),e.getProgram().isAttributeUsed("vertexWC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"vertexWC",e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||Id("Error setting vertexWC in shader VAO.")),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||Id(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed("tcoordMC")&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"tcoordMC",e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||Id("Error setting tcoordMC in shader VAO."):e.getVAO().removeAttributeArray("tcoordMC"),e.getProgram().isAttributeUsed("scalarColor")&&e.getCABO().getColorComponents()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"scalarColor",e.getCABO().getColorOffset(),e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||Id("Error setting scalarColor in shader VAO."):e.getVAO().removeAttributeArray("scalarColor"),t.internalColorTexture&&e.getProgram().isUniformUsed("texture1")&&t.internalColorTexture.getTextureUnit()>-1&&e.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray("mapperIndex",a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi("picking",a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity();t.setUniformf("opacityUniform",o);const a=n.getColor();t.setUniform3fArray("diffuseColorUniform",a)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=xo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=xo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=xo(c[0]-(d[0]-l[0])*p[0]),h=xo(c[1]-(d[1]-l[1])*p[1]),v=-f;let T=-f+s[0];const y=-h;let b=-h+s[1];v===T&&(T=v+1),y===b&&(b=y+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(T-v),x[5]=2/(b-y),x[3]=-1*(T+v)/(T-v),x[7]=-1*(b+y)/(b-y),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===xd?-1:1,x[15]=1,m(x,x),a.setUniformMatrix("WCVCMatrix",(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}(e,t)}),"vtkOpenGLPolyDataMapper2D");en("vtkMapper2D",Rd);const{VectorMode:Md}=il;function Ed(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Vd(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Dd(e,t){return e=>{const t=e.getLastTickBounds(),n=oo().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}const Ld=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),Ht.obj(e,t),Ht.setGet(e,t,["axisTitlePixelOffset","tickLabelPixelOffset","renderable","topTitle","ticks","tickStrings","tickPositions"]),Ht.get(e,t,["lastSize","lastAspectRatio","lastTickBounds","axisTextStyle","tickTextStyle","barActor","tmActor"]),Ht.getArray(e,t,["boxPosition","boxSize"]),Ht.setArray(e,t,["boxPosition","boxSize"],2),t.forceUpdate=!1,t.lastRebuildTime={},Ht.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.barMapper=Fl.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=Uc.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=os.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=Uc.newInstance(),t.tmMapper=Fl.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Hc.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=os.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],function(e,t){t.classHierarchy.push("vtkScalarBarActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left";const n={},r=new Map;let o=0,a=1;Ed(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,Ed(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),"NaN","Below","Above"];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=Po(o),a=Po(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{Ed(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s("NaN",[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s("Below",[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s("ticks",t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s("Above",[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p="vertical"===a?[1,0]:[0,1];"vertical"===a?(d[0]=l.width,d[1]=-l.height,"middle"===o[0]?n[1]-=l.width/2:"right"===o[0]&&(n[1]-=l.width),"middle"===o[1]?n[0]+=l.height/2:"top"===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,"middle"===o[0]?n[0]-=l.width/2:"right"===o[0]&&(n[0]-=l.width),"middle"===o[1]?n[1]-=l.height/2:"top"===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?["right","middle"]:["middle","bottom"];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","top"],"vertical",[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];"ticks"===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,"horizontal",g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),T=e.getTicks(),y=e.getTickStrings(),b=e.getTickPositions();for(let n=0;n<T.length;n++){const o=b?b[n]:(T[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(y[n],r,p,"horizontal",g,c)}const x=Ts.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(x),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Md.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Ts.newInstance({numberOfComponents:i,values:c,name:"Scalars"});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}(e,t)}),"vtkScalarBarActorHelper");function Bd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,function(e){return{automated:!0,autoLayout:null,axisLabel:"Scalar Value",barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif"},tickLabelPixelOffset:14,tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif"},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}(n)),t.autoLayout||(t.autoLayout=Vd(0,t)),t.generateTicks||(t.generateTicks=Dd()),os.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),Ht.setGet(e,t,["automated","autoLayout","axisTitlePixelOffset","axisLabel","scalarsToColors","tickLabelPixelOffset","generateTicks","drawNanAnnotation","drawBelowRangeSwatch","drawAboveRangeSwatch"]),Ht.get(e,t,["axisTextStyle","tickTextStyle"]),Ht.getArray(e,t,["barPosition","barSize","boxPosition","boxSize"]),Ht.setArray(e,t,["barPosition","barSize","boxPosition","boxSize"],2),function(e,t){t.classHierarchy.push("vtkScalarBarActor"),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(Vd(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Dd())}}(e,t)}var Nd={newInstance:Ht.newInstance(Bd,"vtkScalarBarActor"),extend:Bd,newScalarBarActorHelper:Ld};const Fd={};const _d=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fd,n),Xt.extend(e,t,n),t.scalarBarActorHelper=Nd.newScalarBarActorHelper(),function(e,t){t.classHierarchy.push("vtkOpenGLScalarBarActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}(e,t)}),"vtkOpenGLScalarBarActor");en("vtkScalarBarActor",_d);const{vtkErrorMacro:Gd}=jt,kd={context:null};const Ud=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kd,n),Xt.extend(e,t,n),t.openGLTexture=td.newInstance(),t.tris=Bu.newInstance(),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},St(e,t,["context"]),yt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLSkybox"),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi("sbtexture",n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix("IMCPCMatrix",a),"box"===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f("camPos",e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Ts.newInstance({numberOfComponents:3,values:e});n.setName("points");const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Ts.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,"polys",qi.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),"box"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }","")),"background"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }","")),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),"vertexMC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Gd("Error setting vertexMC in shader VAO."));const e=t.renderable.getTextures();e.length||Gd("vtkSkybox requires a texture map"),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}(e,t)}));en("vtkSkybox",Ud);const{FieldAssociations:zd}=_s,Wd={fieldAssociation:zd.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function Hd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wd,n),Ht.obj(e,t),Ht.setGet(e,t,["fieldAssociation","captureZValues"]),function(e,t){t.classHierarchy.push("vtkHardwareSelector"),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}(e,t)}var jd={newInstance:Ht.newInstance(Hd,"vtkHardwareSelector"),extend:Hd};const Kd={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function $d(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kd,n),vt(e,t),t.colorBuffers&&tt("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."),t.colorBuffers=[],At(e,t,["colorBuffers"]),function(e,t){t.classHierarchy.push("vtkFramebuffer"),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void tt("you must set the OpenGLRenderWindow before calling saveCurrentBindings");const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void tt("you must set the OpenGLRenderWindow before calling restorePreviousBindings");const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;null===n&&(n=t.context.FRAMEBUFFER),t.context.bindFramebuffer(n,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):tt("you must set the OpenGLRenderWindow before calling create")},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void tt("you must set the OpenGLRenderWindow before calling setColorBuffer");let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void tt("Using multiple framebuffer attachments requires WebGL 2");o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void tt("you must set the OpenGLRenderWindow before calling removeColorBuffer");let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void tt("Using multiple framebuffer attachments requires WebGL 2");r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else tt("Attaching depth buffer textures to fbo requires WebGL 2");else tt("you must set the OpenGLRenderWindow before calling setDepthBuffer")},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else tt("Attaching depth buffer textures to framebuffers requires WebGL 2");else tt("you must set the OpenGLRenderWindow before calling removeDepthBuffer")},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>null==t.glFramebuffer?null:[t.glFramebuffer.width,t.glFramebuffer.height],e.populateFramebuffer=()=>{if(!t.context)return void tt("you must set the OpenGLRenderWindow before calling populateFrameBuffer");e.bind();const n=t.context,r=td.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(Fu.LINEAR),r.setMagnificationFilter(Fu.LINEAR),r.create2DFromRaw({width:t.glFramebuffer.width,height:t.glFramebuffer.height,numComps:4,dataType:is.UNSIGNED_CHAR,data:null}),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}(e,t)}var qd={newInstance:Et($d,"vtkFramebuffer"),extend:$d};const Xd={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function Yd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xd,n),Ht.obj(e,t),t.properties={},Ht.setGet(e,t,["contentType","fieldType","properties","selectionList"]),function(e,t){t.classHierarchy.push("vtkSelectionNode"),e.getBounds=()=>t.points.getBounds()}(e,t)}var Zd={newInstance:Ht.newInstance(Yd,"vtkSelectionNode"),extend:Yd,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:Qd}=Cl,{SelectionContent:Jd,SelectionField:ep}=Zd,{FieldAssociations:tp}=_s,{vtkErrorMacro:np}=Ht;function rp(e){return`${e.propID} ${e.compositeID}`}function op(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function ap(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function ip(e,t){let n=t;return n<<=24,n|=e,n}function sp(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=ap(n[0],n[1],e.pixBuffer[Qd.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=ap(n[0],n[1],e.pixBuffer[Qd.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[Qd.ID_LOW24]&&0===op(n[0],n[1],e.pixBuffer[Qd.ID_LOW24],e.area))return a;const s=ap(n[0],n[1],e.pixBuffer[Qd.ID_LOW24],e.area),l=ap(n[0],n[1],e.pixBuffer[Qd.ID_HIGH24],e.area);return a.attributeID=ip(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=sp(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=sp(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=sp(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=sp(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=sp(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function lp(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=Zd.newInstance();switch(l.setContentType(Jd.INDICES),e){case tp.FIELD_ASSOCIATION_CELLS:l.setFieldType(ep.CELL);break;case tp.FIELD_ASSOCIATION_POINTS:l.setFieldType(ep.POINT);break;default:np("Unknown field association")}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}const cp={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function up(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cp,n),jd.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),Ht.setGetArray(e,t,["area"],4),Ht.setGet(e,t,["_renderer","currentPass","_openGLRenderWindow","maximumPointId","maximumCellId"]),Ht.setGetArray(e,t,["propColorValue"],3),Ht.moveToProtected(e,t,["renderer","openGLRenderWindow"]),Ht.event(e,t,"event"),function(e,t){t.classHierarchy.push("vtkOpenGLHardwareSelector"),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e&&e[0]===n[0]&&e[1]===n[1]?t.framebuffer.bind():(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer())}else t.framebuffer=qd.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===tp.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=sp(e,[n,t],0,u);if(r&&r.valid){const t=rp(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return lp(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return np("Renderer and view must be set before calling Select."),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:"StartEvent"}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();e.beginSelection();const r=[];for(t.currentPass=Qd.MIN_KNOWN_PASS;t.currentPass<=Qd.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===Qd.ACTOR_PASS&&"function"==typeof n[0].requestDepth&&"function"==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),r.push(t.currentPass));return r.forEach((n=>{t.currentPass=n,e.processPixelBuffers()})),t.currentPass=Qd.MAX_KNOWN_PASS,e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:"EndEvent"}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===Qd.ID_HIGH24){if(t.fieldAssociation===tp.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===tp.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===Qd.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if("function"==typeof e[0].requestDepth&&"function"==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=ap(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===Qd.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===Qd.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>Ht.enumToString(Qd,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=ap(e[0],e[1],t.pixBuffer[Qd.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=ap(e[0],e[1],t.pixBuffer[Qd.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[Qd.ID_LOW24]&&0===op(e[0],e[1],t.pixBuffer[Qd.ID_LOW24],t.area))return a;const s=ap(e[0],e[1],t.pixBuffer[Qd.ID_LOW24],t.area),l=ap(e[0],e[1],t.pixBuffer[Qd.ID_HIGH24],t.area);return a.attributeID=ip(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=rp(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return lp(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}(e,t)}var dp={newInstance:Ht.newInstance(up,"vtkOpenGLHardwareSelector"),extend:up,...Cl};const{vtkErrorMacro:pp}=jt,{Representation:fp}=ts,{ObjectType:gp}=mu,{PassTypes:mp}=dp,hp={type:"StartEvent"},vp={type:"EndEvent"},Tp={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const yp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tp,n),bd.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},vt(t.glyphBOBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkOpenGLGlyph3DMapper");const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(hp),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(vp),!t.currentInput)return void pp("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension("ANGLE_instanced_arrays"),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],T=t[14],y=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*T,e[3]=b*s+x*d+C*m+S*y,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*T,e[7]=b*s+x*d+C*m+S*y,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*T,e[11]=b*s+x*d+C*m+S*y,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*T,e[15]=b*s+x*d+C*m+S*y},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=Pu.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","attribute mat3 gNormal;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=Pu.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity"];a&&(i=i.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let s=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];a&&(s=s.concat(["  vec3 specularColor;","  float specularPower;"])),s=s.concat(["  opacity = opacityUniform;"]),a&&(s=s.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),t.drawingEdges||(i=i.concat(["varying vec4 vertexColorVSOutput;"]),n=Pu.substitute(n,"//VTK::Color::Dec",["attribute vec4 gColor;","varying vec4 vertexColorVSOutput;"]).result,n=Pu.substitute(n,"//VTK::Color::Impl",["vertexColorVSOutput = gColor;"]).result,r=Pu.substitute(r,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,r=Pu.substitute(r,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,s=s.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])),o=Pu.substitute(o,"//VTK::Color::Impl",s).result,o=Pu.substitute(o,"//VTK::Color::Dec",i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(n=Pu.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","vertexVCVSOutput = MCVCMatrix * gVertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result,n=Pu.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result):(n=Pu.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;"]).result,n=Pu.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=Pu.substitute(n,"//VTK::Picking::Dec",["attribute vec3 mapperIndexVS;","varying vec3 mapperIndexVSOutput;"]).result,n=Pu.substitute(n,"//VTK::Picking::Impl","  mapperIndexVSOutput = mapperIndexVS;").result,e.Vertex=n,t=Pu.substitute(t,"//VTK::Picking::Dec",["varying vec3 mapperIndexVSOutput;","uniform vec3 mapperIndex;","uniform int picking;"]).result,t=Pu.substitute(t,"//VTK::Picking::Impl",["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);","  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],T=n[r+1],y=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+T*d+y*g,o[1]=v*i+T*p+y*m,o[2]=v*c+T*f+y*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3("normalMatrix",t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix("MCPCMatrix",t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix("MCVCMatrix",t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray("ambientColorUniform",t.tmpColor),u.setUniform3fArray("diffuseColorUniform",t.tmpColor)}c&&u.setUniform3fArray("mapperIndex",c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===fp.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),y(t.mcpcMatrix,s.wcpc,l.mcwc),y(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===mp.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed("normalMatrix"),v=g.isUniformUsed("MCVCMatrix");if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed("gMatrix")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,"gMatrix",0,64,t.context.FLOAT,4,!1,1)||pp("Error setting gMatrix in shader VAO."):e.getVAO().removeAttributeArray("gMatrix"),e.getProgram().isAttributeUsed("gNormal")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,"gNormal",0,36,t.context.FLOAT,3,!1,1)||pp("Error setting gNormal in shader VAO."):e.getVAO().removeAttributeArray("gNormal"),e.getProgram().isAttributeUsed("gColor")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,"gColor",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pp("Error setting gColor in shader VAO."):e.getVAO().removeAttributeArray("gColor"),e.getProgram().isAttributeUsed("mapperIndexVS")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,"mapperIndexVS",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pp("Error setting mapperIndexVS in shader VAO."):e.getVAO().removeAttributeArray("mapperIndexVS"),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=mu.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=mu.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=mu.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=mu.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,gp.ARRAY_BUFFER),t.normalBuffer.upload(n,gp.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),gp.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,gp.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}(e,t)}),"vtkOpenGLGlyph3DMapper");en("vtkGlyph3DMapper",yp);const{vtkErrorMacro:bp}=Ht;class xp{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}const Cp={};function Sp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cp,n),Ht.obj(e,t),Ht.algo(e,t,1,1),function(e,t){t.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"),e.requestData=(e,t)=>{const n=e[0];if(!n)return void bp("Invalid or missing input");const r=Uc.newInstance();r.shallowCopy(n);const o=new xp,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(Wl.newInstance({values:c,name:"faces"})),t[0]=r}}(e,t)}var Ap={newInstance:Ht.newInstance(Sp,"vtkClosedPolyLineToSurfaceFilter"),extend:Sp};const{vtkErrorMacro:Ip}=jt;function wp(e,t){t.classHierarchy.push("vtkCutter");const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void Ip("Invalid or missing input");if(!t.cutFunction)return void Ip("Missing cut function");const o=Uc.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=e.getPointData(),i=r.getNumberOfPoints(),s=[],l=[],c=[],u={},d=a.getNumberOfArrays();for(let e=0;e<d;e++)u[a.getArrayName(e)]=[];(!t.cutScalars||t.cutScalars.length<i)&&(t.cutScalars=new Float32Array(i));let p=0,f=0;for(;p<o.length;)t.cutScalars[f++]=t.cutFunction.evaluateFunction(o[p++],o[p++],o[p++]);const g=[],m=new Array(3),h=new Array(3),v=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error("Iterator is done");r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)v[e]=t.cutScalars[n.cell[e++]];const e=v[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(v[t]>0!==e){r=!1;break}if(r)continue;const i=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,s=v[e]>0;if(v[r]>0===s)continue;let l=e,c=r,u=v[c]-v[l];u<=0&&(l=r,c=e,u*=-1);let p=0;0!==u&&(p=(t.cutValue-v[l])/u);const f=n.cell[l],g=n.cell[c];m[0]=o[3*f],m[1]=o[3*f+1],m[2]=o[3*f+2],h[0]=o[3*g],h[1]=o[3*g+1],h[2]=o[3*g+2];const T=[m[0]+p*(h[0]-m[0]),m[1]+p*(h[1]-m[1]),m[2]+p*(h[2]-m[2])],y={};for(let e=0;e<d;e++){const t=a.getArrayByIndex(e),n=a.getArrayName(e),r=t.getData(),o=t.getNumberOfComponents(),i=new Array(o);for(let e=0;e<o;e++){const t=r[o*f+e],n=r[o*g+e];i.push(t+p*(n-t))}y[n]=i}i.push({pointEdge1:f,pointEdge2:g,intersectedPoint:T,intersectedArrays:y,newPointID:-1})}for(let e=0;e<i.length;e++){const t=i[e];let n=!1;for(let r=0;r<g.length;r++){const o=g[r],a=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(a||s){n=!0,i[e].newPointID=g[r].newPointID;break}}n||(s.push(t.intersectedPoint[0]),s.push(t.intersectedPoint[1]),s.push(t.intersectedPoint[2]),Object.keys(t.intersectedArrays).forEach((e=>{u[e].push(...t.intersectedArrays[e])})),i[e].newPointID=s.length/3-1,g.push(i[e]))}const p=i.length;2===p?l.push(p,i[0].newPointID,i[1].newPointID):p>2&&(c.push(p),i.forEach((e=>{c.push(e.newPointID)})))}n.getPoints().setData(st(r.getDataType(),s),3);const T=n.getPointData();for(let e=0;e<d;e++){const t=a.getArrayName(e),n=Ts.newInstance({name:t,values:u[t],numberOfComponents:a.getArrayByIndex(e).getNumberOfComponents()});T.addArray(n)}0!==l.length&&n.getLines().setData(Uint16Array.from(l)),0!==c.length&&n.getPolys().setData(Uint16Array.from(c))})(r,o),n[0]=o}}const Op={cutFunction:null,cutScalars:null,cutValue:0};function Pp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Op,n),vt(e,t),Pt(e,t,1,1),St(e,t,["cutFunction","cutValue"]),wp(e,t)}var Rp={newInstance:Et(Pp,"vtkCutter"),extend:Pp};const Mp=e=>e,Ep=1e-6;class Vp{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:Mp}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);vn(n,e[0],e[1],e[2]),vn(r,t[0],t[1],t[2]),Sn(n,n),Sn(r,r);const a=An(n,r);return a>=1||(In(this.tmp,n,r),mn(this.tmp)<Ep&&(In(this.tmp,[1,0,0],e),mn(this.tmp)<Ep&&In(this.tmp,[0,1,0],e)),P(o,Math.acos(a),this.tmp),y(this.matrix,this.matrix,o)),this}rotate(e,t){return vn(this.tmp,...t),Sn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return vn(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return vn(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return y(this.matrix,this.matrix,e),this}multiply3x3(e){return y(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(Yo(so,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)vn(this.tmp,e[n],e[n+1],e[n+2]),wn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var Dp=function(){return new Vp(!0)},Lp=function(){return new Vp(!1)};const Bp=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],Np=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22],Fp={xLength:1,yLength:1,zLength:1,pointType:"Float64Array",generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function _p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fp,n),Ht.obj(e,t),Ht.setGet(e,t,["xLength","yLength","zLength","generate3DTextureCoordinates","generateFaces","generateLines"]),Ht.setGetArray(e,t,["center","rotations"],3),Ht.setGetArray(e,t,["matrix"],16),t._polys=Wl.newInstance({values:Uint16Array.from(Np)}),t._lineCells=Wl.newInstance({values:Uint16Array.from(Bp)}),Ht.moveToProtected(e,t,["polys","lineCells"]),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkCubeSource"),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=Uc.newInstance();n[0]=r;const o=Ht.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=Ht.newTypedArray(t.pointType,72),i=Ts.newInstance({name:"Normals",values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=Ht.newTypedArray(t.pointType,24*s),c=Ts.newInstance({name:"TextureCoordinates",values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&Dp().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Lp().translate(...t.center).apply(o),t.matrix){Lp().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Lp().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}(e,t)}var Gp={newInstance:Ht.newInstance(_p,"vtkCubeSource"),extend:_p};const{vtkErrorMacro:kp}=Ht,Up={};function zp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Up,n),Ht.obj(e,t),Ht.algo(e,t,1,1),t._cubeSource=Gp.newInstance(),Ht.moveToProtected(e,t,["cubeSource","tmpOut"]),function(e,t){t.classHierarchy.push("vtkImageDataOutlineFilter");const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA("vtkImageData"))return void kp("Invalid or missing input");const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):kp("Unable to fetch spatial extents of input image.")},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}(e,t)}var Wp={newInstance:Ht.newInstance(zp,"vtkImageDataOutlineFilter"),extend:zp};const{vtkWarningMacro:Hp}=Ht;let jp;const Kp={preMultiplyFlag:!1,matrix:[...so]};function $p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kp,n),Ht.obj(e,t),Ht.setGet(e,t,["preMultiplyFlag"]),Ht.setGetArray(e,t,["matrix"],16),function(e,t){t.classHierarchy.push("vtkAbstractTransform","vtkHomogeneousTransform","vtkTransform"),e.transformPoint=(e,n)=>(wn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],wn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?y(n,t.matrix,e):y(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>y(o,t.matrix,r):()=>y(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>jp({matrix:La.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag}),e.translate=(n,r,o)=>{if(0===n&&0===r&&0===o)return;const a=c();w(a,[n,r,o]),t.preMultiplyFlag?y(t.matrix,t.matrix,a):y(t.matrix,a,t.matrix),e.modified()},e.rotateWXYZ=(n,r,o,a)=>{if(0===r&&0===o&&0===a)return void Hp("No rotation applied, axis is zero vector.");if(0===n)return;const i=La.radiansFromDegrees(n),s=Na();Fa(s,[r,o,a],i);const l=new Float64Array(16);G(l,s),t.preMultiplyFlag?y(t.matrix,t.matrix,l):y(t.matrix,l,t.matrix),e.modified()},e.rotateX=t=>{e.rotateWXYZ(t,1,0,0)},e.rotateY=t=>{e.rotateWXYZ(t,0,1,0)},e.rotateZ=t=>{e.rotateWXYZ(t,0,0,1)},e.scale=(n,r,o)=>{if(1===n&&1===r&&1===o)return;const a=c();O(a,[n,r,o]),t.preMultiplyFlag?y(t.matrix,t.matrix,a):y(t.matrix,a,t.matrix),e.modified()},e.transformNormal=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const o=se(ie(),t.matrix),a=ie();ge(a,o);const i=ie();return fe(i,a),e.transformVector(n,r,i),La.normalize(r),r},e.transformNormals=(n,r)=>{const o=n.getData(),a=r.getData(),i=[0,0,0],s=se(ie(),t.matrix),l=ie();ge(l,s);const c=ie();fe(c,l);for(let t=0;t<o.length;t+=3)i[0]=o[t],i[1]=o[t+1],i[2]=o[t+2],e.transformVector(i,i,c),La.normalize(i),a[t]=i[0],a[t+1]=i[1],a[t+2]=i[2]},e.transformVector=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return On(n,e,(arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)||se(ie(),t.matrix)),n},e.transformVectors=(t,n)=>{const r=t.getData(),o=n.getData(),a=[0,0,0];for(let t=0;t<r.length;t+=3)a[0]=r[t],a[1]=r[t+1],a[2]=r[t+2],e.transformVector(a,a),La.normalize(a),o[t]=a[0],o[t+1]=a[1],o[t+2]=a[2]},e.transformPointsNormalsVectors=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;const c=t.getNumberOfPoints(),u=s?.length??0,d=new Float64Array(3),p=new Float64Array(3),f=new Float64Array(3),g=new Float64Array(3);let m=!1,h=!1,v=!1;const T=[];for(let y=0;y<c;y++){if(t.getPoint(y,d),p.set(d),e.transformPoint(d,d),n.setPoint(y,...d),La.areEquals(p,d)||(m=!0),a){const t=a.getData(),n=i.getData();d[0]=t[3*y],d[1]=t[3*y+1],d[2]=t[3*y+2],f.set(d),e.transformVector(d,d),n[3*y]=d[0],n[3*y+1]=d[1],n[3*y+2]=d[2],La.areEquals(f,d)||(h=!0)}if(r){const t=r.getData(),n=o.getData();d[0]=t[3*y],d[1]=t[3*y+1],d[2]=t[3*y+2],g.set(d),e.transformNormal(d,d),n[3*y]=d[0],n[3*y+1]=d[1],n[3*y+2]=d[2],La.areEquals(g,d)||(v=!0)}if(s)for(let t=0;t<u;t++){const n=s[t].getData(),r=l[t].getData();d[0]=n[3*y],d[1]=n[3*y+1],d[2]=n[3*y+2],f.set(d),e.transformVector(d,d),r[3*y]=d[0],r[3*y+1]=d[1],r[3*y+2]=d[2],La.arrayEqual(f,d)||T.includes(t)||T.push(t)}}m&&n.modified(),h&&i.modified(),v&&o.modified(),T.forEach((e=>l[e].modified()))}}(e,t)}jp=Ht.newInstance($p,"vtkTransform");var qp={newInstance:jp,extend:$p};function Xp(e,t,n){return e.length>0?`${e.map((e=>e?.getMTime()??"x")).join("/")}-${t}-${n}`:"0"}function Yp(e,t){return`${t.getMTime()}`}const Zp={NEAREST:0,LINEAR:1};var Qp={InterpolationType:Zp};const{vtkErrorMacro:Jp}=jt;function ef(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}const tf={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastNumberOfComponents:0,lastMultiTexturePerVolumeEnabled:!1,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,scalarTextures:[],_scalarTexturesCore:[],colorTexture:null,_colorTextureCore:null,pwfTexture:null,_pwfTextureCore:null,_externalOpenGLTexture:!1,resliceGeom:null,resliceGeomUpdateString:null,tris:null};const nf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tf,n),Xt.extend(e,t,n),od(e,t,n),ad(e,t,n),t.tris=Bu.newInstance(),t.scalarTextures=[],t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},vt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=Wp.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=Uc.newInstance(),t.cutter=Rp.newInstance(),t.lineToSurfaceFilter=Ap.newInstance(),t.transform=qp.newInstance(),yt(e,t,["scalarTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLImageResliceMapper");const n=new Map;function o(t,r,o){r!==o&&(function(t,r){if(!r)return;const o=(n.get(r)??0)-1;o<=0?(t.unregisterGraphicsResourceUser(r,e),n.delete(r)):n.set(r,o)}(t,r),function(t,r){if(!r)return;const o=n.get(r)??0,a=o+1;n.set(r,a),o<=0&&t.registerGraphicsResourceUser(r,e)}(t,o))}function a(t){[...n.keys()].forEach((n=>t.unregisterGraphicsResourceUser(n,e)))}e.buildPass=n=>{if(n){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const n=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera());const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&a(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==dl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update();const o=t.renderable.getNumberOfInputPorts();t.currentValidInputs=[];for(let e=0;e<o;++e){const n=t.renderable.getInputData(e);n&&!n.isDeleted()&&t.currentValidInputs.push({imageData:n,inputIndex:e})}const a=t.currentValidInputs.length;if(a<=0)return void Jp("No input!");const i=t.currentValidInputs[0].imageData.getPointData().getScalars();t.multiTexturePerVolumeEnabled=a>1,t.numberOfComponents=t.multiTexturePerVolumeEnabled?a:i.getNumberOfComponents(),e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:"EndEvent"})},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r);const o=r.getProperties();t.currentValidInputs.forEach((e=>{let{inputIndex:n}=e;const r=o[n].getInterpolationType(),a=t.scalarTextures[n];r===Zp.NEAREST?(a.setMinificationFilter(Fu.NEAREST),a.setMagnificationFilter(Fu.NEAREST)):(a.setMinificationFilter(Fu.LINEAR),a.setMagnificationFilter(Fu.LINEAR))}));const a=t.currentValidInputs[0];o[a.inputIndex].getInterpolationType()===Zp.NEAREST?(t.colorTexture.setMinificationFilter(Fu.NEAREST),t.colorTexture.setMagnificationFilter(Fu.NEAREST),t.pwfTexture.setMinificationFilter(Fu.NEAREST),t.pwfTexture.setMagnificationFilter(Fu.NEAREST)):(t.colorTexture.setMinificationFilter(Fu.LINEAR),t.colorTexture.setMagnificationFilter(Fu.LINEAR),t.pwfTexture.setMinificationFilter(Fu.LINEAR),t.pwfTexture.setMagnificationFilter(Fu.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context,a=[...t.scalarTextures,t.colorTexture,t.pwfTexture];a.forEach((e=>e.activate())),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),a.forEach((e=>e.deactivate()))},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty(t.currentValidInputs[0].inputIndex)?.getMTime()||t.currentValidInputs.some((e=>{let{imageData:n}=e;return t.VBOBuildTime.getMTime()<n.getMTime()}))||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime()||t.scalarTextures.length!==t.currentValidInputs.length||!t.scalarTextures.every((e=>!!e?.getHandle()))||!t.colorTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(e,n)=>{const r=n.getProperties();t.currentValidInputs.forEach(((e,n)=>{let{imageData:a}=e;const i=a.getPointData().getScalars(),s=t._openGLRenderWindow.getGraphicsResourceForObject(i),l=Yp(0,i),c=!s?.oglObject?.getHandle()||s?.hash!==l,u=r[n],d=u.getUpdatedExtents(),p=!!d.length;if(c&&!p){const e=td.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);const r=a.getDimensions();e.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),e.resetFormatAndType(),e.create3DFilterableFromDataArray({width:r[0],height:r[1],depth:r[2],dataArray:i}),t._openGLRenderWindow.setGraphicsResourceForObject(i,e,l),t.scalarTextures[n]=e}else t.scalarTextures[n]=s.oglObject;if(p){u.setUpdatedExtents([]);const e=a.getDimensions();t.scalarTextures[n].create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:i,updatedExtents:d})}o(t._openGLRenderWindow,t._scalarTexturesCore[n],i),t._scalarTexturesCore[n]=i}));const a=t.currentValidInputs[0],i=r[a.inputIndex],s=i.getIndependentComponents(),l=s?t.numberOfComponents:1,c=s?2*l:1,u=[];for(let e=0;e<l;++e)u.push(i.getRGBTransferFunction(e));const d=Xp(u,s,l),p=i.getRGBTransferFunction(),f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.oglObject?.getHandle()&&f?.hash===d)t.colorTexture=f.oglObject;else{let e=t.renderable.getColorTextureWidth();e<=0&&(e=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const n=new Uint8ClampedArray(e*c*3),r=td.newInstance();if(r.setOpenGLRenderWindow(t._openGLRenderWindow),p){const t=new Float32Array(3*e);for(let r=0;r<l;r++){const o=i.getRGBTransferFunction(r),a=o.getRange();if(o.getTable(a[0],a[1],e,t,1),s)for(let o=0;o<3*e;o++)n[r*e*6+o]=255*t[o],n[r*e*6+o+3*e]=255*t[o];else for(let o=0;o<3*e;o++)n[r*e*3+o]=255*t[o]}r.resetFormatAndType(),r.create2DFromRaw({width:e,height:c,numComps:3,dataType:is.UNSIGNED_CHAR,data:n})}else{for(let t=0;t<3*e;++t){const r=255*t/(3*(e-1));for(let o=0;o<c;++o)n[o*e*3+t+0]=r,n[o*e*3+t+1]=r,n[o*e*3+t+2]=r}r.resetFormatAndType(),r.create2DFromRaw({width:e,height:1,numComps:3,dataType:is.UNSIGNED_CHAR,data:n})}p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,r,d),t.colorTexture=r}o(t._openGLRenderWindow,t._colorTextureCore,p),t._colorTextureCore=p;const g=[];for(let e=0;e<l;++e)g.push(i.getPiecewiseFunction(e));const m=Xp(g,s,l),h=i.getPiecewiseFunction(),v=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(v?.oglObject?.getHandle()&&v?.hash===m)t.pwfTexture=v.oglObject;else{let e=t.renderable.getOpacityTextureWidth();e<=0&&(e=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const n=e*c,r=new Uint8ClampedArray(n),o=td.newInstance();if(o.setOpenGLRenderWindow(t._openGLRenderWindow),h){const t=new Float32Array(n),r=new Float32Array(e);for(let n=0;n<l;++n){const o=i.getPiecewiseFunction(n);if(null===o)t.fill(1);else{const a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),s)for(let o=0;o<e;o++)t[n*e*2+o]=r[o],t[n*e*2+o+e]=r[o];else for(let n=0;n<e;n++)t[n]=r[n]}}o.resetFormatAndType(),o.create2DFromRaw({width:e,height:c,numComps:1,dataType:is.FLOAT,data:t})}else r.fill(255),o.resetFormatAndType(),o.create2DFromRaw({width:e,height:c,numComps:1,dataType:is.UNSIGNED_CHAR,data:r});h&&t._openGLRenderWindow.setGraphicsResourceForObject(h,o,m),t.pwfTexture=o}o(t._openGLRenderWindow,t._pwfTextureCore,h),t._pwfTextureCore=h;const T=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==T){const e=Ts.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName("points");const n=Ts.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:Jp("Slab mode requested without normals")}t.tris.getCABO().createVBO(n,"polys",qi.SURFACE,r)}t.VBOBuildString=T,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.currentValidInputs[0].imageData;if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){t.scalarTextures.forEach(((e,t)=>{a.setUniformi(`volumeTexture[${t}]`,e.getTextureUnit())})),a.isAttributeUsed("vertexWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexWC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Jp("Error setting vertexWC in shader VAO.")),a.isAttributeUsed("normalWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"normalWC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Jp("Error setting normalWC in shader VAO.")),a.isUniformUsed("slabThickness")&&a.setUniformf("slabThickness",t.renderable.getSlabThickness()),a.isUniformUsed("spacing")&&a.setUniform3fv("spacing",i.getSpacing()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabTrapezoid")&&a.setUniformi("slabTrapezoid",t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed("WCTCMatrix")){const n=i.getDimensions();d(t.tmpMat4,i.getIndexToWorld()),b(t.tmpMat4,t.tmpMat4,[-.5,-.5,-.5]),x(t.tmpMat4,t.tmpMat4,n),h(t.tmpMat4,t.tmpMat4),e&&y(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix("WCTCMatrix",t.tmpMat4)}a.isUniformUsed("vboScaling")&&a.setUniform3fv("vboScaling",n.getCABO().getCoordScale()??[1,1,1]),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed("MCPCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCPCMatrix",ef([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed("MCVCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCVCMatrix",ef([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(t.currentValidInputs[0].inputIndex),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.numberOfComponents,l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));for(let e=0;e<s;e++){const n=t.multiTexturePerVolumeEnabled,r=n?e:0,i=n?0:e,s=t.scalarTextures[r].getVolumeInfo(),c=s.scale[i],u=s.offset[i],d=l?e:0;let p=a.getColorWindow(),f=a.getColorLevel();const g=a.getRGBTransferFunction(d);if(g&&a.getUseLookupTableScalarRange()){const e=g.getRange();p=e[1]-e[0],f=.5*(e[1]+e[0])}const m=c/p,h=(u-f)/p+.5;o.setUniformf(`cshift${e}`,h),o.setUniformf(`cscale${e}`,m);let v=1,T=0;const y=a.getPiecewiseFunction(d);if(y){const e=y.getRange(),t=e[1]-e[0];v=c/t,T=(u-.5*(e[0]+e[1]))/t+.5}o.setUniformf(`pwfshift${e}`,T),o.setUniformf(`pwfscale${e}`,v)}const c=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",u),o.setUniform4fv("backgroundColor",t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=r.getProperty(t.currentValidInputs[0].inputIndex).getIndependentComponents(),a=t.renderable.getSlabThickness(),i=t.renderable.getSlabType(),s=t.renderable.getSlabTrapezoidIntegration();let l=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(l=!0),!(!l&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&t.lastNumberOfComponents===t.numberOfComponents&&t.lastMultiTexturePerVolumeEnabled===t.multiTexturePerVolumeEnabled&&0!==e.getProgram()?.getHandle()&&t.lastIndependentComponents===o&&t.lastSlabThickness===a&&t.lastSlabType===i&&t.lastSlabTrapezoidIntegration===s||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastNumberOfComponents=t.numberOfComponents,t.lastMultiTexturePerVolumeEnabled=t.multiTexturePerVolumeEnabled,t.lastIndependentComponents=o,t.lastSlabThickness=a,t.lastSlabType=i,t.lastSlabTrapezoidIntegration=s,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=Pu.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=Pu.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=Pu.substitute(o,"//VTK::TCoord::Dec",["uniform mat4 WCTCMatrix;","out vec3 fragTexCoord;"]).result,o=Pu.substitute(o,"//VTK::TCoord::Impl",["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"]).result;const l=t.numberOfComponents,c=r.getProperty(t.currentValidInputs[0].inputIndex).getIndependentComponents();let u=["in vec3 fragTexCoord;",`uniform highp sampler3D volumeTexture[${t.scalarTextures.length}];`,"uniform mat4 WCTCMatrix;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;"];if(u.push("vec4 rawSampleTexture(vec3 pos) {"),t.multiTexturePerVolumeEnabled){u.push("vec4 rawSample;");for(let e=0;e<t.scalarTextures.length;++e)u.push(`rawSample[${e}] = texture(volumeTexture[${e}], pos)[0];`);u.push("return rawSample;","}")}else u.push("return texture(volumeTexture[0], pos);","}");if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:u=u.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Jp("Unsupported number of independent coordinates.")}}s>0&&(u=u.concat(["uniform vec3 spacing;","uniform float slabThickness;","uniform int slabType;","uniform int slabTrapezoid;","uniform vec3 vboScaling;"]),u=u.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)","{","  vec4 retVal = vec4(1.0);","  if (slabType == 0) // min","  {","    retVal = min(currVal, valToComp);","  }","  else if (slabType == 1) // max","  {","    retVal = max(currVal, valToComp);","  }","  else if (slabType == 3) // sum","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  else // mean","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  return retVal;","}"])),i=Pu.substitute(i,"//VTK::TCoord::Dec",u).result;let d=["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}","vec4 tvalue = rawSampleTexture(fragTexCoord);"];if(s>0&&(d=d.concat(["// Get the first and last samples","int numSlices = 1;","float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;","vec3 normalxspacing = scaling * normalWCVSOutput;","float distTraveled = length(normalxspacing);","int trapezoid = 0;","while (distTraveled < slabThickness * 0.5)","{","  distTraveled += length(normalxspacing);","  float fnumSlices = float(numSlices);","  if (distTraveled > slabThickness * 0.5)","  {","    // Before stepping outside the slab, sample at the boundaries","    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;","    trapezoid = slabTrapezoid;","  }","  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = rawSampleTexture(fragTCoordNeg);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = rawSampleTexture(fragTCoordPos);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","}","// Finally, if slab type is *mean*, divide the sum by the numSlices","if (slabType == 2)","{","  tvalue = tvalue / float(numSlices);","}"])),c){const e=["r","g","b","a"];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:d=d.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Jp("Unsupported number of independent coordinates.")}}else switch(l){case 1:d=d.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:d=d.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=Pu.substitute(i,"//VTK::TCoord::Impl",d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=["attribute vec4 vertexWC;"];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat(["attribute vec3 normalWC;","varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),a=Pu.substitute(a,"//VTK::PositionVC::Dec",c).result;let u=["gl_Position = MCPCMatrix * vertexWC;"];l>0&&(u=u.concat(["normalWCVSOutput = normalWC;","vertexWCVSOutput = vertexWC;"])),a=Pu.substitute(a,"//VTK::PositionVC::Impl",u).result,a=Pu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result;let d=[];l>0&&(d=d.concat(["varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),s=Pu.substitute(s,"//VTK::PositionVC::Dec",d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e="";const n=t.currentValidInputs[0].imageData,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`);const t=ie();n&&(e=e.concat(`Image${n.getMTime()}`),de(t,...n.getDirection()),ge(t,t));const r=[...s.getNormal()];On(r,r,t),[o,a]=function(e){La.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=La.dot(e,t);if(o<-.999999||o>.999999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ti.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=Uc.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getSpatialExtent();let l=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[l+a]=r[a],e[l+o[0]]=i[2*o[0]+n],e[l+o[1]]=i[2*o[1]+t],l+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const c=new Uint16Array(8);c[0]=3,c[1]=0,c[2]=1,c[3]=3,c[4]=3,c[5]=0,c[6]=3,c[7]=2;const u=s.getNormal();La.normalize(u);const d=new Float32Array(12);for(let e=0;e<4;++e)d[3*e]=u[0],d[3*e+1]=u[1],d[3*e+2]=u[2];t.resliceGeom||(t.resliceGeom=Uc.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(c,1);const p=Ts.newInstance({numberOfComponents:3,values:d,name:"Normals"});t.resliceGeom.getPointData().setNormals(p)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=Uc.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();La.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Ts.newInstance({numberOfComponents:3,values:a,name:"Normals"});t.resliceGeom.getPointData().setNormals(i)}else Jp("Something went wrong.","A default slice plane should have been created in the beginning of","updateResliceGeometry.");t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setScalarTextures=e=>{t.scalarTextures=[...e],t._externalOpenGLTexture=!0},e.delete=Vt((()=>{t._openGLRenderWindow&&a(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageResliceMapper");en("vtkImageResliceMapper",nf);var rf={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:of}=jt,{SlicingMode:af}=rf;function sf(e){const t=e.split("\n"),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}const lf={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineOpacityTexture:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0};const cf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lf,n),Xt.extend(e,t,n),od(e,t,n),ad(e,t,n),t.tris=Bu.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),St(e,t,[]),t.VBOBuildTime={},vt(t.VBOBuildTime),function(e,t){function n(n){t.openGLTexture.releaseGraphicsResources(n),[t._colorTransferFunc,t._pwFunc,t._labelOutlineThicknessArray,t._labelOutlineOpacity].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),t.renderable.isA("vtkImageMapper")&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(o.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==dl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=nd,e.Fragment=rd,e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=Pu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result,a=Pu.substitute(a,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result,a=Pu.substitute(a,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=["varying vec2 tcoordVCVSOutput;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D texture1;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;"];if(o.getProperty().getUseLabelOutline()&&(c=c.concat(["uniform sampler2D labelOutlineTexture1;","uniform sampler2D labelOutlineOpacityTexture1;"])),l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:c=c.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:of("Unsupported number of independent coordinates.")}}if(i=Pu.substitute(i,"//VTK::TCoord::Dec",c).result,!0===o.getProperty().getUseLabelOutline()&&(i=Pu.substitute(i,"//VTK::LabelOutline::Dec",["uniform float vpWidth;","uniform float vpHeight;","uniform float vpOffsetX;","uniform float vpOffsetY;","uniform mat4 PCWCMatrix;","uniform mat4 vWCtoIDX;","uniform ivec3 imageDimensions;","uniform int sliceAxis;"]).result,i=Pu.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result,i=Pu.substitute(i,"//VTK::LabelOutlineHelperFunction",["#ifdef vtkImageLabelOutlineOn","vec3 fragCoordToIndexSpace(vec4 fragCoord) {","  vec4 pcPos = vec4(","    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,","    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,","    (fragCoord.z - 0.5) * 2.0,","    1.0);","","  vec4 worldCoord = PCWCMatrix * pcPos;","  vec4 vertex = (worldCoord/worldCoord.w);","","  vec3 index = (vWCtoIDX * vertex).xyz;","","  // half voxel fix for labelmapOutline","  return (index + vec3(0.5)) / vec3(imageDimensions);","}","vec2 getSliceCoords(vec3 coord, int axis) {","  if (axis == 0) return coord.yz;","  if (axis == 1) return coord.xz;","  if (axis == 2) return coord.xy;","}","#endif"]).result),l){const e=["r","g","b","a"];let t=["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);break;case 2:t=t.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:of("Unsupported number of independent coordinates.")}i=Pu.substitute(i,"//VTK::TCoord::Impl",t).result}else switch(s){case 1:i=Pu.substitute(i,"//VTK::TCoord::Impl",[...sf("\n                #ifdef vtkImageLabelOutlineOn\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);\n                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;\n                  bool pixelOnBorder = false;\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\n                  float opacityToUse = scalarOpacity * opacity;\n                  int segmentIndex = int(centerValue * 255.0);\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\n                  float outlineOpacity = texture2D(labelOutlineOpacityTexture1, vec2(textureCoordinate, 0.5)).r;\n                  int actualThickness = int(textureValue * 255.0);\n\n                  if (segmentIndex == 0){\n                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);\n                    return;\n                  }\n\n                  for (int i = -actualThickness; i <= actualThickness; i++) {\n                    for (int j = -actualThickness; j <= actualThickness; j++) {\n                      if (i == 0 || j == 0) {\n                        continue;\n                      }\n                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n                        gl_FragCoord.y + float(j),\n                        gl_FragCoord.z, gl_FragCoord.w);\n                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;\n                      if (value != centerValue) {\n                        pixelOnBorder = true;\n                        break;\n                      }\n                    }\n                    if (pixelOnBorder == true) {\n                      break;\n                    }\n                  }\n                  if (pixelOnBorder == true) {\n                    gl_FragData[0] = vec4(tColor, outlineOpacity);\n                  }\n                  else {\n                    gl_FragData[0] = vec4(tColor, opacityToUse);\n                  }\n                #else\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\n                #endif\n                ")]).result;break;case 2:i=Pu.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","float intensity = tcolor.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;break;case 3:i=Pu.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;break;default:i=Pu.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result}t.haveSeenDepthRequest&&(i=Pu.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=Pu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(tt("OpenGL has a limit of 6 clipping planes"),e=6),o=Pu.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=Pu.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=Pu.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=Pu.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!!(i||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||0===e.getProgram()?.getHandle()||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<r.getProperty().getMTime()||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||of("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||of("Error setting tcoordMC in shader VAO.")),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi("texture1",a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();if(n.getProgram().setUniformi("pwfTexture1",u),o.getProperty().getUseLabelOutline()){const e=t.labelOutlineThicknessTexture.getTextureUnit();n.getProgram().setUniformi("labelOutlineTexture1",e);const r=t.labelOutlineOpacityTexture.getTextureUnit();n.getProgram().setUniformi("labelOutlineOpacityTexture1",r)}if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(tt("OpenGL has a limit of 6 clipping planes"),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),y(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),y(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",i)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();y(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(y(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();y(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix("MCPCMatrix",t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();let i=t.renderable.getClosestIJKAxis().ijkMode;i===af.NONE&&(i=af.K),a.setUniform3i("imageDimensions",o[0],o[1],o[2]),a.setUniformi("sliceAxis",i),a.setUniformMatrix("vWCtoIDX",n);const l=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,l.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const c=e.getRenderTargetSize();a.setUniformf("vpWidth",c[0]),a.setUniformf("vpHeight",c[1]);const u=e.getRenderTargetOffset();a.setUniformf("vpOffsetX",u[0]/c[0]),a.setUniformf("vpOffsetY",u[1]/c[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf("opacity",o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),r.getProperty().getUseLabelOutline()&&(t.labelOutlineThicknessTexture.activate(),t.labelOutlineOpacityTexture.activate()),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),r.getProperty().getUseLabelOutline()&&(t.labelOutlineThicknessTexture.deactivate(),t.labelOutlineOpacityTexture.deactivate()),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):of("No input!")},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||r.getProperty().getUseLabelOutline()&&(!t.labelOutlineThicknessTexture?.getHandle()||!t.labelOutlineOpacityTexture?.getHandle())||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=[];for(let e=0;e<d;++e)f.push(l.getRGBTransferFunction(e));const g=Xp(f,u,d),m=l.getRGBTransferFunction(),h=t._openGLRenderWindow.getGraphicsResourceForObject(m);if(h?.oglObject?.getHandle()&&h?.hash===g)t.colorTexture=h.oglObject;else{t.colorTexture=td.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(n*p*3);if(c===Zp.NEAREST?(t.colorTexture.setMinificationFilter(Fu.NEAREST),t.colorTexture.setMagnificationFilter(Fu.NEAREST)):(t.colorTexture.setMinificationFilter(Fu.LINEAR),t.colorTexture.setMagnificationFilter(Fu.LINEAR)),m){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:p,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.create2DFromRaw({width:n,height:1,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}m&&(t._openGLRenderWindow.setGraphicsResourceForObject(m,t.colorTexture,g),m!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(m,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=m)}const v=[];for(let e=0;e<d;++e)v.push(l.getPiecewiseFunction(e));const T=Xp(v,u,d),y=l.getPiecewiseFunction(),b=t._openGLRenderWindow.getGraphicsResourceForObject(y);if(b?.oglObject?.getHandle()&&b?.hash===T)t.pwfTexture=b.oglObject;else{let n=t.renderable.getOpacityTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=td.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),c===Zp.NEAREST?(t.pwfTexture.setMinificationFilter(Fu.NEAREST),t.pwfTexture.setMagnificationFilter(Fu.NEAREST)):(t.pwfTexture.setMinificationFilter(Fu.LINEAR),t.pwfTexture.setMagnificationFilter(Fu.LINEAR)),y){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=l.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:p,numComps:1,dataType:is.FLOAT,data:e})}else o.fill(255),t.pwfTexture.create2DFromRaw({width:n,height:1,numComps:1,dataType:is.UNSIGNED_CHAR,data:o});y&&(t._openGLRenderWindow.setGraphicsResourceForObject(y,t.pwfTexture,T),y!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(y,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=y)}r.getProperty().getUseLabelOutline()&&(e.updatelabelOutlineThicknessTexture(r),e.updateLabelOutlineOpacityTexture(r));const{ijkMode:x}=t.renderable.getClosestIJKAxis();let C=t.renderable.getSlice();x!==t.renderable.getSlicingMode()&&(C=t.renderable.getSliceAtPosition(C));const S=t.renderable.isA("vtkImageArrayMapper")?t.renderable.getSubSlice():Math.round(C),A=o.getExtent();let I;x===af.I&&(I=S-A[0]),x===af.J&&(I=S-A[2]),x!==af.K&&x!==af.NONE||(I=S-A[4]);const w=`${C}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==w){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=td.newInstance({resizable:!0})),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),c===Zp.NEAREST?(new Set([1,3,4]).has(s)&&i===is.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Fu.NEAREST)):t.openGLTexture.setMinificationFilter(Fu.NEAREST),t.openGLTexture.setMagnificationFilter(Fu.NEAREST)):(4!==s||i!==is.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(Fu.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Fu.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(Fu.LINEAR)),t.openGLTexture.setWrapS(Nu.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Nu.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[af.X,af.Y,af.Z].includes(t.renderable.getSlicingMode())?C:S,p=o.getSpatialExtent(),f=a.getData();let g=null;if(x===af.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(I+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(x===af.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+I*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else x===af.K||x===af.NONE?(g=f.subarray(I*n,(I+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):of("Reformat slicing not yet supported.");const m=a.getRanges();t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw({width:e[0],height:e[1],numComps:s,dataType:a.getDataType(),data:g,preferSizeOverAccuracy:!!t.renderable.getPreferSizeOverAccuracy?.(),ranges:m}),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const h=Ts.newInstance({numberOfComponents:3,values:r});h.setName("points");const v=Ts.newInstance({numberOfComponents:2,values:l});v.setName("tcoords");const T=new Uint16Array(8);T[0]=3,T[1]=0,T[2]=1,T[3]=3,T[4]=3,T[5]=0,T[6]=3,T[7]=2;const y=Ts.newInstance({numberOfComponents:1,values:T});t.tris.getCABO().createVBO(y,"polys",qi.SURFACE,{points:h,tcoords:v,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=w}},e.updateLabelOutlineOpacityTexture=n=>{let r=n.getProperty().getLabelOutlineOpacity();"number"==typeof r&&(r=t._cachedLabelOutlineOpacityObj?.[0]===r?t._cachedLabelOutlineOpacityObj:[r],t._cachedLabelOutlineOpacityObj=r);const o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineOpacityTexture=o.oglObject;else{let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const o=1,i=new Float32Array(n*o);for(let e=0;e<n;++e)i[e]=r[e]??r[0];t.labelOutlineOpacityTexture=td.newInstance({resizable:!1}),t.labelOutlineOpacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineOpacityTexture.resetFormatAndType(),t.labelOutlineOpacityTexture.setMinificationFilter(Fu.NEAREST),t.labelOutlineOpacityTexture.setMagnificationFilter(Fu.NEAREST),t.labelOutlineOpacityTexture.create2DFromRaw({width:n,height:o,numComps:1,dataType:is.FLOAT,data:i}),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineOpacityTexture,a),r!==t._labelOutlineOpacity&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineOpacity,e)),t._labelOutlineOpacity=r)}},e.updatelabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThicknessByReference(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture=td.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Fu.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Fu.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw({width:n,height:o,numComps:1,dataType:is.UNSIGNED_CHAR,data:i}),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageMapper");en("vtkAbstractImageMapper",cf);const uf=0,df=1,pf=2,{vtkErrorMacro:ff}=Ht,gf={currentRenderPass:null,volumeTexture:null,colorTexture:null,pwfTexture:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const mf=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gf,n),Xt.extend(e,t,n),od(e,t,n),Ht.algo(e,t,2,0),t.tris=Bu.newInstance(),t.volumeTexture=null,t.colorTexture=null,t.pwfTexture=null,t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},Ht.obj(t.VBOBuildTime,{mtime:0}),function(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageCPRMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()===dl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),e.invokeEvent({type:"EndEvent"}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(n,r)=>{e.getNeedToRebuildBufferObjects(n,r)&&e.buildBufferObjects(n,r),r.getProperty().getInterpolationType()===Zp.NEAREST?(t.volumeTexture.setMinificationFilter(Fu.NEAREST),t.volumeTexture.setMagnificationFilter(Fu.NEAREST),t.colorTexture.setMinificationFilter(Fu.NEAREST),t.colorTexture.setMagnificationFilter(Fu.NEAREST),t.pwfTexture.setMinificationFilter(Fu.NEAREST),t.pwfTexture.setMagnificationFilter(Fu.NEAREST)):(t.volumeTexture.setMinificationFilter(Fu.LINEAR),t.volumeTexture.setMagnificationFilter(Fu.LINEAR),t.colorTexture.setMinificationFilter(Fu.LINEAR),t.colorTexture.setMagnificationFilter(Fu.LINEAR),t.pwfTexture.setMinificationFilter(Fu.LINEAR),t.pwfTexture.setMagnificationFilter(Fu.LINEAR))},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()||!t.volumeTexture?.getHandle()},e.buildBufferObjects=(n,r)=>{const o=t.currentImageDataInput,a=t.currentCenterlineInput,i=r.getProperty(),s=o?.getPointData()?.getScalars();if(!s)return;const l=t._openGLRenderWindow.getGraphicsResourceForObject(s),c=Yp(0,s),u=!l?.oglObject?.getHandle()||l?.hash!==c,d=i.getUpdatedExtents(),p=!!d.length;if(u){t.volumeTexture=td.newInstance(),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.volumeTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromDataArray({width:n[0],height:n[1],depth:n[2],dataArray:s,preferSizeOverAccuracy:t.renderable.getPreferSizeOverAccuracy()}),t._openGLRenderWindow.setGraphicsResourceForObject(s,t.volumeTexture,c),s!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(s,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=s}else t.volumeTexture=l.oglObject;if(p){i.setUpdatedExtents([]);const e=o.getDimensions();t.volumeTexture.create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:s,updatedExtents:d})}const f=s.getNumberOfComponents(),g=r.getProperty(),m=g.getIndependentComponents(),h=m?f:1,v=m?2*h:1,T=[];for(let e=0;e<h;++e)T.push(g.getRGBTransferFunction(e));const y=Xp(T,m,h),b=g.getRGBTransferFunction(),x=t._openGLRenderWindow.getGraphicsResourceForObject(b);if(x?.oglObject?.getHandle()&&x?.hash===y)t.colorTexture=x.oglObject;else{let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(n*v*3);if(t.colorTexture=td.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),b){const e=new Float32Array(3*n);for(let t=0;t<h;t++){const o=g.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),m)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:v,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:1,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}b&&(t._openGLRenderWindow.setGraphicsResourceForObject(b,t.colorTexture,y),b!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(b,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=b)}const C=[];for(let e=0;e<h;++e)C.push(g.getPiecewiseFunction(e));const S=Xp(C,m,h),A=g.getPiecewiseFunction(),I=t._openGLRenderWindow.getGraphicsResourceForObject(A);if(I?.oglObject?.getHandle()&&I?.hash===S)t.pwfTexture=I.oglObject;else{let n=t.renderable.getOpacityTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=n*v,o=new Uint8ClampedArray(r);if(t.pwfTexture=td.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),A){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<h;++t){const r=g.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),m)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:v,numComps:1,dataType:is.FLOAT,data:e})}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:1,numComps:1,dataType:is.UNSIGNED_CHAR,data:o});A&&(t._openGLRenderWindow.setGraphicsResourceForObject(A,t.pwfTexture,S),A!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(A,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=A)}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<a.getMTime()){const e=a.getNumberOfPoints(),n=e<=1?0:e-1,r=a.getDistancesToFirstPoint(),o=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,o-r[e],0],t),t+=3,s.set([l,o-r[e],0],t),t+=3,s.set([l,o-r[e+1],0],t),t+=3,s.set([0,o-r[e+1],0],t),t+=3;const c=Ts.newInstance({numberOfComponents:3,values:s});c.setName("points");const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Ts.newInstance({numberOfComponents:1,values:u}),p=a.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Ts.newInstance({numberOfComponents:3,values:f,name:"centerlinePosition"}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const T=[h,Ts.newInstance({numberOfComponents:1,values:v,name:"quadIndex"})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getOrientedCenterline().getOrientations()??[],r=new Float32Array(4*i),o=new Float32Array(4*i);for(let t=0;t<n;++t){const n=e[t],a=e[t+1];for(let e=0;e<4;++e){const i=4*(e+4*t);r.set(n,i),o.set(a,i)}}const a=Ts.newInstance({numberOfComponents:4,values:r,name:"centerlineTopOrientation"}),s=Ts.newInstance({numberOfComponents:4,values:o,name:"centerlineBotOrientation"});T.push(a,s)}t.tris.getCABO().createVBO(d,"polys",qi.SURFACE,{points:c,customAttributes:T}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation(),l=t.renderable.isProjectionEnabled()&&t.renderable.getProjectionMode();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastProjectionMode!==l||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastProjectionMode=l,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;const s=["vec3 applyQuaternionToVec(vec4 q, vec3 v) {","  float uvx = q.y * v.z - q.z * v.y;","  float uvy = q.z * v.x - q.x * v.z;","  float uvz = q.x * v.y - q.y * v.x;","  float uuvx = q.y * uvz - q.z * uvy;","  float uuvy = q.z * uvx - q.x * uvz;","  float uuvz = q.x * uvy - q.y * uvx;","  float w2 = q.w * 2.0;","  uvx *= w2;","  uvy *= w2;","  uvz *= w2;","  uuvx *= 2.0;","  uuvy *= 2.0;","  uuvz *= 2.0;","  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);","}"];a=Pu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result;const l=["attribute vec3 centerlinePosition;","attribute float quadIndex;","uniform float width;","out vec2 quadOffsetVSOutput;","out vec3 centerlinePosVSOutput;"],c=t.renderable.isProjectionEnabled(),u=t.renderable.getUseUniformOrientation();u?(l.push("out vec3 samplingDirVSOutput;","uniform vec4 centerlineOrientation;","uniform vec3 tangentDirection;",...s),c&&l.push("out vec3 projectionDirVSOutput;","uniform vec3 bitangentDirection;")):l.push("out vec4 centerlineTopOrientationVSOutput;","out vec4 centerlineBotOrientationVSOutput;","attribute vec4 centerlineTopOrientation;","attribute vec4 centerlineBotOrientation;"),a=Pu.substitute(a,"//VTK::Color::Dec",l).result;const d=["quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);","centerlinePosVSOutput = centerlinePosition;"];u?(d.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);"),c&&d.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);")):d.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;","centerlineBotOrientationVSOutput = centerlineBotOrientation;"),a=Pu.substitute(a,"//VTK::Color::Impl",d).result;const p=t.volumeTexture.getComponents(),f=o.getProperty().getIndependentComponents();let g=["uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates","in vec2 quadOffsetVSOutput;","in vec3 centerlinePosVSOutput;","uniform highp sampler3D volumeTexture;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;"];c&&g.push("uniform vec3 volumeSizeMC;","uniform int projectionSlabNumberOfSamples;","uniform float projectionConstantOffset;","uniform float projectionStepLength;"),u?(g.push("in vec3 samplingDirVSOutput;"),c&&g.push("in vec3 projectionDirVSOutput;")):(g.push("uniform vec3 tangentDirection;","in vec4 centerlineTopOrientationVSOutput;","in vec4 centerlineBotOrientationVSOutput;",...s),c&&g.push("uniform vec3 bitangentDirection;"));const m=t.renderable.getCenterPoint();if(m&&g.push("uniform vec3 globalCenterPoint;"),f){for(let e=1;e<p;e++)g=g.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(p){case 1:g=g.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:g=g.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:ff("Unsupported number of independent coordinates.")}}i=Pu.substitute(i,"//VTK::TCoord::Dec",g).result;let h=[];if(u?(h.push("vec3 samplingDirection = samplingDirVSOutput;"),c&&h.push("vec3 projectionDirection = projectionDirVSOutput;")):(h.push("vec4 q0 = centerlineBotOrientationVSOutput;","vec4 q1 = centerlineTopOrientationVSOutput;","float qCosAngle = dot(q0, q1);","vec4 interpolatedOrientation;","if (qCosAngle > 0.999 || qCosAngle < -0.999) {","  // Use LERP instead of SLERP when the two quaternions are close or opposite","  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));","} else {","  float omega = acos(qCosAngle);","  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);","}","vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"),c&&h.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);")),m?h.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);","float horizontalOffset = quadOffsetVSOutput.x + baseOffset;"):h.push("float horizontalOffset = quadOffsetVSOutput.x;"),h.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;","vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;","if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}"),c){const e=t.renderable.getProjectionMode();switch(e===df?h.push("const vec4 initialProjectionTextureValue = vec4(1.0);"):h.push("const vec4 initialProjectionTextureValue = vec4(0.0);"),h.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;","vec3 projectionStep = projectionStepLength * projectionScaledDirection;","vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;","vec4 tvalue = initialProjectionTextureValue;","for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {","  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;","  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);"),e){case uf:h.push("  tvalue = max(tvalue, sampledTextureValue);");break;case df:h.push("  tvalue = min(tvalue, sampledTextureValue);");break;default:h.push("  tvalue = tvalue + sampledTextureValue;")}h.push("}"),e===pf&&h.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);")}else h.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");if(f){const e=["r","g","b","a"];for(let t=0;t<p;++t)h=h.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(p){case 1:h=h.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:h=h.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:ff("Unsupported number of independent coordinates.")}}else switch(p){case 1:h=h.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:h=h.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=Pu.substitute(i,"//VTK::TCoord::Impl",h).result,t.haveSeenDepthRequest&&(i=Pu.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=Pu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(Ht.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6),o=Pu.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=Pu.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=Pu.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=Pu.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=nd,e.Fragment=rd,e.Geometry=""},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=n.getCABO();i.getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(a,i,"vertexMC",i.getVertexOffset(),i.getStride(),t.context.FLOAT,3,t.context.FALSE)||ff("Error setting vertexMC in shader VAO.")),n.getCABO().getCustomData().forEach((e=>{e&&a.isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(a,i,e.name,e.offset,i.getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&ff(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const s=t.volumeTexture.getTextureUnit();if(a.setUniformi("volumeTexture",s),a.setUniformf("width",t.renderable.getWidth()),n.getProgram().setUniform4fv("backgroundColor",t.renderable.getBackgroundColor()),a.isUniformUsed("tangentDirection")){const e=t.renderable.getTangentDirection();n.getProgram().setUniform3fArray("tangentDirection",e)}if(a.isUniformUsed("bitangentDirection")){const e=t.renderable.getBitangentDirection();n.getProgram().setUniform3fArray("bitangentDirection",e)}if(a.isUniformUsed("centerlineOrientation")){const e=t.renderable.getUniformOrientation();n.getProgram().setUniform4fv("centerlineOrientation",e)}if(a.isUniformUsed("globalCenterPoint")){const e=t.renderable.getCenterPoint();a.setUniform3fArray("globalCenterPoint",e)}if(t.renderable.isProjectionEnabled()){const e=t.currentImageDataInput,n=e.getSpacing(),r=e.getDimensions(),o=t.renderable.getProjectionSlabThickness(),i=t.renderable.getProjectionSlabNumberOfSamples(),s=En([],n,r);a.setUniform3fArray("volumeSizeMC",s),a.setUniformi("projectionSlabNumberOfSamples",i);const l=-.5*o;a.setUniformf("projectionConstantOffset",l);const c=o/(i-1);a.setUniformf("projectionStepLength",c)}const l=t.currentImageDataInput,c=l.getWorldToIndex(),u=O(new Float32Array(16),Cn([],l.getDimensions())),p=oe(u,u,c);if(a.setUniformMatrix("MCTCMatrix",p),t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(Ht.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6);const n=i.getCoordShiftAndScaleEnabled()?i.getInverseShiftAndScaleMatrix():null,r=n?d(t.imagematinv,o.getMatrix()):o.getMatrix();n&&(m(r,r),y(r,r,n),m(r,r)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),y(t.imagematinv,r,t.imagemat);const s=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)s.push(e[t])}a.setUniformi("numClipPlanes",e),a.setUniform4fv("clipPlanes",s)}if(a.isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);a.setUniformf("coffset",t.offset),a.isUniformUsed("cfactor")&&a.setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(y(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();y(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix("MCPCMatrix",t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.delete=Ht.chain((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageCPRMapper");en("vtkImageCPRMapper",mf);const hf={context:null,keyMatrixTime:null,keyMatrices:null};const vf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hf,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},St(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLImageSlice"),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}(e,t)}),"vtkOpenGLImageSlice");en("vtkImageSlice",vf);const Tf={};const yf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),St(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLVolume"),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}(e,t)}),"vtkOpenGLVolume");en("vtkVolume",yf);const bf={NEAREST:0,LINEAR:1,FAST_LINEAR:2},xf={FRACTIONAL:0,PROPORTIONAL:1},Cf={DEFAULT:0,ADDITIVE:1,COLORIZE:2,CUSTOM:3};var Sf={InterpolationType:bf,OpacityMode:xf,ColorMixPreset:Cf,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const Af={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5,LABELMAP_EDGE_PROJECTION_BLEND:6};var If={BlendMode:Af};const{vtkWarningMacro:wf,vtkErrorMacro:Of}=jt,Pf={idxToView:g(new Float64Array(16)),vecISToVCMatrix:pe(new Float64Array(9)),modelToView:g(new Float64Array(16)),projectionToView:g(new Float64Array(16)),projectionToWorld:g(new Float64Array(16))};const Rf={context:null,VBOBuildTime:null,scalarTextures:[],_scalarTexturesCore:[],opacityTexture:null,_opacityTextureCore:null,colorTexture:null,_colorTextureCore:null,labelOutlineThicknessTexture:null,_labelOutlineThicknessTextureCore:null,jitterTexture:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,fullViewportTime:1,idxToView:null,vecISToVCMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0};const Mf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),Xt.extend(e,t,n),ad(e,t,n),t.VBOBuildTime={},vt(t.VBOBuildTime,{mtime:0}),t.tris=Bu.newInstance(),t.jitterTexture=td.newInstance(),t.jitterTexture.setWrapS(Nu.REPEAT),t.jitterTexture.setWrapT(Nu.REPEAT),t.framebuffer=qd.newInstance(),St(e,t,["context"]),function(e,t){function n(e){return e.getUseLabelOutline()||t.renderable.getBlendMode()===Af.LABELMAP_EDGE_PROJECTION_BLEND}t.classHierarchy.push("vtkOpenGLVolumeMapper");const r=new Map;function o(t,n,o){n!==o&&(function(t,n){if(!n)return;const o=(r.get(n)??0)-1;o<=0?(t.unregisterGraphicsResourceUser(n,e),r.delete(n)):r.set(n,o)}(t,n),function(t,n){if(!n)return;const o=r.get(n)??0,a=o+1;r.set(n,a),o<=0&&t.registerGraphicsResourceUser(n,e)}(t,o))}function a(t){[...r.keys()].forEach((n=>t.unregisterGraphicsResourceUser(n,e)))}e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(n,r)=>{if(n){const n=t._openGLRenderWindow;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),n&&!n.isDeleted()&&n!==t._openGLRenderWindow&&a(n),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType("vtkOpenGLVolume");const r=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),e.renderPiece(o,r)}},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\nconst float infinity = 3.402823466e38;\n\n// the output of this shader\n//VTK::Output::Dec\n\nin vec3 vertexVCVSOutput;\n\n// From Sources\\Rendering\\Core\\VolumeProperty\\Constants.js\n#define COMPOSITE_BLEND 0\n#define MAXIMUM_INTENSITY_BLEND 1\n#define MINIMUM_INTENSITY_BLEND 2\n#define AVERAGE_INTENSITY_BLEND 3\n#define ADDITIVE_INTENSITY_BLEND 4\n#define RADON_TRANSFORM_BLEND 5\n#define LABELMAP_EDGE_PROJECTION_BLEND 6\n\n#define vtkNumberOfLights //VTK::NumberOfLights\n#define vtkMaxLaoKernelSize //VTK::MaxLaoKernelSize\n#define vtkNumberOfComponents //VTK::NumberOfComponents\n#define vtkBlendMode //VTK::BlendMode\n#define vtkMaximumNumberOfSamples //VTK::MaximumNumberOfSamples\n\n//VTK::EnabledColorFunctions\n\n//VTK::EnabledLightings\n\n//VTK::EnabledMultiTexturePerVolume\n\n//VTK::EnabledGradientOpacity\n\n//VTK::EnabledIndependentComponents\n\n//VTK::vtkProportionalComponents\n\n//VTK::vtkForceNearestComponents\n\nuniform int twoSidedLighting;\n\n#if vtkMaxLaoKernelSize > 0\n  vec2 kernelSample[vtkMaxLaoKernelSize];\n#endif\n\n// Textures\n#ifdef EnabledMultiTexturePerVolume\n  #define vtkNumberOfVolumeTextures vtkNumberOfComponents\n#else\n  #define vtkNumberOfVolumeTextures 1\n#endif\nuniform highp sampler3D volumeTexture[vtkNumberOfVolumeTextures];\nuniform sampler2D colorTexture;\nuniform sampler2D opacityTexture;\nuniform sampler2D jtexture;\nuniform sampler2D labelOutlineThicknessTexture;\n\nstruct Volume {\n  // ---- Volume geometry settings ----\n\n  vec3 originVC;          // in VC\n  vec3 spacing;           // in VC per IC\n  vec3 inverseSpacing;    // 1/spacing\n  ivec3 dimensions;       // in IC\n  vec3 inverseDimensions; // 1/vec3(dimensions)\n  mat3 vecISToVCMatrix;   // convert from IS to VC without translation\n  mat3 vecVCToISMatrix;   // convert from VC to IS without translation\n  mat4 PCWCMatrix;\n  mat4 worldToIndex;\n  float diagonalLength; // in VC, this is: length(size)\n\n  // ---- Texture settings ----\n\n  // Texture shift and scale\n  vec4 colorTextureScale;\n  vec4 colorTextureShift;\n  vec4 opacityTextureScale;\n  vec4 opacityTextureShift;\n\n  // The heights defined below are the locations for the up to four components\n  // of the transfer functions. The transfer functions have a height of (2 *\n  // numberOfComponents) pixels so the values are computed to hit the middle of\n  // the two rows for that component\n  vec4 transferFunctionsSampleHeight;\n\n  // ---- Mode specific settings ----\n\n  // Independent component default preset settings per component\n  vec4 independentComponentMix;\n\n  // Additive / average blending mode settings\n  vec4 ipScalarRangeMin;\n  vec4 ipScalarRangeMax;\n\n  // ---- Rendering settings ----\n\n  // Lighting\n  float ambient;\n  float diffuse;\n  float specular;\n  float specularPower;\n  int computeNormalFromOpacity;\n\n  // Gradient opacity\n  vec4 gradientOpacityScale;\n  vec4 gradientOpacityShift;\n  vec4 gradientOpacityMin;\n  vec4 gradientOpacityMax;\n\n  // Volume shadow\n  float volumetricScatteringBlending;\n  float globalIlluminationReach;\n  float anisotropy;\n  float anisotropySquared;\n\n  // LAO\n  int kernelSize;\n  int kernelRadius;\n\n  // Label outline\n  float outlineOpacity;\n};\nuniform Volume volume;\n\nstruct Light {\n  vec3 color;\n  vec3 positionVC;\n  vec3 directionVC; // normalized\n  vec3 halfAngleVC;\n  vec3 attenuation;\n  float exponent;\n  float coneAngle;\n  int isPositional;\n};\n#if vtkNumberOfLights > 0\n  uniform Light lights[vtkNumberOfLights];\n#endif\n\nuniform float vpWidth;\nuniform float vpHeight;\nuniform float vpOffsetX;\nuniform float vpOffsetY;\n\n// Bitmasks for label outline\nconst int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\n#define MAX_SEGMENTS 256\n#define UINT_SIZE 32\n// We add UINT_SIZE - 1, as we want the ceil of the division instead of the\n// floor\n#define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\nuint labelOutlineBitmasks[BITMASK_SIZE];\n\n// Set the corresponding bit in the bitmask\nvoid setLabelOutlineBit(int segmentIndex) {\n  int arrayIndex = segmentIndex / UINT_SIZE;\n  int bitIndex = segmentIndex % UINT_SIZE;\n  labelOutlineBitmasks[arrayIndex] |= 1u << bitIndex;\n}\n\n// Check if a bit is set in the bitmask\nbool isLabelOutlineBitSet(int segmentIndex) {\n  int arrayIndex = segmentIndex / UINT_SIZE;\n  int bitIndex = segmentIndex % UINT_SIZE;\n  return ((labelOutlineBitmasks[arrayIndex] & (1u << bitIndex)) != 0u);\n}\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n//VTK::ClipPlane::Dec\n\n// A random number between 0 and 1 that only depends on the fragment\n// It uses the jtexture, so this random seed repeats by blocks of 32 fragments\n// in screen space\nfloat fragmentSeed;\n\n// sample texture is global\nuniform float sampleDistance;\nuniform float volumeShadowSampleDistance;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics\n// rendering module is complete)\nvec3 rayDirVC;\n\n#define INV4PI 0.0796\n#define EPSILON 0.001\n#define PI 3.1415\n#define PI2 9.8696\n\nvec4 rawSampleTexture(vec3 pos) {\n  #ifdef EnabledMultiTexturePerVolume\n    vec4 rawSample;\n    rawSample[0] = texture(volumeTexture[0], pos)[0];\n  #if vtkNumberOfComponents > 1\n    rawSample[1] = texture(volumeTexture[1], pos)[0];\n  #endif\n  #if vtkNumberOfComponents > 2\n    rawSample[2] = texture(volumeTexture[2], pos)[0];\n  #endif\n  #if vtkNumberOfComponents > 3\n    rawSample[3] = texture(volumeTexture[3], pos)[0];\n  #endif\n    return rawSample;\n  #else\n    return texture(volumeTexture[0], pos);\n  #endif\n}\n\nvec4 rawFetchTexture(ivec3 pos) {\n  #ifdef EnabledMultiTexturePerVolume\n    vec4 rawSample;\n    #if vtkNumberOfComponents > 0\n      rawSample[0] = texelFetch(volumeTexture[0], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 1\n      rawSample[1] = texelFetch(volumeTexture[1], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 2\n      rawSample[2] = texelFetch(volumeTexture[2], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 3\n      rawSample[3] = texelFetch(volumeTexture[3], pos, 0)[0];\n    #endif\n    return rawSample;\n  #else\n    return texelFetch(volumeTexture[0], pos, 0);\n  #endif\n}\n\nvec4 getTextureValue(vec3 pos) {\n  vec4 tmp = rawSampleTexture(pos);\n\n  // Force nearest\n  #if defined(vtkComponent0ForceNearest) || \\\n      defined(vtkComponent1ForceNearest) || \\\n      defined(vtkComponent2ForceNearest) || \\\n      defined(vtkComponent3ForceNearest)\n    vec3 nearestPos = (floor(pos * vec3(volume.dimensions)) + 0.5) *\n                      volume.inverseDimensions;\n    vec4 nearestValue = rawSampleTexture(nearestPos);\n    #ifdef vtkComponent0ForceNearest\n      tmp[0] = nearestValue[0];\n    #endif\n    #ifdef vtkComponent1ForceNearest\n      tmp[1] = nearestValue[1];\n    #endif\n    #ifdef vtkComponent2ForceNearest\n      tmp[2] = nearestValue[2];\n    #endif\n    #ifdef vtkComponent3ForceNearest\n      tmp[3] = nearestValue[3];\n    #endif\n  #endif\n\n  // Set alpha when using dependent components\n  #ifndef EnabledIndependentComponents\n    #if vtkNumberOfComponents == 1\n      tmp.a = tmp.r;\n    #endif\n    #if vtkNumberOfComponents == 2\n      tmp.a = tmp.g;\n    #endif\n    #if vtkNumberOfComponents == 3\n      tmp.a = length(tmp.rgb);\n    #endif\n  #endif\n\n  return tmp;\n}\n\n// `height` is usually `volume.transferFunctionsSampleHeight[component]`\n// when using independent component and `0.5` otherwise. Don't move the if\n// statement in these function, as the callers usually already knows if it is\n// using independent component or not\nfloat getOpacityFromTexture(float scalar, int component, float height) {\n  float scaledScalar = scalar * volume.opacityTextureScale[component] +\n                       volume.opacityTextureShift[component];\n  return texture2D(opacityTexture, vec2(scaledScalar, height)).r;\n}\nvec3 getColorFromTexture(float scalar, int component, float height) {\n  float scaledScalar = scalar * volume.colorTextureScale[component] +\n                       volume.colorTextureShift[component];\n  return texture2D(colorTexture, vec2(scaledScalar, height)).rgb;\n}\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\nvec3 posIStoVC(vec3 posIS) {\n  return volume.vecISToVCMatrix * posIS + volume.originVC;\n}\n\n// convert vector position from vc to idx\nvec3 posVCtoIS(vec3 posVC) {\n  return volume.vecVCToISMatrix * (posVC - volume.originVC);\n}\n\n// Rotate vector to view coordinate\nvec3 vecISToVC(vec3 dirIS) {\n  return volume.vecISToVCMatrix * dirIS;\n}\n\n// Rotate vector to idx coordinate\nvec3 vecVCToIS(vec3 dirVC) {\n  return volume.vecVCToISMatrix * dirVC;\n}\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(float normalMag, int component) {\n  float goscale = volume.gradientOpacityScale[component];\n  float goshift = volume.gradientOpacityShift[component];\n  float gomin = volume.gradientOpacityMin[component];\n  float gomax = volume.gradientOpacityMax[component];\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n}\n\n#ifdef vtkClippingPlanesOn\n  bool isPointClipped(vec3 posVC) {\n    for (int i = 0; i < clip_numPlanes; ++i) {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0) {\n        return true;\n      }\n    }\n    return false;\n  }\n#endif\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward\n// difference\n\n// The output normal is in VC\nvec4 computeDensityNormal(vec3 opacityUCoords[2], float opacityTextureHeight,\n                          float gradientOpacity, int component) {\n  // Pass the scalars through the opacity functions\n  vec4 opacityG;\n  opacityG.x += getOpacityFromTexture(opacityUCoords[0].x, component,\n                                      opacityTextureHeight);\n  opacityG.y += getOpacityFromTexture(opacityUCoords[0].y, component,\n                                      opacityTextureHeight);\n  opacityG.z += getOpacityFromTexture(opacityUCoords[0].z, component,\n                                      opacityTextureHeight);\n  opacityG.x -= getOpacityFromTexture(opacityUCoords[1].x, component,\n                                      opacityTextureHeight);\n  opacityG.y -= getOpacityFromTexture(opacityUCoords[1].y, component,\n                                      opacityTextureHeight);\n  opacityG.z -= getOpacityFromTexture(opacityUCoords[1].z, component,\n                                      opacityTextureHeight);\n\n  // Divide by spacing and convert to VC\n  opacityG.xyz *= gradientOpacity * volume.inverseSpacing;\n  opacityG.w = length(opacityG.xyz);\n  if (opacityG.w == 0.0) {\n    return vec4(0.0);\n  }\n\n  // Normalize\n  opacityG.xyz = normalize(vecISToVC(opacityG.xyz));\n\n  return opacityG;\n}\n\n// The output normal is in VC\nvec4 computeNormalForDensity(vec3 posIS, out vec3 scalarInterp[2],\n                             const int opacityComponent) {\n  vec3 offsetedPosIS;\n  for (int axis = 0; axis < 3; ++axis) {\n    // Positive direction\n    offsetedPosIS = posIS;\n    offsetedPosIS[axis] += volume.inverseDimensions[axis];\n    scalarInterp[0][axis] =\n        getTextureValue(offsetedPosIS)[opacityComponent];\n    #ifdef vtkClippingPlanesOn\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\n        scalarInterp[0][axis] = 0.0;\n      }\n    #endif\n\n    // Negative direction\n    offsetedPosIS = posIS;\n    offsetedPosIS[axis] -= volume.inverseDimensions[axis];\n    scalarInterp[1][axis] =\n        getTextureValue(offsetedPosIS)[opacityComponent];\n    #ifdef vtkClippingPlanesOn\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\n        scalarInterp[1][axis] = 0.0;\n      }\n    #endif\n  }\n\n  vec4 result;\n  result.xyz = (scalarInterp[0] - scalarInterp[1]) * volume.inverseSpacing;\n  result.w = length(result.xyz);\n  if (result.w == 0.0) {\n    return vec4(0.0);\n  }\n  result.xyz = normalize(vecISToVC(result.xyz));\n  return result;\n}\n\nvec4 fragCoordToPCPos(vec4 fragCoord) {\n  return vec4((fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n              (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n              (fragCoord.z - 0.5) * 2.0, 1.0);\n}\n\nvec4 pcPosToWorldCoord(vec4 pcPos) {\n  return volume.PCWCMatrix * pcPos;\n}\n\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\n  vec4 vertex = (worldCoord / worldCoord.w);\n\n  vec3 index = (volume.worldToIndex * vertex).xyz;\n\n  // half voxel fix for labelmapOutline\n  return (index + vec3(0.5)) * volume.inverseDimensions;\n}\n\nvec3 fragCoordToWorld(vec4 fragCoord) {\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\n  return worldCoord.xyz;\n}\n\n//=======================================================================\n// Compute the normals and gradient magnitudes for a position for independent\n// components The output normals are in VC\nmat4 computeMat4Normal(vec3 posIS, vec4 tValue) {\n  vec3 xvec = vec3(volume.inverseDimensions.x, 0.0, 0.0);\n  vec3 yvec = vec3(0.0, volume.inverseDimensions.y, 0.0);\n  vec3 zvec = vec3(0.0, 0.0, volume.inverseDimensions.z);\n\n  vec4 distX = getTextureValue(posIS + xvec) - getTextureValue(posIS - xvec);\n  vec4 distY = getTextureValue(posIS + yvec) - getTextureValue(posIS - yvec);\n  vec4 distZ = getTextureValue(posIS + zvec) - getTextureValue(posIS - zvec);\n\n  // divide by spacing\n  distX *= 0.5 * volume.inverseSpacing.x;\n  distY *= 0.5 * volume.inverseSpacing.y;\n  distZ *= 0.5 * volume.inverseSpacing.z;\n\n  mat4 result;\n\n  // optionally compute the 1st component\n  #if vtkNumberOfComponents > 0 && !defined(vtkComponent0Proportional)\n    {\n      const int component = 0;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 2nd component\n  #if vtkNumberOfComponents > 1 && !defined(vtkComponent1Proportional)\n    {\n      const int component = 1;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 3rd component\n  #if vtkNumberOfComponents > 2 && !defined(vtkComponent2Proportional)\n    {\n      const int component = 2;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 4th component\n  #if vtkNumberOfComponents > 3 && !defined(vtkComponent3Proportional)\n    {\n      const int component = 3;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n\n// henyey greenstein phase function\nfloat phaseFunction(float cos_angle) {\n  // divide by 2.0 instead of 4pi to increase intensity\n  float anisotropy = volume.anisotropy;\n  if (abs(anisotropy) <= EPSILON) {\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    return 0.5;\n  }\n  float anisotropy2 = volume.anisotropySquared;\n  return ((1.0 - anisotropy2) /\n          pow(1.0 + anisotropy2 - 2.0 * anisotropy * cos_angle, 1.5)) /\n         2.0;\n}\n\n// Compute the two intersection distances of the ray with the volume in VC\n// The entry point is `rayOriginVC + distanceMin * rayDirVC` and the exit point\n// is `rayOriginVC + distanceMax * rayDirVC` If distanceMin < distanceMax, the\n// volume is not intersected The ray origin is inside the box when distanceMin <\n// 0.0 < distanceMax\nvec2 rayIntersectVolumeDistances(vec3 rayOriginVC, vec3 rayDirVC) {\n  // Compute origin and direction in IS\n  vec3 rayOriginIS = posVCtoIS(rayOriginVC);\n  vec3 rayDirIS = vecVCToIS(rayDirVC);\n  // Don't check for infinity as the min/max combination afterward will always\n  // find an intersection before infinity\n  vec3 invDir = 1.0 / rayDirIS;\n\n  // We have: bound = origin + t * dir\n  // So: t = (1/dir) * (bound - origin)\n  vec3 distancesTo0 = invDir * (vec3(0.0) - rayOriginIS);\n  vec3 distancesTo1 = invDir * (vec3(1.0) - rayOriginIS);\n  // Min and max distances to plane intersection per plane\n  vec3 dMinPerAxis = min(distancesTo0, distancesTo1);\n  vec3 dMaxPerAxis = max(distancesTo0, distancesTo1);\n  // Overall first and last intersection\n  float distanceMin = max(dMinPerAxis.x, max(dMinPerAxis.y, dMinPerAxis.z));\n  float distanceMax = min(dMaxPerAxis.x, min(dMaxPerAxis.y, dMaxPerAxis.z));\n  return vec2(distanceMin, distanceMax);\n}\n\n//=======================================================================\n// local ambient occlusion\n#if vtkMaxLaoKernelSize > 0\n\n  // Return a random point on the unit sphere\n  vec3 sampleDirectionUniform(int rayIndex) {\n    // Each ray of each fragment should be different, two sources of randomness\n    // are used. Only depends on ray index\n    vec2 rayRandomness = kernelSample[rayIndex];\n    // Only depends on fragment\n    float fragmentRandomness = fragmentSeed;\n    // Merge both source of randomness in a single uniform random variable using\n    // the formula (x+y < 1 ? x+y : x+y-1). The simpler formula (x+y)/2 doesn't\n    // result in a uniform distribution\n    vec2 mergedRandom = rayRandomness + vec2(fragmentRandomness);\n    mergedRandom -= vec2(greaterThanEqual(mergedRandom, vec2(1.0)));\n\n    // Insipred by:\n    // https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/#better-choice-of-spherical-coordinates\n    float u = mergedRandom[0];\n    float v = mergedRandom[1];\n    float theta = u * 2.0 * PI;\n    float phi = acos(2.0 * v - 1.0);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    return vec3(sinPhi * cosTheta, sinPhi * sinTheta, cosPhi);\n  }\n\n  float computeLAO(vec3 posVC, vec4 normalVC, float originalOpacity) {\n    // apply LAO only at selected locations, otherwise return full brightness\n    if (normalVC.w <= 0.0 || originalOpacity <= 0.05) {\n      return 1.0;\n    }\n\n    #ifdef EnabledGradientOpacity\n      float gradientOpacityFactor = computeGradientOpacityFactor(normalVC.w, 0);\n    #endif\n\n    float visibilitySum = 0.0;\n    float weightSum = 0.0;\n    for (int i = 0; i < volume.kernelSize; i++) {\n      // Only sample on an hemisphere around the normalVC.xyz axis, so\n      // normalDotRay should be negative\n      vec3 rayDirectionVC = sampleDirectionUniform(i);\n      float normalDotRay = dot(normalVC.xyz, rayDirectionVC);\n      if (normalDotRay > 0.0) {\n        // Flip rayDirectionVC when it is in the wrong hemisphere\n        rayDirectionVC = -rayDirectionVC;\n        normalDotRay = -normalDotRay;\n      }\n\n      vec3 currPosIS = posVCtoIS(posVC);\n      float visibility = 1.0;\n      vec3 randomDirStepIS = vecVCToIS(rayDirectionVC * sampleDistance);\n      for (int j = 0; j < volume.kernelRadius; j++) {\n        currPosIS += randomDirStepIS;\n        // If out of the volume, we are done\n        if (any(lessThan(currPosIS, vec3(0.0))) ||\n            any(greaterThan(currPosIS, vec3(1.0)))) {\n          break;\n        }\n        float opacity = getOpacityFromTexture(getTextureValue(currPosIS).r, 0, 0.5);\n        #ifdef EnabledGradientOpacity\n          opacity *= gradientOpacityFactor;\n        #endif\n        visibility *= 1.0 - opacity;\n        // If visibility is less than EPSILON, consider it to be 0\n        if (visibility < EPSILON) {\n          visibility = 0.0;\n          break;\n        }\n      }\n      float rayWeight = -normalDotRay;\n      visibilitySum += visibility * rayWeight;\n      weightSum += rayWeight;\n    }\n\n    // If no sample, LAO factor is one\n    if (weightSum == 0.0) {\n      return 1.0;\n    }\n\n    // LAO factor is the average visibility:\n    // - visibility low => ambient low\n    // - visibility high => ambient high\n    float lao = visibilitySum / weightSum;\n\n    // Reduce variance by clamping\n    return clamp(lao, 0.3, 1.0);\n  }\n#endif\n\n//=======================================================================\n// Volume shadows\n#if vtkNumberOfLights > 0\n\n  // Non-memoised version\n  float computeVolumeShadowWithoutCache(vec3 posVC, vec3 lightDirNormVC) {\n    // modify sample distance with a random number between 1.5 and 3.0\n    float rayStepLength =\n        volumeShadowSampleDistance * mix(1.5, 3.0, fragmentSeed);\n\n    // in case the first sample near surface has a very tiled light ray, we need\n    // to offset start position\n    vec3 initialPosVC = posVC + rayStepLength * lightDirNormVC;\n\n    #ifdef vtkClippingPlanesOn\n      float clippingPlanesMaxDistance = infinity;\n      for (int i = 0; i < clip_numPlanes; ++i) {\n        // Find distance of intersection with the plane\n        // Points are clipped when:\n        // dot(planeOrigin - (rayOrigin + distance * rayDirection), planeNormal) > 0\n        // This is equivalent to:\n        // dot(planeOrigin - rayOrigin, planeNormal) - distance * dot(rayDirection,\n        // planeNormal) > 0.0\n        // We precompute the dot products, so we clip ray points when:\n        // dotOrigin - distance * dotDirection > 0.0\n        float dotOrigin =\n            dot(vClipPlaneOrigins[i] - initialPosVC, vClipPlaneNormals[i]);\n        if (dotOrigin > 0.0) {\n          // The initialPosVC is clipped by this plane\n          return 1.0;\n        }\n        float dotDirection = dot(lightDirNormVC, vClipPlaneNormals[i]);\n        if (dotDirection < 0.0) {\n          // We only hit the plane if dotDirection is negative, as (distance is\n          // positive)\n          float intersectionDistance =\n              dotOrigin / dotDirection; // negative divided by negative => positive\n          clippingPlanesMaxDistance =\n              min(clippingPlanesMaxDistance, intersectionDistance);\n        }\n      }\n    #endif\n\n    vec2 intersectionDistances =\n        rayIntersectVolumeDistances(initialPosVC, lightDirNormVC);\n\n    if (intersectionDistances[1] <= intersectionDistances[0] ||\n        intersectionDistances[1] <= 0.0) {\n      // Volume not hit or behind the ray\n      return 1.0;\n    }\n\n    // When globalIlluminationReach is 0, no sample at all\n    // When globalIlluminationReach is 1, the ray will go through the whole\n    // volume\n    float maxTravelDistance = mix(0.0, volume.diagonalLength,\n                                  volume.globalIlluminationReach);\n    float startDistance = max(intersectionDistances[0], 0.0);\n    float endDistance = min(intersectionDistances[1], startDistance + maxTravelDistance);\n    #ifdef vtkClippingPlanesOn\n      endDistance = min(endDistance, clippingPlanesMaxDistance);\n    #endif\n    if (endDistance - startDistance < 0.0) {\n      return 1.0;\n    }\n\n    // These two variables are used to compute posIS, without having to call\n    // VCtoIS at each step\n    vec3 initialPosIS = posVCtoIS(initialPosVC);\n    // The light dir is scaled and rotated, but not translated, as it is a\n    // vector (w = 0)\n    vec3 scaledLightDirIS = vecVCToIS(lightDirNormVC);\n\n    float shadow = 1.0;\n    for (float currentDistance = startDistance; currentDistance <= endDistance;\n          currentDistance += rayStepLength) {\n      vec3 posIS = initialPosIS + currentDistance * scaledLightDirIS;\n      vec4 scalar = getTextureValue(posIS);\n      float opacity = getOpacityFromTexture(scalar.r, 0, 0.5);\n      #if defined(EnabledGradientOpacity) && !defined(EnabledIndependentComponents)\n        vec3 scalarInterp[2];\n        vec4 normal = computeNormalForDensity(posIS, scalarInterp, 3);\n        float opacityFactor = computeGradientOpacityFactor(normal.w, 0);\n        opacity *= opacityFactor;\n      #endif\n      shadow *= 1.0 - opacity;\n\n      // Early termination if shadow coeff is near 0.0\n      if (shadow < EPSILON) {\n        return 0.0;\n      }\n    }\n    return shadow;\n  }\n\n  // Some cache for volume shadows\n  struct {\n    vec3 posVC;\n    float shadow;\n  } cachedShadows[vtkNumberOfLights];\n\n  // Memoised version\n  float computeVolumeShadow(vec3 posVC, vec3 lightDirNormVC, int lightIdx) {\n    if (posVC == cachedShadows[lightIdx].posVC) {\n      return cachedShadows[lightIdx].shadow;\n    }\n    float shadow = computeVolumeShadowWithoutCache(posVC, lightDirNormVC);\n    cachedShadows[lightIdx].posVC = posVC;\n    cachedShadows[lightIdx].shadow = shadow;\n    return shadow;\n  }\n\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkNumberOfLights > 0\n  vec3 applyLighting(vec3 tColor, vec4 normalVC) {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\n      float df = dot(normalVC.xyz, lights[lightIdx].directionVC);\n      if (df > 0.0) {\n        diffuse += df * lights[lightIdx].color;\n        float sf = dot(normalVC.xyz, -lights[lightIdx].halfAngleVC);\n        if (sf > 0.0) {\n          specular += pow(sf, volume.specularPower) * lights[lightIdx].color;\n        }\n      }\n    }\n    return tColor * (diffuse * volume.diffuse + volume.ambient) +\n          specular * volume.specular;\n  }\n\n  vec3 applySurfaceShadowLighting(vec3 tColor, float alpha, vec3 posVC,\n                                  vec4 normalVC) {\n    // everything in VC\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    for (int ligthIdx = 0; ligthIdx < vtkNumberOfLights; ligthIdx++) {\n      vec3 vertLightDirection;\n      float attenuation;\n      if (lights[ligthIdx].isPositional == 1) {\n        vertLightDirection = posVC - lights[ligthIdx].positionVC;\n        float lightDistance = length(vertLightDirection);\n        // Normalize with precomputed length\n        vertLightDirection = vertLightDirection / lightDistance;\n        // Base attenuation\n        vec3 attenuationPolynom = lights[ligthIdx].attenuation;\n        attenuation =\n            1.0 / (attenuationPolynom[0] +\n                  lightDistance * (attenuationPolynom[1] +\n                                    lightDistance * attenuationPolynom[2]));\n        // Cone attenuation\n        float coneDot = dot(vertLightDirection, lights[ligthIdx].directionVC);\n        // Per OpenGL standard cone angle is 90 or less for a spot light\n        if (lights[ligthIdx].coneAngle <= 90.0) {\n          if (coneDot >= cos(radians(lights[ligthIdx].coneAngle))) {\n            // Inside the cone\n            attenuation *= pow(coneDot, lights[ligthIdx].exponent);\n          } else {\n            // Outside the cone\n            attenuation = 0.0;\n          }\n        }\n      } else {\n        vertLightDirection = lights[ligthIdx].directionVC;\n        attenuation = 1.0;\n      }\n\n      float ndotL = dot(normalVC.xyz, vertLightDirection);\n      if (ndotL < 0.0 && twoSidedLighting == 1) {\n        ndotL = -ndotL;\n      }\n      if (ndotL > 0.0) {\n        // Diffuse\n        diffuse += ndotL * attenuation * lights[ligthIdx].color;\n        // Specular\n        float vdotR =\n            dot(-rayDirVC, normalize(vertLightDirection - 2.0 * ndotL * normalVC.xyz));\n        if (vdotR > 0.0) {\n          specular += pow(vdotR, volume.specularPower) * attenuation *\n                      lights[ligthIdx].color;\n        }\n      }\n    }\n    #if vtkMaxLaoKernelSize > 0\n      float laoFactor = computeLAO(posVC, normalVC, alpha);\n    #else\n      const float laoFactor = 1.0;\n    #endif\n    return tColor * (diffuse * volume.diffuse +\n                    volume.ambient * laoFactor) +\n          specular * volume.specular;\n  }\n\n  vec3 applyVolumeShadowLighting(vec3 tColor, vec3 posVC) {\n    // Here we have no effect of cones and no attenuation\n    vec3 diffuse = vec3(0.0);\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\n      vec3 lightDirVC = lights[lightIdx].isPositional == 1\n                            ? normalize(lights[lightIdx].positionVC - posVC)\n                            : -lights[lightIdx].directionVC;\n      float shadowCoeff = computeVolumeShadow(posVC, lightDirVC, lightIdx);\n      float phaseAttenuation = phaseFunction(dot(rayDirVC, lightDirVC));\n      diffuse += phaseAttenuation * shadowCoeff * lights[lightIdx].color;\n    }\n    return tColor * (diffuse * volume.diffuse + volume.ambient);\n  }\n#endif\n\n// LAO of surface shadows and volume shadows only work with dependent components\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posVC,\n                       vec4 surfaceNormalVC) {\n  #if vtkNumberOfLights > 0\n    // 0 <= volCoeff < EPSILON => only surface shadows\n    // EPSILON <= volCoeff < 1 - EPSILON => mix of surface and volume shadows\n    // 1 - EPSILON <= volCoeff => only volume shadows\n    float volCoeff = volume.volumetricScatteringBlending *\n                    (1.0 - alpha / 2.0) *\n                    (1.0 - atan(surfaceNormalVC.w) * INV4PI);\n\n    // Compute surface lighting if needed\n    vec3 surfaceShadedColor = tColor;\n    #ifdef EnableSurfaceLighting\n      if (volCoeff < 1.0 - EPSILON) {\n        surfaceShadedColor =\n            applySurfaceShadowLighting(tColor, alpha, posVC, surfaceNormalVC);\n      }\n    #endif\n\n    // Compute volume lighting if needed\n    vec3 volumeShadedColor = tColor;\n    #ifdef EnableVolumeLighting\n      if (volCoeff >= EPSILON) {\n        volumeShadedColor = applyVolumeShadowLighting(tColor, posVC);\n      }\n    #endif\n\n    // Return the right mix\n    if (volCoeff < EPSILON) {\n      // Surface shadows\n      return surfaceShadedColor;\n    }\n    if (volCoeff >= 1.0 - EPSILON) {\n      // Volume shadows\n      return volumeShadedColor;\n    }\n    // Mix of surface and volume shadows\n    return mix(surfaceShadedColor, volumeShadedColor, volCoeff);\n  #endif\n  return tColor;\n}\n\nvec4 getColorForLabelOutline() {\n  vec3 centerPosIS =\n      fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = vec4(getColorFromTexture(centerValue.r, 0, 0.5),\n                     getOpacityFromTexture(centerValue.r, 0, 0.5));\n\n  int segmentIndex = int(centerValue.r * 255.0);\n\n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue =\n      texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\n  int actualThickness = int(textureValue * 255.0);\n\n  // If it is the background (segment index 0), we should quickly bail out.\n  // Previously, this was determined by tColor.a, which was incorrect as it\n  // prevented the outline from appearing when the fill is 0.\n  if (segmentIndex == 0) {\n    return vec4(0, 0, 0, 0);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't\n  // invisible. Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  for (int i = -actualThickness; i <= actualThickness; i++) {\n    for (int j = -actualThickness; j <= actualThickness; j++) {\n      if (i == 0 || j == 0) {\n        continue;\n      }\n\n      vec4 neighborPixelCoord =\n          vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j),\n               gl_FragCoord.z, gl_FragCoord.w);\n\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n      vec4 value = getTextureValue(neighborPosIS);\n\n      // If any of my neighbours are not the same value as I\n      // am, this means I am on the border of the segment.\n      // We can break the loops\n      if (any(notEqual(value, centerValue))) {\n        pixelOnBorder = true;\n        break;\n      }\n    }\n\n    if (pixelOnBorder == true) {\n      break;\n    }\n  }\n\n  // If I am on the border, I am displayed at full opacity\n  if (pixelOnBorder == true) {\n    tColor.a = volume.outlineOpacity;\n  }\n\n  return tColor;\n}\n\nvec4 getColorForAdditivePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\n  // compute normals\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\n  vec4 normalLights[2];\n  normalLights[0] = normalMat[0];\n  normalLights[1] = normalMat[1];\n  #if vtkNumberOfLights > 0\n    if (volume.computeNormalFromOpacity == 1) {\n      for (int component = 0; component < 2; ++component) {\n        vec3 scalarInterp[2];\n        float height = volume.transferFunctionsSampleHeight[component];\n        computeNormalForDensity(posIS, scalarInterp, component);\n        normalLights[component] =\n            computeDensityNormal(scalarInterp, height, 1.0, component);\n      }\n    }\n  #endif\n\n  // compute opacities\n  float opacities[2];\n  opacities[0] = getOpacityFromTexture(\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\n  opacities[1] = getOpacityFromTexture(\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\n  #ifdef EnabledGradientOpacity\n    for (int component = 0; component < 2; ++component) {\n      opacities[component] *=\n          computeGradientOpacityFactor(normalMat[component].a, component);\n    }\n  #endif\n  float opacitySum = opacities[0] + opacities[1];\n  if (opacitySum <= 0.0) {\n    return vec4(0.0);\n  }\n\n  // mix the colors and opacities\n  vec3 colors[2];\n  for (int component = 0; component < 2; ++component) {\n    float sampleHeight = volume.transferFunctionsSampleHeight[component];\n    vec3 color = getColorFromTexture(tValue[component], component, sampleHeight);\n    color = applyAllLightning(color, opacities[component], posVC,\n                              normalLights[component]);\n    colors[component] = color;\n  }\n  vec3 mixedColor =\n      (opacities[0] * colors[0] + opacities[1] * colors[1]) / opacitySum;\n  return vec4(mixedColor, min(1.0, opacitySum));\n}\n\nvec4 getColorForColorizePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\n  // compute normals\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\n  vec4 normalLight = normalMat[0];\n  #if vtkNumberOfLights > 0\n    if (volume.computeNormalFromOpacity == 1) {\n      vec3 scalarInterp[2];\n      float height = volume.transferFunctionsSampleHeight[0];\n      computeNormalForDensity(posIS, scalarInterp, 0);\n      normalLight = computeDensityNormal(scalarInterp, height, 1.0, 0);\n    }\n  #endif\n\n  // compute opacities\n  float opacity = getOpacityFromTexture(\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\n  #ifdef EnabledGradientOpacity\n    opacity *= computeGradientOpacityFactor(normalMat[0].a, 0);\n  #endif\n\n  // colorizing component\n  vec3 colorizingColor = getColorFromTexture(\n      tValue[0], 1, volume.transferFunctionsSampleHeight[1]);\n  float colorizingOpacity = getOpacityFromTexture(\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\n\n  // mix the colors and opacities\n  vec3 color =\n      getColorFromTexture(tValue[0], 0,\n                          volume.transferFunctionsSampleHeight[0]) *\n      mix(vec3(1.0), colorizingColor, colorizingOpacity);\n  color = applyAllLightning(color, opacity, posVC, normalLight);\n  return vec4(color, opacity);\n}\n\nvec4 getColorForDefaultIndependentPreset(vec4 tValue, vec3 posIS) {\n\n  // compute the normal vectors as needed\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\n    mat4 normalMat = computeMat4Normal(posIS, tValue);\n  #endif\n\n  // process color and opacity for each component\n  // initial value of alpha is determined by wether the first component is\n  // proportional or not\n  #if defined(vtkComponent0Proportional)\n    // when it is proportional, it starts at 1 (neutral for multiplications)\n    float alpha = 1.0;\n  #else\n    // when it is not proportional, it starts at 0 (neutral for additions)\n    float alpha = 0.0;\n  #endif\n\n  vec3 mixedColor = vec3(0.0);\n  #if vtkNumberOfComponents > 0\n    {\n      const int component = 0;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent0Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 1\n    {\n      const int component = 1;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent1Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 2\n    {\n      const int component = 2;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent2Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 3\n    {\n      const int component = 3;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent3Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n\n  return vec4(mixedColor, alpha);\n}\n\nvec4 getColorForDependentComponents(vec4 tValue, vec3 posVC, vec3 posIS) {\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\n    // use component 3 of the opacity texture as getTextureValue() sets alpha to\n    // the opacity value\n    vec3 scalarInterp[2];\n    vec4 normal0 = computeNormalForDensity(posIS, scalarInterp, 3);\n    float gradientOpacity = computeGradientOpacityFactor(normal0.a, 0);\n  #endif\n\n  // get color and opacity\n  #if vtkNumberOfComponents == 1\n    vec3 tColor = getColorFromTexture(tValue.r, 0, 0.5);\n    float alpha = getOpacityFromTexture(tValue.r, 0, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 2\n    vec3 tColor = vec3(tValue.r * volume.colorTextureScale[0] +\n                  volume.colorTextureShift[0]);\n    float alpha = getOpacityFromTexture(tValue.a, 1, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 3\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\n              volume.colorTextureShift.rgb;\n      float alpha = getOpacityFromTexture(tValue.a, 0, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 4\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\n              volume.colorTextureShift.rgb;\n      float alpha = getOpacityFromTexture(tValue.a, 3, 0.5);\n  #endif\n\n  // Apply gradient opacity\n  #if defined(EnabledGradientOpacity)\n    alpha *= gradientOpacity;\n  #endif\n\n  #if vtkNumberOfComponents == 1\n    if (alpha < EPSILON) {\n      return vec4(0.0);\n    }\n  #endif\n\n  // lighting\n  #if vtkNumberOfLights > 0\n    vec4 normalLight;\n    if (volume.computeNormalFromOpacity == 1) {\n      if (normal0[3] != 0.0) {\n        normalLight =\n            computeDensityNormal(scalarInterp, 0.5, gradientOpacity, 0);\n        if (normalLight[3] == 0.0) {\n          normalLight = normal0;\n        }\n      }\n    } else {\n      normalLight = normal0;\n    }\n    tColor = applyAllLightning(tColor, alpha, posVC, normalLight);\n  #endif\n\n  return vec4(tColor, alpha);\n}\n\nvec4 getColorForValue(vec4 tValue, vec3 posVC, vec3 posIS) {\n  #ifdef EnableColorForValueFunctionId0\n    return getColorForDependentComponents(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId1\n    return getColorForAdditivePreset(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId2\n    return getColorForColorizePreset(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId3\n    /*\n      * Mix the color information from all the independent components to get a\n      * single rgba output. See other shader functions like\n      * `getColorForAdditivePreset` to learn how to create a custom color mix.\n      * The custom color mix should return a value, but if it doesn't, it will\n      * fallback on the default shading\n      */\n    //VTK::CustomColorMix\n  #endif\n\n  #if defined(EnableColorForValueFunctionId4) || defined(EnableColorForValueFunctionId3)\n    return getColorForDefaultIndependentPreset(tValue, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId5\n    return getColorForLabelOutline();\n  #endif\n}\n\nbool valueWithinScalarRange(vec4 val) {\n  #if vtkNumberOfComponents > 1 && !defined(EnabledIndependentComponents)\n    return false;\n  #endif\n  vec4 rangeMin = volume.ipScalarRangeMin;\n  vec4 rangeMax = volume.ipScalarRangeMax;\n  for (int component = 0; component < vtkNumberOfComponents; ++component) {\n    if (val[component] < rangeMin[component] ||\n        rangeMax[component] < val[component]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n#if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\n  bool checkOnEdgeForNeighbor(int xFragmentOffset, int yFragmentOffset,\n                              int segmentIndex, vec3 stepIS) {\n    vec3 volumeDimensions = vec3(volume.dimensions);\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(xFragmentOffset),\n                                  gl_FragCoord.y + float(yFragmentOffset),\n                                  gl_FragCoord.z, gl_FragCoord.w);\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n\n    vec3 neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\n      vec4 texValue = rawFetchTexture(texCoord);\n      if (int(texValue.g) == segmentIndex) {\n        // not on edge\n        return false;\n      }\n      neighborPosIS += stepIS;\n    }\n\n    neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\n      vec4 texValue = rawFetchTexture(texCoord);\n      if (int(texValue.g) == segmentIndex) {\n        // not on edge\n        return false;\n      }\n      neighborPosIS -= stepIS;\n    }\n\n    // onedge\n    float sampleHeight = volume.transferFunctionsSampleHeight[1];\n    vec3 tColorSegment =\n        getColorFromTexture(float(segmentIndex), 1, sampleHeight);\n    float pwfValueSegment =\n        getOpacityFromTexture(float(segmentIndex), 1, sampleHeight);\n    gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\n    return true;\n  }\n#endif\n\nvec4 getColorAtPos(vec3 posVC) {\n  vec3 posIS = posVCtoIS(posVC);\n  vec4 texValue = getTextureValue(posIS);\n  return getColorForValue(texValue, posVC, posIS);\n}\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 rayOriginVC, vec3 rayDirVC, float minDistance,\n                float maxDistance) {\n  // start slightly inside and apply some jitter\n  vec3 stepVC = rayDirVC * sampleDistance;\n  float raySteps = (maxDistance - minDistance) / sampleDistance;\n\n  // Avoid 0.0 jitter\n  float jitter = 0.01 + 0.99 * fragmentSeed;\n\n  #if vtkBlendMode == COMPOSITE_BLEND\n    // now map through opacity and color\n    vec3 firstPosVC = rayOriginVC + minDistance * rayDirVC;\n    vec4 firstColor = getColorAtPos(firstPosVC);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0) {\n      firstColor.a = 1.0 - pow(1.0 - firstColor.a, raySteps);\n      gl_FragData[0] = firstColor;\n      return;\n    }\n\n    // first color only counts for `jitter` factor of the step\n    firstColor.a = 1.0 - pow(1.0 - firstColor.a, jitter);\n    vec4 color = vec4(firstColor.rgb * firstColor.a, firstColor.a);\n    vec3 posVC = firstPosVC + jitter * stepVC;\n    float stepsTraveled = jitter;\n\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n      vec4 tColor = getColorAtPos(posVC);\n\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * (1.0 - color.a);\n      stepsTraveled++;\n      posVC += stepVC;\n      if (color.a > 0.99) {\n        color.a = 1.0;\n        break;\n      }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0) {\n      vec3 endPosVC = rayOriginVC + maxDistance * rayDirVC;\n      vec4 tColor = getColorAtPos(endPosVC);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb / color.a, color.a);\n  #endif\n\n  #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND ||                                 \\\n      vtkBlendMode == MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND\n      #define OP max\n    #else\n      #define OP min\n    #endif\n\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    // Find a value to initialize the selected variables\n    vec4 selectedValue;\n    vec3 selectedPosVC;\n    vec3 selectedPosIS;\n    {\n      vec3 posIS = posVCtoIS(posVC);\n      selectedValue = getTextureValue(posIS);\n      selectedPosVC = posVC;\n      selectedPosIS = posIS;\n    }\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\n      return;\n    }\n\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      // Get selected values\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 previousSelectedValue = selectedValue;\n      vec4 currentValue = getTextureValue(posIS);\n      selectedValue = OP(selectedValue, currentValue);\n      if (previousSelectedValue != selectedValue) {\n        selectedPosVC = posVC;\n        selectedPosIS = posIS;\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posVC += stepVC;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posVC = rayOriginVC + maxDistance * rayDirVC;\n    {\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 previousSelectedValue = selectedValue;\n      vec4 currentValue = getTextureValue(posIS);\n      selectedValue = OP(selectedValue, currentValue);\n      if (previousSelectedValue != selectedValue) {\n        selectedPosVC = posVC;\n        selectedPosIS = posIS;\n      }\n    }\n\n    gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\n  #endif\n\n  #if vtkBlendMode == ADDITIVE_INTENSITY_BLEND ||                                \\\n      vtkBlendMode == AVERAGE_INTENSITY_BLEND\n    vec4 sum = vec4(0.);\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n      float totalWeight = 0.0;\n    #endif\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    vec3 posIS = posVCtoIS(posVC);\n    vec4 value = getTextureValue(posIS);\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(value * raySteps, posVC, posIS);\n      return;\n    }\n\n    if (valueWithinScalarRange(value)) {\n      sum += value * jitter;\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n        totalWeight += jitter;\n      #endif\n    }\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      posIS = posVCtoIS(posVC);\n      value = getTextureValue(posIS);\n      // One can control the scalar range by setting the AverageIPScalarRange to\n      // disregard scalar values, not in the range of interest, from the average\n      // computation. Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(value)) {\n        sum += value;\n        #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n          totalWeight++;\n        #endif\n      }\n\n      stepsTraveled++;\n      posVC += stepVC;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posVC = rayOriginVC + maxDistance * rayDirVC;\n    posIS = posVCtoIS(posVC);\n    value = getTextureValue(posIS);\n    if (valueWithinScalarRange(value)) {\n      sum += value;\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n        totalWeight += raySteps - stepsTraveled;\n      #endif\n    }\n\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n      sum /= vec4(totalWeight, totalWeight, totalWeight, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posVC, posIS);\n  #endif\n\n  #if vtkBlendMode == RADON_TRANSFORM_BLEND\n    float normalizedRayIntensity = 1.0;\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0) {\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 tValue = getTextureValue(posIS);\n      normalizedRayIntensity -= raySteps * sampleDistance *\n                                getOpacityFromTexture(tValue.r, 0, 0.5);\n      gl_FragData[0] =\n          vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\n      return;\n    }\n\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 value = getTextureValue(posIS);\n      // Convert scalar value to normalizedRayIntensity coefficient and\n      // accumulate normalizedRayIntensity\n      normalizedRayIntensity -=\n          sampleDistance * getOpacityFromTexture(value.r, 0, 0.5);\n\n      posVC += stepVC;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] =\n        vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\n  #endif\n\n  #if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\n    // Only works with a single volume\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n    vec3 posIS = posVCtoIS(posVC);\n    vec4 tValue = getTextureValue(posIS);\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(tValue, posVC, posIS);\n      return;\n    }\n\n    vec3 stepIS = vecVCToIS(stepVC);\n    vec4 value = tValue;\n    posIS += jitter * stepIS;\n    stepsTraveled += jitter;\n    vec3 maxPosIS = posIS; // Store the position of the max value\n    int segmentIndex = int(value.g);\n    bool originalPosHasSeenNonZero = false;\n\n    if (segmentIndex != 0) {\n      // Tried using the segment index in an boolean array but reading\n      // from the array by dynamic indexing was horrondously slow\n      // so use bit masking instead and assign 1 to the bit corresponding to the\n      // segment index and later check if the bit is set via bit operations\n      setLabelOutlineBit(segmentIndex);\n    }\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n      segmentIndex = int(tValue.g);\n\n      if (segmentIndex != 0) {\n        originalPosHasSeenNonZero = true;\n        setLabelOutlineBit(segmentIndex);\n      }\n\n      if (tValue.r > value.r) {\n        value = tValue;   // Update the max value\n        maxPosIS = posIS; // Update the position where max occurred\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = posVCtoIS(rayOriginVC + maxDistance * rayDirVC);\n    tValue = getTextureValue(posIS);\n\n    if (tValue.r > value.r) {\n      value = tValue;   // Update the max value\n      maxPosIS = posIS; // Update the position where max occurred\n    }\n\n    // If we have not seen any non-zero segments, we can return early\n    // and grab color from the actual center value first component (image)\n    if (!originalPosHasSeenNonZero) {\n      vec3 maxPosVC = posIStoVC(maxPosIS);\n      gl_FragData[0] = getColorForValue(value, maxPosVC, maxPosIS);\n      return;\n    }\n\n    vec3 neighborRayStepsIS = stepIS;\n    float neighborRaySteps = raySteps;\n    bool shouldLookInAllNeighbors = false;\n\n    vec3 volumeSpacings = volume.spacing;\n    float minVoxelSpacing =\n        min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\n    vec4 base =\n        vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z,\n                          gl_FragCoord.w);\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z,\n                          gl_FragCoord.w);\n\n    vec3 baseWorld = fragCoordToWorld(base);\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\n\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\n\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\n\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\n      // bail out quickly if the segment index has not\n      // been seen by the center segment\n      if (!isLabelOutlineBitSet(s)) {\n        continue;\n      }\n\n      // Use texture sampling for outlineThickness so that we can have\n      // per segment thickness\n      float textureCoordinate = float(s - 1) / 1024.0;\n      float textureValue =\n          texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\n\n      int actualThickness = int(textureValue * 255.0);\n\n      // check the extreme points in the neighborhood since there is a better\n      // chance of finding the edge there, so that we can bail out\n      // faster if we find the edge\n      bool onEdge = checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(actualThickness, actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(actualThickness, -actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s,\n                                          stepIS);\n\n      if (onEdge) {\n        return;\n      }\n\n      // since the next step is computationally expensive, we need to perform\n      // some optimizations to avoid it if possible. One of the optimizations\n      // is to check the whether the minimum of the voxel spacing is greater than\n      // the 2 * the thickness of the outline segment. If that is the case\n      // then we can safely skip the next step since we can be sure that the\n      // the previous 4 checks on the extreme points would caught the entirety\n      // of the all the fragments inside. i.e., this happens when we zoom out,\n      if (minVoxelSpacing >\n          (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\n        continue;\n      }\n\n      // Loop through the rest, skipping the processed extremes and the center\n      for (int i = -actualThickness; i <= actualThickness; i++) {\n        for (int j = -actualThickness; j <= actualThickness; j++) {\n          if (i == 0 && j == 0)\n            continue; // Skip the center\n          if (abs(i) == actualThickness && abs(j) == actualThickness)\n            continue; // Skip corners\n          if (checkOnEdgeForNeighbor(i, j, s, stepIS)) {\n            return;\n          }\n        }\n      }\n    }\n\n    float sampleHeight = volume.transferFunctionsSampleHeight[0];\n    vec3 tColor0 = getColorFromTexture(value.r, 0, sampleHeight);\n    float pwfValue0 = getOpacityFromTexture(value.r, 0, sampleHeight);\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\n  #endif\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayOriginVC, vec3 rayDirVC) {\n  vec2 dists = rayIntersectVolumeDistances(rayOriginVC, rayDirVC);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0, dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick / rayDirVC.z;\n  dists.y = min(farDist, dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\nfloat getFragmentSeed() {\n  // This first noise has a diagonal pattern\n  float firstNoise =\n      fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n  // This second noise is made out of blocks of CPU generated noise\n  float secondNoise = texture2D(jtexture, gl_FragCoord.xy / 32.0).r;\n  // Combine the two sources of noise in a way that the distribution is uniform\n  // in [0,1[\n  float noiseSum = firstNoise + secondNoise;\n  return noiseSum < 1.0 ? noiseSum : noiseSum - 1.0;\n}\n\nvoid main() {\n  fragmentSeed = getFragmentSeed();\n\n  if (cameraParallel == 1) {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 rayOriginVC = vertexVCVSOutput;\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayOriginVC, rayDirVC);\n  if (rayStartEndDistancesVC[1] <= rayStartEndDistancesVC[0] ||\n      rayStartEndDistancesVC[1] <= 0.0) {\n    // Volume not hit or behind the ray\n    discard;\n  }\n\n  // Perform the blending operation along the ray\n  applyBlend(rayOriginVC, rayDirVC, rayStartEndDistancesVC[0], rayStartEndDistancesVC[1]);\n}\n",e.Geometry=""},e.replaceShaderValues=(e,n,r)=>{let o=e.Fragment;o=Pu.substitute(o,"//VTK::EnabledColorFunctions",`#define EnableColorForValueFunctionId${t.previousState.colorForValueFunctionId}`).result;const a=[];t.previousState.surfaceLightingEnabled&&a.push("Surface"),t.previousState.volumeLightingEnabled&&a.push("Volume"),o=Pu.substitute(o,"//VTK::EnabledLightings",a.map((e=>`#define Enable${e}Lighting`))).result,t.previousState.multiTexturePerVolumeEnabled&&(o=Pu.substitute(o,"//VTK::EnabledMultiTexturePerVolume","#define EnabledMultiTexturePerVolume").result),t.previousState.useIndependentComponents&&(o=Pu.substitute(o,"//VTK::EnabledIndependentComponents","#define EnabledIndependentComponents").result),t.previousState.gradientOpacityEnabled&&(o=Pu.substitute(o,"//VTK::EnabledGradientOpacity","#define EnabledGradientOpacity").result),o=Pu.substitute(o,"//VTK::vtkProportionalComponents",t.previousState.proportionalComponents.map((e=>`#define vtkComponent${e}Proportional`)).join("\n")).result,o=Pu.substitute(o,"//VTK::vtkForceNearestComponents",t.previousState.forceNearestComponents.map((e=>`#define vtkComponent${e}ForceNearest`)).join("\n")).result,t.previousState.hasZBufferTexture&&(o=Pu.substitute(o,"//VTK::ZBuffer::Dec",["uniform sampler2D zBufferTexture;","uniform float vpZWidth;","uniform float vpZHeight;"]).result,o=Pu.substitute(o,"//VTK::ZBuffer::Impl",["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));","float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;","zdepth = zdepth * 2.0 - 1.0;","if (cameraParallel == 0) {","zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}","else {","zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n","zdepth = -zdepth/rayDirVC.z;","dists.y = min(zdepth,dists.y);"]).result),o=Pu.substitute(o,"//VTK::BlendMode",`${t.previousState.blendMode}`).result,o=Pu.substitute(o,"//VTK::NumberOfLights",`${t.previousState.numberOfLights}`).result,o=Pu.substitute(o,"//VTK::MaxLaoKernelSize",`${t.previousState.maxLaoKernelSize}`).result,o=Pu.substitute(o,"//VTK::NumberOfComponents",`${t.previousState.numberOfComponents}`).result,o=Pu.substitute(o,"//VTK::MaximumNumberOfSamples",`${t.previousState.maximumNumberOfSamples}`).result,e.Fragment=o;const i=t.previousState.numberOfClippingPlanes;i>0&&(o=Pu.substitute(o,"//VTK::ClipPlane::Dec",["uniform vec3 vClipPlaneNormals[6];","uniform float vClipPlaneDistances[6];","uniform vec3 vClipPlaneOrigins[6];","uniform int clip_numPlanes;","//VTK::ClipPlane::Dec","#define vtkClippingPlanesOn"],!1).result,o=Pu.substitute(o,"//VTK::ClipPlane::Impl",[`for(int i = 0; i < ${i}; i++) {`,"  float rayDirRatio = dot(rayDirVC, vClipPlaneNormals[i]);","  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];","  if (rayDirRatio == 0.0)","  {","    if (equationResult < 0.0) dists.x = dists.y;","    continue;","  }","  float result = -1.0 * equationResult / rayDirRatio;","  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);","  else dists.x = max(dists.x, result);","}","//VTK::ClipPlane::Impl"],!1).result),e.Fragment=o},e.getNeedToRebuildShaders=(r,o,a)=>{const i=!!t.zBufferTexture,s=t.currentValidInputs.length,l=t.numberOfLights,c=t.numberOfComponents,u=t.useIndependentComponents,d=a.getProperties(),p=t.currentValidInputs[0],f=d[p.inputIndex],g=s>1,m=p.imageData.getBounds(),h=Fi.getDiagonalLength(m),v=Math.ceil(h/e.getCurrentSampleDistance(o));v>t.renderable.getMaximumSamplesPerRay()&&wf(`The number of steps required ${v} is larger than the specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\nPlease either change the volumeMapper sampleDistance or its maximum number of samples.`);const T=u?c:1;let y=!1;for(let e=0;e<T;++e)if(f.getUseGradientOpacity(e)){y=!0;break}let b=0;const x=f.getLAOKernelSize();x>b&&f.getLocalAmbientOcclusion()&&f.getAmbient()>0&&(b=x);const C=t.renderable.getClippingPlanes().length,S=t.renderable.getViewSpecificProperties().OpenGL?.ShaderReplacements,A=t.currentRenderPass?.getShaderReplacement(),I=t.renderable.getBlendMode(),w=(()=>{if(I!==Af.LABELMAP_EDGE_PROJECTION_BLEND&&n(f))return 5;if(u)switch(f.getColorMixPreset()){case Cf.ADDITIVE:return 1;case Cf.COLORIZE:return 2;case Cf.CUSTOM:return 3;default:return 4}return 0})(),O=f.getVolumetricScatteringBlending()<1,P=f.getVolumetricScatteringBlending()>0;let R=!1;for(let e=0;e<c;++e)if(f.getForceNearestInterpolation(e)){R=!0;break}const M=[],E=[];for(let e=0;e<c;e++)f.getOpacityMode(e)===xf.PROPORTIONAL&&M.push(e),f.getForceNearestInterpolation(e)&&E.push(e);const V={numberOfComponents:c,useIndependentComponents:u,proportionalComponents:M,forceNearestComponents:E,blendMode:I,numberOfLights:l,numberOfValidInputs:s,maximumNumberOfSamples:v,hasZBufferTexture:i,maxLaoKernelSize:b,numberOfClippingPlanes:C,mapperShaderReplacements:S,renderPassShaderReplacements:A,colorForValueFunctionId:w,surfaceLightingEnabled:O,volumeLightingEnabled:P,forceNearestInterpolationEnabled:R,multiTexturePerVolumeEnabled:g,gradientOpacityEnabled:y};return!(0!==r.getProgram()?.getHandle()&&t.previousState&&Ge()(t.previousState,V)||(t.previousState=V,0))},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexDC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexDC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Of("Error setting vertexDC in shader VAO.")),n.getAttributeUpdateTime().modified());const i=e.getCurrentSampleDistance(r);a.setUniformf("sampleDistance",i);const s=i*t.renderable.getVolumeShadowSamplingDistFactor();a.setUniformf("volumeShadowSampleDistance",s),t.scalarTextures.forEach(((e,t)=>{a.setUniformi(`volumeTexture[${t}]`,e.getTextureUnit())}));const l=o.getProperties()[t.currentValidInputs[0].inputIndex].getIpScalarRange(),c=new Float32Array(4),u=new Float32Array(4),d=(e,t,n)=>{t?.dataComputedScale?.length&&(c[e]=l[0]*t.dataComputedScale[n]+t.dataComputedOffset[n],u[e]=l[1]*t.dataComputedScale[n]+t.dataComputedOffset[n],c[e]=(c[e]-t.offset[n])/t.scale[n],u[e]=(u[e]-t.offset[n])/t.scale[n])};if(t.previousState.multiTexturePerVolumeEnabled)t.scalarTextures.forEach(((e,t)=>{const n=e.getVolumeInfo();d(t,n,0)}));else{const e=t.scalarTextures[0].getVolumeInfo();for(let t=0;t<4;++t)d(t,e,t)}const p="volume";if(a.setUniform4f(`${p}.ipScalarRangeMin`,c[0],c[1],c[2],c[3]),a.setUniform4f(`${p}.ipScalarRangeMax`,u[0],u[1],u[2],u[3]),null!==t.zBufferTexture){a.setUniformi("zBufferTexture",t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf("vpZWidth",e[0]),a.setUniformf("vpZHeight",e[1])}},e.setCameraShaderParameters=(r,o,a)=>{const{idxToView:i,vecISToVCMatrix:s,modelToView:l,projectionToView:c,projectionToWorld:u}=Pf,d=t.openGLCamera.getKeyMatrices(o),p=t.openGLVolume.getKeyMatrices();y(l,d.wcvc,p.mcwc);const f=r.getProgram(),g=t.openGLCamera.getRenderable(),m=g.getParallelProjection(),v=g.getClippingRange();f.setUniformf("camThick",v[1]-v[0]),f.setUniformf("camNear",v[0]),f.setUniformf("camFar",v[1]),f.setUniformi("cameraParallel",m);const T=t.currentValidInputs[0],b=T.imageData.getBounds(),x=Fi.getCorners(b,[]).map((e=>(wn(e,e,l),m||xn(e,e,-v[0]/(e[2]*mn(e))),wn(e,e,d.vcpc),e))),C=Fi.addPoints([...Fi.INIT_BOUNDS],x);f.setUniformf("dcxmin",C[0]),f.setUniformf("dcxmax",C[1]),f.setUniformf("dcymin",C[2]),f.setUniformf("dcymax",C[3]);const S=e.getRenderTargetSize();f.setUniformf("vpWidth",S[0]),f.setUniformf("vpHeight",S[1]);const A=e.getRenderTargetOffset();f.setUniformf("vpOffsetX",A[0]/S[0]),f.setUniformf("vpOffsetY",A[1]/S[1]),h(c,d.vcpc),f.setUniformMatrix("PCVCMatrix",c),f.setUniformi("twoSidedLighting",o.getTwoSidedLighting());const I=new Array(2*t.previousState.maxLaoKernelSize);for(let e=0;e<t.previousState.maxLaoKernelSize;e++)I[2*e]=Math.random(),I[2*e+1]=Math.random();if(f.setUniform2fv("kernelSample",I),t.numberOfLights>0){let e=0;o.getLights().forEach((t=>{if(t.getSwitch()>0){const n=`lights[${e}]`,r=xn([],t.getColor(),t.getIntensity());f.setUniform3fv(`${n}.color`,r);const o=t.getTransformedPosition();wn(o,o,l),f.setUniform3fv(`${n}.positionVC`,o);const a=[...t.getDirection()];On(a,a,d.normalMatrix),Sn(a,a),f.setUniform3fv(`${n}.directionVC`,a);const i=[-.5*a[0],-.5*a[1],-.5*(a[2]-1)];f.setUniform3fv(`${n}.halfAngleVC`,i);const s=t.getAttenuationValues();f.setUniform3fv(`${n}.attenuation`,s);const c=t.getExponent();f.setUniformf(`${n}.exponent`,c);const u=t.getConeAngle();f.setUniformf(`${n}.coneAngle`,u);const p=t.getPositional();f.setUniformi(`${n}.isPositional`,p),e++}}))}const w="volume",O=a.getProperties()[T.inputIndex],P=T.imageData,R=P.getSpatialExtent(),M=P.getSpacing(),E=P.getDimensions(),V=P.getIndexToWorld(),D=P.getWorldToIndex(),L=P.getDirectionByReference();y(i,l,V),f.setUniform3fv(`${w}.spacing`,M);const B=Cn([],M);f.setUniform3fv(`${w}.inverseSpacing`,B),f.setUniform3iv(`${w}.dimensions`,E),f.setUniform3fv(`${w}.inverseDimensions`,Cn([],E)),f.setUniformMatrix(`${w}.worldToIndex`,D),s.fill(0);const N=bn(new Float64Array(3),E,M);s[0]=N[0],s[4]=N[1],s[8]=N[2],ve(s,L,s),ve(s,p.normalMatrix,s),ve(s,d.normalMatrix,s),f.setUniformMatrix3x3(`${w}.vecISToVCMatrix`,s),f.setUniformMatrix3x3(`${w}.vecVCToISMatrix`,ge(new Float32Array(9),s));const F=hn(R[0],R[2],R[4]),_=wn(new Float64Array(3),F,i);f.setUniform3fv(`${w}.originVC`,_);const G=mn(N);if(f.setUniformf(`${w}.diagonalLength`,G),n(O)){const e=g.getDistance();g.setClippingRange(e,e+.1),h(u,t.openGLCamera.getKeyMatrices(o).wcpc),g.setClippingRange(v[0],v[1]),t.openGLCamera.getKeyMatrices(o),f.setUniformMatrix(`${w}.PCWCMatrix`,u)}if(O.getVolumetricScatteringBlending()>0&&(f.setUniformf(`${w}.globalIlluminationReach`,O.getGlobalIlluminationReach()),f.setUniformf(`${w}.volumetricScatteringBlending`,O.getVolumetricScatteringBlending()),f.setUniformf(`${w}.anisotropy`,O.getAnisotropy()),f.setUniformf(`${w}.anisotropySquared`,O.getAnisotropy()**2)),O.getLocalAmbientOcclusion()&&O.getAmbient()>0){const e=O.getLAOKernelSize();f.setUniformi(`${w}.kernelSize`,e);const t=O.getLAOKernelRadius();f.setUniformi(`${w}.kernelRadius`,t)}else f.setUniformi(`${w}.kernelSize`,0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();o.setUniformi("jtexture",t.jitterTexture.getTextureUnit());const a=r.getProperties();o.setUniformi("labelOutlineThicknessTexture",t.labelOutlineThicknessTexture.getTextureUnit()),o.setUniformi("opacityTexture",t.opacityTexture.getTextureUnit()),o.setUniformi("colorTexture",t.colorTexture.getTextureUnit());const i="volume",s=a[t.currentValidInputs[0].inputIndex],l=t.previousState.numberOfComponents,c=t.previousState.useIndependentComponents;if(c){const e=new Float32Array(4);for(let t=0;t<l;t++)e[t]=s.getComponentWeight(t);o.setUniform4fv(`${i}.independentComponentMix`,e);const t=new Float32Array(4),n=1/l;for(let e=0;e<l;++e)t[e]=(e+.5)*n;o.setUniform4fv(`${i}.transferFunctionsSampleHeight`,t)}const u=t.colorForValueFunctionId;o.setUniformi(`${i}.colorForValueFunctionId`,u);const d=s.getComputeNormalFromOpacity();o.setUniformi(`${i}.computeNormalFromOpacity`,d);const p=new Float32Array(4),f=new Float32Array(4),g=new Float32Array(4),m=new Float32Array(4);for(let e=0;e<l;e++){const n=t.previousState.multiTexturePerVolumeEnabled,r=n?e:0,o=n?0:e,a=t.scalarTextures[r].getVolumeInfo(),i=c?e:0,l=a.scale[o],u=s.getRGBTransferFunction(i).getRange();p[e]=l/(u[1]-u[0]),f[e]=(a.offset[o]-u[0])/(u[1]-u[0]);const d=s.getScalarOpacity(i).getRange();g[e]=l/(d[1]-d[0]),m[e]=(a.offset[o]-d[0])/(d[1]-d[0])}if(o.setUniform4fv(`${i}.colorTextureScale`,p),o.setUniform4fv(`${i}.colorTextureShift`,f),o.setUniform4fv(`${i}.opacityTextureScale`,g),o.setUniform4fv(`${i}.opacityTextureShift`,m),t.previousState.gradientOpacityEnabled){const e=new Array(4),n=new Array(4),r=new Array(4),a=new Array(4);if(c)for(let o=0;o<l;++o){const i=t.previousState.multiTexturePerVolumeEnabled,l=i?o:0,c=i?0:o,u=t.scalarTextures[l].getVolumeInfo().scale[c];if(s.getUseGradientOpacity(o)){const t=[s.getGradientOpacityMinimumOpacity(o),s.getGradientOpacityMaximumOpacity(o)],i=[s.getGradientOpacityMinimumValue(o),s.getGradientOpacityMaximumValue(o)];r[o]=t[0],a[o]=t[1],e[o]=u*(t[1]-t[0])/(i[1]-i[0]),n[o]=-i[0]*(t[1]-t[0])/(i[1]-i[0])+t[0]}else r[o]=1,a[o]=1,e[o]=0,n[o]=1}else{const o=l-1,i=t.previousState.multiTexturePerVolumeEnabled,c=i?o:0,u=i?0:o,d=t.scalarTextures[c].getVolumeInfo().scale[u],p=[s.getGradientOpacityMinimumOpacity(0),s.getGradientOpacityMaximumOpacity(0)],f=[s.getGradientOpacityMinimumValue(0),s.getGradientOpacityMaximumValue(0)];r[0]=p[0],a[0]=p[1],e[0]=d*(p[1]-p[0])/(f[1]-f[0]),n[0]=-f[0]*(p[1]-p[0])/(f[1]-f[0])+p[0]}o.setUniform4f(`${i}.gradientOpacityScale`,e),o.setUniform4f(`${i}.gradientOpacityShift`,n),o.setUniform4f(`${i}.gradientOpacityMin`,r),o.setUniform4f(`${i}.gradientOpacityMax`,a)}const h=s.getLabelOutlineOpacity();if(o.setUniformf(`${i}.outlineOpacity`,h),t.numberOfLights>0){o.setUniformf(`${i}.ambient`,s.getAmbient()),o.setUniformf(`${i}.diffuse`,s.getDiffuse()),o.setUniformf(`${i}.specular`,s.getSpecular());const e=s.getSpecularPower();o.setUniformf(`${i}.specularPower`,0===e?1:e)}},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();On(t,t,r.normalMatrix),wn(n,n,r.wcvc);const l=-1*An(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv("vClipPlaneNormals",o),c.setUniformfv("vClipPlaneDistances",a),c.setUniform3fv("vClipPlaneOrigins",i),c.setUniformi("clip_numPlanes",l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),(()=>{t._openGLRenderWindow&&a(t._openGLRenderWindow)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n&&n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r);const a=r.getProperties();t.currentValidInputs.forEach((e=>{let{inputIndex:n}=e;const r=a[n].getInterpolationType(),o=t.scalarTextures[n];r===bf.NEAREST?(o.setMinificationFilter(Fu.NEAREST),o.setMagnificationFilter(Fu.NEAREST)):(o.setMinificationFilter(Fu.LINEAR),o.setMagnificationFilter(Fu.LINEAR))})),null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context,a=[...t.scalarTextures,t.colorTexture,t.opacityTexture,t.labelOutlineThicknessTexture,t.jitterTexture];a.forEach((e=>e.activate())),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),a.forEach((e=>e.deactivate()))},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","uniform vec2 tfactor;","varying vec2 tcoord;","void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"),["//VTK::System::Dec","//VTK::Output::Dec","uniform sampler2D texture1;","varying vec2 tcoord;","void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"),"");const e=t.copyShader;t.copyVAO=Eu.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Of("Error setting vertexDC in copy shader VAO.")}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi("texture",n.getTextureUnit()),t.copyShader.setUniform2f("tfactor",t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update();const o=t.renderable.getNumberOfInputPorts();t.currentValidInputs=[];for(let e=0;e<o;++e){const n=t.renderable.getInputData(e);n&&!n.isDeleted()&&t.currentValidInputs.push({imageData:n,inputIndex:e})}let a=0;if(t.currentValidInputs.length>0){const e=r.getProperties(),o=t.currentValidInputs[0],i=o.imageData.getPointData().getScalars(),s=e[o.inputIndex];s.getShade()&&t.renderable.getBlendMode()===Af.COMPOSITE_BLEND&&n.getLights().forEach((e=>{e.getSwitch()>0&&a++}));const l=t.currentValidInputs.length,c=l>1;t.numberOfComponents=c?l:i.getNumberOfComponents(),t.useIndependentComponents=function(e,t){const n=e.getIndependentComponents(),r=e.getColorMixPreset();return n&&t>=2||!!r}(s,t.numberOfComponents)}a!==t.numberOfLights&&(t.numberOfLights=a,e.modified()),e.invokeEvent({type:"EndEvent"}),0!==t.currentValidInputs.length&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty(t.currentValidInputs[0].inputIndex)?.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.currentValidInputs.some((e=>{let{imageData:n}=e;return t.VBOBuildTime.getMTime()<n.getMTime()}))||t.scalarTextures.length!==t.currentValidInputs.length||!t.scalarTextures.every((e=>!!e?.getHandle()))||!t.colorTexture?.getHandle()||!t.opacityTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle()||!t.jitterTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{if(!t.jitterTexture.getHandle()){const e=new Float32Array(1024);for(let t=0;t<1024;++t)e[t]=Math.random();t.jitterTexture.setMinificationFilter(Fu.NEAREST),t.jitterTexture.setMagnificationFilter(Fu.NEAREST),t.jitterTexture.create2DFromRaw({width:32,height:32,numComps:1,dataType:is.FLOAT,data:e})}const a=r.getProperties(),i=t.currentValidInputs[0],s=a[i.inputIndex],l=t.numberOfComponents,c=t.useIndependentComponents,u=c?l:1,d=[];for(let e=0;e<u;++e)d.push(s.getScalarOpacity(e));const p=Xp(d,c,u),f=s.getScalarOpacity(),g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g.hash===p)t.opacityTexture=g.oglObject;else{const r=td.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow);let o=t.renderable.getOpacityTextureWidth();o<=0&&(o=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const a=2*o*u,i=new Float32Array(a),l=new Float32Array(o);for(let t=0;t<u;++t){const r=s.getScalarOpacity(t),a=e.getCurrentSampleDistance(n)/s.getScalarOpacityUnitDistance(t),c=r.getRange();r.getTable(c[0],c[1],o,l,1);for(let e=0;e<o;++e)i[t*o*2+e]=1-(1-l[e])**a,i[t*o*2+e+o]=i[t*o*2+e]}if(r.resetFormatAndType(),r.setMinificationFilter(Fu.LINEAR),r.setMagnificationFilter(Fu.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))r.create2DFromRaw({width:o,height:2*u,numComps:1,dataType:is.FLOAT,data:i});else{const e=new Uint8ClampedArray(a);for(let t=0;t<a;++t)e[t]=255*i[t];r.create2DFromRaw({width:o,height:2*u,numComps:1,dataType:is.UNSIGNED_CHAR,data:e})}f&&t._openGLRenderWindow.setGraphicsResourceForObject(f,r,p),t.opacityTexture=r}o(t._openGLRenderWindow,t._opacityTextureCore,f),t._opacityTextureCore=f;const m=[];for(let e=0;e<u;++e)m.push(s.getRGBTransferFunction(e));const h=Xp(m,c,u),v=s.getRGBTransferFunction(),T=t._openGLRenderWindow.getGraphicsResourceForObject(v);if(T?.oglObject?.getHandle()&&T?.hash===h)t.colorTexture=T.oglObject;else{const e=td.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(2*n*u*3),o=new Float32Array(3*n);for(let e=0;e<u;++e){const t=s.getRGBTransferFunction(e),a=t.getRange();t.getTable(a[0],a[1],n,o,1);for(let t=0;t<3*n;++t)r[e*n*6+t]=255*o[t],r[e*n*6+t+3*n]=255*o[t]}e.resetFormatAndType(),e.setMinificationFilter(Fu.LINEAR),e.setMagnificationFilter(Fu.LINEAR),e.create2DFromRaw({width:n,height:2*u,numComps:3,dataType:is.UNSIGNED_CHAR,data:r}),t._openGLRenderWindow.setGraphicsResourceForObject(v,e,h),t.colorTexture=e}o(t._openGLRenderWindow,t._colorTextureCore,v),t._colorTextureCore=v,t.currentValidInputs.forEach(((e,n)=>{let{imageData:r,inputIndex:i}=e;const s=a[i],l=r.getPointData().getScalars(),c=t._openGLRenderWindow.getGraphicsResourceForObject(l),u=Yp(0,l),d=!c?.oglObject?.getHandle()||c?.hash!==u,p=s.getUpdatedExtents(),f=!!p.length;if(d&&!f){const e=td.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);const o=r.getDimensions();e.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),e.resetFormatAndType(),e.create3DFilterableFromDataArray({width:o[0],height:o[1],depth:o[2],dataArray:l,preferSizeOverAccuracy:s.getPreferSizeOverAccuracy()}),t._openGLRenderWindow.setGraphicsResourceForObject(l,e,u),t.scalarTextures[n]=e}else t.scalarTextures[n]=c.oglObject;if(f){s.setUpdatedExtents([]);const e=r.getDimensions();t.scalarTextures[n].create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:l,updatedExtents:p})}o(t._openGLRenderWindow,t._scalarTexturesCore[n],l),t._scalarTexturesCore[n]=l}));const y=s.getLabelOutlineThickness(),b=t._openGLRenderWindow.getGraphicsResourceForObject(y),x=y.join("-");if(b?.oglObject?.getHandle()&&b?.hash===x)t.labelOutlineThicknessTexture=b.oglObject;else{const e=td.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=1,o=new Uint8Array(n*r);for(let e=0;e<n;++e){const t=void 0!==y[e]?y[e]:y[0];o[e]=t}e.resetFormatAndType(),e.setMinificationFilter(Fu.NEAREST),e.setMagnificationFilter(Fu.NEAREST),e.create2DFromRaw({width:n,height:r,numComps:1,dataType:is.UNSIGNED_CHAR,data:o}),y&&t._openGLRenderWindow.setGraphicsResourceForObject(y,e,x),t.labelOutlineThicknessTexture=e}if(o(t._openGLRenderWindow,t._labelOutlineThicknessTextureCore,y),t._labelOutlineThicknessTextureCore=y,!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Ts.newInstance({numberOfComponents:3,values:e});r.setName("points");const o=Ts.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,"polys",qi.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLVolumeMapper");en("vtkVolumeMapper",Mf);const{vtkDebugMacro:Ef}=jt,Vf={};const Df=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vf,n),Xt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():Ef("No framebuffer to save/restore");const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}(e,t)}),"vtkOpenGLPixelSpaceCallbackMapper");en("vtkPixelSpaceCallbackMapper",Df);var Lf="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtktextureObjectVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\nattribute vec2 tcoordDC;\nvarying vec2 tcoordVC;\n\nvoid main()\n{\n  tcoordVC = tcoordDC;\n  gl_Position = vertexDC;\n}\n";const{Representation:Bf}=ts;function Nf(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=td.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw({width:o,height:a,numComps:4,dataType:"Float32Array",data:null}),s.activate(),s.sendParameters(),s.deactivate(),s}function Ff(e,t){return Nf(e,t,td.Filter.NEAREST,td.Wrap.CLAMP_TO_EDGE)}const _f={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function Gf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_f,n),Ht.obj(e,t),Ht.get(e,t,["readIndex"]),Ht.setGet(e,t,["doEEPass","doVTPass","_openGLRenderWindow","vectorTexture","maskVectorTexture","noiseTexture","framebuffer","size"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkLICPingPongBufferManager"),t._openGLRenderWindow?(t.quad=function(e){const t=Bu.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ts.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ts.newInstance({numberOfComponents:1,values:o}),s=Ts.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",Bf.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=Ff(t._openGLRenderWindow,t.size),t.seedTexture0=Ff(t._openGLRenderWindow,t.size),t.licTexture1=Ff(t._openGLRenderWindow,t.size),t.seedTexture1=Ff(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?Nf(t._openGLRenderWindow,t.size,td.Filter.NEAREST,td.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?(n=t._openGLRenderWindow,r=t.size,Nf(n,r,td.Filter.LINEAR,td.Wrap.CLAMP_TO_EDGE)):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=Eu.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error("Wrong LIC pass number")}},e.deactivateNoiseTexture=function(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error("Wrong LIC pass number")}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error("Pass renderwindow to ping pong manager");var n,r}(e,t)}var kf={newInstance:Ht.newInstance(Gf,"vtkLICPingPongBufferManager"),extend:Gf};const Uf=0,zf=1,Wf=2,Hf=3,jf=1,Kf={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function $f(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kf,n),Ht.obj(e,t),Ht.setGet(e,t,["context","_openGLRenderWindow","nuberOfSteps","stepSize","normalizeVectors","maskThreshold","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","componentIds","isComposite"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){function n(e,t){e.setUniformi("texLIC",t.getLICTextureUnit()),e.setUniformi("texSeedPts",t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push("vtkLineIntegralConvolution2D"),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Lf,e,""),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=qd.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t="xyzw";return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n/**\nThis shader initializes the convolution for the LIC computation.\n*/\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texMaskVectors;\nuniform sampler2D texNoise;\nuniform sampler2D texLIC;\n\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the *whole* domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value. this\n// depends on the pass number.\nvec2 getNoiseTC(vec2 vectc)\n{\n  // in pass 1 : convert from vector tc to noise tc\n  // in pass 2 : use vector tc\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(vectc);\n    }\n  else\n    {\n    return vectc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the\n// need to convert to noise texture coordinates.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\nvoid main(void)\n{\n  vec2 vectc = tcoordVC.st;\n\n  // lic => (convolution, mask, 0, step count)\n  if (uStepNo == 0)\n    {\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\n    float maskFlag;\n    if (maskCriteria <= uMaskThreshold)\n      {\n      maskFlag = 1.0;\n      }\n    else\n      {\n      maskFlag = 0.0;\n      }\n    float noise = getNoise(vectc);\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\n    }\n  else\n    {\n    LICOutput = texture2D(texLIC, vectc);\n    }\n\n  // initial seed\n  SeedOutput = vec4(vectc, 0.0, 1.0);\n}\n");const n=Pu.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// move vector field to normalized image space\n// pre-processing for vtkLineIntegralConvolution2D\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Fragment shader used by the gaussian blur filter render pass.\n\nuniform sampler2D texVectors; // input texture\nuniform vec2      uTexSize;   // size of texture\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  //VTK::LICComponentSelection::Impl\n  V = V/uTexSize;\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\n}\n","//VTK::LICComponentSelection::Impl",`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=Pu.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D  texVectors;\nuniform sampler2D  texNoise;\nuniform sampler2D  texLIC;\nuniform sampler2D  texSeedPts;\n\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\nuniform float uStepSize;        // step size in parametric space\n\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n//VTK::LICVectorLookup::Impl\n\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\n// are very poorly supported in webgl\nvec2 clampToBorder(vec2 uv){\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n  {\n    return vec2(0.0, 0.0);\n  }\n  return getVector(uv);\n}\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the whole domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value.\n// in pass 1 repeatedly tile the noise texture across\n// the computational domain.\nvec2 getNoiseTC(vec2 tc)\n{\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(tc);\n    }\n  else\n    {\n    return tc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the need\n// to convert to either noise or lic texture coordinates in\n// pass 1 and 2 respectively.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\n// fourth-order Runge-Kutta streamline integration\n// no bounds checks are made, therefore it's essential\n// to have the entire texture initialized to 0\n// and set clamp to border and have border color 0\n// an integer is set if the step was taken, keeping\n// an accurate step count is necessary to prevent\n// boundary artifacts. Don't count the step if\n// all vector lookups are identically 0. This is\n// a proxy for \"stepped outside valid domain\"\nvec2 rk4(vec2 pt0, float dt, out bool count)\n{\n  count=true;\n  float dtHalf = dt * 0.5;\n  vec2 pt1;\n\n  vec2 v0 = clampToBorder(pt0);\n  pt1 = pt0 + v0 * dtHalf;\n\n  vec2 v1 = clampToBorder(pt1);\n  pt1 = pt0 + v1 * dtHalf;\n\n  vec2 v2 = clampToBorder(pt1);\n  pt1 = pt0 + v2 * dt;\n\n  vec2 v3 = clampToBorder(pt1);\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\n\n  if (vSum == vec2(0.0, 0.0))\n    {\n      count = false;\n    }\n\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\n\n return pt1;\n}\n\nvoid main(void)\n{\n  vec2 lictc = tcoordVC.st;\n  vec4 lic = texture2D(texLIC, lictc);\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\n\n  bool count;\n  vec2 pt1 = rk4(pt0, uStepSize, count);\n\n  if (count)\n    {\n    // accumulate lic step\n    // (lic, mask, 0, step count)\n    float noise = getNoise(pt1);\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\n    SeedOutput = vec4(pt1, 0.0, 1.0);\n    }\n  else\n    {\n    // keep existing values\n    LICOutput = lic;\n    SeedOutput = vec4(pt0, 0.0, 1.0);\n    }\n}\n","//VTK::LICVectorLookup::Impl",function(){return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?"\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      return texture2D( texVectors, vectc ).xy;\n\n      }\n\n    ":"\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      vec2 V = texture2D( texVectors, vectc ).xy;\n\n      // normalize if |V| not 0\n\n      float lenV = length( V );\n\n      if ( lenV > 1.0e-8 )\n\n        {\n\n        return V/lenV;\n\n        }\n\n      else\n\n        {\n\n        return vec2( 0.0, 0.0 );\n\n        }\n\n      }\n\n    "}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(" //VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n/**\nThis shader finalizes the convolution for the LIC computation\napplying the normalization. eg. if box kernel is used the this\nis the number of steps taken.\n*/\n\nuniform sampler2D texLIC;\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\n  conv.r = conv.r/conv.a;\n  // lic => (convolution, mask, 0, 1)\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.CEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// gray scale contrast enhance stage implemented via histogram stretching\n// if the min and max are tweaked it can generate out-of-range values\n// these will be clamped in 0 to 1\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n\nuniform sampler2D texLIC;  // most recent lic pass\nuniform float uMin;        // min gray scale color value\nuniform float uMaxMinDiff; // max-min\n\nin vec2 tcoordVC;\n\nvoid main( void )\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g!=0.0)\n    {\n    LICOutput = lic;\n    }\n  else\n    {\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\n    LICOutput = vec4(CElic, lic.gb, 1.0);\n    }\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.EEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\n// noise for pass2.\n\n// the output of this shader\nlayout(location = 0) out vec4 EEOutput;\n\nuniform sampler2D texLIC; // most recent lic pass\nuniform float     uDx;    // fragment size\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n// kernel for simple laplace edge enhancement.\n// p=Laplace(p)+p\nfloat K[9] = float[9](\n  -1.0, -1.0, -1.0,\n  -1.0,  9.0, -1.0,\n  -1.0, -1.0, -1.0\n  );\n\n// determine if the fragment was masked\nbool Masked(float val) { return val != 0.0; }\n\nvoid main(void)\n{\n  // tex coord neighbor offsets\n  vec2 fragDx[9] = vec2[9](\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\n    );\n\n  vec2 lictc = tcoordVC.st;\n\n  // compute the convolution but don't use convovled values if\n  // any masked fragments on the stencil. Fragments outside\n  // the valid domain are masked during initialization, and\n  // texture wrap parameters are clamp to border with border\n  // color that contains masked flag\n  float conv = 0.0;\n  bool dontUse = false;\n  for (int i=0; i<9; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    vec4 lic = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic.g);\n    conv = conv + K[i] * lic.r;\n    }\n\n  if (dontUse)\n    {\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\n    }\n  else\n    {\n    conv = clamp(conv, 0.0, 1.0);\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\n    }\n\n}\n"),t.AAHProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// horizontal pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDx;    // fragment size\n\nin vec2 tcoordVC;\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.AAVProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// vertical pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\n\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDy[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n")},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;const g=f?.getSize();f&&g&&o[0]===g&&o[1]===g||(f=qd.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=kf.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const m=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],h=1/o[0],v=1/o[1],T=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;T.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f("uTexSize",...o),e.setUniformi("texVectors",t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:y}=t;T.readyShaderProgram(y),y.setUniformi("uStepNo",0),y.setUniformi("uPassNo",0),y.setUniformf("uMaskThreshold",t.maskThreshold),y.setUniform2f("uNoiseBoundsPt1",...m),y.setUniformi("texMaskVectors",t.bufs.getMaskVectorTextureUnit()),y.setUniformi("texLIC",t.bufs.getLICTextureUnit()),y.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,y);const{LICIShaderProgram:b}=t;T.readyShaderProgram(b),b.setUniformi("uPassNo",0),b.setUniformf("uStepSize",-d),b.setUniform2f("uNoiseBoundsPt1",...m),b.setUniformi("texVectors",t.bufs.getImageVectorTextureUnit()),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);T.readyShaderProgram(y),y.setUniformi("uStepNo",1),n(y,t.bufs),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:x}=t;if(T.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),r(t.bufs,o,x),t.enhancedLIC){t.enhanceContrast!==zf&&t.enhanceContrast!==Hf||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;T.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDx",h),a.setUniformf("uDy",v),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),T.readyShaderProgram(y),y.setUniformi("uStepNo",0),y.setUniformi("uPassNo",1),n(y,t.bufs),y.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformi("uPassNo",1),b.setUniformf("uStepSize",-d),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);T.readyShaderProgram(y),y.setUniformi("uStepNo",1),n(y,t.bufs),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),T.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),x.setUniformi("texSeedPts",t.bufs.getSeedTextureUnit()),r(t.bufs,o,x)}if(t.antiAlias){const e=t.AAHProgram;T.readyShaderProgram(e),e.setUniformi("texLIC",t.bufs.getLICTextureUnit()),e.setUniformf("uDx",h);const a=t.AAVProgram;T.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDy",v);for(let i=0;i<t.antiAlias;++i)T.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),T.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==zf&&t.enhanceContrast!==Hf||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error("Invalid color range: ",i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi("texLIC",t.bufs.getLICTextureUnit()),c.setUniformf("uMin",i),c.setUniformf("uMaxMinDiff",l),r(t.bufs,o,c)}}(e,t)}var qf={newInstance:Ht.newInstance($f,"vtkLineIntegralConvolution2D"),extend:$f};const Xf={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:Uf,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:jf,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function Yf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xf,n),Ht.obj(e,t),Ht.setGet(e,t,["enableLIC","numberOfSteps","stepSize","normalizeVectors","transformVectors","maskOnSurface","maskThreshold","maskColor","maskIntensity","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor","antiAlias","colorMode","LICIntensity","mapModeBias","noiseTextureSize","noiseTextureType","noiseGrainSize","minNoiseValue","maxNoiseValue","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","noiseGeneratorSeed","viewPortScale","rebuildNoiseTexture"]),function(e,t){t.classHierarchy.push("vtkSurfaceLICInterface")}(0,t)}var Zf={newInstance:Ht.newInstance(Yf,"vtkSurfaceLICInterface"),extend:Yf};const{Representation:Qf}=ts;const Jf={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function eg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jf,n),Zf.extend(e,t,n),Ht.obj(e,t),Ht.setGet(e,t,["context","_openGLRenderWindow","reallocateTextures","licInterface","size"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICInterface"),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=Eu.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),io()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get("noiseTextureType","noiseGrainSize","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","minNoiseValue","maxNoiseValue");n=r===jf?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=td.newInstance({wrapS:td.Wrap.REPEAT,wrapT:td.Wrap.REPEAT,minificationFilter:td.Filter.NEAREST,magnificationFilter:td.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw({width:e,height:e,numComps:4,dataType:"Float32Array",data:d}),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Lf,e,""),e.allocateTextures=()=>{const n=td.Filter.NEAREST,r=td.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=td.newInstance({wrapS:td.Wrap.CLAMP_TO_EDGE,wrapT:td.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw({width:t.size[0],height:t.size[1],numComps:4,dataType:"Float32Array",data:null}),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=td.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw({width:t.size[0],height:t.size[1],dataType:"Float32Array",data:null}),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=qd.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader combines surface geometry, LIC, and  scalar colors.\n\n// the output of this shader\nlayout(location = 0) out vec4 RGBOutput;\nlayout(location = 1) out vec4 HSLOutput;\n\nuniform sampler2D texVectors;       // vectors, depth\nuniform sampler2D texGeomColors;    // scalar colors + lighting\nuniform sampler2D texLIC;           // image lic\nuniform int       uScalarColorMode; // select between blend, and map shader\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\nuniform float     uMaskIntensity;   // blending factor for mask color\nuniform vec3      uMaskColor;       // color for the masked out fragments\n\nin vec2 tcoordVC;\n\n/**\nConvert from RGB color space into HSL colorspace.\n*/\nvec3 RGBToHSL(vec3 RGB)\n{\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\n\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\n  float RGBMaxMinDiff = RGBMax - RGBMin;\n\n  HSL.z = (RGBMax + RGBMin) / 2.0;\n\n  if (RGBMaxMinDiff == 0.0)\n    {\n    // Gray scale\n    HSL.x = 0.0;\n    HSL.y = 0.0;\n    }\n  else\n    {\n    // Color\n    if (HSL.z < 0.5)\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\n    else\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\n\n    float dR\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dG\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dB\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n\n    if (RGB.r == RGBMax)\n      HSL.x = dB - dG;\n    else\n    if (RGB.g == RGBMax)\n      HSL.x = (1.0 / 3.0) + dR - dB;\n    else\n    if (RGB.b == RGBMax)\n      HSL.x = (2.0 / 3.0) + dG - dR;\n\n    if (HSL.x < 0.0)\n      HSL.x += 1.0;\n\n    if (HSL.x > 1.0)\n      HSL.x -= 1.0;\n    }\n\n  return HSL;\n}\n\n/**\nHelper for HSL to RGB conversion.\n*/\nfloat Util(float v1, float v2, float vH)\n{\n  if (vH < 0.0)\n    vH += 1.0;\n\n  if (vH > 1.0)\n     vH -= 1.0;\n\n  if ((6.0 * vH) < 1.0)\n    return (v1 + (v2 - v1) * 6.0 * vH);\n\n  if ((2.0 * vH) < 1.0)\n    return (v2);\n\n  if ((3.0 * vH) < 2.0)\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\n\n  return v1;\n}\n\n/**\nConvert from HSL space into RGB space.\n*/\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  if (HSL.y == 0.0)\n    {\n    // Gray\n    RGB.r = HSL.z;\n    RGB.g = HSL.z;\n    RGB.b = HSL.z;\n    }\n  else\n    {\n    // Chromatic\n    float v2;\n    if (HSL.z < 0.5)\n      v2 = HSL.z * (1.0 + HSL.y);\n    else\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\n\n    float v1 = 2.0 * HSL.z - v2;\n\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\n    RGB.g = Util(v1, v2, HSL.x);\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\n    }\n\n  return RGB.rgb;\n}\n\nvoid main()\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n\n  // depth is used to determine which fragment belong to us\n  // and we can change\n  float depth = texture2D(texVectors, tcoordVC.st).a;\n\n  vec3 fragColorRGB;\n  float valid;\n  if (depth > 1.0e-3)\n    {\n    // we own it\n    // shade LIC'ed geometry, or apply mask\n    if (lic.g!=0.0)\n      {\n      // it's masked\n      // apply fragment mask\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\n      valid = 0.0;\n      }\n    else\n      {\n      if (uScalarColorMode==0)\n        {\n        // blend with scalars\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\n        }\n      else\n        {\n        // multiply with scalars\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\n        }\n      if (lic.b != 0.0)\n        {\n        // didn't have the required guard pixels\n        // don't consider it in min max estimation\n        // for histpgram stretching\n        valid = 0.0;\n        }\n      else\n        {\n        // ok to use in min/max estimates for histogram\n        // stretching\n        valid = 1.0;\n        }\n      }\n    }\n  else\n    {\n    // we don't own it\n    // pass through scalars\n    fragColorRGB = geomColor.rgb;\n    valid = 0.0;\n    }\n\n  // if no further stages this texture is\n  // copied to the screen\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\n\n  // if further stages, move to hsl space for contrast\n  // enhancement. encoding validity saves moving a texture to the cpu\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\n  HSLOutput = vec4(fragColorHSL, valid);\n}\n"),t.licCopyPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader copies fragments and depths to the output buffer\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texDepth;     // z values from vertex shader\nuniform sampler2D texRGBColors; // final rgb LIC colors\n\nin vec2 tcoordVC;\n\nvoid main()\n{\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\n\n  // since we render a screen aligned quad\n  // we're going to be writing fragments\n  // not touched by the original geometry\n  // it's critical not to modify those\n  // fragments.\n  if (gl_FragDepth == 1.0)\n    {\n    discard;\n    }\n}\n"),t.enhanceContrastPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// color contrast enhance stage implemented via histogram stretching\n// on lightness channel. if the min and max are tweaked it can generate\n// out-of-range values these will be clamped in 0 to 1\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texGeomColors; // scalars + lighting\nuniform sampler2D texLIC;        // image lic, mask\nuniform sampler2D texHSLColors;  // hsla colors\n\nuniform float     uLMin;         // min lightness over all fragments\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\n\nin vec2 tcoordVC;\n\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  float v;\n  float h = HSL.x;\n  float sl = HSL.y;\n  float l = HSL.z;\n\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\n  if (v <= 0.0) {\n    RGB = vec3(0.0,0.0,0.0);\n  } else {\n    float m;\n    int sextant;\n    float fract, vsf, mid1, mid2;\n\n    m = l + l - v;\n    h *= 6.0;\n    sextant = int(h);\n    fract = h - float(sextant);\n\n    vsf = (v - m) * fract;\n    mid1 = m + vsf;\n    mid2 = v - vsf;\n    switch (sextant) {\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\n    }\n  }\n  return RGB;\n}\n\nvoid main()\n{\n  // lookup hsl color , mask\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\n\n  // don't modify masked fragments (masked => lic.g==1)\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g==0.0)\n    {\n    // normalize lightness channel\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\n    }\n\n  // back into rgb space\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\n\n  // add alpha\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n  fragColor.a = geomColor.a;\n\n  gl_FragData[0] = fragColor;\n}\n"),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=Bu.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ts.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ts.newInstance({numberOfComponents:1,values:o}),s=Ts.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",Qf.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=qf.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi("texDepth",t.depthTexture.getTextureUnit()),r.setUniformi("texRGBColors",t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi("texVectors",t.vectorImage.getTextureUnit()),o.setUniformi("texGeomColors",t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get("colorMode","LICIntensity","mapModeBias","maskIntensity","maskColor","enhanceContrast","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor");if(o.setUniformi("texLIC",t.LICImage.getTextureUnit()),o.setUniformi("uScalarColorMode",a),o.setUniformf("uLICIntensity",i),o.setUniformf("uMapBias",s),o.setUniformf("uMaskIntensity",l),o.setUniform3f("uMaskColor",...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===Wf||u===Hf){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi("texGeomColors",t.geometryImage.getTextureUnit()),s.setUniformi("texHSLColors",t.HSLColorImage.getTextureUnit()),s.setUniformi("texLIC",t.LICImage.getTextureUnit()),s.setUniformf("uLMin",o),s.setUniformf("uLMaxMinDiff",i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get("stepSize","numberOfSteps","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","normalizeVectors","maskThreshold","transformVectors"),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error("Failed to compute image LIC"),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}(e,t)}var tg={newInstance:Ht.newInstance(eg,"vtkSurfaceLICInterface"),extend:eg};const{vtkErrorMacro:ng}=jt,rg={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const og=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rg,n),bd.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICMapper");const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=Pu.substitute(s,"//VTK::Output::Dec",["//VTK::Output::Dec","layout(location = 2) out vec4 vectorTexture;","layout(location = 3) out vec4 maskVectorTexture;"]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=Pu.substitute(i,"//VTK::TCoord::Dec",[`attribute vec3 ${n};`,"out vec3 licOutput;","//VTK::TCoord::Dec"]).result,i=Pu.substitute(i,"//VTK::TCoord::Impl",[`licOutput = ${n};`,"//VTK::TCoord::Impl"]).result,s=Pu.substitute(s,"//VTK::TCoord::Dec",["uniform int uMaskOnSurface;","uniform mat3 normalMatrix;","in vec3 licOutput;","//VTK::TCoord::Dec"]).result,s=Pu.substitute(s,"//VTK::TCoord::Impl",["// projected vectors","  vec3 tcoordLIC = normalMatrix * licOutput;","  vec3 normN = normalize(normalVCVSOutput);","  float k = dot(tcoordLIC, normN);","  vec3 projected = (tcoordLIC - k*normN);","  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","// vectors for fragment masking","  if (uMaskOnSurface == 0)","    {","    maskVectorTexture = vec4(licOutput, 1.0);","    }","  else","    {","    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","    }","//VTK::TCoord::Impl"],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi("uMaskOnSurface",t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(ng("SurfaceLICMapper Requires WebGL 2"),a=!1),t.context.getExtension("EXT_color_buffer_float")&&t.context.getExtension("OES_texture_float_linear")||(ng("SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions."),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(ng("No input"),a=!1);let i=t.renderable.getLicInterface();i||(i=Zf.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=tg.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(ng("No vector input array"),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}(e,t),St(e,t,["openGLLicInterface"])}),"vtkOpenGLSurfaceLICMapper");en("vtkSurfaceLICMapper",og);const{vtkErrorMacro:ag}=jt,ig={};const sg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ig,n),bd.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLSphereMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=rd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=Pu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=Pu.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=Pu.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;\n"]).result,i=Pu.substitute(i,"//VTK::Normal::Dec",["uniform float invertedDepth;\n","uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=Pu.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float b = 2.0*dot(EyePos,EyeDir);\n","  float c = dot(EyePos,EyePos) - 1.0;\n","  float d = b*b - 4.0*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t = (-b - invertedDepth*sqrt(d))*0.5;\n","    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n","    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=Pu.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=Pu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"offsetMC",12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||ag("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isUniformUsed("invertedDepth")&&e.getProgram().setUniformf("invertedDepth",t.invert?-1:1),e.getProgram().isUniformUsed("scaleFactor")){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf("scaleFactor",t.renderable.getScaleFactor()):e.getProgram().setUniformf("scaleFactor",1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc);const s=new Float64Array(16);if(o.isUniformUsed("MCVCMatrix"))if(r.getIsIdentity())d(s,i.wcvc),e.getCABO().getCoordShiftAndScaleEnabled()&&y(s,s,e.getCABO().getInverseShiftAndScaleMatrix()),o.setUniformMatrix("MCVCMatrix",s);else{const n=t.openGLActor.getKeyMatrices();y(s,i.wcvc,n.mcwc),e.getCABO().getCoordShiftAndScaleEnabled()&&y(s,s,e.getCABO().getInverseShiftAndScaleMatrix()),o.setUniformMatrix("MCVCMatrix",s)}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(mu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(yo(30));let h=0,v=0;const{useShiftAndScale:T,coordShift:y,coordScale:b}=hu(s);T&&a.setCoordShiftAndScale(y,b);let x=0,C=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e;const r=(c[h++]-y[0])*b[0],o=(c[h++]-y[1])*b[1],a=(c[h++]-y[2])*b[2];g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=-2*n*m,g[x++]=-n,d&&(v=e*p,f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3]),g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=2*n*m,g[x++]=-n,d&&(f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3]),g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=0,g[x++]=2*n,d&&(f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3])}a.setElementCount(x/5),a.upload(g,uu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,uu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLSphereMapper");en("vtkSphereMapper",sg);const{vtkErrorMacro:lg}=jt,cg={};const ug=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cg,n),bd.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLStickMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=rd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=Pu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=Pu.substitute(i,"//VTK::PositionVC::Dec","varying vec4 vertexVCVSOutput;").result,i=Pu.substitute(i,"//VTK::PositionVC::Impl","  vec4 vertexVC = vertexVCVSOutput;\n").result,i=Pu.substitute(i,"//VTK::Normal::Dec",["uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 orientVCVSOutput;\n","varying float lengthVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=Pu.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  vec3 base1;\n","  if (abs(orientVCVSOutput.z) < 0.99) {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n","  else {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n","  vec3 base2 = cross(orientVCVSOutput,base1);\n","  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n","  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n","  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n","  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n","  float d = b*b - 4.0*a*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t =  (-b - sqrt(d))/(2.0*a);\n","    float tz = EyePos.z + t*EyeDir.z;\n","    vec3 iPoint = EyePos + t*EyeDir;\n","    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n","      float t2 = (-b + sqrt(d))/(2.0*a);\n","      float tz2 = EyePos.z + t2*EyeDir.z;\n","      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n","      else {\n","        normalVCVSOutput = orientVCVSOutput;\n","        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n","        iPoint = EyePos + t3*EyeDir;\n","        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","        }\n","      }\n","    else {\n","      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n","      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","      }\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=Pu.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=Pu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed("orientMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"orientMC",12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||lg("Error setting 'orientMC' in shader VAO.")),e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"offsetMC",0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||lg("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isAttributeUsed("radiusMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"radiusMC",24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||lg("Error setting 'radiusMC' in shader VAO."))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),r.getIsIdentity())o.isUniformUsed("MCVCMatrix")&&o.setUniformMatrix("MCVCMatrix",i.wcvc),o.isUniformUsed("normalMatrix")&&o.setUniformMatrix3x3("normalMatrix",i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed("MCVCMatrix")){const t=new Float64Array(16);y(t,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",t)}if(o.isUniformUsed("normalMatrix")){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3("normalMatrix",t)}}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(mu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():lg(["Error setting orientationArray.\n","You have to specify the stick orientation"]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let T=0,y=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)T=3*e,f[b++]=c[T++],f[b++]=c[T++],f[b++]=c[T++],T=3*e,f[b++]=h[T++]*n,f[b++]=h[T++]*n,f[b++]=h[T++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,y=e*p,d&&(g[x++]=d[y],g[x++]=d[y+1],g[x++]=d[y+2],g[x++]=d[y+3])}a.setElementCount(b/7),a.upload(f,uu.ARRAY_BUFFER),a.getColorBO().upload(g,uu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLStickMapper");en("vtkStickMapper",ug);const dg=[];dg["-".charCodeAt(0)]=62,dg["_".charCodeAt(0)]=63;const pg="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let e=0;e<64;e++)dg[pg.charCodeAt(e)]=e;function fg(e){return void 0!==dg[e.charCodeAt(0)]}function gg(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!fg(e[l]);)l++;for(c=dg[e.charCodeAt(l++)]<<18;!fg(e[l]);)l++;for(c|=dg[e.charCodeAt(l++)]<<12;!fg(e[l]);)l++;for(c|=dg[e.charCodeAt(l++)]<<6;!fg(e[l]);)l++;c|=dg[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!fg(e[l]);)l++;for(c=dg[e.charCodeAt(l++)]<<10;!fg(e[l]);)l++;for(c|=dg[e.charCodeAt(l++)]<<4;!fg(e[l]);)l++;c|=dg[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!fg(e[l]);)l++;for(c=dg[e.charCodeAt(l++)]<<2;!fg(e[l]);)l++;c|=dg[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error("BASE64: remain 1 should not happen")}return u}function mg(e,t,n){const r=(e<<16)+(t<<8)+n;return pg[r>>18]+pg[r>>12&63]+pg[r>>6&63]+pg[63&r]}function hg(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=mg(t[n],t[n+1],t[n+2])}if(n>0){const e=mg(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join("")}var vg={toArrayBuffer:function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)fg(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):"="===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=gg(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o},fromArrayBuffer:hg};const Tg={};function yg(e,t){Tg[e]=t}var bg={get:function(){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Tg[arguments.length>0&&void 0!==arguments[0]?arguments[0]:"http"](e)},has:function(e){return!!Tg[e]},registerType:yg},xg=Uint8Array,Cg=Uint16Array,Sg=Uint32Array,Ag=new xg([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Ig=new xg([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),wg=new xg([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Og=function(e,t){for(var n=new Cg(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new Sg(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},Pg=Og(Ag,2),Rg=Pg[0],Mg=Pg[1];Rg[28]=258,Mg[258]=28;for(var Eg=Og(Ig,0),Vg=Eg[0],Dg=(Eg[1],new Cg(32768)),Lg=0;Lg<32768;++Lg){var Bg=(43690&Lg)>>>1|(21845&Lg)<<1;Bg=(61680&(Bg=(52428&Bg)>>>2|(13107&Bg)<<2))>>>4|(3855&Bg)<<4,Dg[Lg]=((65280&Bg)>>>8|(255&Bg)<<8)>>>1}var Ng=function(e,t,n){for(var r=e.length,o=0,a=new Cg(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new Cg(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new Cg(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[Dg[d]>>>l]=c}else for(i=new Cg(r),o=0;o<r;++o)e[o]&&(i[o]=Dg[s[e[o]-1]++]>>>15-e[o]);return i},Fg=new xg(288);for(Lg=0;Lg<144;++Lg)Fg[Lg]=8;for(Lg=144;Lg<256;++Lg)Fg[Lg]=9;for(Lg=256;Lg<280;++Lg)Fg[Lg]=7;for(Lg=280;Lg<288;++Lg)Fg[Lg]=8;var _g=new xg(32);for(Lg=0;Lg<32;++Lg)_g[Lg]=5;var Gg=Ng(Fg,9,1),kg=Ng(_g,5,1),Ug=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},zg=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},Wg=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},Hg=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?Cg:4==e.BYTES_PER_ELEMENT?Sg:xg)(n-t);return r.set(e.subarray(t,n)),r},jg=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],Kg=function(e,t,n){var r=new Error(t||jg[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,Kg),!n)throw r;return r},$g=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new xg(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new xg(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new xg(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=zg(e,c,1);var h=zg(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(P=4+((i+7)/8|0))-4)]|e[P-3]<<8,T=P+v;if(T>r){a&&Kg(0);break}o&&s(u+v),t.set(e.subarray(P,T),u),n.b=u+=v,n.p=c=8*T,n.f=l;continue}if(1==h)d=Gg,p=kg,f=9,g=5;else if(2==h){var y=zg(e,c,31)+257,b=zg(e,c+10,15)+4,x=y+zg(e,c+5,31)+1;c+=14;for(var C=new xg(x),S=new xg(19),A=0;A<b;++A)S[wg[A]]=zg(e,c+3*A,7);c+=3*b;var I=Ug(S),w=(1<<I)-1,O=Ng(S,I,1);for(A=0;A<x;){var P,R=O[zg(e,c,w)];if(c+=15&R,(P=R>>>4)<16)C[A++]=P;else{var M=0,E=0;for(16==P?(E=3+zg(e,c,3),c+=2,M=C[A-1]):17==P?(E=3+zg(e,c,7),c+=3):18==P&&(E=11+zg(e,c,127),c+=7);E--;)C[A++]=M}}var V=C.subarray(0,y),D=C.subarray(y);f=Ug(V),g=Ug(D),d=Ng(V,f,1),p=Ng(D,g,1)}else Kg(1);if(c>m){a&&Kg(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var F=(M=d[Wg(e,c)&L])>>>4;if((c+=15&M)>m){a&&Kg(0);break}if(M||Kg(2),F<256)t[u++]=F;else{if(256==F){N=c,d=null;break}var _=F-254;if(F>264){var G=Ag[A=F-257];_=zg(e,c,(1<<G)-1)+Rg[A],c+=G}var k=p[Wg(e,c)&B],U=k>>>4;if(k||Kg(3),c+=15&k,D=Vg[U],U>3&&(G=Ig[U],D+=Wg(e,c)&(1<<G)-1,c+=G),c>m){a&&Kg(0);break}o&&s(u+131072);for(var z=u+_;u<z;u+=4)t[u]=t[u-D],t[u+1]=t[u+1-D],t[u+2]=t[u+2-D],t[u+3]=t[u+3-D];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:Hg(t,0,u)},qg=new xg(0),Xg=function(e,t){return e[t]|e[t+1]<<8},Yg=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},Zg=function(e,t){return Yg(e,t)+4294967296*Yg(e,t+4)};function Qg(e,t){return $g(e,t)}function Jg(e,t){return $g(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||Kg(6,"invalid gzip data");var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new xg((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function em(e,t){return $g(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&Kg(6,"invalid zlib data"),32&n[1]&&Kg(6,"invalid zlib data: preset dictionaries not supported"),e.subarray(2,-4)),t);var n}function tm(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?Jg(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?Qg(e,t):em(e,t)}var nm="undefined"!=typeof TextEncoder&&new TextEncoder,rm="undefined"!=typeof TextDecoder&&new TextDecoder;try{rm.decode(qg,{stream:!0})}catch(e){}function om(e,t){if(t){for(var n="",r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(rm)return rm.decode(e);var o=function(e){for(var t="",n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,Hg(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&Kg(8),a}var am=function(e,t){return t+30+Xg(e,t+26)+Xg(e,t+28)},im=function(e,t,n){var r=Xg(e,t+28),o=om(e.subarray(t+46,t+46+r),!(2048&Xg(e,t+8))),a=t+46+r,i=Yg(e,t+20),s=n&&4294967295==i?sm(e,a):[i,Yg(e,t+24),Yg(e,t+42)],l=s[0],c=s[1],u=s[2];return[Xg(e,t+10),l,c,o,a+Xg(e,t+30)+Xg(e,t+32),u]},sm=function(e,t){for(;1!=Xg(e,t);t+=4+Xg(e,t+2));return[Zg(e,t+12),Zg(e,t+4),Zg(e,t+20)]};function lm(e,t){for(var n={},r=e.length-22;101010256!=Yg(e,r);--r)(!r||e.length-r>65558)&&Kg(13);var o=Xg(e,r+8);if(!o)return{};var a=Yg(e,r+16),i=4294967295==a;i&&(r=Yg(e,r-12),101075792!=Yg(e,r)&&Kg(13),o=Yg(e,r+32),a=Yg(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=im(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=am(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=Qg(e.subarray(h,h+d),new xg(p)):Kg(14,"unknown compression type "+u):n[f]=Hg(e,h,h+d))}return n}function cm(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?"LittleEndian":2712847316===n[0]?"BigEndian":null}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;var um=cm(),dm=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:pm,vtkDebugMacro:fm}=Ht;let gm=0;function mm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener("progress",n.progressCallback),r}const hm={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/");const s=mm("GET",i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++gm&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=om(tm(new Uint8Array(n.buffer))):n.buffer=tm(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(um!==n.ref.encode&&um&&(fm(`Swap bytes of ${n.name}`),dm(n.buffer,as[n.dataType])),n.values=Ht.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&pm(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--gm&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||"string"!==n.dataType?"arraybuffer":"text",s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=mm("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++gm&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--gm&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(om(tm(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&"gz"!==n.compression&&(pm("Supported algorithms are: [gz]"),pm(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=mm("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++gm&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--gm&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(om(tm(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&"gz"!==t.compression&&(pm("Supported algorithms are: [gz]"),pm(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=mm("GET",e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(tm(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType="arraybuffer",o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};yg("http",(e=>hm));const{vtkDebugMacro:vm}=Ht,Tm={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function ym(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tm,n),Ht.obj(e,t),Ht.get(e,t,["distance"]),Ht.setGet(e,t,["parallelProjection","useHorizontalViewAngle","viewAngle","parallelScale","useOffAxisProjection","freezeFocalPoint","physicalScale"]),Ht.getArray(e,t,["directionOfProjection","viewPlaneNormal","position","focalPoint"]),Ht.setGetArray(e,t,["clippingRange","windowCenter"],2),Ht.setGetArray(e,t,["viewUp","screenBottomLeft","screenBottomRight","screenTopRight","physicalTranslation","physicalViewUp","physicalViewNorth"],3),function(e,t){t.classHierarchy.push("vtkCamera");const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function T(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,vm("Distance is set to minimum."));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,vm("Distance is set to minimum.");const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,T()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,yo(n),s),Ba(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,yo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),wn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,yo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),wn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,yo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),wn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,yo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),wn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Eo(t.position,a,t.position),Eo(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Ba(o,[...t.position,1],n),Ba(a,[...t.focalPoint,1],n),Ba(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,vm("Thickness is set to minimum.")),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,vm("Thickness is set to minimum.")),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),O(i,[t.distance,t.distance,t.distance]),y(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=Ga(e[0],e[1],e[2],e[3]),n=Na(),r=Ga(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],_a(r,t,r),_a(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Fo(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),vn(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),wn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),wn(l,r,a),yn(l,l,s),Sn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),wn(c,o,a),yn(c,c,s),Sn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),y(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return vn(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error("Off-Axis projection is not supported at this time");{const n=Math.tan(yo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return y(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,T()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Fo(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,yo(n),t.physicalViewUp),C(s,s,yo(r),i),C(s,s,yo(o),t.physicalViewNorth),C(s,s,yo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);wn(l,l,s),wn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=yo(t),i=Na();Fa(i,[n,r,o],e),G(a,i)}const i=new Float64Array(3);wn(i,[0,0,-1],a);const s=new Float64Array(3);wn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}(e,t)}var bm={newInstance:Ht.newInstance(ym,"vtkCamera"),extend:ym};const xm={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:"SceneLight",shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Cm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xm,n),Ht.obj(e,t),Ht.setGet(e,t,["intensity","switch","positional","exponent","coneAngle","coneFalloff","transformMatrix","lightType","shadowAttenuation","attenuationValues"]),Ht.setGetArray(e,t,["color","position","focalPoint","attenuationValues"],3),function(e,t){t.classHierarchy.push("vtkLight");const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?wn(n,t.position,t.transformMatrix):vn(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?wn(n,t.focalPoint,t.transformMatrix):vn(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(Mn(t.direction,t.focalPoint,t.position),Go(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);Mn(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=yo(t),o=yo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType("HeadLight")},e.setLightTypeToCameraLight=()=>{e.setLightType("CameraLight")},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType("SceneLight")},e.lightTypeIsHeadLight=()=>"HeadLight"===t.lightType,e.lightTypeIsSceneLight=()=>"SceneLight"===t.lightType,e.lightTypeIsCameraLight=()=>"CameraLight"===t.lightType}(e,t)}var Sm={newInstance:Ht.newInstance(Cm,"vtkLight"),extend:Cm,LIGHT_TYPES:["HeadLight","CameraLight","SceneLight"]};const{vtkErrorMacro:Am}=Ht;const Im={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function wm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Im,n),Ht.obj(e,t),Ht.event(e,t,"event"),Ht.setGetArray(e,t,["viewport"],4),Ht.setGetArray(e,t,["background","background2"],3),function(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push("vtkViewport"),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{let r=[];const o=e.getActors2D();o.sort(((e,t)=>e.getLayerNumber()-t.getLayerNumber()));const a=t.props.filter((e=>!o.includes(e)));for(let e=0;e<a.length;e++)n(a[e],r);return r=r.concat(o),r},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Am("call displayToView on your view instead"),e.viewToDisplay=()=>Am("callviewtodisplay on your view instead"),e.getSize=()=>Am("call getSize on your View instead"),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=()=>Am("vtkViewport::PickPropFrom - NOT IMPLEMENTED")}(e,t)}var Om={newInstance:Ht.newInstance(wm,"vtkViewport"),extend:wm};const{vtkDebugMacro:Pm,vtkErrorMacro:Rm,vtkWarningMacro:Mm}=jt;function Em(e){return()=>Rm(`vtkRenderer::${e} - NOT IMPLEMENTED`)}const Vm={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Ra(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function Dm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,Vm,n),Om.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),yt(e,t,["_renderWindow","allocatedRenderTime","timeFactor","lastRenderTimeInSeconds","numberOfPropsRendered","lastRenderingUsedDepthPeeling","selector"]),St(e,t,["twoSidedLighting","lightFollowCamera","automaticLightCreation","erase","draw","nearClippingPlaneTolerance","clippingRangeExpansion","backingStore","interactive","layer","preserveColorBuffer","preserveDepthBuffer","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","delegate","backgroundTexture","texturedBackground","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","useShadows","pass"]),At(e,t,["actors","volumes","lights"]),wt(e,t,["background"],4,1),Ot(0,t,["renderWindow"]),function(e,t){t.classHierarchy.push("vtkRenderer");const n={type:"ComputeVisiblePropBoundsEvent",renderer:e},r={type:"ResetCameraClippingRangeEvent",renderer:e},o={type:"ResetCameraEvent",renderer:e};e.updateCamera=()=>(t.activeCamera||(Pm("No cameras are on, creating one."),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):Rm("light has unknown light type",e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=Em("allocateTime"),e.updateGeometry=Em("updateGeometry"),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{Pm(e.getClassName(),e,"setting Layer to ",n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:"ActiveCameraEvent",camera:n}),!0),e.makeCamera=()=>{const t=bm.newInstance();return e.invokeEvent({type:"CreateCameraEvent",camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=Sm.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return Rm("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return wn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return Rm("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return wn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return Rm("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return wn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return Rm("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return wn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=Fi.INIT_BOUNDS[0],t.allBounds[1]=Fi.INIT_BOUNDS[1],t.allBounds[2]=Fi.INIT_BOUNDS[2],t.allBounds[3]=Fi.INIT_BOUNDS[3],t.allBounds[4]=Fi.INIT_BOUNDS[4],t.allBounds[5]=Fi.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&ba(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(ya(t.allBounds),Pm("Can't compute bounds, no 3D props are visible")),t.allBounds},e.resetCamera=function(){const n=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null)||e.computeVisiblePropBounds(),r=[0,0,0];if(!ba(n))return Pm("Cannot reset camera!"),!1;let a=null;if(!e.getActiveCamera())return Rm("Trying to reset non-existent camera"),!1;a=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),r[0]=(n[0]+n[1])/2,r[1]=(n[2]+n[3])/2,r[2]=(n[4]+n[5])/2;let i=n[1]-n[0],s=n[3]-n[2],l=n[5]-n[4];i*=i,s*=s,l*=l;let c=i+s+l;c=0===c?1:c,c=.5*Math.sqrt(c);const u=yo(t.activeCamera.getViewAngle()),d=c,p=c/Math.sin(.5*u),f=t.activeCamera.getViewUp();return Math.abs(No(f,a))>.999&&(Mm("Resetting view-up since view plane normal is parallel"),t.activeCamera.setViewUp(-f[2],f[0],f[1])),t.activeCamera.setFocalPoint(r[0],r[1],r[2]),t.activeCamera.setPosition(r[0]+p*a[0],r[1]+p*a[1],r[2]+p*a[2]),e.resetCameraClippingRange(n),t.activeCamera.setParallelScale(d),t.activeCamera.setPhysicalScale(c),t.activeCamera.setPhysicalTranslation(-r[0],-r[1],-r[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){const n=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null)||e.computeVisiblePropBounds();if(!ba(n))return Pm("Cannot reset camera clipping range!"),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return Rm("Trying to reset clipping range of non-existent camera"),!1;const o=t.activeCamera.computeClippingRange(n);let a=0;if(t.activeCamera.getParallelProjection())a=.2*t.activeCamera.getParallelScale();else{const e=yo(t.activeCamera.getViewAngle());a=.2*Math.tan(e/2)*o[1]}return o[1]-o[0]<a&&(a=a-o[1]+o[0],o[1]+=a/2,o[0]-=a/2),o[0]<0&&(o[0]=0),o[0]=.99*o[0]-(o[1]-o[0])*t.clippingRangeExpansion,o[1]=1.01*o[1]+(o[1]-o[0])*t.clippingRangeExpansion,o[0]=o[0]>=o[1]?.01*o[1]:o[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),o[0]<t.nearClippingPlaneTolerance*o[1]&&(o[0]=t.nearClippingPlaneTolerance*o[1]),t.activeCamera.setClippingRange(o[0],o[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}(e,t)}var Lm={newInstance:Et(Dm,"vtkRenderer"),extend:Dm};const Bm=Object.create(null);function Nm(e,t){Bm[e]=t}function Fm(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Bm[e]&&Bm[e](t)}const _m={defaultViewAPI:"WebGL",renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1,childRenderWindows:[]};function Gm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_m,n),Ht.obj(e,t),Ht.setGet(e,t,["interactor","numberOfLayers","_views","defaultViewAPI"]),Ht.get(e,t,["neverRendered"]),Ht.getArray(e,t,["renderers","childRenderWindows"]),Ht.moveToProtected(e,t,["views"]),Ht.event(e,t,"completion"),function(e,t){t.classHierarchy.push("vtkRenderWindow"),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Fm(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{t.getGraphicsMemoryInfo&&(e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6)})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){t.getAllocatedGPUMemoryInBytes&&(e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6);const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join("\n"),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Ht.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))},e.addRenderWindow=n=>!t.childRenderWindows.includes(n)&&(t.childRenderWindows.push(n),e.modified(),!0),e.removeRenderWindow=n=>{const r=t.childRenderWindows.findIndex((e=>e===n));return!(r<0||(t.childRenderWindows.splice(r,1),e.modified(),0))}}(e,t)}var km={newInstance:Ht.newInstance(Gm,"vtkRenderWindow"),extend:Gm,registerViewConstructor:Nm,listViewAPIs:function(){return Object.keys(Bm)},newAPISpecificView:Fm};const Um={Unknown:0,LeftController:1,RightController:2},zm={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var Wm={Device:Um,Input:zm,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4},MouseButton:{LeftButton:1,MiddleButton:2,RightButton:3}};const{Device:Hm,Input:jm}=Wm,{vtkWarningMacro:Km,vtkErrorMacro:$m,normalizeWheel:qm,vtkOnceErrorMacro:Xm}=Ht,Ym={ctrlKey:!1,altKey:!1,shiftKey:!1},Zm={"xr-standard":[jm.Trigger,jm.Grip,jm.TrackPad,jm.Thumbstick,jm.A,jm.B]},Qm=["StartAnimation","Animation","EndAnimation","PointerEnter","PointerLeave","MouseEnter","MouseLeave","StartMouseMove","MouseMove","EndMouseMove","LeftButtonPress","LeftButtonRelease","MiddleButtonPress","MiddleButtonRelease","RightButtonPress","RightButtonRelease","KeyPress","KeyDown","KeyUp","StartMouseWheel","MouseWheel","EndMouseWheel","StartPinch","Pinch","EndPinch","StartPan","Pan","EndPan","StartRotate","Rotate","EndRotate","Button3D","Move3D","StartPointerLock","EndPointerLock","StartInteraction","Interaction","EndInteraction","AnimationFrameRateUpdate"];function Jm(e){e.cancelable&&e.preventDefault()}function eh(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}const th={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:"Start",animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function nh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,th,n),Ht.obj(e,t),t._animationExtendedEnd=0,Ht.event(e,t,"RenderEvent"),Qm.forEach((n=>Ht.event(e,t,n))),Ht.get(e,t,["initialized","interactorStyle","lastFrameTime","recentAnimationFrameRate","_view"]),Ht.setGet(e,t,["container","lightFollowCamera","enabled","enableRender","recognizeGestures","desiredUpdateRate","stillUpdateRate","picker","preventDefaultOnPointerDown","preventDefaultOnPointerUp","mouseScrollDebounceByPass"]),Ht.moveToProtected(e,t,["view"]),function(e,t){t.classHierarchy.push("vtkRenderWindowInteractor");const n={...e},r=new Set,o=new Map;let a=1;function i(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{$m("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor")},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>Km("empty event loop"),e.getCurrentRenderer=()=>(t.currentRenderer||i(0,0),t.currentRenderer);const s=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),r=n.getBoundingClientRect(),a=n.width/r.width,s=n.height/r.height,l={x:a*(e.clientX-r.left),y:s*(r.height-e.clientY+r.top),z:0,movementX:a*e.movementX,movementY:s*e.movementY};return(o.size<=1||!t.currentRenderer)&&i(l.x,l.y),l};function l(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function c(e){const t=l(e);return{key:e.key,keyCode:e.charCode,...t}}function u(e){return e.pointerType||""}const d=()=>{if(null===t.container)return;const{container:n}=t;n.addEventListener("contextmenu",Jm),n.addEventListener("wheel",e.handleWheel),n.addEventListener("DOMMouseScroll",e.handleWheel),n.addEventListener("pointerenter",e.handlePointerEnter),n.addEventListener("pointerleave",e.handlePointerLeave),n.addEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.addEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.addEventListener("pointerup",e.handlePointerUp),n.addEventListener("pointercancel",e.handlePointerCancel),n.addEventListener("keypress",e.handleKeyPress),n.addEventListener("keydown",e.handleKeyDown),document.addEventListener("keyup",e.handleKeyUp),document.addEventListener("pointerlockchange",e.handlePointerLockChange),n.tabIndex=0,n.style.touchAction="none",n.style.userSelect="none",n.style.webkitTapHighlightColor="rgba(0,0,0,0)"};e.bindEvents=e=>{null!==e&&n.setContainer(e)&&d()};const p=()=>{clearTimeout(t.moveTimeoutID),clearTimeout(t.wheelTimeoutID),t.moveTimeoutID=0,t.wheelTimeoutID=0,a=1;const{container:n}=t;n&&(n.removeEventListener("contextmenu",Jm),n.removeEventListener("wheel",e.handleWheel),n.removeEventListener("DOMMouseScroll",e.handleWheel),n.removeEventListener("pointerenter",e.handlePointerEnter),n.removeEventListener("pointerleave",e.handlePointerLeave),n.removeEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.removeEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.removeEventListener("pointerup",e.handlePointerUp),n.removeEventListener("pointercancel",e.handlePointerCancel),n.removeEventListener("keypress",e.handleKeyPress),n.removeEventListener("keydown",e.handleKeyDown)),document.removeEventListener("keyup",e.handleKeyUp),document.removeEventListener("pointerlockchange",e.handlePointerLockChange),o.clear()};function f(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.unbindEvents=()=>{p(),n.setContainer(null)},e.handleKeyPress=t=>{const n=c(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=c(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=c(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerEnterEvent(n),"mouse"===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerLeaveEvent(n),"mouse"===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&Jm(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),o.has(n.pointerId)&&Km("[RenderWindowInteractor] duplicate pointerId detected"),o.set(n.pointerId,{pointerId:n.pointerId,position:s(n)}),n.pointerType){case"pen":case"touch":e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(o.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&Jm(n),o.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case"pen":case"touch":e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(o.has(t.pointerId))switch(o.delete(t.pointerId),t.pointerType){case"pen":case"touch":e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(o.has(t.pointerId)&&(o.get(t.pointerId).position=s(t)),t.pointerType){case"pen":case"touch":e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:$m(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=n=>{void 0!==n?r.has(n)?Km("requester is already registered for animating"):(r.add(n),t.animationRequest||1!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):$m("undefined requester, can not start animating")},e.extendAnimation=n=>{const o=Date.now()+n;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(n){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(r.has(n))r.delete(n),t.animationRequest&&0===r.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=n&&n.getClassName?n.getClassName():n;Km(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==r.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=null==n.gripSpace?null:r.getPose(n.targetRaySpace,o),s=n.gamepad,l=n.handedness;if(s){s.index in t.lastGamepadValues||(t.lastGamepadValues[s.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<s.buttons.length;++r)r in t.lastGamepadValues[s.index][l].buttons||(t.lastGamepadValues[s.index][l].buttons[r]=!1),t.lastGamepadValues[s.index][l].buttons[r]!==s.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,pressed:s.buttons[r].pressed,device:"left"===n.handedness?Hm.LeftController:Hm.RightController,input:Zm[s.mapping]&&Zm[s.mapping][r]?Zm[s.mapping][r]:jm.Trigger}),t.lastGamepadValues[s.index][l].buttons[r]=s.buttons[r].pressed),t.lastGamepadValues[s.index][l].buttons[r]&&null!=a&&e.move3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,device:"left"===n.handedness?Hm.LeftController:Hm.RightController})}}))},e.handleMouseMove=n=>{const r={...l(n),position:s(n),deviceType:u(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const n=Date.now();t._animationFrameCount++,n-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(n-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=n,t._animationFrameCount=1),e.animationEvent(),f(),r.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{Jm(n);const r={...qm(n),...l(n),position:s(n),deviceType:u(n)};0===t.wheelTimeoutID&&(a=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=a,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:$m(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=eh(o);if(2===r.length){const t={...l(Ym),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture("TouchStart",t)}else if(1===r.length){const t={...l(Ym),position:s(n),deviceType:u(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=eh(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Ym),position:r[0].position,deviceType:u(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const r=[...o.values()];if(t.recognizeGestures)if(0===r.length){const t={...l(Ym),position:s(n),deviceType:u(n)};e.leftButtonReleaseEvent(t)}else if(1===r.length){const t=eh(o);e.recognizeGesture("TouchEnd",t);const a={...l(Ym),position:r[0].position,deviceType:u(n)};e.leftButtonPressEvent(a)}else{const t=eh(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Ym),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||f()},Qm.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void Xm("\n          Can not forward events without a current renderer on the interactor.\n        ");const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),"TouchStart"===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture="Start");if("TouchEnd"===n)return"Pinch"===t.currentGesture&&(e.render(),e.endPinchEvent()),"Rotate"===t.currentGesture&&(e.render(),e.endRotateEvent()),"Pan"===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture="Start",void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=bo(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=bo(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,"TouchMove"===n)if("Start"===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture="Pinch";const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture="Rotate";const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture="Pan";const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if("Rotate"===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if("Pinch"===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if("Pan"===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e},e.setContainer=e=>{p();const t=n.setContainer(e??null);return t&&d(),t},e.delete=()=>{for(;r.size;)e.cancelAnimation(r.values().next().value);void 0!==document.hidden&&document.removeEventListener("visibilitychange",e.handleVisibilityChange),t.container&&e.setContainer(null),n.delete()},void 0!==document.hidden&&document.addEventListener("visibilitychange",e.handleVisibilityChange,!1)}(e,t)}var rh={newInstance:Ht.newInstance(nh,"vtkRenderWindowInteractor"),extend:nh,handledEvents:Qm,...Wm};const{vtkErrorMacro:oh,VOID:ah}=Ht,ih={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function sh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ih,n),Ht.obj(e,t),Ht.event(e,t,"InteractionEvent"),Ht.event(e,t,"StartInteractionEvent"),Ht.event(e,t,"EndInteractionEvent"),Ht.get(e,t,["_interactor","enabled"]),Ht.setGet(e,t,["priority","processEvents"]),Ht.moveToProtected(e,t,["interactor"]),function(e,t){t.classHierarchy.push("vtkInteractorObserver");const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){rh.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):ah),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():oh("\n          The interactor must be set before subscribing to events\n        ")),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}(e,t)}var lh={newInstance:Ht.newInstance(sh,"vtkInteractorObserver"),extend:sh,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},ch={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:uh}=ch,dh={Rotate:uh.IS_ROTATE,Pan:uh.IS_PAN,Spin:uh.IS_SPIN,Dolly:uh.IS_DOLLY,CameraPose:uh.IS_CAMERA_POSE,WindowLevel:uh.IS_WINDOW_LEVEL,Slice:uh.IS_SLICE},ph={state:uh.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function fh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ph,n),lh.extend(e,t,n),Ht.setGet(e,t,["focusedRenderer"]),function(e,t){t.classHierarchy.push("vtkInteractorStyle"),Object.keys(dh).forEach((n=>{Ht.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===uh.IS_NONE&&(t.state=dh[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:"StartInteractionEvent"}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},Ht.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===dh[n]&&(t.state=uh.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:"EndInteractionEvent"}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),t.getRenderer=e=>t.focusedRenderer||e.pokedRenderer,e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case"r":case"R":t.getRenderer(e).resetCamera(),n.render();break;case"w":case"W":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case"s":case"S":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case"v":case"V":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}(e,t)}var gh={newInstance:Ht.newInstance(fh,"vtkInteractorStyle"),extend:fh,...ch};const{States:mh}=ch,hh={motionFactor:10,zoomFactor:10};function vh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hh,n),gh.extend(e,t,n),Ht.setGet(e,t,["motionFactor","zoomFactor"]),function(e,t){t.classHierarchy.push("vtkInteractorStyleTrackballCamera"),e.handleMouseMove=n=>{const r=n.position,o=t.getRenderer(n);switch(t.state){case mh.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case mh.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case mh.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case mh.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:"InteractionEvent"})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==Um.RightController||n.input!==zm.Trigger&&n.input!==zm.TrackPad?!n||n.pressed||n.device!==Um.RightController||n.input!==zm.Trigger&&n.input!==zm.TrackPad||t.state!==mh.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===mh.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const n=t.getRenderer(e).getActiveCamera(),r=n.getPhysicalTranslation(),o=.025*n.getPhysicalScale(),a=n.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);n.setPhysicalTranslation(r[0]+a[0]*o,r[1]+a[1]*o,r[2]+a[2]*o)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case mh.IS_DOLLY:e.endDolly();break;case mh.IS_PAN:e.endPan();break;case mh.IS_SPIN:e.endSpin();break;case mh.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(t.getRenderer(n),n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=t.getRenderer(n).getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(t.getRenderer(n),o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(t.getRenderer(n),o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(t.getRenderer(n),o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&t.getRenderer(n).updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=t.getRenderer(e).getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=bo(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=bo(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(t.getRenderer(n),r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}(e,t)}var Th={newInstance:Ht.newInstance(vh,"vtkInteractorStyleTrackballCamera"),extend:vh};function yh(e){return e}function bh(e){return null===e||"null"===e?null:"true"===e||"false"!==e&&(void 0!==e&&"undefined"!==e?"["===e[0]&&"]"===e[e.length-1]?e.substring(1,e.length-1).split(",").map((e=>bh(e.trim()))):""===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var xh=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?bh:yh;return new URLSearchParams(t).forEach(((e,t)=>{t&&(n[t]=!e||r(e))})),n};const Ch={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function Sh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ch,n),Ht.obj(e,t),Ht.get(e,t,["currentOperation"]),Ht.setGet(e,t,["delegates","_currentParent","preDelegateOperations","postDelegateOperations"]),Ht.moveToProtected(e,t,["currentParent"]),function(e,t){t.classHierarchy.push("vtkRenderPass"),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${Ht.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}(e,t)}var Ah={newInstance:Ht.newInstance(Sh,"vtkRenderPass"),extend:Sh};const{Representation:Ih}=ts,{vtkErrorMacro:wh}=Ht;function Oh(e){const t=Pu.substitute(e.Fragment,"//VTK::RenderPassFragmentShader::Impl","\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\n      gl_FragData[1].r = weight;\n    ",!1);e.Fragment=t.result}const Ph={framebuffer:null,copyShader:null,tris:null};function Rh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ph,n),Ah.extend(e,t,n),t.VBOBuildTime={},Ht.obj(t.VBOBuildTime,{mtime:0}),t.tris=Bu.newInstance(),Ht.get(e,t,["framebuffer"]),function(e,t){t.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Ts.newInstance({numberOfComponents:3,values:e});o.setName("points");const a=Ts.newInstance({numberOfComponents:2,values:n});a.setName("tcoords");const i=Ts.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,"polys",Ih.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=qd.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=td.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw({width:n[0],height:n[1],numComps:4,dataType:"Float32Array",data:null}),t.translucentRTexture=td.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw({width:n[0],height:n[1],numComps:1,dataType:"Float32Array",data:null}),t.translucentZTexture=td.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw({width:n[0],height:n[1],dataType:"Float32Array",data:null}),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","attribute vec2 tcoordTC;","varying vec2 tcoord;","void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"),"//VTK::System::Dec\n\nin vec2 tcoord;\n\nuniform sampler2D translucentRTexture;\nuniform sampler2D translucentRGBATexture;\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\n  float t2Color = texture(translucentRTexture, tcoord).r;\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\n}\n","")},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||wh("Error setting vertexDC in copy shader VAO."),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"tcoordTC",t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||wh("Error setting vertexDC in copy shader VAO.")},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension("EXT_color_buffer_half_float")&&!i.getExtension("EXT_color_buffer_float"))return e.setCurrentOperation("translucentPass"),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation("opaqueZBufferPass"),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation("translucentPass"),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=Eu.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi("translucentRGBATexture",t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi("translucentRTexture",t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate();const s=r.getTiledSizeAndOrigin();i.scissor(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize),i.viewport(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize)},e.getShaderReplacement=()=>t._supported?Oh:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}(e,t)}var Mh={newInstance:Ht.newInstance(Rh,"vtkOpenGLOrderIndependentTranslucentPass"),extend:Rh};const Eh={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function Vh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Eh,n),Ah.extend(e,t,n),Ht.get(e,t,["framebuffer","opaqueActorCount","translucentActorCount","volumeCount"]),function(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getRenderable().getRenderersByReference();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getViewNodeFor(i);if(i.getDraw()&&i.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation("queryPass"),s.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=qd.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation("zBufferPass"),s.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation("cameraPass"),s.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation("opaquePass"),s.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Mh.newInstance()),t.translucentPass.traverse(n,s,e)),t.volumeCount>0&&(e.setCurrentOperation("volumePass"),s.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation("overlayPass"),s.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}(e,t)}var Dh={newInstance:Ht.newInstance(Vh,"vtkForwardPass"),extend:Vh},Lh=n(292),Bh=n.n(Lh);const Nh=["lastShaderProgramBound","context","_openGLRenderWindow"],Fh={lastShaderProgramBound:null,shaderPrograms:null,context:null};function _h(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fh,n),t.shaderPrograms={},Ht.obj(e,t),Ht.setGet(e,t,Nh),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkShaderCache"),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=Pu.substitute(o,"VSOut","GSOut").result);const a=t._openGLRenderWindow.getWebgl2();let i="\n",s="#version 100\n";a?s="#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n":(t.context.getExtension("OES_standard_derivatives"),t.context.getExtension("EXT_frag_depth")&&(i="#extension GL_EXT_frag_depth : enable\n"),t.context.getExtension("EXT_shader_texture_lod")&&(i+="#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT")),o=Pu.substitute(o,"//VTK::System::Dec",[`${s}\n`,a?"":"#extension GL_OES_standard_derivatives : enable\n",i,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;let l=Pu.substitute(e,"//VTK::System::Dec",[`${s}\n`,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;if(a){l=Pu.substitute(l,"varying","out").result,o=Pu.substitute(o,"varying","in").result;let e="",t=0;for(;o.includes(`gl_FragData[${t}]`);)o=Pu.substitute(o,`gl_FragData\\[${t}\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\n`,t++;o=Pu.substitute(o,"//VTK::Output::Dec",e).result}return{VSSource:l,FSSource:o,GSSource:Pu.substitute(r,"//VTK::System::Dec",s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=Bh().hash(o);if(!(a in t.shaderPrograms)){const o=Pu.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}(e,t)}var Gh={newInstance:Ht.newInstance(_h,"vtkShaderCache"),extend:_h};const{vtkErrorMacro:kh}=Ht,Uh={context:null,numberOfTextureUnits:0,textureUnits:0};function zh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Uh,n),Ht.obj(e,t),t.textureUnits=[],Ht.get(e,t,["numberOfTextureUnits"]),Ht.setGet(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLTextureUnitManager"),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&kh("some texture units  were not properly released");t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}(e,t)}var Wh={newInstance:Ht.newInstance(zh,"vtkOpenGLTextureUnitManager"),extend:zh};const Hh={size:void 0,selector:void 0};function jh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hh,n),t.size||(t.size=[300,300]),Ht.getArray(e,t,["size"],2),Ht.get(e,t,["selector"]),Xt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkRenderWindowViewNode"),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{Ht.vtkErrorMacro("not implemented")},e.getPixelData=(e,t,n,r)=>{Ht.vtkErrorMacro("not implemented")},e.createSelector=()=>{Ht.vtkErrorMacro("not implemented")}}(e,t)}var Kh={newInstance:Ht.newInstance(jh,"vtkRenderWindowViewNode"),extend:jh};const{vtkDebugMacro:$h,vtkErrorMacro:qh}=Ht,Xh={position:"absolute",top:0,left:0,width:"100%",height:"100%"},Yh=["activateTexture","deactivateTexture","disableCullFace","enableCullFace","get3DContext","getActiveFramebuffer","getContext","getDefaultTextureByteSize","getDefaultTextureInternalFormat","getDefaultToWebgl2","getGLInformations","getGraphicsMemoryInfo","getGraphicsResourceForObject","getHardwareMaximumLineWidth","getPixelData","getShaderCache","getTextureUnitForTexture","getTextureUnitManager","getWebgl2","makeCurrent","releaseGraphicsResources","registerGraphicsResourceUser","unregisterGraphicsResourceUser","restoreContext","setActiveFramebuffer","setContext","setDefaultToWebgl2","setGraphicsResourceForObject"];function Zh(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let Qh=0;const Jh=[];function ev(e){e.preventDefault()}function tv(e,t){let n;t.classHierarchy.push("vtkOpenGLRenderWindow"),e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener("webglcontextlost",ev,!1),t.canvas.addEventListener("webglcontextrestored",e.restoreContext,!1);const r=[0,0];let o;e.onModified((function(){t.renderable&&(t.size[0]===r[0]&&t.size[1]===r[1]||(r[0]=t.size[0],r[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.addMissingNodes(t.renderable.getChildRenderWindowsByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow?.(e)}))}},e.initialize=()=>{if(!t.initialized){if(t.rootOpenGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.rootOpenGLRenderWindow)t.context2D=e.get2DContext();else{t.context=e.get3DContext(),e.resizeFromChildRenderWindows(),t.context&&(Qh++,Jh.forEach((e=>e(Qh)))),t.textureUnitManager=Wh.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND)}t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&qh("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>{const e=t.activeFramebuffer?.getSize();return e||t.size},e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:"high-performance"},r=null;const o="undefined"!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(r=t.canvas.getContext("webgl2",e),r&&(t.webgl2=!0,$h("using webgl2"))),r||($h("using webgl1"),r=t.canvas.getContext("webgl",e)||t.canvas.getContext("experimental-webgl",e)),new Proxy(r,(n||(n=function(){const e=new Map,t={apply(t,n,r){return e.has(r[0])?e.get(r[0]):t.apply(n,r)}},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply(t,n,r){return e.set(a,r[0]),t.apply(n,r)}}));var a},{get(e,t,r){if("__getUnderlyingContext"===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}()),n))},e.get2DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.canvas.getContext("2d",e)},e.restoreContext=()=>{const t=Ah.newInstance();t.setCurrentOperation("Release"),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?qh("Hardware does not support the number of textures defined."):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case is.CHAR:case is.SIGNED_CHAR:case is.UNSIGNED_CHAR:return 1;case n:case r:case is.UNSIGNED_SHORT:case is.SHORT:case is.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case is.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&is.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&is.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return o?t.context.R16F:t.context.R32F;case 2:return o?t.context.RG16F:t.context.RG32F;case 3:return o?t.context.RGB16F:t.context.RGB32F;default:return o?t.context.RGBA16F:t.context.RGBA32F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Xh,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t.rootOpenGLRenderWindow?.resizeFromChildRenderWindows(),t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=o)return o;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return o=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension("OES_texture_float"),o=n.getExtension("OES_texture_half_float"),a=n.getExtension("WEBGL_debug_renderer_info"),i=n.getExtension("WEBGL_draw_buffers"),s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),l=[["Max Vertex Attributes","MAX_VERTEX_ATTRIBS",n.getParameter(n.MAX_VERTEX_ATTRIBS)],["Max Varying Vectors","MAX_VARYING_VECTORS",n.getParameter(n.MAX_VARYING_VECTORS)],["Max Vertex Uniform Vectors","MAX_VERTEX_UNIFORM_VECTORS",n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],["Max Fragment Uniform Vectors","MAX_FRAGMENT_UNIFORM_VECTORS",n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],["Max Fragment Texture Image Units","MAX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],["Max Vertex Texture Image Units","MAX_VERTEX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],["Max Combined Texture Image Units","MAX_COMBINED_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],["Max 2D Texture Size","MAX_TEXTURE_SIZE",n.getParameter(n.MAX_TEXTURE_SIZE)],["Max Cube Texture Size","MAX_CUBE_MAP_TEXTURE_SIZE",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],["Max Texture Anisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT",s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],["Point Size Range","ALIASED_POINT_SIZE_RANGE",n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(" - ")],["Line Width Range","ALIASED_LINE_WIDTH_RANGE",n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(" - ")],["Max Viewport Dimensions","MAX_VIEWPORT_DIMS",n.getParameter(n.MAX_VIEWPORT_DIMS).join(" - ")],["Max Renderbuffer Size","MAX_RENDERBUFFER_SIZE",n.getParameter(n.MAX_RENDERBUFFER_SIZE)],["Framebuffer Red Bits","RED_BITS",n.getParameter(n.RED_BITS)],["Framebuffer Green Bits","GREEN_BITS",n.getParameter(n.GREEN_BITS)],["Framebuffer Blue Bits","BLUE_BITS",n.getParameter(n.BLUE_BITS)],["Framebuffer Alpha Bits","ALPHA_BITS",n.getParameter(n.ALPHA_BITS)],["Framebuffer Depth Bits","DEPTH_BITS",n.getParameter(n.DEPTH_BITS)],["Framebuffer Stencil Bits","STENCIL_BITS",n.getParameter(n.STENCIL_BITS)],["Framebuffer Subpixel Bits","SUBPIXEL_BITS",n.getParameter(n.SUBPIXEL_BITS)],["MSAA Samples","SAMPLES",n.getParameter(n.SAMPLES)],["MSAA Sample Buffers","SAMPLE_BUFFERS",n.getParameter(n.SAMPLE_BUFFERS)],["Supported Formats for UByte Render Targets     ","UNSIGNED_BYTE RENDER TARGET FORMATS",[r&&Zh(n,n.RGBA,n.UNSIGNED_BYTE)?"RGBA":"",r&&Zh(n,n.RGB,n.UNSIGNED_BYTE)?"RGB":"",r&&Zh(n,n.LUMINANCE,n.UNSIGNED_BYTE)?"LUMINANCE":"",r&&Zh(n,n.ALPHA,n.UNSIGNED_BYTE)?"ALPHA":"",r&&Zh(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Half Float Render Targets","HALF FLOAT RENDER TARGET FORMATS",[o&&Zh(n,n.RGBA,o.HALF_FLOAT_OES)?"RGBA":"",o&&Zh(n,n.RGB,o.HALF_FLOAT_OES)?"RGB":"",o&&Zh(n,n.LUMINANCE,o.HALF_FLOAT_OES)?"LUMINANCE":"",o&&Zh(n,n.ALPHA,o.HALF_FLOAT_OES)?"ALPHA":"",o&&Zh(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Full Float Render Targets","FLOAT RENDER TARGET FORMATS",[r&&Zh(n,n.RGBA,n.FLOAT)?"RGBA":"",r&&Zh(n,n.RGB,n.FLOAT)?"RGB":"",r&&Zh(n,n.LUMINANCE,n.FLOAT)?"LUMINANCE":"",r&&Zh(n,n.ALPHA,n.FLOAT)?"ALPHA":"",r&&Zh(n,n.LUMINANCE_ALPHA,n.FLOAT)?"LUMINANCE_ALPHA":""].join(" ")],["Max Multiple Render Targets Buffers","MAX_DRAW_BUFFERS_WEBGL",i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],["High Float Precision in Vertex Shader","HIGH_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Vertex Shader","MEDIUM_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Vertex Shader","LOW_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Float Precision in Fragment Shader","HIGH_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Fragment Shader","MEDIUM_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Fragment Shader","LOW_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Int Precision in Vertex Shader","HIGH_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Vertex Shader","MEDIUM_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Vertex Shader","LOW_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["High Int Precision in Fragment Shader","HIGH_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Fragment Shader","MEDIUM_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Fragment Shader","LOW_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["Supported Extensions","EXTENSIONS",n.getSupportedExtensions().join("<br/>\t\t\t\t\t    ")],["WebGL Renderer","RENDERER",n.getParameter(n.RENDERER)],["WebGL Vendor","VENDOR",n.getParameter(n.VENDOR)],["WebGL Version","VERSION",n.getParameter(n.VERSION)],["Shading Language Version","SHADING_LANGUAGE_VERSION",n.getParameter(n.SHADING_LANGUAGE_VERSION)],["Unmasked Renderer","UNMASKED_RENDERER",a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],["Unmasked Vendor","UNMASKED_VENDOR",a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],["WebGL Version","WEBGL_VERSION",t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);e.copyParentContent(),t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect();t.renderable.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const i=r.toDataURL(n);r.remove(),e.invokeImageReady(i)}();const n=t.renderable.getChildRenderWindowsByReference();for(let t=0;t<n.length;++t)e.getViewNodeFor(n[t])?.traverseAllPasses()},e.copyParentContent=()=>{const e=t.rootOpenGLRenderWindow;if(!e||!t.context2D||t.children.some((e=>!!e.getSelector?.())))return;const n=e.getCanvas(),r=t.canvas;t.context2D.drawImage(n,0,n.height-r.height,r.width,r.height,0,0,r.width,r.height)},e.resizeFromChildRenderWindows=()=>{const n=t.renderable.getChildRenderWindowsByReference();if(n.length>0){const t=[0,0];for(let r=0;r<n.length;++r){const o=e.getViewNodeFor(n[r])?.getSize();o&&(t[0]=o[0]>t[0]?o[0]:t[0],t[1]=o[1]>t[1]?o[1]:t[1])}e.setSize(...t)}},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=dp.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=Ht.chain((()=>{t.context&&(Qh--,Jh.forEach((e=>e(Qh)))),e.setContainer(),e.setViewStream()}),(function(){t.canvas.removeEventListener("webglcontextlost",ev),t.canvas.removeEventListener("webglcontextrestored",e.restoreContext)}),e.delete),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const a=e.setSize;e.setSize=(t,n)=>{const r=a(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.registerGraphicsResourceUser=(n,r)=>{t._graphicsResources.has(n)||e.setGraphicsResourceForObject(n,null,null);const o=t._graphicsResources.get(n);o?.users.add(r)},e.unregisterGraphicsResourceUser=(n,r)=>{const o=t._graphicsResources.get(n);o&&(o.users.delete(r),o.users.size||(o.oglObject?.releaseGraphicsResources(e),t._graphicsResources.delete(n)))},e.getGraphicsResourceForObject=e=>t._graphicsResources.get(e),e.setGraphicsResourceForObject=(n,r,o)=>{if(!n)return;const a=t._graphicsResources.get(n);a?.oglObject?.releaseGraphicsResources(e),t._graphicsResources.set(n,{coreObject:n,oglObject:r,hash:o,users:a?.users??new Set})},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach((t=>{let{oglObject:n}=t;e+=n.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach((t=>{let{oglObject:n}=t;n.releaseGraphicsResources(e)})),t._graphicsResources.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{const n=e.getViewNodeFor(t);n?.releaseGraphicsResources()}))};const i={...e};Yh.forEach((n=>{e[n]=function(){return t.rootOpenGLRenderWindow?t.rootOpenGLRenderWindow[n](...arguments):i[n](...arguments)}}))}const nv={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,context2D:null,canvas:null,cursorVisibility:!0,cursor:"pointer",textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1};const rv=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nv,n),Kh.extend(e,t,n),t.canvas||(t.canvas=document.createElement("canvas"),t.canvas.style.width="100%"),t.selector||(t.selector=dp.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",t._textureResourceIds=new Map,t._graphicsResources=new Map,t._glInformation=null,t.myFactory=rn.newInstance(),t.shaderCache=Gh.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=Dh.newInstance(),Ht.get(e,t,["shaderCache","textureUnitManager","webgl2","useBackgroundImage","activeFramebuffer","rootOpenGLRenderWindow"]),Ht.setGet(e,t,["initialized","context","context2D","canvas","renderPasses","notifyStartCaptureImage","defaultToWebgl2","cursor","useOffScreen"]),Ht.setGetArray(e,t,["size"],2),Ht.event(e,t,"imageReady"),Ht.event(e,t,"windowResizeEvent"),tv(e,t)}),"vtkOpenGLRenderWindow");Nm("WebGL",rv),en("vtkRenderWindow",rv);const ov={device:null,handle:null};function av(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ov,n),Ht.obj(e,t),Ht.get(e,t,["lastCameraMTime"]),Ht.setGet(e,t,["device","handle"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderModule"),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}(e,t)}var iv={newInstance:Ht.newInstance(av,"vtkWebGPUShaderModule"),extend:av};const sv={shaderModules:null,device:null,window:null};function lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sv,n),t._shaderModules=new Map,Ht.obj(e,t),Ht.setGet(e,t,["device","window"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderCache"),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=iv.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}(e,t)}var cv={newInstance:Ht.newInstance(lv,"vtkWebGPUShaderCache"),extend:lv,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join("\n"):n;let a=!1;-1!==e.search(t)&&(a=!0);let i="";r&&(i="g");const s=new RegExp(t,i);return{replace:a,result:e.replace(s,o)}}};const uv={device:null,handle:null,label:null};function dv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uv,n),Ht.obj(e,t),t.bindables=[],t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),Ht.get(e,t,["bindGroupTime","handle","sizeInBytes","usage"]),Ht.setGet(e,t,["label","device","arrayInformation"]),function(e,t){t.classHierarchy.push("vtkWebGPUBindGroup"),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join("\n")}}(e,t)}var pv={newInstance:Ht.newInstance(dv),extend:dv};const fv={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fv,n),vt(e,t),t.layouts=[],t.shaderDescriptions=[],yt(e,t,["handle","pipelineDescription"]),St(e,t,["device","renderEncoder","topology","vertexState"]),function(e,t){t.classHierarchy.push("vtkWebGPUPipeline"),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);"vertex"===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint="main"),"fragment"===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint="main")}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}(e,t)}var mv={newInstance:Et(gv,"vtkWebGPUPipeline"),extend:gv};const hv={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function vv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hv,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],Ht.obj(e,t),Ht.setGet(e,t,["type","hash","code"]),Ht.getArray(e,t,["outputTypes","outputNames","outputInterpolations"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderDescription"),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push("};"),o=n,r[r.length-1]+=",",r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=cv.substitute(t.code,"//VTK::IOStructs::Input",r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push("};"),o=o.concat(e),t.code=cv.substitute(t.code,"//VTK::IOStructs::Output",[`-> ${t.type}Output`]).result}t.code=cv.substitute(t.code,"//VTK::IOStructs::Dec",o).result}}(e,t)}var Tv={newInstance:Ht.newInstance(vv,"vtkWebGPUShaderDescription"),extend:vv};const yv={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"float"},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"float"},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"sint"},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"uint"},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:"sint"},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:"float"},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"float"},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"float"},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"uint"},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"sint"},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:"uint"},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:"sint"},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"unfilterable-float"},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:"uint"},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:"sint"},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:"float"},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"rgba8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"float"},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"uint"},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"sint"},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"bgra8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:"float"},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:"uint"},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:"sint"},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:"unfilterable-float"},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:"uint"},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:"sint"},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:"float"},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:"uint"},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:"sint"},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:"unfilterable-float"},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"depth"},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:"depth"},"depth24plus-stencil8":{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:"mixed"},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"depth"}};var bv=function(e){return!e||e.length<6?0:e in yv==1?yv[e]:(tt(`unknown format ${e}`),null)},xv=function(e){if(!e||e.length<5)return 0;let t=1;"x"===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(tt(`unknown format ${e}`),0):t*(5-r/2)},Cv=function(e){if(!e||e.length<5)return 0;let t;if("f"===e[0])t="Float";else if("s"===e[0])t="Int";else{if("u"!==e[0])return void tt(`unknown format ${e}`);t="Uint"}const n=e.split("x")[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+="Array",t;tt(`unknown format ${e}`)},Sv=function(e){let t;if("f"===e[0]||"n"===e[1])t="f32";else if("s"===e[0]&&"i"===e[1])t="i32";else{if("u"!==e[0]||"i"!==e[1])return void tt(`unknown format ${e}`);t="u32"}let n=1;return"x"===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},Av=function(e){if(!e)return 0;let t=1;return"vec"===e.substring(0,3)?t=Number(e[3]):"mat"===e.substring(0,3)&&(t=e[3]*e[5]),4*t},Iv=function(e){if(e)return e.includes("f32")?"Float32Array":e.includes("i32")?"Int32Array":e.includes("u32")?"Uint32Array":void tt(`unknown format ${e}`)};function wv(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}const Ov={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function Pv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ov,n),vt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],St(e,t,["created","device","handle","indexBuffer"]),function(e,t){t.classHierarchy.push("vtkWebGPUVertexInput"),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"vertex",o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(wv(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e="",n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=Sv(a.format);n>0&&(e+=",\n"),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}(e,t)}var Rv={newInstance:Et(Pv,"vtkWebGPUVertexInput"),extend:Pv};const Mv={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:"triangle-list",UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function Ev(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mv,n),Xt.extend(e,t,n),t.textureViews=[],t.vertexInput=Rv.newInstance(),t.bindGroup=pv.newInstance({label:"mapperBG"}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||"\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n",t.vertexShaderTemplate=t.vertexShaderTemplate||"\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n",t.shaderReplacements=new Map,Ht.get(e,t,["pipeline","vertexInput"]),Ht.setGet(e,t,["additionalBindables","device","fragmentShaderTemplate","interpolate","numberOfInstances","numberOfVertices","pipelineHash","shaderReplacements","SSBO","textureViews","topology","UBO","vertexShaderTemplate","WebGPURenderer"]),function(e,t){t.classHierarchy.push("vtkWebGPUSimpleMapper"),e.generateShaderDescriptions=(n,r,o)=>{const a=Tv.newInstance({type:"vertex",hash:n,code:t.vertexShaderTemplate}),i=Tv.newInstance({type:"fragment",hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp("//VTK::[^:]*::","g"),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];"replaceShaderIOStructs"!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.replaceShaderCode(null,n),t.getShaderDescription("fragment").replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set("replaceShaderRenderEncoder",e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=cv.substitute(i,"//VTK::Renderer::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");i=s.getCode(),i=cv.substitute(i,"//VTK::Renderer::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderRenderer",e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=cv.substitute(i,"//VTK::Mapper::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");s.addBuiltinInput("bool","@builtin(front_facing) frontFacing"),i=s.getCode(),i=cv.substitute(i,"//VTK::Mapper::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderMapper",e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=cv.substitute(o,"//VTK::Position::Impl",["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription("vertex").addOutput("vec2<f32>","tcoordVS")},t.shaderReplacements.set("replaceShaderTCoord",e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=mv.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}(e,t)}var Vv={newInstance:Ht.newInstance(Ev,"vtkWebGPUSimpleMapper"),extend:Ev};const Dv={};function Lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dv,n),Vv.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkWebGPUFullScreenQuad"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position"),r.addOutput("vec4<f32>","vertexVC");let o=r.getCode();o=cv.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);","output.vertexVC = vec4<f32>(vertexBC, 1);"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,["vertexBC"]),t.numberOfVertices=6}}(e,t)}var Bv={newInstance:Ht.newInstance(Lv,"vtkWebGPUFullScreenQuad"),extend:Lv};const Nv=["setBindGroup","setIndexBuffer","setVertexBuffer","draw","drawIndexed"],Fv={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function _v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fv,n),vt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:"load",storeOp:"store"}],depthStencilAttachment:{view:void 0,depthLoadOp:"clear",depthClearValue:0,depthStoreOp:"store"}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = computedColor;"]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater-equal",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}},t.colorTextureViews=[],yt(e,t,["boundPipeline","colorTextureViews"]),St(e,t,["depthTextureView","description","handle","label","pipelineHash","pipelineSettings","replaceShaderCodeFunction"]),function(e,t){t.classHierarchy.push("vtkWebGPURenderEncoder"),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!("depthStencil"in n))console.log("mismatched depth attachments"),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\n${o}\n versus pipeline\n${a}\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<Nv.length;n++)e[Nv[n]]=function(){return t.handle[Nv[n]](...arguments)}}(e,t)}var Gv={newInstance:Et(_v,"vtkWebGPURenderEncoder"),extend:_v};const kv={device:null,handle:null,label:null,options:null};function Uv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),Ht.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),Ht.get(e,t,["bindGroupTime","handle","options"]),Ht.setGet(e,t,["bindGroupLayoutEntry","device","label"]),function(e,t){t.classHierarchy.push("vtkWebGPUSampler"),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:"clamp-to-edge",t.options.addressModeV=n.addressModeV?n.addressModeV:"clamp-to-edge",t.options.addressModeW=n.addressModeW?n.addressModeW:"clamp-to-edge",t.options.magFilter=n.magFilter?n.magFilter:"nearest",t.options.minFilter=n.minFilter?n.minFilter:"nearest",t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:"nearest",t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}(e,t)}var zv={newInstance:Ht.newInstance(Uv),extend:Uv};const Wv={texture:null,handle:null,sampler:null,label:null};function Hv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wv,n),Ht.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d"}},t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),Ht.get(e,t,["bindGroupTime","texture"]),Ht.setGet(e,t,["bindGroupLayoutEntry","label","sampler"]),function(e,t){t.classHierarchy.push("vtkWebGPUTextureView"),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=bv(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=bv(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r="f32";"sint"===t.bindGroupLayoutEntry.texture.sampleType?r="i32":"uint"===t.bindGroupLayoutEntry.texture.sampleType&&(r="u32");let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return"depth"===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=zv.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}(e,t)}var jv={newInstance:Ht.newInstance(Hv),extend:Hv};const Kv={device:null,handle:null,buffer:null,ready:!1,label:null};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),Ht.obj(e,t),Ht.get(e,t,["handle","ready","width","height","depth","format","usage"]),Ht.setGet(e,t,["device","label"]),function(e,t){t.classHierarchy.push("vtkWebGPUTexture"),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?"2d":"3d";t.format=n.format?n.format:"rgba8unorm",t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:"rgba8unorm",t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];const o=r=>{t.device.getHandle().queue.copyExternalImageToTexture({source:r,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0,mipLevel:0,origin:{x:0,y:0,z:0}},[r.width,r.height,t.depth]),3!==e.getDimensionality()&&t.mipLevel>0&&Hc.generateMipmaps(t.device.getHandle(),t.handle,t.mipLevel+1),t.ready=!0};if(n.canvas)return void o(n.canvas);if(n.imageBitmap)return n.width=n.imageBitmap.width,n.height=n.imageBitmap.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.imageBitmap);if(n.jsImageData)return n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.jsImageData);if(n.image)return n.width=n.image.width,n.height=n.image.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.image);const a=bv(t.format);let i=t.width*a.stride;n.nativeArray&&(r=n.nativeArray);const s=3===e.getDimensionality(),l=((e,t,n)=>{const r=2===a.elementSize&&"float"===a.sampleType,o=e.BYTES_PER_ELEMENT,i=e.length/(t*n)*o;if(!r&&i%256==0)return[e,i];const s=i/o,l=a.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=Ht.newTypedArray(r?"Uint16Array":e.constructor.name,u*t*n),p=t*n;if(r)for(let t=0;t<p;t++){const n=t*s,r=t*u;for(let t=0;t<s;t++)d[r+t]=Uu.toHalf(e[n+t])}else if(u===s)d.set(e);else for(let t=0;t<p;t++)d.set(e.subarray(t*s,(t+1)*s),t*u);return[d,c]})(r,t.height,s?t.depth:1);i=l[1];const c=l[0];t.device.getHandle().queue.writeTexture({texture:t.handle,mipLevel:0,origin:{x:0,y:0,z:0}},c,{offset:0,bytesPerRow:i,rowsPerImage:t.height},{width:t.width,height:t.height,depthOrArrayLayers:s?t.depth:1}),!s&&t.mipLevel>0&&Hc.generateMipmaps(t.device.getHandle(),t.handle,t.mipLevel+1),t.ready=!0},e.getScale=()=>{const e=bv(t.format);return 2===e.elementSize&&"float"===e.sampleType?1:255},e.getNumberOfComponents=()=>bv(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?"2d":"3d");const o=jv.newInstance({label:n});return o.create(e,r),o}}(e,t)}var qv={newInstance:Ht.newInstance($v),extend:$v};const Xv={renderEncoder:null,colorTexture:null,depthTexture:null};function Yv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xv,n),Ah.extend(e,t,n),Ht.get(e,t,["colorTexture","depthTexture"]),function(e,t){t.classHierarchy.push("vtkWebGPUOpaquePass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=qv.newInstance({label:"opaquePassColor"}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView("opaquePassColorTexture");t.renderEncoder.setColorTextureView(0,n),t.depthFormat="depth32float",t.depthTexture=qv.newInstance({label:"opaquePassDepth"}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("opaquePassDepthTexture");t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation("opaquePass"),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=Gv.newInstance({label:"OpaquePass"}),t.renderEncoder.setPipelineHash("op")}}(e,t)}var Zv={newInstance:Ht.newInstance(Yv,"vtkWebGPUOpaquePass"),extend:Yv};const Qv={colorTextureView:null,depthTextureView:null};function Jv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qv,n),Ah.extend(e,t,n),Ht.setGet(e,t,["colorTextureView","depthTextureView"]),function(e,t){t.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=qv.newInstance({label:"translucentPassColor"}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView("oitpColorTexture");t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=qv.newInstance({label:"translucentPassAccumulate"}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView("oitpAccumTexture");t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=Bv.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash("oitpfsq"),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\n  if (reveal == 1.0) { discard; }\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\n  var total: f32 = max(tcolor.a, 0.01);\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n")}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation("translucentPass"),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=Gv.newInstance({label:"translucentRender"});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:void 0,clearValue:[1,0,0,0],loadOp:"clear",storeOp:"store"}],e.depthStencilAttachment={view:void 0,depthLoadOp:"load",depthStoreOp:"store"},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addOutput("f32","outAccum"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);","output.outColor = vec4<f32>(computedColor.rgb*w, w);","output.outAccum = computedColor.a;"]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash("oitpr"),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!1,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one"},alpha:{srcFactor:"one",dstFactor:"one"}}},{format:"r16float",blend:{color:{srcFactor:"zero",dstFactor:"one-minus-src"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=Gv.newInstance({label:"translucentFinal"}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash("oitpf"),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})}}(e,t)}var eT={newInstance:Ht.newInstance(Jv,"vtkWebGPUOrderIndependentTranslucentPass"),extend:Jv},tT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const nT=["getMappedRange","mapAsync","unmap"];const rT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function oT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rT,n),Ht.obj(e,t),Ht.get(e,t,["handle","sizeInBytes","usage"]),Ht.setGet(e,t,["strideInBytes","device","arrayInformation","label","sourceTime"]),function(e,t){t.classHierarchy.push("vtkWebGPUBuffer"),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{const r=4*Math.ceil(e.byteLength/4);t.handle=t.device.getHandle().createBuffer({size:r,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=r,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<nT.length;n++)e[nT[n]]=function(){return t.handle[nT[n]](...arguments)}}(e,t)}var aT={newInstance:Ht.newInstance(oT),extend:oT,...tT};const{Representation:iT}=ts,{PrimitiveTypes:sT}=tT;class lT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function cT(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function uT(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=cT(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=cT(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=cT(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=cT(n,o,t),n.ibo[n.iboId++]=a}function dT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let pT;const fT=new Uint32Array(1),gT=new Uint32Array(2),mT=new Uint32Array(3),hT={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)fT[0]=t[n+a],pT(fT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)gT[0]=t[n+a],gT[1]=t[n+a+1],pT(gT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)gT[0]=t[n+a],gT[1]=t[n+(a+1)%e],pT(gT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)gT[0]=t[n+a],gT[1]=t[n+a+1],pT(gT,r,o);for(let a=0;a<e-2;a++)gT[0]=t[n+a],gT[1]=t[n+a+2],pT(gT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)mT[0]=t[n],mT[1]=t[n+a+1],mT[2]=t[n+a+2],pT(mT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)mT[0]=t[n+a],mT[1]=t[n+a+1+a%2],mT[2]=t[n+a+1+(a+1)%2],pT(mT,r,o)}};const vT={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function TT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vT,n),aT.extend(e,t,n),Ht.setGet(e,t,["flatIdToPointId","flatIdToCellId","flatSize","indexCount"]),function(e,t){t.classHierarchy.push("vtkWebGPUIndexBuffer"),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case sT.Points:return"points";case sT.Lines:return"lines";case sT.Triangles:case sT.TriangleEdges:return"polys";case sT.TriangleStripEdges:case sT.TriangleStrips:return"strips";default:return""}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new lT};let d=null;d=o===iT.POINTS||r===sT.Points?hT.anythingToPoints:o===iT.WIREFRAME||r===sT.Lines?hT[`${l}ToWireframe`]:hT[`${l}ToSurface`],pT=dT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format="uint16"):(u.ibo=new Uint32Array(u.iboSize),e.format="uint32"),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),pT=uT,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}(e,t)}var yT={newInstance:Ht.newInstance(TT),extend:TT,...tT};const{BufferUsage:bT}=tT,{vtkErrorMacro:xT}=jt,{VtkDataTypes:CT}=Ts;function ST(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,"packExtra")&&o.packExtra;let u,d=0;const p=it(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function AT(e,t,n,r){const o=[];return Fo([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),Go(o),o}const IT={device:null,fullScreenQuadBuffer:null};function wT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,IT,n),vt(e,t),St(e,t,["device"]),function(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===bT.Index&&(n=yT.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=aT.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===bT.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===bT.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===bT.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===bT.PointArray){r=GPUBufferUsage.VERTEX;const t=Cv(e.format),o=ST(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(xv(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?"flat":"perspective"}])}if(e.usage===bT.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=Cv(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=AT(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=ST(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(xv(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:"flat"}])}return e.usage===bT.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(xv(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push("vtkWebGPUBufferManager"),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case CT.UNSIGNED_CHAR:t="uint8";break;case CT.FLOAT:t="float32";break;case CT.UNSIGNED_INT:t="uint32";break;case CT.INT:t="sint32";break;case CT.DOUBLE:t="float32";break;case CT.UNSIGNED_SHORT:t="uint16";break;case CT.SHORT:t="sin16";break;default:t="float32"}switch(e.getNumberOfComponents()){case 2:t+="x2";break;case 3:t.includes("32")||xT(`unsupported x3 type for ${t}`),t+="x3";break;case 4:t+="x4"}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:bT.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=aT.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:"float32x3"}]),t.fullScreenQuadBuffer}}(e,t)}var OT={newInstance:Et(wT),extend:wT,...tT};const{BufferUsage:PT}=OT,{vtkErrorMacro:RT}=Ht,MT={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function ET(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),Ht.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"uniform"}},t.sendTime={},Ht.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,Ht.get(e,t,["binding","bindGroupTime"]),Ht.setGet(e,t,["bindGroupLayoutEntry","device","label","sizeInBytes"]),function(e,t){t.classHierarchy.push("vtkWebGPUUniformBuffer"),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?RT(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:Av(n),offset:-1,nativeType:Iv(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:PT.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=Ht.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void RT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void RT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join("\n")}}(e,t)}var VT={newInstance:Ht.newInstance(ET,"vtkWebGPUUniformBuffer"),extend:ET};const{BufferUsage:DT}=OT,{vtkErrorMacro:LT}=Ht,BT={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function NT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,BT,n),Ht.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},Ht.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"read-only-storage"}},Ht.get(e,t,["bindGroupTime"]),Ht.setGet(e,t,["device","bindGroupLayoutEntry","label","numberOfInstances","sizeInBytes"]),function(e,t){t.classHierarchy.push("vtkWebGPUStorageBuffer"),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void LT(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=Av(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:Iv(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:DT.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=Ht.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void LT(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void LT(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void LT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void LT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void LT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\n};\nstruct ${t.label}Struct\n{\n  values: array<${t.label}StructEntry>,\n};\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\n`),r.join("\n")},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}(e,t)}var FT={newInstance:Ht.newInstance(NT,"vtkWebGPUStorageBuffer"),extend:NT};const _T=new Float64Array(16),GT=new Float64Array(16),kT={volumes:null,rowLength:1024,lastVolumeLength:0};function UT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kT,n),Bv.extend(e,t,n),t.fragmentShaderTemplate="\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n",t.UBO=VT.newInstance({label:"mapperUBO"}),t.UBO.addEntry("SampleDistance","f32"),t.SSBO=FT.newInstance({label:"volumeSSBO"}),t.componentSSBO=FT.newInstance({label:"componentSSBO"}),t.lutBuildTime={},Ht.obj(t.lutBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkWebGPUVolumePassFSQ"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=cv.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);"]).result,r.setCode(o),t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription("fragment");let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===Af.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push("    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);")):(s.push(`  sampleColor = traverseVals[${e}];`),s.push("  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);"));a=cv.substitute(a,"//VTK::Volume::CompositeCalls",i).result,a=cv.substitute(a,"//VTK::Volume::TraverseCalls",s).result,a=cv.substitute(a,"//VTK::Volume::TraverseDec",[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===Af.COMPOSITE_BLEND?l=!0:n===Af.MAXIMUM_INTENSITY_BLEND?a=cv.substitute(a,"//VTK::Volume::Loop",[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===Af.MINIMUM_INTENSITY_BLEND?a=cv.substitute(a,"//VTK::Volume::Loop",[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===Af.AVERAGE_INTENSITY_BLEND?a=cv.substitute(a,"//VTK::Volume::Loop",[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===Af.ADDITIVE_INTENSITY_BLEND&&(a=cv.substitute(a,"//VTK::Volume::Loop",[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result)}l&&(a=cv.substitute(a,"//VTK::Volume::Loop",["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result),o.setCode(a)},t.shaderReplacements.set("replaceShaderVolume",e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8ClampedArray(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:"rgba8unorm"},r=n.getTextureManager().getTexture(e).createView("tfunTexture");t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:"r16float"},r=n.getTextureManager().getTexture(e).createView("ofunTexture");t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper().getInputData();g(_T),b(_T,_T,o);const d=n.getMatrix();m(GT,d),h(GT,GT),y(_T,GT,_T);const p=r.getWorldToIndex();y(_T,p,_T);const f=r.getDimensions();g(GT),x(GT,GT,[1/f[0],1/f[1],1/f[2]]),y(_T,GT,_T);for(let t=0;t<16;t++)a[16*e+t]=_T[t];h(_T,_T);for(let t=0;t<4;t++)i[16*e+4*t]=_T[4*t],i[16*e+4*t+1]=_T[4*t+1],i[16*e+4*t+2]=_T[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/f[0],s[4*e+1]=1/f[1],s[4*e+2]=1/f[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const v=r.getSpacing();c[4*e]=v[0],c[4*e+1]=v[1],c[4*e+2]=v[2],c[4*e+3]=1;const T=t.textureViews[e+4].getTexture().getScale(),C=n.getProperty().getIpScalarRange();u[4*e]=C[0]/T,u[4*e+1]=C[1]/T,u[4*e+2]=n.getProperty().getFilterMode()}t.SSBO.addEntry("SCTCMatrix","mat4x4<f32>"),t.SSBO.addEntry("planeNormals","mat4x4<f32>"),t.SSBO.addEntry("shade","vec4<f32>"),t.SSBO.addEntry("tstep","vec4<f32>"),t.SSBO.addEntry("spacing","vec4<f32>"),t.SSBO.addEntry("ipScalarRange","vec4<f32>"),t.SSBO.setAllInstancesFromArray("SCTCMatrix",a),t.SSBO.setAllInstancesFromArray("planeNormals",i),t.SSBO.setAllInstancesFromArray("shade",l),t.SSBO.setAllInstancesFromArray("tstep",s),t.SSBO.setAllInstancesFromArray("spacing",c),t.SSBO.setAllInstancesFromArray("ipScalarRange",u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),T=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=bv(l),u={scale:[255],offset:[0]};2===c.elementSize&&"float"===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);T[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else T[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry("cScale","f32"),t.componentSSBO.addEntry("cShift","f32"),t.componentSSBO.addEntry("oScale","f32"),t.componentSSBO.addEntry("oShift","f32"),t.componentSSBO.addEntry("goShift","f32"),t.componentSSBO.addEntry("goScale","f32"),t.componentSSBO.addEntry("gomin","f32"),t.componentSSBO.addEntry("gomax","f32"),t.componentSSBO.setAllInstancesFromArray("cScale",d),t.componentSSBO.setAllInstancesFromArray("cShift",p),t.componentSSBO.setAllInstancesFromArray("oScale",f),t.componentSSBO.setAllInstancesFromArray("oShift",v),t.componentSSBO.setAllInstancesFromArray("goScale",A),t.componentSSBO.setAllInstancesFromArray("goShift",S),t.componentSSBO.setAllInstancesFromArray("gomin",T),t.componentSSBO.setAllInstancesFromArray("gomax",C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue("SampleDistance",r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=zv.newInstance({label:"clampSampler"}),t.clampSampler.create(t.device,{minFilter:"linear",magFilter:"linear"}))},e.computePipelineHash=()=>{t.pipelineHash="volfsq";for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}(e,t)}var zT={newInstance:Ht.newInstance(UT,"vtkWebGPUVolumePassFSQ"),extend:UT};const{Representation:WT}=ts,{BufferUsage:HT,PrimitiveTypes:jT}=OT,KT=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],$T={colorTextureView:null,depthTextureView:null,volumes:null};function qT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$T,n),Ah.extend(e,t,n),t._mapper=Vv.newInstance(),t._mapper.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Select::Dec\n\n//VTK::VolumePass::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Select::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::VolumePass::Impl\n\n  // use the maximum (closest) of the current value and the zbuffer\n  // the blend func will then take the min to find the farthest stop value\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._mapper.getShaderReplacements().set("replaceShaderVolumePass",((e,t,n)=>{t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")})),t._boundsPoly=Uc.newInstance(),t._lastMTimes=[],Ht.setGet(e,t,["colorTextureView","depthTextureView"]),function(e,t){t.classHierarchy.push("vtkWebGPUVolumePass"),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=zT.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=Bv.newInstance(),t._volumeCopyQuad.setPipelineHash("volpassfsq"),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._copyUBO=VT.newInstance({label:"mapperUBO"}),t._copyUBO.addEntry("tscale","vec2<f32>"),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Uo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray("tscale",[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray("tscale",[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=Ht.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:HT.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:jT.Triangles,representation:WT.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:HT.PointArray,format:"float32x4",hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,["vertexBC"]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+KT[e][0],l[n++]=r+KT[e][1],l[n++]=r+KT[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation("volumeDepthRangePass"),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=Gv.newInstance({label:"VolumePass DepthRange"}),t._depthRangeEncoder.setPipelineHash("volr"),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor1"),t.addOutput("vec4<f32>","outColor2");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);","output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:null,clearValue:[1,1,1,1],loadOp:"clear",storeOp:"store"}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"max"},alpha:{srcFactor:"one",dstFactor:"one",operation:"max"}}},{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"min"},alpha:{srcFactor:"one",dstFactor:"one",operation:"min"}}}]}}),t._depthRangeTexture=qv.newInstance({label:"volumePassMaxDepth"}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView("maxTexture");t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=qv.newInstance({label:"volumePassDepthMin"}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView("minTexture");t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=qv.newInstance({label:"volumePassColor"}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView("volumePassColorTexture"),t._colorTextureView.addSampler(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._clearEncoder=Gv.newInstance({label:"VolumePass Clear"}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),t._clearEncoder.setPipelineHash("volpf"),t._clearEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=Gv.newInstance({label:"volumePassCopy"}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._copyEncoder.setPipelineHash("volcopypf"),t._copyEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=Gv.newInstance({label:"volumePassMerge"}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash("volpf"),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}(e,t)}var XT={newInstance:Ht.newInstance(qT,"vtkWebGPUVolumePass"),extend:qT};const YT={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function ZT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,YT,n),Ah.extend(e,t,n),Ht.setGet(e,t,["opaquePass","translucentPass","volumePass"]),function(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e),t.opaquePass||(t.opaquePass=Zv.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation("queryPass"),i.traverse(e),e.setCurrentOperation("cameraPass"),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=eT.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=XT.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=Gv.newInstance({label:"forwardPassBlit"}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._finalBlitEncoder.setPipelineHash("fpf"),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}}),t._fsqSampler=zv.newInstance({label:"finalPassSampler"}),t._fsqSampler.create(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._fullScreenQuad=Bv.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash("fpfsq"),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._finalBlitOutputTextureView=jv.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}(e,t)}var QT={newInstance:Ht.newInstance(ZT,"vtkForwardPass"),extend:ZT};const{VtkDataTypes:JT}=Ts,ey={handle:null,device:null};function ty(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ey,n),Ht.obj(e,t),Ht.setGet(e,t,["device"]),function(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format="r";break;case 2:e.format="rg";break;default:e.format="rgba"}switch(e.dataArray.getDataType()){case JT.UNSIGNED_CHAR:e.format+="8unorm";break;case JT.FLOAT:case JT.UNSIGNED_INT:case JT.INT:case JT.DOUBLE:case JT.UNSIGNED_SHORT:case JT.SHORT:default:e.format+="16float"}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.nativeArray=e.jsImageData.data,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.imageBitmap&&(e.width=e.imageBitmap.width,e.height=e.imageBitmap.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=qv.newInstance({label:e.label});return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas||e.imageBitmap)&&n.writeImageData(e),n}t.classHierarchy.push("vtkWebGPUTextureManager"),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;const o={time:e.getMTime(),label:r};return e.getInputData()?o.imageData=e.getInputData():e.getImage()?o.image=e.getImage():e.getJsImageData()?o.jsImageData=e.getJsImageData():e.getImageBitmap()?o.imageBitmap=e.getImageBitmap():e.getCanvas()&&(o.canvas=e.getCanvas()),n(o),o.mipLevel=e.getMipLevel(),o.hash=o.time+o.format+o.mipLevel,t.device.getTextureManager().getTexture(o)}}(e,t)}var ny={newInstance:Ht.newInstance(ty),extend:ty};class ry extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&"object"==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}const oy={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function ay(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oy,n),vt(e,t),St(e,t,["handle"]),yt(e,t,["bufferManager","shaderCache","textureManager"]),t.objectCache=new ry,t.shaderCache=cv.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=OT.newInstance(),t.bufferManager.setDevice(e),t.textureManager=ny.newInstance(),t.textureManager.setDevice(e),t.pipelines={},function(e,t){t.classHierarchy.push("vtkWebGPUDevice"),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro("layout not found"),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro("attempt to cache an object without a hash"),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}(e,t)}var iy={newInstance:Et(ay,"vtkWebGPUDevice"),extend:ay};const sy={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function ly(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sy,n),Ah.extend(e,t,n),Ht.get(e,t,["colorTexture","depthTexture"]),function(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelectionPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=qv.newInstance({label:"hardwareSelectorColor"}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"rgba32uint",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView("hardwareSelectColorTexture");t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=qv.newInstance({label:"hardwareSelectorDepth"}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("hardwareSelectDepthTexture");t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation("cameraPass"),r.traverse(e),e.setCurrentOperation("opaquePass"),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=Gv.newInstance({label:"HardwareSelectionPass"}),t.selectionRenderEncoder.setPipelineHash("sel"),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<u32>","outColor");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba32uint",blend:void 0}]}})}}(e,t)}var cy={newInstance:Ht.newInstance(ly,"vtkWebGPUHardwareSelectionPass"),extend:ly};const{SelectionContent:uy,SelectionField:dy}=Zd,{FieldAssociations:py}=_s,{vtkErrorMacro:fy}=Ht;function gy(e){return`${e.propID} ${e.compositeID}`}function my(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function hy(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=my(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=my(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=hy(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=hy(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=hy(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=hy(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=hy(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}const vy={};function Ty(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vy,n),jd.extend(e,t,n),t._selectionPass=cy.newInstance(),Ht.setGet(e,t,["_WebGPURenderWindow"]),Ht.moveToProtected(e,t,["WebGPURenderWindow"]),function(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelector"),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return fy("Renderer and view must be set before calling Select."),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=aT.newInstance({label:"hardwareSelectColorBuffer"});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=aT.newInstance({label:"hardwareSelectDepthBuffer"}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:"depth-only"},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=hy(e,[n,t],0,u);if(r){const t=gy(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=Zd.newInstance();switch(i.setContentType(uy.INDICES),e){case py.FIELD_ASSOCIATION_CELLS:i.setFieldType(dy.CELL);break;case py.FIELD_ASSOCIATION_POINTS:i.setFieldType(dy.POINT);break;default:fy("Unknown field association")}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}(e,t)}var yy={newInstance:Ht.newInstance(Ty,"vtkWebGPUHardwareSelector"),extend:Ty};const by=Object.create(null),xy={};function Cy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xy,n),t.overrides=by,Qt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkWebGPUViewNodeFactory")}(0,t)}var Sy={newInstance:Ht.newInstance(Cy,"vtkWebGPUViewNodeFactory"),extend:Cy};const{vtkErrorMacro:Ay}=Ht,Iy={position:"absolute",top:0,left:0,width:"100%",height:"100%"};const wy={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:"pointer",containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const Oy=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wy,n),t.canvas=document.createElement("canvas"),t.canvas.style.width="100%",t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",Kh.extend(e,t,n),t.myFactory=Sy.newInstance(),t.renderPasses[0]=QT.newInstance(),t.selector||(t.selector=yy.newInstance(),t.selector.setWebGPURenderWindow(e)),Ht.event(e,t,"imageReady"),Ht.event(e,t,"initialized"),Ht.get(e,t,["commandEncoder","device","presentationFormat","useBackgroundImage","xrSupported"]),Ht.setGet(e,t,["initialized","context","canvas","device","renderPasses","notifyStartCaptureImage","cursor","useOffScreen"]),Ht.setGetArray(e,t,["size"],2),Ht.event(e,t,"windowResizeEvent"),function(e,t){t.classHierarchy.push("vtkWebGPURenderWindow"),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Ay("WebGPU is not enabled.");e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Ay("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),t.deleted||(t.device=iy.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext("webgpu"))},e.releaseGraphicsResources=()=>{const n=Ah.newInstance();n.setCurrentOperation("Release"),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Iy,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect();t.renderable.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const l=r.toDataURL(n);r.remove(),e.invokeImageReady(l)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=aT.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Uu.fromHalf(r.colorValues[o]),s[n+1]=255*Uu.fromHalf(r.colorValues[o+1]),s[n+2]=255*Uu.fromHalf(r.colorValues[o+2]),s[n+3]=255*Uu.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=yy.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=Ht.chain(e.delete,e.setViewStream)}(e,t)}),"vtkWebGPURenderWindow");var Py;Nm("WebGPU",Oy),Py=Oy,by.vtkRenderWindow=Py;const Ry=xh(),My={margin:"0",padding:"0",position:"absolute",top:"0",left:"0",width:"100%",height:"100%",overflow:"hidden"},Ey={position:"absolute",left:"25px",top:"25px",backgroundColor:"white",borderRadius:"5px",listStyle:"none",padding:"5px 10px",margin:"0",display:"block",border:"solid 1px black",maxWidth:"calc(100% - 70px)",maxHeight:"calc(100% - 60px)",overflow:"auto"};function Vy(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}const Dy={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function Ly(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dy,n),Ht.obj(e,t),Ht.get(e,t,["renderWindow","renderer","apiSpecificRenderWindow","interactor","rootContainer","container","controlContainer"]),function(e,t){t.classHierarchy.push("vtkFullScreenRenderWindow");const n=document.querySelector("body");function r(t){"c"===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement("div"),Vy(t.container,t.containerStyle||My),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height="100%",n.style.height="100%",n.style.padding="0",n.style.margin="0"),t.renderWindow=km.newInstance(),t.renderer=Lm.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(Ry.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=rh.newInstance(),t.interactor.setInteractorStyle(Th.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?"block":"none")},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement("div"),Vy(t.controlContainer,t.controlPanelStyle||Ey),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener("keypress",r)},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=Ht.chain(e.setContainer,t.apiSpecificRenderWindow.delete,(()=>{t.rootContainer?.removeEventListener("keypress",r),window.removeEventListener("resize",e.resize)}),e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener("resize",e.resize),e.resize()}(e,t)}var By={newInstance:Ht.newInstance(Ly),extend:Ly},Ny={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:Fy,Scale:_y}=Ny,{ScalarMappingTarget:Gy}=il,{vtkDebugMacro:ky,vtkErrorMacro:Uy,vtkWarningMacro:zy}=Ht;function Wy(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function Hy(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function jy(e,t,n,r){const o=[],a=[];va(t,o),va(n,a);const i=[],s=[];Wy(o,i),Wy(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=Hy(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=Hy(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Ta(u,r)}const Ky={clamping:!0,colorSpace:Fy.RGB,hSVWrap:!0,scale:_y.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function $y(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ky,n),il.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},Ht.obj(t.buildTime),Ht.get(e,t,["buildTime","mappingRange"]),Ht.setGet(e,t,["useAboveRangeColor","useBelowRangeColor","discretize","numberOfValues",{type:"enum",name:"colorSpace",enum:Fy},{type:"enum",name:"scale",enum:_y}]),Ht.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),Ht.getArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"]),function(e,t){t.classHierarchy.push("vtkColorTransferFunction"),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return Uy("Midpoint outside range [0.0, 1.0]"),-1;if(s<0||s>1)return Uy("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[];return pa([n,r,o],s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];pa([n,r,o],u),pa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.logScaleEnabled=()=>t.scale===_y.LOG10,e.usingLogScale=()=>e.logScaleEnabled()&&t.mappingRange[0]>0,e.getTable=(n,r,o,a)=>{const i=e.usingLogScale(),s=i?Math.log10(Number(n)):Number(n),l=i?Math.log10(Number(r)):Number(r);if(Pa(s)||Pa(l)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let c=0;const u=t.nodes.length;let d=0,p=0,f=0;0!==u&&(d=t.nodes[u-1].r,p=t.nodes[u-1].g,f=t.nodes[u-1].b);let g=0,m=0,h=0;const v=[0,0,0],T=[0,0,0];let y=0,b=0;const x=[];let C=t.mappingRange;i&&(C=[Math.log10(t.mappingRange[0]),Math.log10(t.mappingRange[1])]);for(let n=0;n<o;n++){const r=3*n;if(g=o>1?s+n/(o-1)*(l-s):.5*(s+l),t.discretize){const e=C;if(g>=e[0]&&g<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)g=e[0]+r/2;else{const t=(g-e[0])/r,o=Co(n*t);g=e[0]+o/(n-1)*r}}}for(;c<u&&g>t.nodes[c].x;)c++,c<u&&(m=t.nodes[c-1].x,h=t.nodes[c].x,v[0]=t.nodes[c-1].r,T[0]=t.nodes[c].r,v[1]=t.nodes[c-1].g,T[1]=t.nodes[c].g,v[2]=t.nodes[c-1].b,T[2]=t.nodes[c].b,y=t.nodes[c-1].midpoint,b=t.nodes[c-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(g>C[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=d,a[r+1]=p,a[r+2]=f));else if(g<C[0]||Ia(g)&&g<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):u>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===c&&(Math.abs(g-s)<1e-6||t.discretize))u>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=(g-m)/(h-m),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),b>.99){if(e<.5){a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}a[r]=T[0],a[r+1]=T[1],a[r+2]=T[2];continue}if(b<.01){if(t.colorSpace===Fy.RGB)a[r]=(1-e)*v[0]+e*T[0],a[r+1]=(1-e)*v[1]+e*T[1],a[r+2]=(1-e)*v[2]+e*T[2];else if(t.colorSpace===Fy.HSV){const n=[],o=[];da(v,n),da(T,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],pa(i,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else if(t.colorSpace===Fy.LAB){const t=[],n=[];va(v,t),va(T,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Ta(o,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else t.colorSpace===Fy.DIVERGING?(jy(e,v,T,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]):Uy("ColorSpace set to invalid value.",t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*b):e>.5&&(e=1-.5*(2*(1-e))**(1+10*b));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===Fy.RGB)for(let e=0;e<3;e++)u=T[e]-v[e],d=(1-b)*u,a[r+e]=i*v[e]+s*T[e]+l*d+c*d;else if(t.colorSpace===Fy.HSV){const e=[],n=[];da(v,e),da(T,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-b)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);pa(o,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else if(t.colorSpace===Fy.LAB){const e=[],t=[];va(v,e),va(T,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-b)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Ta(n,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else t.colorSpace===Fy.DIVERGING?(jy(e,v,T,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]):Uy("ColorSpace set to invalid value.");for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return Uy("Attempting to lookup a value with no points in the function"),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(Uy("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return Uy("Index out of range!"),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>{if(t.indexedLookup&&e.getSize())return e.getSize();if(t.tableSize)return t.tableSize;const n=t.nodes?.length??0;return Math.max(4094,n)},e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=[n,r],i=e.getRange(),s=e.logScaleEnabled();if(i[1]===o[1]&&i[0]===o[0])return;if(o[1]===o[0])return void Uy("attempt to set zero width color range");s&&(o[0]<=0?console.warn("attempt to set log scale color range with non-positive minimum"):(a[0]=Math.log10(o[0]),a[1]=Math.log10(o[1])));const l=(a[1]-a[0])/(i[1]-i[0]),c=a[0]-i[0]*l;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*l+c;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):ky("Transfer Function Has No Points!")},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void zy("Transfer Function Has No Points!");const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===Gy.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===Gy.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===Gy.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===Gy.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=Fy[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(Uy(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=Fy.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}(e,t)}var qy={newInstance:Ht.newInstance($y,"vtkColorTransferFunction"),extend:$y,...Ny},Xy={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:Yy,ScaleModes:Zy}=Xy,{vtkErrorMacro:Qy}=Ht,Jy={orient:!0,orientationMode:Yy.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:Zy.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function eb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jy,n),Fl.extend(e,t,n),Ht.algo(e,t,2,0),t.buildTime={},Ht.obj(t.buildTime,{mtime:0}),t.boundsTime={},Ht.obj(t.boundsTime,{mtime:0}),Ht.setGet(e,t,["orient","orientationMode","orientationArray","scaleArray","scaleFactor","scaleMode","scaling"]),Ht.get(e,t,["colorArray","matrixArray","normalArray","buildTime"]),function(e,t){t.classHierarchy.push("vtkGlyph3DMapper"),e.getOrientationModeAsString=()=>Ht.enumToString(Yy,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(Yy.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(Yy.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(Yy.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>Ht.enumToString(Zy,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(Zy.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(Zy.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(Zy.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Ra()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===Zy.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(Qy("Cannot scale by components since scale array does not have 3 components."),a=null);const l=r.getBounds(),c=[];Fi.getCorners(l,c),t.bounds[0]=Fi.INIT_BOUNDS[0],t.bounds[1]=Fi.INIT_BOUNDS[1],t.bounds[2]=Fi.INIT_BOUNDS[2],t.bounds[3]=Fi.INIT_BOUNDS[3],t.bounds[4]=Fi.INIT_BOUNDS[4],t.bounds[5]=Fi.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const T=t.normalArray.buffer,w=[],O=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,O),t.orientationMode){case Yy.MATRIX:y(n,n,[...O.slice(0,3),0,...O.slice(3,6),0,...O.slice(6,9),0,0,0,0,1]);break;case Yy.ROTATION:I(n,n,O[2]),S(n,n,O[0]),A(n,n,O[1]);break;case Yy.DIRECTION:if(0===O[1]&&0===O[2])O[0]<0&&A(n,n,3.1415926);else{const e=_o(O),t=[];t[0]=(O[0]+e)/2,t[1]=O[1]/2,t[2]=O[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case Zy.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=_o(w,s),m[1]=m[0],m[2]=m[0];break;case Zy.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case Zy.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)wn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(T,36*e,9);se(r,n),ge(r,r),fe(r,r)}const P=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&P&&(R.build(),t.colorArray=R.mapScalars(P,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}(e,t)}var tb={newInstance:Ht.newInstance(eb,"vtkGlyph3DMapper"),extend:eb,...Xy};const{vtkErrorMacro:nb}=Ht,rb={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function ob(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rb,n),Ht.obj(e,t),t.nodes=[],Ht.setGet(e,t,["allowDuplicateScalars","clamping"]),Ht.setArray(e,t,["range"],2),Ht.getArray(e,t,["range"]),function(e,t){t.classHierarchy.push("vtkPiecewiseFunction"),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return"Constant";case 1:return"NonDecreasing";case 2:return"NonIncreasing";default:return"Varied"}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(nb("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return nb("Index out of range!"),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return nb("Midpoint outside range [0.0, 1.0]"),-1;if(a<0||a>1)return nb("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,T=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>T?T:o[v]}}}}(e,t)}var ab={newInstance:Ht.newInstance(ob,"vtkPiecewiseFunction"),extend:ob};const{InterpolationType:ib,OpacityMode:sb,FilterMode:lb,ColorMixPreset:cb}=Sf,{vtkErrorMacro:ub}=Ht;function db(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,(e=>({colorMixPreset:cb.DEFAULT,independentComponents:!0,interpolationType:ib.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1,ipScalarRange:[-1e6,1e6],filterMode:lb.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7,updatedExtents:[],...e}))(n)),Ht.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:sb.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1,forceNearestInterpolation:!1})}Ht.setGet(e,t,["colorMixPreset","independentComponents","interpolationType","shade","ambient","diffuse","specular","specularPower","useLabelOutline","labelOutlineOpacity","filterMode","preferSizeOverAccuracy","computeNormalFromOpacity","volumetricScatteringBlending","globalIlluminationReach","anisotropy","localAmbientOcclusion","LAOKernelSize","LAOKernelRadius","updatedExtents"]),Ht.setGetArray(e,t,["ipScalarRange"],2),Ht.setGetArray(e,t,["labelOutlineThickness"]),function(e,t){t.classHierarchy.push("vtkVolumeProperty");const n={...e};e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(ub("Bad index - must be between 0 and 3"),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=ab.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=qy.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=ab.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return ub("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(ub("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(ib.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(ib.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(ib.FAST_LINEAR),e.getInterpolationTypeAsString=()=>Ht.enumToString(ib,t.interpolationType),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=Ht.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=Ht.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]})),e.setAverageIPScalarRange=(t,n)=>{console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>Ht.enumToString(lb,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(lb.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(lb.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(lb.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(xa(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(xa(e,0,1)),e.setAnisotropy=e=>n.setAnisotropy(xa(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Co(xa(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}(e,t)}var pb={newInstance:Ht.newInstance(db,"vtkVolumeProperty"),extend:db,...Sf};const fb={mapper:null};function gb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fb,n),Ki.extend(e,t,n),t.boundsMTime={},Ht.obj(t.boundsMTime),Ht.setGet(e,t,["mapper"]),function(e,t){t.classHierarchy.push("vtkVolume"),e.getVolumes=()=>[e],e.makeProperty=pb.newInstance,e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}(e,t)}var mb={newInstance:Ht.newInstance(gb,"vtkVolume"),extend:gb};const{BlendMode:hb}=If,vb=["getAnisotropy","getComputeNormalFromOpacity","getFilterMode","getFilterModeAsString","getGlobalIlluminationReach","getIpScalarRange","getIpScalarRangeByReference","getLAOKernelRadius","getLAOKernelSize","getLocalAmbientOcclusion","getPreferSizeOverAccuracy","getVolumetricScatteringBlending","setAnisotropy","setAverageIPScalarRange","setComputeNormalFromOpacity","setFilterMode","setFilterModeToNormalized","setFilterModeToOff","setFilterModeToRaw","setGlobalIlluminationReach","setIpScalarRange","setIpScalarRangeFrom","setLAOKernelRadius","setLAOKernelSize","setLocalAmbientOcclusion","setPreferSizeOverAccuracy","setVolumetricScatteringBlending"],Tb={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=ab.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,(e=>({bounds:[...Fi.INIT_BOUNDS],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:hb.COMPOSITE_BLEND,volumeShadowSamplingDistFactor:5,colorTextureWidth:1024,opacityTextureWidth:1024,labelOutlineTextureWidth:1024,...e}))(n)),xs(e,t,n),Ht.setGet(e,t,["sampleDistance","imageSampleDistance","maximumSamplesPerRay","autoAdjustSampleDistances","initialInteractionScale","interactionSampleDistanceFactor","blendMode","volumeShadowSamplingDistFactor","colorTextureWidth","opacityTextureWidth","labelOutlineTextureWidth"]),Ht.event(e,t,"lightingActivated"),function(e,t){t.classHierarchy.push("vtkVolumeMapper");const n={...e};e.getBounds=()=>(t.static||e.update(),t.bounds=[...e.getInputData().getBounds()],t.bounds),e.setBlendModeToComposite=()=>{e.setBlendMode(hb.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(hb.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(hb.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(hb.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(hb.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(hb.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>Ht.enumToString(hb,t.blendMode),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),vb.forEach((t=>{e[t]=()=>{throw new Error(`The method "volumeMapper.${t}()" doesn't exist anymore. It is a rendering property that has been moved to the volume property. Replace your code with:\nvolumeActor.getProperty().${t}()\n`)}}))}(e,t)}var bb={newInstance:Ht.newInstance(yb,"vtkVolumeMapper"),extend:yb,...Tb};const{InterpolationType:xb}=Qp,{vtkErrorMacro:Cb}=Ht;function Sb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,(e=>({independentComponents:!1,interpolationType:xb.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1,updatedExtents:[],...e}))(n)),Ht.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}Ht.setGet(e,t,["independentComponents","interpolationType","colorWindow","colorLevel","ambient","diffuse","opacity","useLookupTableScalarRange","useLabelOutline","labelOutlineOpacity","updatedExtents"]),Ht.setGetArray(e,t,["labelOutlineThickness"]),function(e,t){t.classHierarchy.push("vtkImageProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(n)||(o=n,r=0),t.componentData[r].rGBTransferFunction!==o&&(t.componentData[r].rGBTransferFunction=o,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(n)||(o=n,r=0),t.componentData[r].piecewiseFunction!==o&&(t.componentData[r].piecewiseFunction=o,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(t)||(r=t,n=0),e.setPiecewiseFunction(n,r)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return Cb("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(Cb("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(xb.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(xb.LINEAR),e.getInterpolationTypeAsString=()=>Ht.enumToString(xb,t.interpolationType)}(e,t)}var Ab={newInstance:Ht.newInstance(Sb,"vtkImageProperty"),extend:Sb};const Ib={mapper:null,forceOpaque:!1,forceTranslucent:!1};function wb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ib,n),Ki.extend(e,t,n),t.boundsMTime={},Ht.obj(t.boundsMTime),Ht.setGet(e,t,["mapper","forceOpaque","forceTranslucent"]),function(e,t){t.classHierarchy.push("vtkImageSlice"),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.properties[0]||e.getProperty();let n=t.properties[0].getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=Ab.newInstance,e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!Fi.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),Fi.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return t.properties.forEach((t=>{e=Math.max(e,t.getMTime());const n=t.getRGBTransferFunction();null!==n&&(e=Math.max(e,n.getMTime()))})),e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}(e,t)}var Ob={newInstance:Ht.newInstance(wb,"vtkImageSlice"),extend:wb};const Pb={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1],colorTextureWidth:1024,opacityTextureWidth:1024,labelOutlineTextureWidth:1024};var Rb=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pb,n),xs(e,t,n),Ht.setGet(e,t,["slice","useCustomExtents","colorTextureWidth","opacityTextureWidth","labelOutlineTextureWidth"]),Ht.setGetArray(e,t,["customDisplayExtent"],6),Ht.setGetArray(e,t,["backgroundColor"],4),function(e,t){t.classHierarchy.push("vtkAbstractImageMapper"),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(Ht.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"),Ra())}(e,t)};function Mb(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA("vtkImageArrayMapper")?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Sn(c,c);const u=ti.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:Eb,otherStaticMethods:Vb}=bl,{SlicingMode:Db}=rf;const Lb={slicingMode:Db.NONE,closestIJKAxis:{ijkMode:Db.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function Bb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lb,n),Rb(e,t,n),Ht.get(e,t,["slicingMode"]),Ht.setGet(e,t,["closestIJKAxis","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy"]),bl.implementCoincidentTopologyMethods(e,t),function(e,t){function n(){let n;switch(t.slicingMode){case Db.X:n=0;break;case Db.Y:n=1;break;case Db.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=Ma(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push("vtkImageMapper"),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case Db.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case Db.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case Db.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case Db.I:l=xa(a[0],i[0],i[1]);break;case Db.J:l=xa(a[1],i[2],i[3]);break;case Db.K:l=xa(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case Db.I:case Db.J:case Db.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case Db.X:e.setSlice(r[0]);break;case Db.Y:e.setSlice(r[1]);break;case Db.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(Db.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(Db.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(Db.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(Db.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(Db.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(Db.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case Db.X:n[0]=1;break;case Db.Y:n[1]=1;break;case Db.Z:n[2]=1;break;case Db.I:jo(r,[1,0,0],n);break;case Db.J:jo(r,[0,1,0],n);break;case Db.K:jo(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==Db.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Ra();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case Db.I:r[0]=a,r[1]=a;break;case Db.J:r[2]=a,r[3]=a;break;case Db.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Ra();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case Db.I:a[0]=s-r,a[1]=s+r;break;case Db.J:a[2]=s-r,a[3]=s+r;break;case Db.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=Mb(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=Mb(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}(e,t)}var Nb={newInstance:Ht.newInstance(Bb,"vtkImageMapper"),extend:Bb,...Eb,...Vb,...rf};const{vtkErrorMacro:Fb}=Ht;function _b(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}const Gb={outputPointsPrecision:Os.DEFAULT};function kb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gb,n),Ht.setGet(e,t,["outputPointsPrecision"]),Ht.obj(e,t),Ht.algo(e,t,1,1),function(e,t){t.classHierarchy.push("vtkAppendPolyData"),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void Fb("No input specified.");if(1===o)return void(r[0]=n[0]);const a=Uc.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===Os.SINGLE?s=is.FLOAT:t.outputPointsPrecision===Os.DOUBLE&&(s=is.DOUBLE);const v=ql.newInstance({dataType:s});v.setNumberOfPoints(i);const T=v.getData(),y=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Ts.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Ts.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Ts.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];T.set(t.getPoints().getData(),3*i),_b(y,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),_b(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),_b(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),_b(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(y),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}(e,t)}var Ub={newInstance:Ht.newInstance(kb,"vtkAppendPolyData"),extend:kb};const zb={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:"Float64Array"};function Wb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zb,n),Ht.obj(e,t),Ht.setGet(e,t,["height","radius","resolution","capping"]),Ht.setGetArray(e,t,["center","direction"],3),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkConeSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=Ht.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Lp().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=Uc.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}(e,t)}var Hb={newInstance:Ht.newInstance(Wb,"vtkConeSource"),extend:Wb};const jb={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:"Float64Array"};function Kb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jb,n),Ht.obj(e,t),Ht.setGet(e,t,["height","initAngle","otherRadius","radius","resolution","capping"]),Ht.setGetArray(e,t,["center","direction"],3),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkCylinderSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=Ht.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Ts.newInstance({numberOfComponents:3,values:u,name:"Normals"}),p=new Float32Array(2*a),f=Ts.newInstance({numberOfComponents:2,values:p,name:"TCoords"}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],T=[0,0],y=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],T[0]=Math.abs(2*e/t.resolution-1),y[0]=T[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],T[1]=0,y[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=T[e],p[2*(n+1)+e]=y[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],T[0]=h[0],y[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],T[1]=h[2],y[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=T[e],p[2*r+e]=y[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Lp().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=Uc.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}(e,t)}var $b={newInstance:Ht.newInstance(Kb,"vtkCylinderSource"),extend:Kb};const qb={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:"Float64Array"};function Xb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qb,n),Ht.obj(e,t),Ht.setGet(e,t,["tipResolution","tipRadius","tipLength","shaftResolution","shaftRadius","invert"]),Ht.setGetArray(e,t,["direction"],3),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkArrowSource"),e.requestData=function(e,n){if(t.deleted)return;const r=$b.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();Dp().rotateZ(-90).apply(a).apply(i);const s=Hb.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Lp().translate(1-.5*t.tipLength,0,0).apply(c);const u=Ub.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Lp().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Lp().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Lp().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}(e,t)}var Yb={newInstance:Ht.newInstance(Xb,"vtkArrowSource"),extend:Xb};function Zb(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];Dp().translate(...n).apply(e.getPoints().getData())}function Qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=e.getPoints().getBounds(),o=[0,0,0];o[t]=n?-r[2*t+1]:-r[2*t],Dp().translate(...o).apply(e.getPoints().getData())}function Jb(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8ClampedArray(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Ts.newInstance({name:"color",numberOfComponents:3,values:a}))}function ex(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};os.extend(e,t,function(e){return{config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1,...e?.config},xConfig:{color:[255,0,0],invert:!1,...e?.xConfig},yConfig:{color:[255,255,0],invert:!1,...e?.yConfig},zConfig:{color:[0,128,0],invert:!1,...e?.zConfig}}}(n)),Ht.setGet(e,t,["config","xConfig","yConfig","zConfig"]),function(e,t){t.classHierarchy.push("vtkAxesActor");const n=Fl.newInstance();e.setMapper(n),e.update=()=>{let e={...t.config,...t.xConfig};const r=Yb.newInstance({direction:[1,0,0],...e}).getOutputData();t.config.recenter?Zb(r):Qb(r,0,e.invert),Jb(r,...e.color),e={...t.config,...t.yConfig};const o=Yb.newInstance({direction:[0,1,0],...e}).getOutputData();t.config.recenter?Zb(o):Qb(o,1,e.invert),Jb(o,...e.color),e={...t.config,...t.zConfig};const a=Yb.newInstance({direction:[0,0,1],...e}).getOutputData();t.config.recenter?Zb(a):Qb(a,2,e.invert),Jb(a,...e.color);const i=Ub.newInstance();i.setInputData(r),i.addInputData(o),i.addInputData(a),n.setInputConnection(i.getOutputPort())},e.update();const r=Ht.debounce(e.update,0);e.setXAxisColor=t=>e.setXConfig({...e.getXConfig(),color:t}),e.setYAxisColor=t=>e.setYConfig({...e.getYConfig(),color:t}),e.setZAxisColor=t=>e.setZConfig({...e.getZConfig(),color:t}),e.getXAxisColor=()=>t.getXConfig().color,e.getYAxisColor=()=>t.getYConfig().color,e.getZAxisColor=()=>t.getZConfig().color,t._onConfigChanged=r,t._onXConfigChanged=r,t._onYConfigChanged=r,t._onZConfigChanged=r}(e,t)}var tx={newInstance:Ht.newInstance(ex,"vtkAxesActor"),extend:ex};const nx="resetcamera",rx="orientation",ox={MODE_RESET_CAMERA:nx,MODE_ORIENTATION:rx,MODE_SAME:"same"};const ax={mode:rx,focalPoint:[0,0,0],distance:6.8,active:!0};function ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ax,n),vt(e,t),St(e,t,["mode","active","srcRenderer","dstRenderer","distance"]),wt(e,t,["focalPoint"],3,0),function(e,t){t.classHierarchy.push("vtkCameraSynchronizer");const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._onSrcRendererChanged=a,t._onDstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName("position"),s=e.getReferenceByName("focalPoint"),l=e.getReferenceByName("viewUp"),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===rx?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],Go(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===nx&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}(e,t)}var sx={newInstance:Et(ix,"vtkCameraSynchronizer"),extend:ix,SynchronizationMode:ox};const lx={},cx={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=sx.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:sx.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var ux=function(e,t,n){const r=e.get("synchronizedViewId").synchronizedViewId;if(!t.behaviors||!r)return;lx[r]||(lx[r]={});const o=lx[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=sx.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];cx[e.type]?o[r]=new cx[e.type](n,e):console.log("No mapping for",e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const dx={},px=/instance:\${([^}]+)}/,fx={},gx=[],mx={},hx={vtkPoints:ql,vtkCellArray:Wl,vtkDataArray:Ts};function vx(e){return e.map((e=>px.exec(e))).filter((e=>e)).map((e=>e[1]))}function Tx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),Tx(e,t)})),t}function yx(e,t,n,r){if(!t)return Promise.reject(new Error("No instance provided."));const o=dx[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function bx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=dx[e];return n&&n.build?n.build(t):(console.log("No builder for",e),null)}function xx(){Object.keys(dx).forEach((e=>{delete dx[e]}))}function Cx(e){if(1===e[1].length)return-1===gx.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===gx.indexOf(e[1][n]);return t}function Sx(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(mx[r]){const{key:n,value:o}=mx[r];if(!n||e.properties[n]===o)return void gx.push((e=>`instance:\${${e}}`)(t))}let o=n.getInstance(t);o||(o=bx(r,{managedInstanceId:t}),n.registerInstance(t,o)),yx(r,o,e,n)})),t.calls&&t.calls.filter(Cx).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=px.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:"addArray",a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:"vtkDataArray",l=hx[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log("Error fetching array",JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error("Error in array handling for state",JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function Ax(e,t,n){fx[t.id]||Sx(e,t,n),fx[t.id]=!0}function Ix(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function wx(e){const t=e.name?`_${e.name}`:"";return`${e.hash}_${e.dataType}${t}`}function Ox(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${lt(r)}`;const t=wx(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=wx(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),Ix(t.getPointData(),i.pointData),Ix(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=Sx(t,s,r);return r.end(),l}}const Px=Ox(["points","polys","verts","lines","strips"]),Rx=Ox([]);function Mx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Sx;bx||yx?dx[e]={build:t,update:n}:delete dx[e]}const Ex={vtkMapper:["vtkOpenGLPolyDataMapper","vtkCompositePolyDataMapper2","vtkDataSetMapper"],vtkProperty:["vtkOpenGLProperty"],vtkRenderer:["vtkOpenGLRenderer"],vtkCamera:["vtkOpenGLCamera"],vtkColorTransferFunction:["vtkPVDiscretizableColorTransferFunction"],vtkActor:["vtkOpenGLActor","vtkPVLODActor"],vtkLight:["vtkOpenGLLight","vtkPVLight"],vtkTexture:["vtkOpenGLTexture"],vtkImageMapper:["vtkOpenGLImageSliceMapper"],vtkVolumeMapper:["vtkFixedPointVolumeRayCastMapper"]},Vx={vtkAxesActor:{build:tx.newInstance,update:Sx},vtkRenderWindow:{build:km.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(Cx).filter((e=>"removeRenderer"===e[0])).forEach((e=>{vx(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),Sx(e,t,n),ux(e,t,n)}},vtkRenderer:{build:Lm.newInstance,update:function(e,t,n){Sx(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=Tx(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(Cx).filter((e=>"removeViewProp"===e[0])).forEach((e=>{vx(e[1]).forEach((e=>{const t=n.getInstance(e).get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:ul.newInstance,update:Sx},vtkCamera:{build:bm.newInstance,update:Ax},vtkPolyData:{build:Uc.newInstance,update:Px},vtkImageData:{build:Ks.newInstance,update:Rx},vtkMapper:{build:Fl.newInstance,update:Sx},vtkGlyph3DMapper:{build:tb.newInstance,update:Sx},vtkProperty:{build:ts.newInstance,update:Sx},vtkActor:{build:os.newInstance,update:Sx},vtkLight:{build:Sm.newInstance,update:Sx},vtkColorTransferFunction:{build:qy.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Hc.newInstance,update:Sx},vtkVolume:{build:mb.newInstance,update:Sx},vtkVolumeMapper:{build:bb.newInstance,update:Sx},vtkVolumeProperty:{build:pb.newInstance,update:Sx},vtkImageSlice:{build:Ob.newInstance,update:Sx},vtkImageMapper:{build:Nb.newInstance,update:Sx},vtkImageProperty:{build:Ab.newInstance,update:Sx},vtkPiecewiseFunction:{build:ab.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:su.newInstance,update:Sx},vtkScalarBarActor:{build:Nd.newInstance,update:Sx}};function Dx(){(!(arguments.length>0&&void 0!==arguments[0])||arguments[0])&&xx(),Object.keys(Vx).forEach((e=>{const t=Vx[e];Mx(e,t.build,t.update)}))}function Lx(){Object.keys(Ex).forEach((e=>{Ex[e].forEach((t=>{dx[t]=dx[e]}))}))}Dx(),Lx(),mx.vtkPVLight={};var Bx={build:bx,update:yx,genericUpdater:Sx,oneTimeGenericUpdater:Ax,setTypeMapping:Mx,clearTypeMapping:xx,getSupportedTypes:function(){return Object.keys(dx)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return void Object.keys(fx).forEach((e=>{delete fx[e]}));let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete fx[e]})),r},updateRenderWindow:function(e,t,n){return yx("vtkRenderWindow",e,t,n)},excludeInstance:function(e,t,n){mx[e]={key:t,value:n}},setDefaultMapping:Dx,applyDefaultAliases:Lx,alwaysUpdateCamera:function(){Mx("vtkCamera",bm.newInstance),Lx()}};const Nx={};function Fx(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if("string"==typeof t&&(i=vg.toArrayBuffer(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=it(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=it(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log("Error getting data array:"),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use "setArrayFetcher" to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function _x(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function Gx(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Mt(t,n,"progressEvent"),Mt(t,n,"progressDone"),t}function kx(){const e={};let t="default";return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function Ux(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"default",t=Nx[e];return t||(t={...Fx(),..._x(),...Gx(),...kx()},Nx[e]=t),t}function zx(e,t){let n=-1,r=100;const o=e=>e.get("managedInstanceId").managedInstanceId,a=()=>Lt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get("synchronizedViewId").synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),Bx.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){Bx.clearOneTimeUpdaters(a())}}}const Wx={synchronizerContextName:"default",synchronizerContext:null,synchronizedViewId:null};function Hx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wx,n),km.extend(e,t),yt(e,t,["synchronizerContext"]),function(e,t){t.classHierarchy.push("vtkSynchronizableRenderWindow"),t.synchronizerContext||(t.synchronizerContext=Ux(t.synchronizerContextName));const n=zx(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}(e,t)}var jx={newInstance:Et(Hx,"vtkSynchronizableRenderWindow"),extend:Hx,getSynchronizerContext:Ux,setSynchronizerContext:function(e,t){Nx[e]=t},clearSynchronizerContext:function(e){if(e&&Nx[e]&&delete Nx[e],!e){const e=Object.keys(Nx);for(let t=0;t<e.length;t++)delete Nx[e[t]]}},decorate:function(e){const t=zx(e,Ux(arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default"));return{...t,...e,delete:Vt(e.delete,t.delete)}},createInstanceMap:_x,createArrayHandler:Fx,createProgressHandler:Gx,createSceneMtimeHandler:kx,vtkObjectManager:Bx};const{vtkErrorMacro:Kx,vtkDebugMacro:$x}=Ht;let qx=0;function Xx(e){const t=document.querySelector(`.webResource[data-url="${e}"]`);return t?t.innerHTML:null}function Yx(e){return"/"===e[0]?e.substr(1):e}const Zx={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=Xx(Yx(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=Xx(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=Yx([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/")),s=Xx(i);if(null===s)a(new Error(`No such array ${i}`));else{if("string"===n.dataType){let e=atob(s);r.compression&&(e=om(tm(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(vg.toArrayBuffer(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=om(tm(new Uint8Array(n.buffer))):n.buffer=tm(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(um!==n.ref.encode&&um&&($x(`Swap bytes of ${n.name}`),dm(n.buffer,as[n.dataType])),n.values=Ht.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&Kx(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--qx&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url="${e}"]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};yg("html",(e=>Zx));const{vtkErrorMacro:Qx,vtkDebugMacro:Jx}=Ht;function eC(e){return function(e){return"/"===e[0]?e.substr(1):e}(function(e){return new URL(e,"http://any").pathname}(e))}const tC=function(e){let t=!1,n=0,r=null,o="";var a;return(a=e.zipContent,new Promise(((e,t)=>{"string"==typeof a?e(function(e,t){if(t){for(var n=new xg(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(nm)return nm.encode(e);var o=e.length,a=new xg(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new xg(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return Hg(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error("Invalid datatype to unpack."))}))).then((n=>{r=lm(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith("index.json")&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\.json$/,""),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||Qx("ERROR!!! zip not ready...");const u=eC([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join("/"));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if("string"!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&("string"===e.dataType||"JSON"===e.dataType?e.buffer=om(tm(new Uint8Array(e.buffer))):e.buffer=tm(new Uint8Array(e.buffer)).buffer),"JSON"===e.ref.encode?e.values=JSON.parse(e.buffer):(um!==e.ref.encode&&um&&(Jx(`Swap bytes of ${e.name}`),dm(e.buffer,as[e.dataType])),e.values=Ht.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&Qx(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(om(tm(r))):JSON.parse(r),n()}}(i,s.compression,d);e(om(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=eC(n);t||Qx("ERROR!!! zip not ready...");const s=r[`${o}${i}`];if(a.compression){if("gz"===a.compression){const e=om(tm(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error("Invalid compression"))}return Promise.resolve(JSON.parse(om(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=eC(n);t||Qx("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(om(lm(s))):Promise.reject(new Error("Invalid compression")):Promise.resolve(om(s))},fetchImage(e,n){const a=eC(n);t||Qx("ERROR!!! zip not ready...");const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=hg(i.buffer);n.src=`data:image/${function(e){const t=e.split(".").pop().toLowerCase();return"jpg"===t?"jpeg":t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=eC(n);t||Qx("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(tm(s).buffer):Promise.reject(new Error("Invalid compression")):Promise.resolve(s.buffer)}}};yg("zip",(e=>tC(e)));var nC=n(911),rC=n.n(nC),oC=n(893),aC=n.n(oC),iC=n(383),sC=n.n(iC),lC=n(884),cC=n.n(lC),uC=n(88),dC=n.n(uC),pC=n(997),fC=n.n(pC),gC=n(96),mC={};mC.styleTagTransform=fC(),mC.setAttributes=cC(),mC.insert=sC().bind(null,"head"),mC.domAPI=aC(),mC.insertStyleElement=dC(),rC()(gC.A,mC);var hC=gC.A&&gC.A.locals?gC.A.locals:void 0;let vC=!0;function TC(e){e.preventDefault(),e.stopPropagation()}function yC(e,t){vC=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=By.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:"100%",width:"100%",position:"absolute"}}).getRenderWindow(),o=jx.getSynchronizerContext(),a=jx.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement("div");n.setAttribute("class",hC.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=Ht.formatBytesToProperUnit(e.loaded)};t.fileURL?hm.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=bg.get("zip",{zipContent:t,callback:e=>{r.fetchJSON(null,"index.json").then(i)}})})):hm.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=bg.get("zip",{zipContent:t.file,callback:t=>{e.fetchJSON(null,"index.json").then(i)}})}else if(t.base64Str){const e=vg.toArrayBuffer(t.base64Str),n=bg.get("zip",{zipContent:e,callback:e=>{n.fetchJSON(null,"index.json").then(i)}})}}function bC(e){vC=!1;const t=document.querySelector(".content"),n=document.querySelector("body"),r=e||t||n;r!==e?(r.classList.add(hC.fullScreen),n.style.margin="0",n.style.padding="0"):(n.style.margin="0",n.style.padding="0");const o=document.createElement("div");o.innerHTML=`<div class="${hC.bigFileDrop}"/><input type="file" accept=".zip,.vtksz" style="display: none;"/>`,r.appendChild(o);const a=o.querySelector("input");function i(e){TC(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(".").slice(-1)[0];yC(r,{file:n[0],ext:e})}}a.addEventListener("change",i),o.addEventListener("drop",i),o.addEventListener("click",(e=>a.click())),o.addEventListener("dragover",TC)}const xC=xh();if(xC.url||xC.fileURL){const e=document.querySelector(".content"),t=document.querySelector("body"),n=e||t;n&&(n.classList.add(hC.fullScreen),t.style.margin="0",t.style.padding="0"),vC=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>yC(n,xC)))}setTimeout((()=>{vC&&bC()}),100),window.OfflineLocalView={initLocalFileLoader:bC,load:yC}},613:function(e){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,o,a){"string"==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=a),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),o&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=o):u[4]="".concat(o)),t.push(u))}},t}},336:function(e){"use strict";e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e):e}},20:function(e){"use strict";e.exports=function(e){return e[1]}},555:function(e,t,n){"use strict";var r=n(382),o="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,"x",{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||"function"==typeof(o=r)&&"[object Function]"===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},77:function(e,t,n){"use strict";e.exports=function(){if("object"==typeof globalThis)return globalThis;var e;try{e=this||new Function("return this")()}catch(e){if("object"==typeof window)return window;if("object"==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},730:function(e){"use strict";e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},979:function(e){"use strict";"undefined"!=typeof self?e.exports=self:"undefined"!=typeof window?e.exports=window:e.exports=Function("return this")()},59:function(e,t,n){"use strict";var r=n(555),o=n(979),a=n(920),i=n(482),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},920:function(e,t,n){"use strict";var r=n(979);e.exports=function(){return"object"==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},482:function(e,t,n){"use strict";var r=n(555),o=n(920);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,"globalThis");t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,"globalThis",{configurable:!0,enumerable:!1,value:e,writable:!0})}else"object"==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},982:function(e,t,n){"use strict";var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(642),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},"toString"),c=s.call((function(){}),"prototype"),u=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!p["$"+e]&&o.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&"object"==typeof e,n="[object Function]"===a.call(e),r=i(e),s=t&&"[object String]"===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError("Object.keys called on a non-object");var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&"prototype"===v||!o.call(e,v)||p.push(String(v));if(l)for(var T=function(e){if("undefined"==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),y=0;y<u.length;++y)T&&"constructor"===u[y]||!o.call(e,u[y])||p.push(u[y]);return p}}e.exports=r},382:function(e,t,n){"use strict";var r=Array.prototype.slice,o=n(642),a=Object.keys,i=a?function(e){return a(e)}:n(982),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},642:function(e){"use strict";var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r="[object Arguments]"===n;return r||(r="[object Array]"!==n&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Function]"===t.call(e.callee)),r}},318:function(e,t,n){var r=n(767),o=n(698),a=n(744),i=n(402),s=n(576),l=n(886),c=n(262);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},767:function(e,t,n){var r;!function(e,o){function a(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new a(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.alea=s}(0,e=n.nmd(e),n.amdD)},886:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.tychei=s}(0,e=n.nmd(e),n.amdD)},698:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xor128=s}(0,e=n.nmd(e),n.amdD)},576:function(e,t,n){var r;!function(e,o){function a(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xor4096=s}(0,e=n.nmd(e),n.amdD)},402:function(e,t,n){var r;!function(e,o){function a(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xorshift7=s}(0,e=n.nmd(e),n.amdD)},744:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xorwow=s}(0,e=n.nmd(e),n.amdD)},262:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,T(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),T(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,T(a)]}}():e,3),r),f=new g(r),y=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return y.int32=function(){return 0|f.g(4)},y.quick=function(){return f.g(4)/4294967296},y.double=y,v(T(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(y,p,"global"in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&"object"==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:"string"==o?e:e+"\0"}function v(e,t){for(var n,r=e+"",o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return T(t)}function T(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(1)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},292:function(e){e.exports=function(){"use strict";var e=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];function t(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function n(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function o(e){var r,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(r=64;r<=c;r+=64)t(u,n(e.substring(r-64,r)));for(o=(e=e.substring(r-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],r=0;r<o;r+=1)a[r>>2]|=e.charCodeAt(r)<<(r%4<<3);if(a[r>>2]|=128<<(r%4<<3),r>55)for(t(u,a),r=0;r<16;r+=1)a[r]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,t(u,a),u}function a(t){var n,r="";for(n=0;n<4;n+=1)r+=e[t>>8*n+4&15]+e[t>>8*n&15];return r}function i(e){var t;for(t=0;t<e.length;t+=1)e[t]=a(e[t]);return e.join("")}function s(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function l(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function c(){this.reset()}return i(o("hello")),"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),c.prototype.append=function(e){return this.appendBinary(s(e)),this},c.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var r,o=this._buff.length;for(r=64;r<=o;r+=64)t(this._hash,n(this._buff.substring(r-64,r)));return this._buff=this._buff.substring(r-64),this},c.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=i(this._hash),e&&(n=l(n)),this.reset(),n},c.prototype.reset=function(){return this._buff="",this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},c.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},c.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},c.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},c.prototype._finish=function(e,n){var r,o,a,i=n;if(e[i>>2]|=128<<(i%4<<3),i>55)for(t(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,t(this._hash,e)},c.hash=function(e,t){return c.hashBinary(s(e),t)},c.hashBinary=function(e,t){var n=i(o(e));return t?l(n):n},c.ArrayBuffer=function(){this.reset()},c.ArrayBuffer.prototype.append=function(e){var n,o,a,i,s,l=(o=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(o.byteLength+a.byteLength)).set(new Uint8Array(o)),s.set(new Uint8Array(a),o.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,n=64;n<=c;n+=64)t(this._hash,r(l.subarray(n-64,n)));return this._buff=n-64<c?new Uint8Array(l.buffer.slice(n-64)):new Uint8Array(0),this},c.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=i(this._hash),e&&(n=l(n)),this.reset(),n},c.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},c.ArrayBuffer.prototype.getState=function(){var e,t=c.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},c.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),c.prototype.setState.call(this,e)},c.ArrayBuffer.prototype.destroy=c.prototype.destroy,c.ArrayBuffer.prototype._finish=c.prototype._finish,c.ArrayBuffer.hash=function(e,n){var o=i(function(e){var n,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(n=64;n<=c;n+=64)t(u,r(e.subarray(n-64,n)));for(o=(e=n-64<c?e.subarray(n-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],n=0;n<o;n+=1)a[n>>2]|=e[n]<<(n%4<<3);if(a[n>>2]|=128<<(n%4<<3),n>55)for(t(u,a),n=0;n<16;n+=1)a[n]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,t(u,a),u}(new Uint8Array(e)));return n?l(o):o},c}()},96:function(e,t,n){"use strict";var r=n(20),o=n.n(r),a=n(613),i=n.n(a),s=n(336),l=n.n(s),c=new URL(n(183),n.b),u=i()(o()),d=l()(c);u.push([e.id,".viewer-module-fullScreen_bbk9Y {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  background: black;\n  margin: 0;\n  padding: 0;\n  z-index: -1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.viewer-module-fullParentSize_ETopO {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.viewer-module-bigFileDrop_aqCgh {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  background-image: url("+d+");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n  border-radius: 10px;\n  width: 50px;\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\n  cursor: pointer;\n}\n\n.viewer-module-progress_cYjQJ {\n  flex: none;\n  font-size: 50px;\n  color: black;\n  z-index: 1;\n  background: rgba(128,128,128,.5);\n  padding: 20px;\n  border-radius: 10px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n\nbody {\n  margin: 0;\n}\n\nhtml { \n  overflow: hidden; \n}\n",""]),u.locals={fullScreen:"viewer-module-fullScreen_bbk9Y",fullParentSize:"viewer-module-fullParentSize_ETopO",bigFileDrop:"viewer-module-bigFileDrop_aqCgh",progress:"viewer-module-progress_cYjQJ"},t.A=u},50:function(e,t,n){var r=n(975),o=n(77);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},911:function(e){"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d="".concat(c," ").concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},383:function(e){"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},88:function(e){"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},884:function(e,t,n){"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},893:function(e){"use strict";e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var o=void 0!==n.layer;o&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,o&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var a=n.sourceMap;a&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},997:function(e){"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},183:function(e,t,n){"use strict";e.exports=n.p+"138e7b1469f64156810a.jpg"},1:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p="",n.b=document.baseURI||self.location.href,n.nc=void 0,n(50)}();
</script>
<script>
var container = document.querySelector('.content');
var base64Str = "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";

OfflineLocalView.load(container, { base64Str });
</script>
</body>
</html>
