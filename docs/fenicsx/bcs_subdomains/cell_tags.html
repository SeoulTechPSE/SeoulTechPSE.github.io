<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8"/>
    <meta name="viewport" content="width=device-width, height=device-height, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no">
  </head>
  <body>
    <div class="content"></div>
<script type="text/javascript">
!function(){var e={346:function(){const e=document.querySelector("head");e&&[16,32,96,160,196].forEach((t=>{const n=document.createElement("link");n.setAttribute("rel","icon"),n.setAttribute("href",`https://kitware.github.io/vtk-js/icon/favicon-${t}x${t}.png`),n.setAttribute("sizes",`${t}x${t}`),n.setAttribute("type","image/png"),e.appendChild(n)}))},975:function(e,t,n){"use strict";n.r(t),n.d(t,{initLocalFileLoader:function(){return bC},load:function(){return yC}});var r={};n.r(r),n.d(r,{add:function(){return Q},adjoint:function(){return v},clone:function(){return u},copy:function(){return d},create:function(){return c},determinant:function(){return T},equals:function(){return re},exactEquals:function(){return ne},frob:function(){return Z},fromQuat:function(){return G},fromQuat2:function(){return D},fromRotation:function(){return P},fromRotationTranslation:function(){return V},fromRotationTranslationScale:function(){return F},fromRotationTranslationScaleOrigin:function(){return _},fromScaling:function(){return O},fromTranslation:function(){return w},fromValues:function(){return p},fromXRotation:function(){return R},fromYRotation:function(){return M},fromZRotation:function(){return E},frustum:function(){return k},getRotation:function(){return N},getScaling:function(){return B},getTranslation:function(){return L},identity:function(){return g},invert:function(){return h},lookAt:function(){return q},mul:function(){return oe},multiply:function(){return y},multiplyScalar:function(){return ee},multiplyScalarAndAdd:function(){return te},ortho:function(){return K},orthoNO:function(){return j},orthoZO:function(){return $},perspective:function(){return z},perspectiveFromFieldOfView:function(){return H},perspectiveNO:function(){return U},perspectiveZO:function(){return W},rotate:function(){return C},rotateX:function(){return S},rotateY:function(){return A},rotateZ:function(){return I},scale:function(){return x},set:function(){return f},str:function(){return Y},sub:function(){return ae},subtract:function(){return J},targetTo:function(){return X},translate:function(){return b},transpose:function(){return m}});var o={};n.r(o),n.d(o,{add:function(){return Me},adjoint:function(){return me},clone:function(){return le},copy:function(){return ce},create:function(){return ie},determinant:function(){return he},equals:function(){return Be},exactEquals:function(){return Le},frob:function(){return Re},fromMat2d:function(){return Ae},fromMat4:function(){return se},fromQuat:function(){return Ie},fromRotation:function(){return Ce},fromScaling:function(){return Se},fromTranslation:function(){return xe},fromValues:function(){return ue},identity:function(){return pe},invert:function(){return ge},mul:function(){return Ne},multiply:function(){return ve},multiplyScalar:function(){return Ve},multiplyScalarAndAdd:function(){return De},normalFromMat4:function(){return we},projection:function(){return Oe},rotate:function(){return ye},scale:function(){return be},set:function(){return de},str:function(){return Pe},sub:function(){return Fe},subtract:function(){return Ee},translate:function(){return Te},transpose:function(){return fe}}),n(346);var a=1e-6,i="undefined"!=typeof Float32Array?Float32Array:Array;Math.random;var s=Math.PI/180;function l(e){return e*s}function c(){var e=new i(16);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=0,e[12]=0,e[13]=0,e[14]=0),e[0]=1,e[5]=1,e[10]=1,e[15]=1,e}function u(e){var t=new i(16);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t[9]=e[9],t[10]=e[10],t[11]=e[11],t[12]=e[12],t[13]=e[13],t[14]=e[14],t[15]=e[15],t}function d(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function p(e,t,n,r,o,a,s,l,c,u,d,p,f,g,m,h){var v=new i(16);return v[0]=e,v[1]=t,v[2]=n,v[3]=r,v[4]=o,v[5]=a,v[6]=s,v[7]=l,v[8]=c,v[9]=u,v[10]=d,v[11]=p,v[12]=f,v[13]=g,v[14]=m,v[15]=h,v}function f(e,t,n,r,o,a,i,s,l,c,u,d,p,f,g,m,h){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e[9]=u,e[10]=d,e[11]=p,e[12]=f,e[13]=g,e[14]=m,e[15]=h,e}function g(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function m(e,t){if(e===t){var n=t[1],r=t[2],o=t[3],a=t[6],i=t[7],s=t[11];e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=n,e[6]=t[9],e[7]=t[13],e[8]=r,e[9]=a,e[11]=t[14],e[12]=o,e[13]=i,e[14]=s}else e[0]=t[0],e[1]=t[4],e[2]=t[8],e[3]=t[12],e[4]=t[1],e[5]=t[5],e[6]=t[9],e[7]=t[13],e[8]=t[2],e[9]=t[6],e[10]=t[10],e[11]=t[14],e[12]=t[3],e[13]=t[7],e[14]=t[11],e[15]=t[15];return e}function h(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],T=n*s-r*i,y=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,O=d*h-p*m,P=d*v-f*m,R=p*v-f*h,M=T*R-y*P+b*O+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*P+c*O)*M,e[1]=(o*P-r*R-a*O)*M,e[2]=(m*S-h*C+v*x)*M,e[3]=(p*C-d*S-f*x)*M,e[4]=(l*w-i*R-c*I)*M,e[5]=(n*R-o*w+a*I)*M,e[6]=(h*b-g*S-v*y)*M,e[7]=(u*S-p*b+f*y)*M,e[8]=(i*P-s*w+c*A)*M,e[9]=(r*w-n*P-a*A)*M,e[10]=(g*C-m*b+v*T)*M,e[11]=(d*b-u*C-f*T)*M,e[12]=(s*I-i*O-l*A)*M,e[13]=(n*O-r*I+o*A)*M,e[14]=(m*y-g*x-h*T)*M,e[15]=(u*x-d*y+p*T)*M,e):null}function v(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15];return e[0]=s*(p*v-f*h)-d*(l*v-c*h)+m*(l*f-c*p),e[1]=-(r*(p*v-f*h)-d*(o*v-a*h)+m*(o*f-a*p)),e[2]=r*(l*v-c*h)-s*(o*v-a*h)+m*(o*c-a*l),e[3]=-(r*(l*f-c*p)-s*(o*f-a*p)+d*(o*c-a*l)),e[4]=-(i*(p*v-f*h)-u*(l*v-c*h)+g*(l*f-c*p)),e[5]=n*(p*v-f*h)-u*(o*v-a*h)+g*(o*f-a*p),e[6]=-(n*(l*v-c*h)-i*(o*v-a*h)+g*(o*c-a*l)),e[7]=n*(l*f-c*p)-i*(o*f-a*p)+u*(o*c-a*l),e[8]=i*(d*v-f*m)-u*(s*v-c*m)+g*(s*f-c*d),e[9]=-(n*(d*v-f*m)-u*(r*v-a*m)+g*(r*f-a*d)),e[10]=n*(s*v-c*m)-i*(r*v-a*m)+g*(r*c-a*s),e[11]=-(n*(s*f-c*d)-i*(r*f-a*d)+u*(r*c-a*s)),e[12]=-(i*(d*h-p*m)-u*(s*h-l*m)+g*(s*p-l*d)),e[13]=n*(d*h-p*m)-u*(r*h-o*m)+g*(r*p-o*d),e[14]=-(n*(s*h-l*m)-i*(r*h-o*m)+g*(r*l-o*s)),e[15]=n*(s*p-l*d)-i*(r*p-o*d)+u*(r*l-o*s),e}function T(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8],u=e[9],d=e[10],p=e[11],f=e[12],g=e[13],m=e[14],h=e[15];return(t*i-n*a)*(d*h-p*m)-(t*s-r*a)*(u*h-p*g)+(t*l-o*a)*(u*m-d*g)+(n*s-r*i)*(c*h-p*f)-(n*l-o*i)*(c*m-d*f)+(r*l-o*s)*(c*g-u*f)}function y(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],m=t[12],h=t[13],v=t[14],T=t[15],y=n[0],b=n[1],x=n[2],C=n[3];return e[0]=y*r+b*s+x*d+C*m,e[1]=y*o+b*l+x*p+C*h,e[2]=y*a+b*c+x*f+C*v,e[3]=y*i+b*u+x*g+C*T,y=n[4],b=n[5],x=n[6],C=n[7],e[4]=y*r+b*s+x*d+C*m,e[5]=y*o+b*l+x*p+C*h,e[6]=y*a+b*c+x*f+C*v,e[7]=y*i+b*u+x*g+C*T,y=n[8],b=n[9],x=n[10],C=n[11],e[8]=y*r+b*s+x*d+C*m,e[9]=y*o+b*l+x*p+C*h,e[10]=y*a+b*c+x*f+C*v,e[11]=y*i+b*u+x*g+C*T,y=n[12],b=n[13],x=n[14],C=n[15],e[12]=y*r+b*s+x*d+C*m,e[13]=y*o+b*l+x*p+C*h,e[14]=y*a+b*c+x*f+C*v,e[15]=y*i+b*u+x*g+C*T,e}function b(e,t,n){var r,o,a,i,s,l,c,u,d,p,f,g,m=n[0],h=n[1],v=n[2];return t===e?(e[12]=t[0]*m+t[4]*h+t[8]*v+t[12],e[13]=t[1]*m+t[5]*h+t[9]*v+t[13],e[14]=t[2]*m+t[6]*h+t[10]*v+t[14],e[15]=t[3]*m+t[7]*h+t[11]*v+t[15]):(r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=t[9],f=t[10],g=t[11],e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=c,e[7]=u,e[8]=d,e[9]=p,e[10]=f,e[11]=g,e[12]=r*m+s*h+d*v+t[12],e[13]=o*m+l*h+p*v+t[13],e[14]=a*m+c*h+f*v+t[14],e[15]=i*m+u*h+g*v+t[15]),e}function x(e,t,n){var r=n[0],o=n[1],a=n[2];return e[0]=t[0]*r,e[1]=t[1]*r,e[2]=t[2]*r,e[3]=t[3]*r,e[4]=t[4]*o,e[5]=t[5]*o,e[6]=t[6]*o,e[7]=t[7]*o,e[8]=t[8]*a,e[9]=t[9]*a,e[10]=t[10]*a,e[11]=t[11]*a,e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15],e}function C(e,t,n,r){var o,i,s,l,c,u,d,p,f,g,m,h,v,T,y,b,x,C,S,A,I,w,O,P,R=r[0],M=r[1],E=r[2],V=Math.hypot(R,M,E);return V<a?null:(R*=V=1/V,M*=V,E*=V,o=Math.sin(n),s=1-(i=Math.cos(n)),l=t[0],c=t[1],u=t[2],d=t[3],p=t[4],f=t[5],g=t[6],m=t[7],h=t[8],v=t[9],T=t[10],y=t[11],b=R*R*s+i,x=M*R*s+E*o,C=E*R*s-M*o,S=R*M*s-E*o,A=M*M*s+i,I=E*M*s+R*o,w=R*E*s+M*o,O=M*E*s-R*o,P=E*E*s+i,e[0]=l*b+p*x+h*C,e[1]=c*b+f*x+v*C,e[2]=u*b+g*x+T*C,e[3]=d*b+m*x+y*C,e[4]=l*S+p*A+h*I,e[5]=c*S+f*A+v*I,e[6]=u*S+g*A+T*I,e[7]=d*S+m*A+y*I,e[8]=l*w+p*O+h*P,e[9]=c*w+f*O+v*P,e[10]=u*w+g*O+T*P,e[11]=d*w+m*O+y*P,t!==e&&(e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e)}function S(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[4],i=t[5],s=t[6],l=t[7],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[4]=a*o+c*r,e[5]=i*o+u*r,e[6]=s*o+d*r,e[7]=l*o+p*r,e[8]=c*o-a*r,e[9]=u*o-i*r,e[10]=d*o-s*r,e[11]=p*o-l*r,e}function A(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[8],u=t[9],d=t[10],p=t[11];return t!==e&&(e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o-c*r,e[1]=i*o-u*r,e[2]=s*o-d*r,e[3]=l*o-p*r,e[8]=a*r+c*o,e[9]=i*r+u*o,e[10]=s*r+d*o,e[11]=l*r+p*o,e}function I(e,t,n){var r=Math.sin(n),o=Math.cos(n),a=t[0],i=t[1],s=t[2],l=t[3],c=t[4],u=t[5],d=t[6],p=t[7];return t!==e&&(e[8]=t[8],e[9]=t[9],e[10]=t[10],e[11]=t[11],e[12]=t[12],e[13]=t[13],e[14]=t[14],e[15]=t[15]),e[0]=a*o+c*r,e[1]=i*o+u*r,e[2]=s*o+d*r,e[3]=l*o+p*r,e[4]=c*o-a*r,e[5]=u*o-i*r,e[6]=d*o-s*r,e[7]=p*o-l*r,e}function w(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=t[0],e[13]=t[1],e[14]=t[2],e[15]=1,e}function O(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=t[1],e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=t[2],e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function P(e,t,n){var r,o,i,s=n[0],l=n[1],c=n[2],u=Math.hypot(s,l,c);return u<a?null:(s*=u=1/u,l*=u,c*=u,r=Math.sin(t),i=1-(o=Math.cos(t)),e[0]=s*s*i+o,e[1]=l*s*i+c*r,e[2]=c*s*i-l*r,e[3]=0,e[4]=s*l*i-c*r,e[5]=l*l*i+o,e[6]=c*l*i+s*r,e[7]=0,e[8]=s*c*i+l*r,e[9]=l*c*i-s*r,e[10]=c*c*i+o,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e)}function R(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=r,e[6]=n,e[7]=0,e[8]=0,e[9]=-n,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function M(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=0,e[2]=-n,e[3]=0,e[4]=0,e[5]=1,e[6]=0,e[7]=0,e[8]=n,e[9]=0,e[10]=r,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function E(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=0,e[4]=-n,e[5]=r,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=1,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function V(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=r+r,l=o+o,c=a+a,u=r*s,d=r*l,p=r*c,f=o*l,g=o*c,m=a*c,h=i*s,v=i*l,T=i*c;return e[0]=1-(f+m),e[1]=d+T,e[2]=p-v,e[3]=0,e[4]=d-T,e[5]=1-(u+m),e[6]=g+h,e[7]=0,e[8]=p+v,e[9]=g-h,e[10]=1-(u+f),e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function D(e,t){var n=new i(3),r=-t[0],o=-t[1],a=-t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=r*r+o*o+a*a+s*s;return p>0?(n[0]=2*(l*s+d*r+c*a-u*o)/p,n[1]=2*(c*s+d*o+u*r-l*a)/p,n[2]=2*(u*s+d*a+l*o-c*r)/p):(n[0]=2*(l*s+d*r+c*a-u*o),n[1]=2*(c*s+d*o+u*r-l*a),n[2]=2*(u*s+d*a+l*o-c*r)),V(e,t,n),e}function L(e,t){return e[0]=t[12],e[1]=t[13],e[2]=t[14],e}function B(e,t){var n=t[0],r=t[1],o=t[2],a=t[4],i=t[5],s=t[6],l=t[8],c=t[9],u=t[10];return e[0]=Math.hypot(n,r,o),e[1]=Math.hypot(a,i,s),e[2]=Math.hypot(l,c,u),e}function N(e,t){var n=new i(3);B(n,t);var r=1/n[0],o=1/n[1],a=1/n[2],s=t[0]*r,l=t[1]*o,c=t[2]*a,u=t[4]*r,d=t[5]*o,p=t[6]*a,f=t[8]*r,g=t[9]*o,m=t[10]*a,h=s+d+m,v=0;return h>0?(v=2*Math.sqrt(h+1),e[3]=.25*v,e[0]=(p-g)/v,e[1]=(f-c)/v,e[2]=(l-u)/v):s>d&&s>m?(v=2*Math.sqrt(1+s-d-m),e[3]=(p-g)/v,e[0]=.25*v,e[1]=(l+u)/v,e[2]=(f+c)/v):d>m?(v=2*Math.sqrt(1+d-s-m),e[3]=(f-c)/v,e[0]=(l+u)/v,e[1]=.25*v,e[2]=(p+g)/v):(v=2*Math.sqrt(1+m-s-d),e[3]=(l-u)/v,e[0]=(f+c)/v,e[1]=(p+g)/v,e[2]=.25*v),e}function F(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=t[3],l=o+o,c=a+a,u=i+i,d=o*l,p=o*c,f=o*u,g=a*c,m=a*u,h=i*u,v=s*l,T=s*c,y=s*u,b=r[0],x=r[1],C=r[2];return e[0]=(1-(g+h))*b,e[1]=(p+y)*b,e[2]=(f-T)*b,e[3]=0,e[4]=(p-y)*x,e[5]=(1-(d+h))*x,e[6]=(m+v)*x,e[7]=0,e[8]=(f+T)*C,e[9]=(m-v)*C,e[10]=(1-(d+g))*C,e[11]=0,e[12]=n[0],e[13]=n[1],e[14]=n[2],e[15]=1,e}function _(e,t,n,r,o){var a=t[0],i=t[1],s=t[2],l=t[3],c=a+a,u=i+i,d=s+s,p=a*c,f=a*u,g=a*d,m=i*u,h=i*d,v=s*d,T=l*c,y=l*u,b=l*d,x=r[0],C=r[1],S=r[2],A=o[0],I=o[1],w=o[2],O=(1-(m+v))*x,P=(f+b)*x,R=(g-y)*x,M=(f-b)*C,E=(1-(p+v))*C,V=(h+T)*C,D=(g+y)*S,L=(h-T)*S,B=(1-(p+m))*S;return e[0]=O,e[1]=P,e[2]=R,e[3]=0,e[4]=M,e[5]=E,e[6]=V,e[7]=0,e[8]=D,e[9]=L,e[10]=B,e[11]=0,e[12]=n[0]+A-(O*A+M*I+D*w),e[13]=n[1]+I-(P*A+E*I+L*w),e[14]=n[2]+w-(R*A+V*I+B*w),e[15]=1,e}function G(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[1]=u+v,e[2]=p-h,e[3]=0,e[4]=u-v,e[5]=1-c-g,e[6]=f+m,e[7]=0,e[8]=p+h,e[9]=f-m,e[10]=1-c-d,e[11]=0,e[12]=0,e[13]=0,e[14]=0,e[15]=1,e}function k(e,t,n,r,o,a,i){var s=1/(n-t),l=1/(o-r),c=1/(a-i);return e[0]=2*a*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=2*a*l,e[6]=0,e[7]=0,e[8]=(n+t)*s,e[9]=(o+r)*l,e[10]=(i+a)*c,e[11]=-1,e[12]=0,e[13]=0,e[14]=i*a*2*c,e[15]=0,e}function U(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=(o+r)*a,e[14]=2*o*r*a):(e[10]=-1,e[14]=-2*r),e}Math.hypot||(Math.hypot=function(){for(var e=0,t=arguments.length;t--;)e+=arguments[t]*arguments[t];return Math.sqrt(e)});var z=U;function W(e,t,n,r,o){var a,i=1/Math.tan(t/2);return e[0]=i/n,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=i,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[11]=-1,e[12]=0,e[13]=0,e[15]=0,null!=o&&o!==1/0?(a=1/(r-o),e[10]=o*a,e[14]=o*r*a):(e[10]=-1,e[14]=-r),e}function H(e,t,n,r){var o=Math.tan(t.upDegrees*Math.PI/180),a=Math.tan(t.downDegrees*Math.PI/180),i=Math.tan(t.leftDegrees*Math.PI/180),s=Math.tan(t.rightDegrees*Math.PI/180),l=2/(i+s),c=2/(o+a);return e[0]=l,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=c,e[6]=0,e[7]=0,e[8]=-(i-s)*l*.5,e[9]=(o-a)*c*.5,e[10]=r/(n-r),e[11]=-1,e[12]=0,e[13]=0,e[14]=r*n/(n-r),e[15]=0,e}function j(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=2*c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=(i+a)*c,e[15]=1,e}var K=j;function $(e,t,n,r,o,a,i){var s=1/(t-n),l=1/(r-o),c=1/(a-i);return e[0]=-2*s,e[1]=0,e[2]=0,e[3]=0,e[4]=0,e[5]=-2*l,e[6]=0,e[7]=0,e[8]=0,e[9]=0,e[10]=c,e[11]=0,e[12]=(t+n)*s,e[13]=(o+r)*l,e[14]=a*c,e[15]=1,e}function q(e,t,n,r){var o,i,s,l,c,u,d,p,f,m,h=t[0],v=t[1],T=t[2],y=r[0],b=r[1],x=r[2],C=n[0],S=n[1],A=n[2];return Math.abs(h-C)<a&&Math.abs(v-S)<a&&Math.abs(T-A)<a?g(e):(d=h-C,p=v-S,f=T-A,o=b*(f*=m=1/Math.hypot(d,p,f))-x*(p*=m),i=x*(d*=m)-y*f,s=y*p-b*d,(m=Math.hypot(o,i,s))?(o*=m=1/m,i*=m,s*=m):(o=0,i=0,s=0),l=p*s-f*i,c=f*o-d*s,u=d*i-p*o,(m=Math.hypot(l,c,u))?(l*=m=1/m,c*=m,u*=m):(l=0,c=0,u=0),e[0]=o,e[1]=l,e[2]=d,e[3]=0,e[4]=i,e[5]=c,e[6]=p,e[7]=0,e[8]=s,e[9]=u,e[10]=f,e[11]=0,e[12]=-(o*h+i*v+s*T),e[13]=-(l*h+c*v+u*T),e[14]=-(d*h+p*v+f*T),e[15]=1,e)}function X(e,t,n,r){var o=t[0],a=t[1],i=t[2],s=r[0],l=r[1],c=r[2],u=o-n[0],d=a-n[1],p=i-n[2],f=u*u+d*d+p*p;f>0&&(u*=f=1/Math.sqrt(f),d*=f,p*=f);var g=l*p-c*d,m=c*u-s*p,h=s*d-l*u;return(f=g*g+m*m+h*h)>0&&(g*=f=1/Math.sqrt(f),m*=f,h*=f),e[0]=g,e[1]=m,e[2]=h,e[3]=0,e[4]=d*h-p*m,e[5]=p*g-u*h,e[6]=u*m-d*g,e[7]=0,e[8]=u,e[9]=d,e[10]=p,e[11]=0,e[12]=o,e[13]=a,e[14]=i,e[15]=1,e}function Y(e){return"mat4("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+", "+e[9]+", "+e[10]+", "+e[11]+", "+e[12]+", "+e[13]+", "+e[14]+", "+e[15]+")"}function Z(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8],e[9],e[10],e[11],e[12],e[13],e[14],e[15])}function Q(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e[9]=t[9]+n[9],e[10]=t[10]+n[10],e[11]=t[11]+n[11],e[12]=t[12]+n[12],e[13]=t[13]+n[13],e[14]=t[14]+n[14],e[15]=t[15]+n[15],e}function J(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e[9]=t[9]-n[9],e[10]=t[10]-n[10],e[11]=t[11]-n[11],e[12]=t[12]-n[12],e[13]=t[13]-n[13],e[14]=t[14]-n[14],e[15]=t[15]-n[15],e}function ee(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e[9]=t[9]*n,e[10]=t[10]*n,e[11]=t[11]*n,e[12]=t[12]*n,e[13]=t[13]*n,e[14]=t[14]*n,e[15]=t[15]*n,e}function te(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e[9]=t[9]+n[9]*r,e[10]=t[10]+n[10]*r,e[11]=t[11]+n[11]*r,e[12]=t[12]+n[12]*r,e[13]=t[13]+n[13]*r,e[14]=t[14]+n[14]*r,e[15]=t[15]+n[15]*r,e}function ne(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]&&e[9]===t[9]&&e[10]===t[10]&&e[11]===t[11]&&e[12]===t[12]&&e[13]===t[13]&&e[14]===t[14]&&e[15]===t[15]}function re(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=e[9],f=e[10],g=e[11],m=e[12],h=e[13],v=e[14],T=e[15],y=t[0],b=t[1],x=t[2],C=t[3],S=t[4],A=t[5],I=t[6],w=t[7],O=t[8],P=t[9],R=t[10],M=t[11],E=t[12],V=t[13],D=t[14],L=t[15];return Math.abs(n-y)<=a*Math.max(1,Math.abs(n),Math.abs(y))&&Math.abs(r-b)<=a*Math.max(1,Math.abs(r),Math.abs(b))&&Math.abs(o-x)<=a*Math.max(1,Math.abs(o),Math.abs(x))&&Math.abs(i-C)<=a*Math.max(1,Math.abs(i),Math.abs(C))&&Math.abs(s-S)<=a*Math.max(1,Math.abs(s),Math.abs(S))&&Math.abs(l-A)<=a*Math.max(1,Math.abs(l),Math.abs(A))&&Math.abs(c-I)<=a*Math.max(1,Math.abs(c),Math.abs(I))&&Math.abs(u-w)<=a*Math.max(1,Math.abs(u),Math.abs(w))&&Math.abs(d-O)<=a*Math.max(1,Math.abs(d),Math.abs(O))&&Math.abs(p-P)<=a*Math.max(1,Math.abs(p),Math.abs(P))&&Math.abs(f-R)<=a*Math.max(1,Math.abs(f),Math.abs(R))&&Math.abs(g-M)<=a*Math.max(1,Math.abs(g),Math.abs(M))&&Math.abs(m-E)<=a*Math.max(1,Math.abs(m),Math.abs(E))&&Math.abs(h-V)<=a*Math.max(1,Math.abs(h),Math.abs(V))&&Math.abs(v-D)<=a*Math.max(1,Math.abs(v),Math.abs(D))&&Math.abs(T-L)<=a*Math.max(1,Math.abs(T),Math.abs(L))}var oe=y,ae=J;function ie(){var e=new i(9);return i!=Float32Array&&(e[1]=0,e[2]=0,e[3]=0,e[5]=0,e[6]=0,e[7]=0),e[0]=1,e[4]=1,e[8]=1,e}function se(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[4],e[4]=t[5],e[5]=t[6],e[6]=t[8],e[7]=t[9],e[8]=t[10],e}function le(e){var t=new i(9);return t[0]=e[0],t[1]=e[1],t[2]=e[2],t[3]=e[3],t[4]=e[4],t[5]=e[5],t[6]=e[6],t[7]=e[7],t[8]=e[8],t}function ce(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function ue(e,t,n,r,o,a,s,l,c){var u=new i(9);return u[0]=e,u[1]=t,u[2]=n,u[3]=r,u[4]=o,u[5]=a,u[6]=s,u[7]=l,u[8]=c,u}function de(e,t,n,r,o,a,i,s,l,c){return e[0]=t,e[1]=n,e[2]=r,e[3]=o,e[4]=a,e[5]=i,e[6]=s,e[7]=l,e[8]=c,e}function pe(e){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function fe(e,t){if(e===t){var n=t[1],r=t[2],o=t[5];e[1]=t[3],e[2]=t[6],e[3]=n,e[5]=t[7],e[6]=r,e[7]=o}else e[0]=t[0],e[1]=t[3],e[2]=t[6],e[3]=t[1],e[4]=t[4],e[5]=t[7],e[6]=t[2],e[7]=t[5],e[8]=t[8];return e}function ge(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=u*i-s*c,p=-u*a+s*l,f=c*a-i*l,g=n*d+r*p+o*f;return g?(g=1/g,e[0]=d*g,e[1]=(-u*r+o*c)*g,e[2]=(s*r-o*i)*g,e[3]=p*g,e[4]=(u*n-o*l)*g,e[5]=(-s*n+o*a)*g,e[6]=f*g,e[7]=(-c*n+r*l)*g,e[8]=(i*n-r*a)*g,e):null}function me(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8];return e[0]=i*u-s*c,e[1]=o*c-r*u,e[2]=r*s-o*i,e[3]=s*l-a*u,e[4]=n*u-o*l,e[5]=o*a-n*s,e[6]=a*c-i*l,e[7]=r*l-n*c,e[8]=n*i-r*a,e}function he(e){var t=e[0],n=e[1],r=e[2],o=e[3],a=e[4],i=e[5],s=e[6],l=e[7],c=e[8];return t*(c*a-i*l)+n*(-c*o+i*s)+r*(l*o-a*s)}function ve(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1],g=n[2],m=n[3],h=n[4],v=n[5],T=n[6],y=n[7],b=n[8];return e[0]=p*r+f*i+g*c,e[1]=p*o+f*s+g*u,e[2]=p*a+f*l+g*d,e[3]=m*r+h*i+v*c,e[4]=m*o+h*s+v*u,e[5]=m*a+h*l+v*d,e[6]=T*r+y*i+b*c,e[7]=T*o+y*s+b*u,e[8]=T*a+y*l+b*d,e}function Te(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=n[0],f=n[1];return e[0]=r,e[1]=o,e[2]=a,e[3]=i,e[4]=s,e[5]=l,e[6]=p*r+f*i+c,e[7]=p*o+f*s+u,e[8]=p*a+f*l+d,e}function ye(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=t[4],l=t[5],c=t[6],u=t[7],d=t[8],p=Math.sin(n),f=Math.cos(n);return e[0]=f*r+p*i,e[1]=f*o+p*s,e[2]=f*a+p*l,e[3]=f*i-p*r,e[4]=f*s-p*o,e[5]=f*l-p*a,e[6]=c,e[7]=u,e[8]=d,e}function be(e,t,n){var r=n[0],o=n[1];return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=o*t[3],e[4]=o*t[4],e[5]=o*t[5],e[6]=t[6],e[7]=t[7],e[8]=t[8],e}function xe(e,t){return e[0]=1,e[1]=0,e[2]=0,e[3]=0,e[4]=1,e[5]=0,e[6]=t[0],e[7]=t[1],e[8]=1,e}function Ce(e,t){var n=Math.sin(t),r=Math.cos(t);return e[0]=r,e[1]=n,e[2]=0,e[3]=-n,e[4]=r,e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Se(e,t){return e[0]=t[0],e[1]=0,e[2]=0,e[3]=0,e[4]=t[1],e[5]=0,e[6]=0,e[7]=0,e[8]=1,e}function Ae(e,t){return e[0]=t[0],e[1]=t[1],e[2]=0,e[3]=t[2],e[4]=t[3],e[5]=0,e[6]=t[4],e[7]=t[5],e[8]=1,e}function Ie(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=n+n,s=r+r,l=o+o,c=n*i,u=r*i,d=r*s,p=o*i,f=o*s,g=o*l,m=a*i,h=a*s,v=a*l;return e[0]=1-d-g,e[3]=u-v,e[6]=p+h,e[1]=u+v,e[4]=1-c-g,e[7]=f-m,e[2]=p-h,e[5]=f+m,e[8]=1-c-d,e}function we(e,t){var n=t[0],r=t[1],o=t[2],a=t[3],i=t[4],s=t[5],l=t[6],c=t[7],u=t[8],d=t[9],p=t[10],f=t[11],g=t[12],m=t[13],h=t[14],v=t[15],T=n*s-r*i,y=n*l-o*i,b=n*c-a*i,x=r*l-o*s,C=r*c-a*s,S=o*c-a*l,A=u*m-d*g,I=u*h-p*g,w=u*v-f*g,O=d*h-p*m,P=d*v-f*m,R=p*v-f*h,M=T*R-y*P+b*O+x*w-C*I+S*A;return M?(M=1/M,e[0]=(s*R-l*P+c*O)*M,e[1]=(l*w-i*R-c*I)*M,e[2]=(i*P-s*w+c*A)*M,e[3]=(o*P-r*R-a*O)*M,e[4]=(n*R-o*w+a*I)*M,e[5]=(r*w-n*P-a*A)*M,e[6]=(m*S-h*C+v*x)*M,e[7]=(h*b-g*S-v*y)*M,e[8]=(g*C-m*b+v*T)*M,e):null}function Oe(e,t,n){return e[0]=2/t,e[1]=0,e[2]=0,e[3]=0,e[4]=-2/n,e[5]=0,e[6]=-1,e[7]=1,e[8]=1,e}function Pe(e){return"mat3("+e[0]+", "+e[1]+", "+e[2]+", "+e[3]+", "+e[4]+", "+e[5]+", "+e[6]+", "+e[7]+", "+e[8]+")"}function Re(e){return Math.hypot(e[0],e[1],e[2],e[3],e[4],e[5],e[6],e[7],e[8])}function Me(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e[3]=t[3]+n[3],e[4]=t[4]+n[4],e[5]=t[5]+n[5],e[6]=t[6]+n[6],e[7]=t[7]+n[7],e[8]=t[8]+n[8],e}function Ee(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e[3]=t[3]-n[3],e[4]=t[4]-n[4],e[5]=t[5]-n[5],e[6]=t[6]-n[6],e[7]=t[7]-n[7],e[8]=t[8]-n[8],e}function Ve(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e[3]=t[3]*n,e[4]=t[4]*n,e[5]=t[5]*n,e[6]=t[6]*n,e[7]=t[7]*n,e[8]=t[8]*n,e}function De(e,t,n,r){return e[0]=t[0]+n[0]*r,e[1]=t[1]+n[1]*r,e[2]=t[2]+n[2]*r,e[3]=t[3]+n[3]*r,e[4]=t[4]+n[4]*r,e[5]=t[5]+n[5]*r,e[6]=t[6]+n[6]*r,e[7]=t[7]+n[7]*r,e[8]=t[8]+n[8]*r,e}function Le(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]&&e[6]===t[6]&&e[7]===t[7]&&e[8]===t[8]}function Be(e,t){var n=e[0],r=e[1],o=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=t[0],f=t[1],g=t[2],m=t[3],h=t[4],v=t[5],T=t[6],y=t[7],b=t[8];return Math.abs(n-p)<=a*Math.max(1,Math.abs(n),Math.abs(p))&&Math.abs(r-f)<=a*Math.max(1,Math.abs(r),Math.abs(f))&&Math.abs(o-g)<=a*Math.max(1,Math.abs(o),Math.abs(g))&&Math.abs(i-m)<=a*Math.max(1,Math.abs(i),Math.abs(m))&&Math.abs(s-h)<=a*Math.max(1,Math.abs(s),Math.abs(h))&&Math.abs(l-v)<=a*Math.max(1,Math.abs(l),Math.abs(v))&&Math.abs(c-T)<=a*Math.max(1,Math.abs(c),Math.abs(T))&&Math.abs(u-y)<=a*Math.max(1,Math.abs(u),Math.abs(y))&&Math.abs(d-b)<=a*Math.max(1,Math.abs(d),Math.abs(b))}var Ne=ve,Fe=Ee,_e=n(730),Ge=n.n(_e),ke=n(59);const Ue=n.n(ke)()(),ze={vtkObject:()=>null};function We(e){if(null==e)return e;if(e.isA)return e;if(!e.vtkClass)return Ue.console&&Ue.console.error&&Ue.console.error("Invalid VTK object"),null;const t=ze[e.vtkClass];if(!t)return Ue.console&&Ue.console.error&&Ue.console.error(`No vtk class found for Object of type ${e.vtkClass}`),null;const n={...e};Object.keys(n).forEach((e=>{n[e]&&"object"==typeof n[e]&&n[e].vtkClass&&(n[e]=We(n[e]))}));const r=t(n);return r&&r.modified&&r.modified(),r}We.register=function(e,t){ze[e]=t};class He extends Array{push(){for(let e=0;e<arguments.length;e++)this.includes(arguments[e])||super.push(arguments[e]);return this.length}}let je=0;const Ke=e=>{throw new Error(`Named parameter '${e}' is missing`)},$e=Symbol("void"),qe={};function Xe(){}["log","debug","info","warn","error","time","timeEnd","group","groupEnd"].forEach((e=>{qe[e]=Xe})),Ue.console=console.hasOwnProperty("log")?console:qe;const Ye={debug:Xe,error:Ue.console.error||Xe,info:Ue.console.info||Xe,log:Ue.console.log||Xe,warn:Ue.console.warn||Xe};function Ze(e,t){Ye[e]&&(Ye[e]=t||Xe)}function Qe(){Ye.log(...arguments)}function Je(){Ye.info(...arguments)}function et(){Ye.debug(...arguments)}function tt(){Ye.error(...arguments)}function nt(){Ye.warn(...arguments)}const rt={};function ot(e){rt[e]||(Ye.error(e),rt[e]=!0)}const at=Object.create(null);at.Float32Array=Float32Array,at.Float64Array=Float64Array,at.Uint8Array=Uint8Array,at.Int8Array=Int8Array,at.Uint16Array=Uint16Array,at.Int16Array=Int16Array,at.Uint32Array=Uint32Array,at.Int32Array=Int32Array,at.Uint8ClampedArray=Uint8ClampedArray;try{at.BigInt64Array=BigInt64Array,at.BigUint64Array=BigUint64Array}catch{}function it(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return new(at[e]||Float64Array)(...n)}function st(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),r=1;r<t;r++)n[r-1]=arguments[r];return(at[e]||Float64Array).from(...n)}function lt(e){return e.charAt(0).toUpperCase()+e.slice(1)}function ct(e){return lt("_"===e[0]?e.slice(1):e)}function ut(e){return e.charAt(0).toLowerCase()+e.slice(1)}function dt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1e3;const r=["TB","GB","MB","KB"];let o=Number(e),a="B";for(;o>n;)o/=n,a=r.pop();return`${o.toFixed(t)} ${a}`}function pt(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:" ";const n=[];let r=e;for(;r>1e3;)n.push(("000"+r%1e3).slice(-3)),r=Math.floor(r/1e3);return r>0&&n.push(r),n.reverse(),n.join(t)}function ft(e){Object.keys(e).forEach((t=>{Array.isArray(e[t])&&(e[t]=[].concat(e[t]))}))}function gt(e){return e&&e.isA?e.getState():e}function mt(e){setTimeout(e,0)}function ht(e,t){const n=performance.now();e.finally((()=>{const e=performance.now()-n;t(e)}))}function vt(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};ft(t);const n=[];if(Number.isInteger(t.mtime)||(t.mtime=++je),"classHierarchy"in t){if(!(t.classHierarchy instanceof He)){const e=new He;for(let n=0;n<t.classHierarchy.length;n++)e.push(t.classHierarchy[n]);t.classHierarchy=e}}else t.classHierarchy=new He("vtkObject");function r(e){n[e]=null}return e.isDeleted=()=>!!t.deleted,e.modified=r=>{t.deleted?tt("instance deleted - cannot call any method"):r&&r<e.getMTime()||(t.mtime=++je,n.forEach((t=>t&&t(e))))},e.onModified=e=>{if(t.deleted)return tt("instance deleted - cannot call any method"),null;const o=n.length;return n.push(e),function(e){return Object.freeze({unsubscribe:function(){r(e)}})}(o)},e.getMTime=()=>t.mtime,e.isA=e=>{let n=t.classHierarchy.length;for(;n--;)if(t.classHierarchy[n]===e)return!0;return!1},e.getClassName=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.classHierarchy[t.classHierarchy.length-1-e]},e.set=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]&&arguments[1],o=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=!1;return Object.keys(n).forEach((i=>{const s=o?null:e[`set${lt(i)}`];s&&Array.isArray(n[i])&&s.length>1?a=s(...n[i])||a:s?a=s(n[i])||a:(-1!==["mtime"].indexOf(i)||r||nt(`Warning: Set value to model directly ${i}, ${n[i]}`),a=t[i]!==n[i]||a,t[i]=n[i])})),a},e.get=function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];if(!n.length)return t;const o={};return n.forEach((e=>{o[e]=t[e]})),o},e.getReferenceByName=e=>t[e],e.delete=()=>{Object.keys(t).forEach((e=>delete t[e])),n.forEach(((e,t)=>r(t))),t.deleted=!0},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};Object.keys(n).forEach((e=>{null===n[e]||void 0===n[e]||"_"===e[0]?delete n[e]:n[e].isA?n[e]=n[e].getState():Array.isArray(n[e])?n[e]=n[e].map(gt):function(e){return Object.values(at).some((t=>e instanceof t))}(n[e])&&(n[e]=Array.from(n[e]))}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.shallowCopy=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n.getClassName()!==e.getClassName())throw new Error(`Cannot ShallowCopy ${n.getClassName()} into ${e.getClassName()}`);const o=n.get(),a=Object.keys(t).sort();Object.keys(o).sort().forEach((e=>{const n=a.indexOf(e);-1===n?r&&et(`add ${e} in shallowCopy`):a.splice(n,1),t[e]=o[e]})),a.length&&r&&et(`Untouched keys: ${a.join(", ")}`),e.modified()},e.toJSON=function(){return e.getState()},e}const Tt={object(e,t,n){return function(){return{...t[n.name]}}}};function yt(e,t,n){n.forEach((n=>{if("object"==typeof n){const r=Tt[n.type];e[`get${ct(n.name)}`]=r?r(e,t,n):()=>t[n.name]}else e[`get${ct(n)}`]=()=>t[n]}))}const bt={enum(e,t,n){const r=`_on${ct(n.name)}Changed`;return o=>{if("string"==typeof o){if(void 0!==n.enum[o])return t[n.name]!==n.enum[o]&&(t[n.name]=n.enum[o],e.modified(),!0);throw tt(`Set Enum with invalid argument ${n}, ${o}`),new RangeError("Set Enum with invalid string argument")}if("number"==typeof o){if(t[n.name]!==o){if(-1!==Object.keys(n.enum).map((e=>n.enum[e])).indexOf(o)){const a=t[n.name];return t[n.name]=o,t[r]?.(e,t,o,a),e.modified(),!0}throw tt(`Set Enum outside numeric range ${n}, ${o}`),new RangeError("Set Enum outside numeric range")}return!1}throw tt(`Set Enum with invalid argument (String/Number) ${n}, ${o}`),new TypeError("Set Enum with invalid argument (String/Number)")}},object(e,t,n){1===n.params?.length&&nt('Setter of type "object" with a single "param" field is not supported');const r=`_on${ct(n.name)}Changed`;return function(){for(var o=arguments.length,a=new Array(o),i=0;i<o;i++)a[i]=arguments[i];let s;if(s=a.length>1&&n.params?.length?n.params.reduce(((e,t,n)=>Object.assign(e,{[t]:a[n]})),{}):a[0],!Ge()(t[n.name],s)){const o=t[n.name];return t[n.name]=s,t[r]?.(e,t,s,o),e.modified(),!0}return!1}}};function xt(e){if("object"==typeof e){const t=bt[e.type];if(t)return(n,r)=>t(n,r,e);throw tt(`No setter for field ${e}`),new TypeError("No setter for field")}return function(t,n){const r=`_on${ct(e)}Changed`;return function(o){if(n.deleted)return tt("instance deleted - cannot call any method"),!1;if(n[e]!==o){const a=n[e.name];return n[e]=o,n[r]?.(t,n,o,a),t.modified(),!0}return!1}}}function Ct(e,t,n){n.forEach((n=>{"object"==typeof n?e[`set${ct(n.name)}`]=xt(n)(e,t):e[`set${ct(n)}`]=xt(n)(e,t)}))}function St(e,t,n){yt(e,t,n),Ct(e,t,n)}function At(e,t,n){n.forEach((n=>{e[`get${ct(n)}`]=()=>t[n]?Array.from(t[n]):t[n],e[`get${ct(n)}ByReference`]=()=>t[n]}))}function It(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;n.forEach((n=>{if(t[n]&&r&&t[n].length!==r)throw new RangeError(`Invalid initial number of values for array (${n})`);const a=`_on${ct(n)}Changed`;e[`set${ct(n)}`]=function(){if(t.deleted)return tt("instance deleted - cannot call any method"),!1;for(var i=arguments.length,s=new Array(i),l=0;l<i;l++)s[l]=arguments[l];let c,u=s,d=!1;if(1===u.length&&(null==u[0]||u[0].length>=0)&&(u=u[0],d=!0),null==u)c=t[n]!==u;else{if(r&&u.length!==r){if(!(u.length<r&&void 0!==o))throw new RangeError(`Invalid number of values for array setter (${n})`);for(u=Array.from(u),d=!1;u.length<r;)u.push(o)}c=null==t[n]||t[n].length!==u.length;for(let e=0;!c&&e<u.length;++e)c=t[n][e]!==u[e];c&&d&&(u=Array.from(u))}if(c){const r=t[n.name];t[n]=u,t[a]?.(e,t,u,r),e.modified()}return c},e[`set${ct(n)}From`]=e=>{const r=t[n];e.forEach(((e,t)=>{r[t]=e}))}}))}function wt(e,t,n,r){let o=arguments.length>4&&void 0!==arguments[4]?arguments[4]:void 0;At(e,t,n),It(e,t,n,r,o)}function Ot(e,t,n){for(let e=0;e<n.length;e++){const r=n[e];void 0!==t[r]&&(t[`_${r}`]=t[r],delete t[r])}}function Pt(e,t,n,r){function o(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;t.deleted?tt("instance deleted - cannot call any method"):r>=t.numberOfInputs?tt(`algorithm ${e.getClassName()} only has ${t.numberOfInputs} input ports. To add more input ports, use addInputData()`):(t.inputData[r]!==n||t.inputConnection[r])&&(t.inputData[r]=n,t.inputConnection[r]=null,e.modified&&e.modified())}function a(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(t.deleted)tt("instance deleted - cannot call any method");else{if(r>=t.numberOfInputs){let n=`algorithm ${e.getClassName()} only has `;return n+=`${t.numberOfInputs}`,n+=" input ports. To add more input ports, use addInputConnection()",void tt(n)}t.inputData[r]=null,t.inputConnection[r]=n}}function i(){let e=t.numberOfInputs;for(;e&&!t.inputData[e-1]&&!t.inputConnection[e-1];)e--;return e===t.numberOfInputs&&t.numberOfInputs++,e}function s(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.deleted?(tt("instance deleted - cannot call any method"),null):(e.shouldUpdate()&&e.update(),t.output[n])}if(t.inputData?t.inputData=t.inputData.map(We):t.inputData=[],t.inputConnection?t.inputConnection=t.inputConnection.map(We):t.inputConnection=[],t.output?t.output=t.output.map(We):t.output=[],t.inputArrayToProcess?t.inputArrayToProcess=t.inputArrayToProcess.map(We):t.inputArrayToProcess=[],t.numberOfInputs=n,e.shouldUpdate=()=>{const n=e.getMTime();let o=1/0,a=r;for(;a--;){if(!t.output[a]||t.output[a].isDeleted())return!0;const e=t.output[a].getMTime();if(e<n)return!0;e<o&&(o=e)}for(a=t.numberOfInputs;a--;)if(t.inputConnection[a]?.filter.shouldUpdate()||e.getInputData(a)?.getMTime()>o)return!0;return!1},t.numberOfInputs){let n=t.numberOfInputs;for(;n--;)t.inputData.push(null),t.inputConnection.push(null);e.setInputData=o,e.setInputConnection=a,e.addInputData=function(e){t.deleted?tt("instance deleted - cannot call any method"):o(e,i())},e.addInputConnection=function(e){t.deleted?tt("instance deleted - cannot call any method"):a(e,i())},e.getInputData=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]&&(t.inputData[e]=t.inputConnection[e]()),t.inputData[e]},e.getInputConnection=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.inputConnection[e]}}r&&(e.getOutputData=s,e.getOutputPort=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=()=>s(t);return n.filter=e,n}),e.update=()=>{const n=[];if(t.numberOfInputs){let r=0;for(;r<t.numberOfInputs;)n[r]=e.getInputData(r),r++}e.requestData&&e.shouldUpdate()&&e.requestData(n,t.output)},e.getNumberOfInputPorts=()=>t.numberOfInputs,e.getNumberOfOutputPorts=()=>r||t.output.length,e.getInputArrayToProcess=e=>{const n=t.inputArrayToProcess[e],r=t.inputData[e];return n&&r?r[`get${n.fieldAssociation}`]().getArray(n.arrayName):null},e.setInputArrayToProcess=function(e,n,r){let o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"Scalars";for(;t.inputArrayToProcess.length<e;)t.inputArrayToProcess.push(null);t.inputArrayToProcess[e]={arrayName:n,fieldAssociation:r,attributeType:o}}}const Rt=Symbol("Event abort");function Mt(e,t,n){const r=[],o=e.delete;let a=1;function i(e){for(let t=0;t<r.length;++t){const[n]=r[t];if(n===e)return void r.splice(t,1)}}e[`invoke${ct(n)}`]=function(){if(t.deleted)return void tt("instance deleted - cannot call any method");const n=r.slice();for(let t=0;t<n.length;++t){const[,r,o]=n[t];if(r)if(o<0)setTimeout((()=>r.apply(e,arguments)),1-o);else if(r.apply(e,arguments)===Rt)break}},e[`on${ct(n)}`]=function(e){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!e.apply)return console.error(`Invalid callback for event ${n}`),null;if(t.deleted)return tt("instance deleted - cannot call any method"),null;const s=a++;return r.push([s,e,o]),r.sort(((e,t)=>t[2]-e[2])),function(e){return Object.freeze({unsubscribe:function(){i(e)}})}(s)},e.delete=()=>{o(),r.forEach((e=>{let[t]=e;return i(t)}))}}function Et(e,t){const n=function(){const t={};return e(t,{},arguments.length>0&&void 0!==arguments[0]?arguments[0]:{}),Object.freeze(t)};return t&&We.register(t,n),n}function Vt(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(){for(var e=arguments.length,n=new Array(e),r=0;r<e;r++)n[r]=arguments[r];return t.filter((e=>!!e)).map((e=>e(...n)))}}function Dt(e){return e&&e.isA&&e.isA("vtkObject")}function Lt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];if(Dt(e)){if(r.indexOf(e)>=0)return n;r.push(e);const o=t(e);void 0!==o&&n.push(o);const a=e.get();Object.keys(a).forEach((e=>{const o=a[e];Array.isArray(o)?o.forEach((e=>{Lt(e,t,n,r)})):Lt(o,t,n,r)}))}return n}function Bt(e,t,n){var r=this;let o;const a=function(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];const l=r,c=n&&!o;clearTimeout(o),o=setTimeout((()=>{o=null,n||e.apply(l,i)}),t),c&&e.apply(l,i)};return a.cancel=()=>clearTimeout(o),a}function Nt(e,t){let n=!1,r=null;function o(){n=!1,null!==r&&(a(...r),r=null)}function a(){for(var a=arguments.length,i=new Array(a),s=0;s<a;s++)i[s]=arguments[s];n?r=i:(n=!0,e(...i),setTimeout(o,t))}return a}function Ft(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};t.keystore=Object.assign(t.keystore||{},n),e.setKey=(e,n)=>{t.keystore[e]=n},e.getKey=e=>t.keystore[e],e.getAllKeys=()=>Object.keys(t.keystore),e.deleteKey=e=>delete t.keystore[e],e.clearKeystore=()=>e.getAllKeys().forEach((e=>delete t.keystore[e]))}let _t=1;const Gt="__root__";function kt(e,t){Ft(e,t);const n=e.delete;t.proxyId=""+_t++,t.ui=JSON.parse(JSON.stringify(t.ui||[])),yt(e,t,["proxyId","proxyGroup","proxyName"]),St(e,t,["proxyManager"]);const r={},o={};function a(e,t){o[t]||(o[t]=[]);const n=o[t];for(let t=0;t<e.length;t++)n.push(e[t].name),r[e[t].name]=e[t],e[t].children&&e[t].children.length&&a(e[t].children,e[t].name)}function i(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt;const r=[],a=t.proxyId,s=function(){return o[arguments.length>0&&void 0!==arguments[0]?arguments[0]:Gt]}(n)||[];for(let t=0;t<s.length;t++){const n=s[t],o=e[`get${ct(n)}`],l={id:a,name:n,value:o?o():void 0},c=i(n);c.length&&(l.children=c),r.push(l)}return r}a(t.ui,Gt),e.updateUI=n=>{t.ui=JSON.parse(JSON.stringify(n||[])),Object.keys(r).forEach((e=>delete r[e])),Object.keys(o).forEach((e=>delete o[e])),a(t.ui,Gt),e.modified()},e.updateProxyProperty=(e,t)=>{const n=r[e];n?Object.assign(n,t):r[e]={...t}},e.activate=()=>{if(t.proxyManager){const n=`setActive${ct(e.getProxyGroup().slice(0,-1))}`;t.proxyManager[n]&&t.proxyManager[n](e)}},t.propertyLinkSubscribers={},e.registerPropertyLinkForGC=(e,n)=>{n in t.propertyLinkSubscribers||(t.propertyLinkSubscribers[n]=[]),t.propertyLinkSubscribers[n].push(e)},e.gcPropertyLinks=n=>{const r=t.propertyLinkSubscribers[n]||[];for(;r.length;)r.pop().unbind(e)},t.propertyLinkMap={},e.getPropertyLink=function(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(t.propertyLinkMap[e])return t.propertyLinkMap[e];let r=null;const o=[];let a=0,i=!1;function s(n){let s=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(i)return null;const l=[];let c=null;for(a=o.length;a--;){const e=o[a];e.instance===n?c=e:l.push(e)}if(!c)return null;const u=c.instance[`get${ct(c.propertyName)}`]();if(!function(e,t){if(e===t)return!0;if(Array.isArray(e)&&Array.isArray(t)){if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}return!1}(u,r)||s){for(r=u,i=!0;l.length;){const e=l.pop();e.instance.set({[e.propertyName]:r})}i=!1}return t.propertyLinkMap[e].persistent&&(t.propertyLinkMap[e].value=u),u}function l(e,t){const n=[];for(a=o.length;a--;){const r=o[a];r.instance!==e||r.propertyName!==t&&void 0!==t||(r.subscription.unsubscribe(),n.push(a))}for(;n.length;)o.splice(n.pop(),1)}const c={bind:function(n,r){let a=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const i=n.onModified(s),c=o[0];return o.push({instance:n,propertyName:r,subscription:i}),a&&(t.propertyLinkMap[e].persistent&&void 0!==t.propertyLinkMap[e].value?n.set({[r]:t.propertyLinkMap[e].value}):c&&s(c.instance,!0)),{unsubscribe:()=>l(n,r)}},unbind:l,unsubscribe:function(){for(;o.length;)o.pop().subscription.unsubscribe()},persistent:n};return t.propertyLinkMap[e]=c,c},e.listPropertyNames=()=>i().map((e=>e.name)),e.getPropertyByName=e=>i().find((t=>t.name===e)),e.getPropertyDomainByName=e=>(r[e]||{}).domain,e.getProxySection=()=>({id:t.proxyId,name:t.proxyGroup,ui:t.ui,properties:i()}),e.delete=()=>{const r=Object.keys(t.propertyLinkMap);let o=r.length;for(;o--;)t.propertyLinkMap[r[o]].unsubscribe();Object.keys(t.propertyLinkSubscribers).forEach(e.gcPropertyLinks),n()},e.getState=()=>null,mt((function(){if(t.links)for(let n=0;n<t.links.length;n++){const{link:r,property:o,persistent:a,updateOnBind:i,type:s}=t.links[n];if("application"===s){const n=t.proxyManager.getPropertyLink(r,a);e.registerPropertyLinkForGC(n,"application"),n.bind(e,o,i)}}}))}function Ut(e,t,n){const r=e.delete,o=[],a=Object.keys(n);let i=a.length;for(;i--;){const r=a[i],{modelKey:s,property:l,modified:c=!0}=n[r],u=ct(l),d=ct(r);e[`get${d}`]=t[s][`get${u}`],e[`set${d}`]=t[s][`set${u}`],c&&o.push(t[s].onModified(e.modified))}e.delete=()=>{for(;o.length;)o.pop().unsubscribe();r()}}function zt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};function o(e){const n=Object.keys(e);let r=n.length;for(;r--;){const o=n[r];t[o].set(e[o])}}t.this=e;const a=Object.keys(r);let i=a.length;for(;i--;){const s=a[i];t[s]=r[s];const l=n[s];e[`set${ct(s)}`]=n=>{n!==t[s]&&(t[s]=n,o(l[n]),e.modified())}}a.length&&yt(e,t,a)}function Wt(e){let t=0,n=0,r=0,o=0;return"detail"in e&&(n=e.detail),"wheelDelta"in e&&(n=-e.wheelDelta/120),"wheelDeltaY"in e&&(n=-e.wheelDeltaY/120),"wheelDeltaX"in e&&(t=-e.wheelDeltaX/120),"axis"in e&&e.axis===e.HORIZONTAL_AXIS&&(t=n,n=0),r=10*t,o=10*n,"deltaY"in e&&(o=e.deltaY),"deltaX"in e&&(r=e.deltaX),(r||o)&&e.deltaMode&&(1===e.deltaMode?(r*=40,o*=40):(r*=800,o*=800)),r&&!t&&(t=r<1?-1:1),o&&!n&&(n=o<1?-1:1),{spinX:t,spinY:n||t,pixelX:r,pixelY:o||r}}var Ht={algo:Pt,capitalize:lt,chain:Vt,debounce:Bt,enumToString:function(e,t){return Object.keys(e).find((n=>e[n]===t))},event:Mt,EVENT_ABORT:Rt,formatBytesToProperUnit:dt,formatNumbersWithThousandSeparator:pt,get:yt,getArray:At,getCurrentGlobalMTime:function(){return je},getStateArrayMapFunc:gt,isVtkObject:Dt,keystore:Ft,measurePromiseExecution:ht,moveToProtected:Ot,newInstance:Et,newTypedArray:it,newTypedArrayFrom:st,normalizeWheel:Wt,obj:vt,proxy:kt,proxyPropertyMapping:Ut,proxyPropertyState:zt,safeArrays:ft,set:Ct,setArray:It,setGet:St,setGetArray:wt,setImmediate:mt,setLoggerFunction:Ze,throttle:Nt,traverseInstanceTree:Lt,TYPED_ARRAYS:at,uncapitalize:ut,VOID:$e,vtkDebugMacro:et,vtkErrorMacro:tt,vtkInfoMacro:Je,vtkLogMacro:Qe,vtkOnceErrorMacro:ot,vtkWarningMacro:nt,objectSetterMap:bt,requiredParam:Ke},jt=Object.freeze({__proto__:null,requiredParam:Ke,VOID:$e,setLoggerFunction:Ze,vtkLogMacro:Qe,vtkInfoMacro:Je,vtkDebugMacro:et,vtkErrorMacro:tt,vtkWarningMacro:nt,vtkOnceErrorMacro:ot,TYPED_ARRAYS:at,newTypedArray:it,newTypedArrayFrom:st,capitalize:lt,_capitalize:ct,uncapitalize:ut,formatBytesToProperUnit:dt,formatNumbersWithThousandSeparator:pt,setImmediateVTK:mt,measurePromiseExecution:ht,obj:vt,get:yt,set:Ct,setGet:St,getArray:At,setArray:It,setGetArray:wt,moveToProtected:Ot,algo:Pt,EVENT_ABORT:Rt,event:Mt,newInstance:Et,chain:Vt,isVtkObject:Dt,traverseInstanceTree:Lt,debounce:Bt,throttle:Nt,keystore:Ft,proxy:kt,proxyPropertyMapping:Ut,proxyPropertyState:zt,normalizeWheel:Wt,default:Ht});const{vtkErrorMacro:Kt}=Ht,$t={renderable:null,myFactory:null,children:[],visited:!1};function qt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$t,n),Ht.obj(e,t),Ht.event(e,t,"event"),t._renderableChildMap=new Map,Ht.get(e,t,["visited"]),Ht.setGet(e,t,["_parent","renderable","myFactory"]),Ht.getArray(e,t,["children"]),Ht.moveToProtected(e,t,["parent"]),function(e,t){t.classHierarchy.push("vtkViewNode"),e.build=e=>{},e.render=e=>{},e.traverse=n=>{const r=n.getTraverseOperation(),o=e[r];if(o)o(n);else{e.apply(n,!0);for(let e=0;e<t.children.length;e++)t.children[e].traverse(n);e.apply(n,!1)}},e.apply=(t,n)=>{const r=e[t.getOperation()];r&&r(n,t)},e.getViewNodeFor=n=>{if(t.renderable===n)return e;for(let e=0;e<t.children.length;++e){const r=t.children[e].getViewNodeFor(n);if(r)return r}},e.getFirstAncestorOfType=e=>t._parent?t._parent.isA(e)?t._parent:t._parent.getFirstAncestorOfType(e):null,e.getLastAncestorOfType=e=>t._parent?t._parent.getLastAncestorOfType(e)||(t._parent.isA(e)?t._parent:null):null,e.addMissingNode=n=>{if(!n)return;const r=t._renderableChildMap.get(n);if(void 0!==r)return r.setVisited(!0),r;const o=e.createViewNode(n);return o?(o.setParent(e),o.setVisited(!0),t._renderableChildMap.set(n,o),t.children.push(o),o):void 0},e.addMissingNodes=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(n&&n.length)for(let o=0;o<n.length;++o){const a=n[o],i=e.addMissingNode(a);if(r&&void 0!==i&&t.children[o]!==i)for(let e=o+1;e<t.children.length;++e)if(t.children[e]===i){t.children.splice(e,1),t.children.splice(o,0,i);break}}},e.addMissingChildren=n=>{if(n&&n.length)for(let r=0;r<n.length;++r){const o=n[r];if(-1===t.children.indexOf(o)){o.setParent(e),t.children.push(o);const n=o.getRenderable();n&&t._renderableChildMap.set(n,o)}o.setVisited(!0)}},e.removeNode=e=>{const n=t.children.findIndex((t=>t===e));if(n<0)return!1;const r=e.getRenderable();return r&&t._renderableChildMap.delete(r),e.delete(),t.children.splice(n,1),!0},e.prepareNodes=()=>{for(let e=0;e<t.children.length;++e)t.children[e].setVisited(!1)},e.setVisited=e=>{t.visited=e},e.removeUnusedNodes=()=>{let e=0;for(let n=0;n<t.children.length;++n){const r=t.children[n];if(r.getVisited())t.children[e++]=r,r.setVisited(!1);else{const e=r.getRenderable();e&&t._renderableChildMap.delete(e),r.delete()}}t.children.length=e},e.createViewNode=e=>{if(!t.myFactory)return Kt("Cannot create view nodes without my own factory"),null;const n=t.myFactory.createNode(e);return n&&n.setRenderable(e),n};const n=e.delete;e.delete=()=>{for(let e=0;e<t.children.length;e++)t.children[e].delete();n()}}(e,t)}var Xt={newInstance:Ht.newInstance(qt,"vtkViewNode"),extend:qt,PASS_TYPES:["Build","Render"]};const Yt={};function Zt(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Yt,n),Ht.obj(e,t),function(e,t){t.overrides||(t.overrides={}),t.classHierarchy.push("vtkViewNodeFactory"),e.createNode=n=>{if(n.isDeleted())return null;let r=0,o=n.getClassName(r++),a=!1;const i=Object.keys(t.overrides);for(;o&&!a;)-1!==i.indexOf(o)?a=!0:o=n.getClassName(r++);if(!a)return null;const s=t.overrides[o]();return s.setMyFactory(e),s}}(e,t)}var Qt={newInstance:Ht.newInstance(Zt,"vtkViewNodeFactory"),extend:Zt};const Jt=Object.create(null);function en(e,t){Jt[e]=t}const tn={};function nn(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tn,n),t.overrides=Jt,Qt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLViewNodeFactory")}(0,t)}var rn={newInstance:Ht.newInstance(nn,"vtkOpenGLViewNodeFactory"),extend:nn};const on={context:null,lastRenderer:null,keyMatrixTime:null,keyMatrices:null};const an=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,on,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime),t.keyMatrices={normalMatrix:new Float64Array(9),vcpc:new Float64Array(16),wcvc:new Float64Array(16),wcpc:new Float64Array(16)},St(e,t,["context","keyMatrixTime"]),function(e,t){t.classHierarchy.push("vtkOpenGLCamera"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext())},e.opaquePass=e=>{if(e){const e=t._openGLRenderer.getTiledSizeAndOrigin();t.context.viewport(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize),t.context.scissor(e.lowerLeftU,e.lowerLeftV,e.usize,e.vsize)}},e.translucentPass=e.opaquePass,e.zBufferPass=e.opaquePass,e.opaqueZBufferPass=e.opaquePass,e.volumePass=e.opaquePass,e.getKeyMatrices=n=>{if(n!==t.lastRenderer||t._openGLRenderWindow.getMTime()>t.keyMatrixTime.getMTime()||e.getMTime()>t.keyMatrixTime.getMTime()||n.getMTime()>t.keyMatrixTime.getMTime()||t.renderable.getMTime()>t.keyMatrixTime.getMTime()){d(t.keyMatrices.wcvc,t.renderable.getViewMatrix()),se(t.keyMatrices.normalMatrix,t.keyMatrices.wcvc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),m(t.keyMatrices.wcvc,t.keyMatrices.wcvc);const e=t._openGLRenderer.getAspectRatio();d(t.keyMatrices.vcpc,t.renderable.getProjectionMatrix(e,-1,1)),m(t.keyMatrices.vcpc,t.keyMatrices.vcpc),y(t.keyMatrices.wcpc,t.keyMatrices.vcpc,t.keyMatrices.wcvc),t.keyMatrixTime.modified(),t.lastRenderer=n}return t.keyMatrices}}(e,t)}));en("vtkCamera",an);const{vtkDebugMacro:sn}=jt,ln={context:null,_openGLRenderWindow:null,selector:null};const cn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ln,n),Xt.extend(e,t,n),yt(e,t,["shaderCache"]),St(e,t,["selector"]),Ot(0,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkOpenGLRenderer"),e.buildPass=n=>{if(n){if(!t.renderable)return;e.updateLights(),e.prepareNodes(),e.addMissingNode(t.renderable.getActiveCamera()),e.addMissingNodes(t.renderable.getViewPropsWithNestedProps(),!0),e.removeUnusedNodes()}},e.updateLights=()=>{let e=0;const n=t.renderable.getLightsByReference();for(let t=0;t<n.length;++t)n[t].getSwitch()>0&&e++;return e||(sn("No lights are on, creating one."),t.renderable.createLight()),e},e.zBufferPass=n=>{if(n){let n=0;const r=t.context;t.renderable.getTransparent()||(t.context.clearColor(1,0,0,1),n|=r.COLOR_BUFFER_BIT),t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,t.context.depthMask(!0));const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.colorMask(!0,!0,!0,!0),n&&r.clear(n),r.enable(r.DEPTH_TEST)}},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.cameraPass=t=>{t&&e.clear()},e.getAspectRatio=()=>{const e=t._parent.getSizeByReference(),n=t.renderable.getViewportByReference();return e[0]*(n[2]-n[0])/((n[3]-n[1])*e[1])},e.getTiledSizeAndOrigin=()=>{const e=t.renderable.getViewportByReference(),n=[0,0,1,1],r=e[0]-n[0],o=e[1]-n[1],a=t._parent.normalizedDisplayToDisplay(r,o),i=Math.round(a[0]),s=Math.round(a[1]),l=e[2]-n[0],c=e[3]-n[1],u=t._parent.normalizedDisplayToDisplay(l,c);let d=Math.round(u[0])-i,p=Math.round(u[1])-s;return d<0&&(d=0),p<0&&(p=0),{usize:d,vsize:p,lowerLeftU:i,lowerLeftV:s}},e.clear=()=>{let n=0;const r=t.context;if(!t.renderable.getTransparent()){const e=t.renderable.getBackgroundByReference();r.clearColor(e[0],e[1],e[2],e[3]),n|=r.COLOR_BUFFER_BIT}t.renderable.getPreserveDepthBuffer()||(r.clearDepth(1),n|=r.DEPTH_BUFFER_BIT,r.depthMask(!0)),r.colorMask(!0,!0,!0,!0);const o=e.getTiledSizeAndOrigin();r.enable(r.SCISSOR_TEST),r.scissor(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),r.viewport(o.lowerLeftU,o.lowerLeftV,o.usize,o.vsize),n&&r.clear(n),r.enable(r.DEPTH_TEST)},e.releaseGraphicsResources=()=>{null!==t.selector&&t.selector.releaseGraphicsResources(),t.renderable&&t.renderable.getViewProps().forEach((e=>{e.modified()}))},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}(e,t)}),"vtkOpenGLRenderer");en("vtkRenderer",cn);const un={context:null,keyMatrixTime:null,keyMatrices:null,activeTextures:null};const dn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,un,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},St(e,t,["context"]),yt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLActor"),e.buildPass=n=>{if(n){t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(t._openGLRenderer.getSelector()&&t.renderable.getNestedPickable()),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.renderable.getIsIdentity()?pe(t.keyMatrices.normalMatrix):(se(t.keyMatrices.normalMatrix,t.keyMatrices.mcwc),ge(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix),fe(t.keyMatrices.normalMatrix,t.keyMatrices.normalMatrix)),t.keyMatrixTime.modified()),t.keyMatrices)}(e,t)}));en("vtkActor",dn);const pn={context:null,activeTextures:null};const fn=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,pn,n),Xt.extend(e,t,n),St(e,t,["context"]),yt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLActor2D"),e.buildPass=n=>{if(n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNodes(t.renderable.getTextures()),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes(),t.ogltextures=null,t.activeTextures=null;for(let e=0;e<t.children.length;e++){const n=t.children[e];n.isA("vtkOpenGLTexture")?(t.ogltextures||(t.ogltextures=[]),t.ogltextures.push(n)):t.oglmapper=n}}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOverlayActorCount()}},e.traverseOpaquePass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseTranslucentPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&!t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.traverseOverlayPass=n=>{t.oglmapper&&t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable)&&(e.apply(n,!0),t.oglmapper.traverse(n),e.apply(n,!1))},e.activateTextures=()=>{if(t.ogltextures){t.activeTextures=[];for(let e=0;e<t.ogltextures.length;e++){const n=t.ogltextures[e];n.render(),n.getHandle()&&t.activeTextures.push(n)}}},e.opaquePass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.translucentPass=(n,r)=>{if(n)t.context.depthMask(!1),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()},e.overlayPass=(n,r)=>{if(n)t.context.depthMask(!0),e.activateTextures();else if(t.activeTextures)for(let e=0;e<t.activeTextures.length;e++)t.activeTextures[e].deactivate()}}(e,t)}));function gn(){var e=new i(3);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e}function mn(e){var t=e[0],n=e[1],r=e[2];return Math.hypot(t,n,r)}function hn(e,t,n){var r=new i(3);return r[0]=e,r[1]=t,r[2]=n,r}function vn(e,t,n,r){return e[0]=t,e[1]=n,e[2]=r,e}function Tn(e,t,n){return e[0]=t[0]+n[0],e[1]=t[1]+n[1],e[2]=t[2]+n[2],e}function yn(e,t,n){return e[0]=t[0]-n[0],e[1]=t[1]-n[1],e[2]=t[2]-n[2],e}function bn(e,t,n){return e[0]=t[0]*n[0],e[1]=t[1]*n[1],e[2]=t[2]*n[2],e}function xn(e,t,n){return e[0]=t[0]*n,e[1]=t[1]*n,e[2]=t[2]*n,e}function Cn(e,t){return e[0]=1/t[0],e[1]=1/t[1],e[2]=1/t[2],e}function Sn(e,t){var n=t[0],r=t[1],o=t[2],a=n*n+r*r+o*o;return a>0&&(a=1/Math.sqrt(a)),e[0]=t[0]*a,e[1]=t[1]*a,e[2]=t[2]*a,e}function An(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function In(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[0],s=n[1],l=n[2];return e[0]=o*l-a*s,e[1]=a*i-r*l,e[2]=r*s-o*i,e}function wn(e,t,n){var r=t[0],o=t[1],a=t[2],i=n[3]*r+n[7]*o+n[11]*a+n[15];return i=i||1,e[0]=(n[0]*r+n[4]*o+n[8]*a+n[12])/i,e[1]=(n[1]*r+n[5]*o+n[9]*a+n[13])/i,e[2]=(n[2]*r+n[6]*o+n[10]*a+n[14])/i,e}function On(e,t,n){var r=t[0],o=t[1],a=t[2];return e[0]=r*n[0]+o*n[3]+a*n[6],e[1]=r*n[1]+o*n[4]+a*n[7],e[2]=r*n[2]+o*n[5]+a*n[8],e}function Pn(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]}function Rn(e,t){var n=e[0],r=e[1],o=e[2],i=t[0],s=t[1],l=t[2];return Math.abs(n-i)<=a*Math.max(1,Math.abs(n),Math.abs(i))&&Math.abs(r-s)<=a*Math.max(1,Math.abs(r),Math.abs(s))&&Math.abs(o-l)<=a*Math.max(1,Math.abs(o),Math.abs(l))}en("vtkActor2D",fn);var Mn=yn,En=bn,Vn=(gn(),Math.sqrt(50)),Dn=Math.sqrt(10),Ln=Math.sqrt(2);function Bn(e,t,n){var r=(t-e)/Math.max(0,n),o=Math.floor(Math.log(r)/Math.LN10),a=r/Math.pow(10,o);return o>=0?(a>=Vn?10:a>=Dn?5:a>=Ln?2:1)*Math.pow(10,o):-Math.pow(10,-o)/(a>=Vn?10:a>=Dn?5:a>=Ln?2:1)}function Nn(e,t){return null==e||null==t?NaN:e<t?-1:e>t?1:e>=t?0:NaN}function Fn(e){let t=e,n=e,r=e;function o(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<0?o=n+1:a=n}while(o<a)}return o}return 1===e.length&&(t=(t,n)=>e(t)-n,n=Nn,r=(t,n)=>Nn(e(t),n)),{left:o,center:function(e,n,r=0,a=e.length){const i=o(e,n,r,a-1);return i>r&&t(e[i-1],n)>-t(e[i],n)?i-1:i},right:function(e,t,o=0,a=e.length){if(o<a){if(0!==n(t,t))return a;do{const n=o+a>>>1;r(e[n],t)<=0?o=n+1:a=n}while(o<a)}return o}}}const _n=Fn(Nn),Gn=_n.right;_n.left,Fn((function(e){return null===e?NaN:+e})).center;var kn=Gn;function Un(e,t,n){e.prototype=t.prototype=n,n.constructor=e}function zn(e,t){var n=Object.create(e.prototype);for(var r in t)n[r]=t[r];return n}function Wn(){}var Hn=.7,jn=1/Hn,Kn="\\s*([+-]?\\d+)\\s*",$n="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)\\s*",qn="\\s*([+-]?(?:\\d*\\.)?\\d+(?:[eE][+-]?\\d+)?)%\\s*",Xn=/^#([0-9a-f]{3,8})$/,Yn=new RegExp(`^rgb\\(${Kn},${Kn},${Kn}\\)$`),Zn=new RegExp(`^rgb\\(${qn},${qn},${qn}\\)$`),Qn=new RegExp(`^rgba\\(${Kn},${Kn},${Kn},${$n}\\)$`),Jn=new RegExp(`^rgba\\(${qn},${qn},${qn},${$n}\\)$`),er=new RegExp(`^hsl\\(${$n},${qn},${qn}\\)$`),tr=new RegExp(`^hsla\\(${$n},${qn},${qn},${$n}\\)$`),nr={aliceblue:15792383,antiquewhite:16444375,aqua:65535,aquamarine:8388564,azure:15794175,beige:16119260,bisque:16770244,black:0,blanchedalmond:16772045,blue:255,blueviolet:9055202,brown:10824234,burlywood:14596231,cadetblue:6266528,chartreuse:8388352,chocolate:13789470,coral:16744272,cornflowerblue:6591981,cornsilk:16775388,crimson:14423100,cyan:65535,darkblue:139,darkcyan:35723,darkgoldenrod:12092939,darkgray:11119017,darkgreen:25600,darkgrey:11119017,darkkhaki:12433259,darkmagenta:9109643,darkolivegreen:5597999,darkorange:16747520,darkorchid:10040012,darkred:9109504,darksalmon:15308410,darkseagreen:9419919,darkslateblue:4734347,darkslategray:3100495,darkslategrey:3100495,darkturquoise:52945,darkviolet:9699539,deeppink:16716947,deepskyblue:49151,dimgray:6908265,dimgrey:6908265,dodgerblue:2003199,firebrick:11674146,floralwhite:16775920,forestgreen:2263842,fuchsia:16711935,gainsboro:14474460,ghostwhite:16316671,gold:16766720,goldenrod:14329120,gray:8421504,green:32768,greenyellow:11403055,grey:8421504,honeydew:15794160,hotpink:16738740,indianred:13458524,indigo:4915330,ivory:16777200,khaki:15787660,lavender:15132410,lavenderblush:16773365,lawngreen:8190976,lemonchiffon:16775885,lightblue:11393254,lightcoral:15761536,lightcyan:14745599,lightgoldenrodyellow:16448210,lightgray:13882323,lightgreen:9498256,lightgrey:13882323,lightpink:16758465,lightsalmon:16752762,lightseagreen:2142890,lightskyblue:8900346,lightslategray:7833753,lightslategrey:7833753,lightsteelblue:11584734,lightyellow:16777184,lime:65280,limegreen:3329330,linen:16445670,magenta:16711935,maroon:8388608,mediumaquamarine:6737322,mediumblue:205,mediumorchid:12211667,mediumpurple:9662683,mediumseagreen:3978097,mediumslateblue:8087790,mediumspringgreen:64154,mediumturquoise:4772300,mediumvioletred:13047173,midnightblue:1644912,mintcream:16121850,mistyrose:16770273,moccasin:16770229,navajowhite:16768685,navy:128,oldlace:16643558,olive:8421376,olivedrab:7048739,orange:16753920,orangered:16729344,orchid:14315734,palegoldenrod:15657130,palegreen:10025880,paleturquoise:11529966,palevioletred:14381203,papayawhip:16773077,peachpuff:16767673,peru:13468991,pink:16761035,plum:14524637,powderblue:11591910,purple:8388736,rebeccapurple:6697881,red:16711680,rosybrown:12357519,royalblue:4286945,saddlebrown:9127187,salmon:16416882,sandybrown:16032864,seagreen:3050327,seashell:16774638,sienna:10506797,silver:12632256,skyblue:8900331,slateblue:6970061,slategray:7372944,slategrey:7372944,snow:16775930,springgreen:65407,steelblue:4620980,tan:13808780,teal:32896,thistle:14204888,tomato:16737095,turquoise:4251856,violet:15631086,wheat:16113331,white:16777215,whitesmoke:16119285,yellow:16776960,yellowgreen:10145074};function rr(){return this.rgb().formatHex()}function or(){return this.rgb().formatRgb()}function ar(e){var t,n;return e=(e+"").trim().toLowerCase(),(t=Xn.exec(e))?(n=t[1].length,t=parseInt(t[1],16),6===n?ir(t):3===n?new cr(t>>8&15|t>>4&240,t>>4&15|240&t,(15&t)<<4|15&t,1):8===n?sr(t>>24&255,t>>16&255,t>>8&255,(255&t)/255):4===n?sr(t>>12&15|t>>8&240,t>>8&15|t>>4&240,t>>4&15|240&t,((15&t)<<4|15&t)/255):null):(t=Yn.exec(e))?new cr(t[1],t[2],t[3],1):(t=Zn.exec(e))?new cr(255*t[1]/100,255*t[2]/100,255*t[3]/100,1):(t=Qn.exec(e))?sr(t[1],t[2],t[3],t[4]):(t=Jn.exec(e))?sr(255*t[1]/100,255*t[2]/100,255*t[3]/100,t[4]):(t=er.exec(e))?mr(t[1],t[2]/100,t[3]/100,1):(t=tr.exec(e))?mr(t[1],t[2]/100,t[3]/100,t[4]):nr.hasOwnProperty(e)?ir(nr[e]):"transparent"===e?new cr(NaN,NaN,NaN,0):null}function ir(e){return new cr(e>>16&255,e>>8&255,255&e,1)}function sr(e,t,n,r){return r<=0&&(e=t=n=NaN),new cr(e,t,n,r)}function lr(e,t,n,r){return 1===arguments.length?((o=e)instanceof Wn||(o=ar(o)),o?new cr((o=o.rgb()).r,o.g,o.b,o.opacity):new cr):new cr(e,t,n,null==r?1:r);var o}function cr(e,t,n,r){this.r=+e,this.g=+t,this.b=+n,this.opacity=+r}function ur(){return`#${gr(this.r)}${gr(this.g)}${gr(this.b)}`}function dr(){const e=pr(this.opacity);return`${1===e?"rgb(":"rgba("}${fr(this.r)}, ${fr(this.g)}, ${fr(this.b)}${1===e?")":`, ${e})`}`}function pr(e){return isNaN(e)?1:Math.max(0,Math.min(1,e))}function fr(e){return Math.max(0,Math.min(255,Math.round(e)||0))}function gr(e){return((e=fr(e))<16?"0":"")+e.toString(16)}function mr(e,t,n,r){return r<=0?e=t=n=NaN:n<=0||n>=1?e=t=NaN:t<=0&&(e=NaN),new vr(e,t,n,r)}function hr(e){if(e instanceof vr)return new vr(e.h,e.s,e.l,e.opacity);if(e instanceof Wn||(e=ar(e)),!e)return new vr;if(e instanceof vr)return e;var t=(e=e.rgb()).r/255,n=e.g/255,r=e.b/255,o=Math.min(t,n,r),a=Math.max(t,n,r),i=NaN,s=a-o,l=(a+o)/2;return s?(i=t===a?(n-r)/s+6*(n<r):n===a?(r-t)/s+2:(t-n)/s+4,s/=l<.5?a+o:2-a-o,i*=60):s=l>0&&l<1?0:i,new vr(i,s,l,e.opacity)}function vr(e,t,n,r){this.h=+e,this.s=+t,this.l=+n,this.opacity=+r}function Tr(e){return(e=(e||0)%360)<0?e+360:e}function yr(e){return Math.max(0,Math.min(1,e||0))}function br(e,t,n){return 255*(e<60?t+(n-t)*e/60:e<180?n:e<240?t+(n-t)*(240-e)/60:t)}function xr(e,t,n,r,o){var a=e*e,i=a*e;return((1-3*e+3*a-i)*t+(4-6*a+3*i)*n+(1+3*e+3*a-3*i)*r+i*o)/6}Un(Wn,ar,{copy(e){return Object.assign(new this.constructor,this,e)},displayable(){return this.rgb().displayable()},hex:rr,formatHex:rr,formatHex8:function(){return this.rgb().formatHex8()},formatHsl:function(){return hr(this).formatHsl()},formatRgb:or,toString:or}),Un(cr,lr,zn(Wn,{brighter(e){return e=null==e?jn:Math.pow(jn,e),new cr(this.r*e,this.g*e,this.b*e,this.opacity)},darker(e){return e=null==e?Hn:Math.pow(Hn,e),new cr(this.r*e,this.g*e,this.b*e,this.opacity)},rgb(){return this},clamp(){return new cr(fr(this.r),fr(this.g),fr(this.b),pr(this.opacity))},displayable(){return-.5<=this.r&&this.r<255.5&&-.5<=this.g&&this.g<255.5&&-.5<=this.b&&this.b<255.5&&0<=this.opacity&&this.opacity<=1},hex:ur,formatHex:ur,formatHex8:function(){return`#${gr(this.r)}${gr(this.g)}${gr(this.b)}${gr(255*(isNaN(this.opacity)?1:this.opacity))}`},formatRgb:dr,toString:dr})),Un(vr,(function(e,t,n,r){return 1===arguments.length?hr(e):new vr(e,t,n,null==r?1:r)}),zn(Wn,{brighter(e){return e=null==e?jn:Math.pow(jn,e),new vr(this.h,this.s,this.l*e,this.opacity)},darker(e){return e=null==e?Hn:Math.pow(Hn,e),new vr(this.h,this.s,this.l*e,this.opacity)},rgb(){var e=this.h%360+360*(this.h<0),t=isNaN(e)||isNaN(this.s)?0:this.s,n=this.l,r=n+(n<.5?n:1-n)*t,o=2*n-r;return new cr(br(e>=240?e-240:e+120,o,r),br(e,o,r),br(e<120?e+240:e-120,o,r),this.opacity)},clamp(){return new vr(Tr(this.h),yr(this.s),yr(this.l),pr(this.opacity))},displayable(){return(0<=this.s&&this.s<=1||isNaN(this.s))&&0<=this.l&&this.l<=1&&0<=this.opacity&&this.opacity<=1},formatHsl(){const e=pr(this.opacity);return`${1===e?"hsl(":"hsla("}${Tr(this.h)}, ${100*yr(this.s)}%, ${100*yr(this.l)}%${1===e?")":`, ${e})`}`}}));var Cr=e=>()=>e;function Sr(e,t){var n=t-e;return n?function(e,t){return function(n){return e+n*t}}(e,n):Cr(isNaN(e)?t:e)}var Ar=function e(t){var n=function(e){return 1==(e=+e)?Sr:function(t,n){return n-t?function(e,t,n){return e=Math.pow(e,n),t=Math.pow(t,n)-e,n=1/n,function(r){return Math.pow(e+r*t,n)}}(t,n,e):Cr(isNaN(t)?n:t)}}(t);function r(e,t){var r=n((e=lr(e)).r,(t=lr(t)).r),o=n(e.g,t.g),a=n(e.b,t.b),i=Sr(e.opacity,t.opacity);return function(t){return e.r=r(t),e.g=o(t),e.b=a(t),e.opacity=i(t),e+""}}return r.gamma=e,r}(1);function Ir(e){return function(t){var n,r,o=t.length,a=new Array(o),i=new Array(o),s=new Array(o);for(n=0;n<o;++n)r=lr(t[n]),a[n]=r.r||0,i[n]=r.g||0,s[n]=r.b||0;return a=e(a),i=e(i),s=e(s),r.opacity=1,function(e){return r.r=a(e),r.g=i(e),r.b=s(e),r+""}}}function wr(e,t){var n,r=t?t.length:0,o=e?Math.min(r,e.length):0,a=new Array(o),i=new Array(r);for(n=0;n<o;++n)a[n]=Lr(e[n],t[n]);for(;n<r;++n)i[n]=t[n];return function(e){for(n=0;n<o;++n)i[n]=a[n](e);return i}}function Or(e,t){var n=new Date;return e=+e,t=+t,function(r){return n.setTime(e*(1-r)+t*r),n}}function Pr(e,t){return e=+e,t=+t,function(n){return e*(1-n)+t*n}}function Rr(e,t){var n,r={},o={};for(n in null!==e&&"object"==typeof e||(e={}),null!==t&&"object"==typeof t||(t={}),t)n in e?r[n]=Lr(e[n],t[n]):o[n]=t[n];return function(e){for(n in r)o[n]=r[n](e);return o}}Ir((function(e){var t=e.length-1;return function(n){var r=n<=0?n=0:n>=1?(n=1,t-1):Math.floor(n*t),o=e[r],a=e[r+1],i=r>0?e[r-1]:2*o-a,s=r<t-1?e[r+2]:2*a-o;return xr((n-r/t)*t,i,o,a,s)}})),Ir((function(e){var t=e.length;return function(n){var r=Math.floor(((n%=1)<0?++n:n)*t),o=e[(r+t-1)%t],a=e[r%t],i=e[(r+1)%t],s=e[(r+2)%t];return xr((n-r/t)*t,o,a,i,s)}}));var Mr=/[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g,Er=new RegExp(Mr.source,"g");function Vr(e,t){var n,r,o,a=Mr.lastIndex=Er.lastIndex=0,i=-1,s=[],l=[];for(e+="",t+="";(n=Mr.exec(e))&&(r=Er.exec(t));)(o=r.index)>a&&(o=t.slice(a,o),s[i]?s[i]+=o:s[++i]=o),(n=n[0])===(r=r[0])?s[i]?s[i]+=r:s[++i]=r:(s[++i]=null,l.push({i:i,x:Pr(n,r)})),a=Er.lastIndex;return a<t.length&&(o=t.slice(a),s[i]?s[i]+=o:s[++i]=o),s.length<2?l[0]?function(e){return function(t){return e(t)+""}}(l[0].x):function(e){return function(){return e}}(t):(t=l.length,function(e){for(var n,r=0;r<t;++r)s[(n=l[r]).i]=n.x(e);return s.join("")})}function Dr(e,t){t||(t=[]);var n,r=e?Math.min(t.length,e.length):0,o=t.slice();return function(a){for(n=0;n<r;++n)o[n]=e[n]*(1-a)+t[n]*a;return o}}function Lr(e,t){var n,r=typeof t;return null==t||"boolean"===r?Cr(t):("number"===r?Pr:"string"===r?(n=ar(t))?(t=n,Ar):Vr:t instanceof ar?Ar:t instanceof Date?Or:function(e){return ArrayBuffer.isView(e)&&!(e instanceof DataView)}(t)?Dr:Array.isArray(t)?wr:"function"!=typeof t.valueOf&&"function"!=typeof t.toString||isNaN(t)?Rr:Pr)(e,t)}function Br(e,t){return e=+e,t=+t,function(n){return Math.round(e*(1-n)+t*n)}}function Nr(e){return+e}var Fr=[0,1];function _r(e){return e}function Gr(e,t){return(t-=e=+e)?function(n){return(n-e)/t}:function(e){return function(){return e}}(isNaN(t)?NaN:.5)}function kr(e,t,n){var r=e[0],o=e[1],a=t[0],i=t[1];return o<r?(r=Gr(o,r),a=n(i,a)):(r=Gr(r,o),a=n(a,i)),function(e){return a(r(e))}}function Ur(e,t,n){var r=Math.min(e.length,t.length)-1,o=new Array(r),a=new Array(r),i=-1;for(e[r]<e[0]&&(e=e.slice().reverse(),t=t.slice().reverse());++i<r;)o[i]=Gr(e[i],e[i+1]),a[i]=n(t[i],t[i+1]);return function(t){var n=kn(e,t,1,r)-1;return a[n](o[n](t))}}function zr(e,t){switch(arguments.length){case 0:break;case 1:this.range(e);break;default:this.range(t).domain(e)}return this}var Wr,Hr=/^(?:(.)?([<>=^]))?([+\-( ])?([$#])?(0)?(\d+)?(,)?(\.\d+)?(~)?([a-z%])?$/i;function jr(e){if(!(t=Hr.exec(e)))throw new Error("invalid format: "+e);var t;return new Kr({fill:t[1],align:t[2],sign:t[3],symbol:t[4],zero:t[5],width:t[6],comma:t[7],precision:t[8]&&t[8].slice(1),trim:t[9],type:t[10]})}function Kr(e){this.fill=void 0===e.fill?" ":e.fill+"",this.align=void 0===e.align?">":e.align+"",this.sign=void 0===e.sign?"-":e.sign+"",this.symbol=void 0===e.symbol?"":e.symbol+"",this.zero=!!e.zero,this.width=void 0===e.width?void 0:+e.width,this.comma=!!e.comma,this.precision=void 0===e.precision?void 0:+e.precision,this.trim=!!e.trim,this.type=void 0===e.type?"":e.type+""}function $r(e,t){if((n=(e=t?e.toExponential(t-1):e.toExponential()).indexOf("e"))<0)return null;var n,r=e.slice(0,n);return[r.length>1?r[0]+r.slice(2):r,+e.slice(n+1)]}function qr(e){return(e=$r(Math.abs(e)))?e[1]:NaN}function Xr(e,t){var n=$r(e,t);if(!n)return e+"";var r=n[0],o=n[1];return o<0?"0."+new Array(-o).join("0")+r:r.length>o+1?r.slice(0,o+1)+"."+r.slice(o+1):r+new Array(o-r.length+2).join("0")}jr.prototype=Kr.prototype,Kr.prototype.toString=function(){return this.fill+this.align+this.sign+this.symbol+(this.zero?"0":"")+(void 0===this.width?"":Math.max(1,0|this.width))+(this.comma?",":"")+(void 0===this.precision?"":"."+Math.max(0,0|this.precision))+(this.trim?"~":"")+this.type};var Yr={"%":(e,t)=>(100*e).toFixed(t),b:e=>Math.round(e).toString(2),c:e=>e+"",d:function(e){return Math.abs(e=Math.round(e))>=1e21?e.toLocaleString("en").replace(/,/g,""):e.toString(10)},e:(e,t)=>e.toExponential(t),f:(e,t)=>e.toFixed(t),g:(e,t)=>e.toPrecision(t),o:e=>Math.round(e).toString(8),p:(e,t)=>Xr(100*e,t),r:Xr,s:function(e,t){var n=$r(e,t);if(!n)return e+"";var r=n[0],o=n[1],a=o-(Wr=3*Math.max(-8,Math.min(8,Math.floor(o/3))))+1,i=r.length;return a===i?r:a>i?r+new Array(a-i+1).join("0"):a>0?r.slice(0,a)+"."+r.slice(a):"0."+new Array(1-a).join("0")+$r(e,Math.max(0,t+a-1))[0]},X:e=>Math.round(e).toString(16).toUpperCase(),x:e=>Math.round(e).toString(16)};function Zr(e){return e}var Qr,Jr,eo,to=Array.prototype.map,no=["y","z","a","f","p","n","","m","","k","M","G","T","P","E","Z","Y"];function ro(e){var t=e.domain;return e.ticks=function(e){var n=t();return function(e,t,n){var r,o,a,i,s=-1;if(n=+n,(e=+e)==(t=+t)&&n>0)return[e];if((r=t<e)&&(o=e,e=t,t=o),0===(i=Bn(e,t,n))||!isFinite(i))return[];if(i>0){let n=Math.round(e/i),r=Math.round(t/i);for(n*i<e&&++n,r*i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)*i}else{i=-i;let n=Math.round(e*i),r=Math.round(t*i);for(n/i<e&&++n,r/i>t&&--r,a=new Array(o=r-n+1);++s<o;)a[s]=(n+s)/i}return r&&a.reverse(),a}(n[0],n[n.length-1],null==e?10:e)},e.tickFormat=function(e,n){var r=t();return function(e,t,n,r){var o,a=function(e,t,n){var r=Math.abs(t-e)/Math.max(0,n),o=Math.pow(10,Math.floor(Math.log(r)/Math.LN10)),a=r/o;return a>=Vn?o*=10:a>=Dn?o*=5:a>=Ln&&(o*=2),t<e?-o:o}(e,t,n);switch((r=jr(null==r?",f":r)).type){case"s":var i=Math.max(Math.abs(e),Math.abs(t));return null!=r.precision||isNaN(o=function(e,t){return Math.max(0,3*Math.max(-8,Math.min(8,Math.floor(qr(t)/3)))-qr(Math.abs(e)))}(a,i))||(r.precision=o),eo(r,i);case"":case"e":case"g":case"p":case"r":null!=r.precision||isNaN(o=function(e,t){return e=Math.abs(e),t=Math.abs(t)-e,Math.max(0,qr(t)-qr(e))+1}(a,Math.max(Math.abs(e),Math.abs(t))))||(r.precision=o-("e"===r.type));break;case"f":case"%":null!=r.precision||isNaN(o=function(e){return Math.max(0,-qr(Math.abs(e)))}(a))||(r.precision=o-2*("%"===r.type))}return Jr(r)}(r[0],r[r.length-1],null==e?10:e,n)},e.nice=function(n){null==n&&(n=10);var r,o,a=t(),i=0,s=a.length-1,l=a[i],c=a[s],u=10;for(c<l&&(o=l,l=c,c=o,o=i,i=s,s=o);u-- >0;){if((o=Bn(l,c,n))===r)return a[i]=l,a[s]=c,t(a);if(o>0)l=Math.floor(l/o)*o,c=Math.ceil(c/o)*o;else{if(!(o<0))break;l=Math.ceil(l*o)/o,c=Math.floor(c*o)/o}r=o}return e},e}function oo(){var e=function(){var e,t,n,r,o,a,i=Fr,s=Fr,l=Lr,c=_r;function u(){var e,t,n,l=Math.min(i.length,s.length);return c!==_r&&(e=i[0],t=i[l-1],e>t&&(n=e,e=t,t=n),c=function(n){return Math.max(e,Math.min(t,n))}),r=l>2?Ur:kr,o=a=null,d}function d(t){return null==t||isNaN(t=+t)?n:(o||(o=r(i.map(e),s,l)))(e(c(t)))}return d.invert=function(n){return c(t((a||(a=r(s,i.map(e),Pr)))(n)))},d.domain=function(e){return arguments.length?(i=Array.from(e,Nr),u()):i.slice()},d.range=function(e){return arguments.length?(s=Array.from(e),u()):s.slice()},d.rangeRound=function(e){return s=Array.from(e),l=Br,u()},d.clamp=function(e){return arguments.length?(c=!!e||_r,u()):c!==_r},d.interpolate=function(e){return arguments.length?(l=e,u()):l},d.unknown=function(e){return arguments.length?(n=e,d):n},function(n,r){return e=n,t=r,u()}}()(_r,_r);return e.copy=function(){return t=e,oo().domain(t.domain()).range(t.range()).interpolate(t.interpolate()).clamp(t.clamp()).unknown(t.unknown());var t},zr.apply(e,arguments),ro(e)}Qr=function(e){var t,n,r=void 0===e.grouping||void 0===e.thousands?Zr:(t=to.call(e.grouping,Number),n=e.thousands+"",function(e,r){for(var o=e.length,a=[],i=0,s=t[0],l=0;o>0&&s>0&&(l+s+1>r&&(s=Math.max(1,r-l)),a.push(e.substring(o-=s,o+s)),!((l+=s+1)>r));)s=t[i=(i+1)%t.length];return a.reverse().join(n)}),o=void 0===e.currency?"":e.currency[0]+"",a=void 0===e.currency?"":e.currency[1]+"",i=void 0===e.decimal?".":e.decimal+"",s=void 0===e.numerals?Zr:function(e){return function(t){return t.replace(/[0-9]/g,(function(t){return e[+t]}))}}(to.call(e.numerals,String)),l=void 0===e.percent?"%":e.percent+"",c=void 0===e.minus?"":e.minus+"",u=void 0===e.nan?"NaN":e.nan+"";function d(e){var t=(e=jr(e)).fill,n=e.align,d=e.sign,p=e.symbol,f=e.zero,g=e.width,m=e.comma,h=e.precision,v=e.trim,T=e.type;"n"===T?(m=!0,T="g"):Yr[T]||(void 0===h&&(h=12),v=!0,T="g"),(f||"0"===t&&"="===n)&&(f=!0,t="0",n="=");var y="$"===p?o:"#"===p&&/[boxX]/.test(T)?"0"+T.toLowerCase():"",b="$"===p?a:/[%p]/.test(T)?l:"",x=Yr[T],C=/[defgprs%]/.test(T);function S(e){var o,a,l,p=y,S=b;if("c"===T)S=x(e)+S,e="";else{var A=(e=+e)<0||1/e<0;if(e=isNaN(e)?u:x(Math.abs(e),h),v&&(e=function(e){e:for(var t,n=e.length,r=1,o=-1;r<n;++r)switch(e[r]){case".":o=t=r;break;case"0":0===o&&(o=r),t=r;break;default:if(!+e[r])break e;o>0&&(o=0)}return o>0?e.slice(0,o)+e.slice(t+1):e}(e)),A&&0==+e&&"+"!==d&&(A=!1),p=(A?"("===d?d:c:"-"===d||"("===d?"":d)+p,S=("s"===T?no[8+Wr/3]:"")+S+(A&&"("===d?")":""),C)for(o=-1,a=e.length;++o<a;)if(48>(l=e.charCodeAt(o))||l>57){S=(46===l?i+e.slice(o+1):e.slice(o))+S,e=e.slice(0,o);break}}m&&!f&&(e=r(e,1/0));var I=p.length+e.length+S.length,w=I<g?new Array(g-I+1).join(t):"";switch(m&&f&&(e=r(w+e,w.length?g-S.length:1/0),w=""),n){case"<":e=p+e+S+w;break;case"=":e=p+w+e+S;break;case"^":e=w.slice(0,I=w.length>>1)+p+e+S+w.slice(I);break;default:e=w+p+e+S}return s(e)}return h=void 0===h?6:/[gprs]/.test(T)?Math.max(1,Math.min(21,h)):Math.max(0,Math.min(20,h)),S.toString=function(){return e+""},S}return{format:d,formatPrefix:function(e,t){var n=d(((e=jr(e)).type="f",e)),r=3*Math.max(-8,Math.min(8,Math.floor(qr(t)/3))),o=Math.pow(10,-r),a=no[8+r/3];return function(e){return n(o*e)+a}}}}({thousands:",",grouping:[3],currency:["$",""]}),Jr=Qr.format,eo=Qr.formatPrefix;var ao=n(318),io=n.n(ao);const so=[1,0,0,0,0,1,0,0,0,0,1,0,0,0,0,1],lo=[1,0,0,0,1,0,0,0,1],co=1e-6,uo=1e-12,{vtkErrorMacro:po,vtkWarningMacro:fo}=Ht;let go=0;function mo(e){return()=>po(`vtkMath::${e} - NOT IMPLEMENTED`)}function ho(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[n*t+a],e[n*t+a]=e[r*t+a],e[r*t+a]=o}function vo(e,t,n,r){let o;for(let a=0;a<t;a++)o=e[a*t+n],e[a*t+n]=e[a*t+r],e[a*t+r]=o}function To(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:3;const t=Array(e);for(let n=0;n<e;++n)t[n]=0;return t}function yo(e){return e/180*Math.PI}function bo(e){return 180*e/Math.PI}const{round:xo,floor:Co,ceil:So,min:Ao,max:Io}=Math;const wo=mo("ceilLog2"),Oo=mo("factorial");function Po(e){let t=1;for(;t<e;)t*=2;return t}function Ro(e){return e===Po(e)}const Mo=mo("gaussian");function Eo(e,t,n){return n[0]=e[0]+t[0],n[1]=e[1]+t[1],n[2]=e[2]+t[2],n}function Vo(e,t,n){return n[0]=e[0]-t[0],n[1]=e[1]-t[1],n[2]=e[2]-t[2],n}function Do(e,t){return e[0]*=t,e[1]*=t,e[2]*=t,e}function Lo(e,t){return e[0]*=t,e[1]*=t,e}function Bo(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r[2]=e[2]+t[2]*n,r}function No(e,t){return e[0]*t[0]+e[1]*t[1]+e[2]*t[2]}function Fo(e,t,n){const r=e[1]*t[2]-e[2]*t[1],o=e[2]*t[0]-e[0]*t[2],a=e[0]*t[1]-e[1]*t[0];return n[0]=r,n[1]=o,n[2]=a,n}function _o(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;switch(t){case 1:return Math.abs(e);case 2:return Math.sqrt(e[0]*e[0]+e[1]*e[1]);case 3:return Math.sqrt(e[0]*e[0]+e[1]*e[1]+e[2]*e[2]);default:{let n=0;for(let r=0;r<t;r++)n+=e[r]*e[r];return Math.sqrt(n)}}}function Go(e){const t=_o(e);return 0!==t&&(e[0]/=t,e[1]/=t,e[2]/=t),t}function ko(e,t){return e[0]*t[0]+e[1]*t[1]}function Uo(e,t){return(e[0]-t[0])*(e[0]-t[0])+(e[1]-t[1])*(e[1]-t[1])+(e[2]-t[2])*(e[2]-t[2])}function zo(e){return Math.sqrt(e[0]*e[0]+e[1]*e[1])}function Wo(e){const t=zo(e);return 0!==t&&(e[0]/=t,e[1]/=t),t}function Ho(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return 2===t.length?t[0][0]*t[1][1]-t[1][0]*t[0][1]:4===t.length?t[0]*t[3]-t[1]*t[2]:Number.NaN}function jo(e,t,n){const r=e[0]*t[0]+e[1]*t[1]+e[2]*t[2],o=e[3]*t[0]+e[4]*t[1]+e[5]*t[2],a=e[6]*t[0]+e[7]*t[1]+e[8]*t[2];n[0]=r,n[1]=o,n[2]=a}function Ko(e,t,n){const r=[...e],o=[...t];for(let e=0;e<3;e++)n[e]=r[0]*o[e]+r[1]*o[e+3]+r[2]*o[e+6],n[e+3]=r[3]*o[e]+r[4]*o[e+3]+r[5]*o[e+6],n[e+6]=r[6]*o[e]+r[7]*o[e+3]+r[8]*o[e+6]}function $o(e,t){let n;n=e[3],t[3]=e[1],t[1]=n,n=e[6],t[6]=e[2],t[2]=n,n=e[7],t[7]=e[5],t[5]=n,t[0]=e[0],t[4]=e[4],t[8]=e[8]}function qo(e){return e[0]*e[4]*e[8]+e[3]*e[7]*e[2]+e[6]*e[1]*e[5]-e[0]*e[7]*e[5]-e[3]*e[1]*e[8]-e[6]*e[4]*e[2]}function Xo(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:co;return e.length===t.length&&e.every((function(e,r){return Math.abs(e-t[r])<=n}))}const Yo=Xo;function Zo(e){for(let t=0;t<3;t++)e[3*t]=e[3*t+1]=e[3*t+2]=0,e[3*t+t]=1}function Qo(e,t){for(let n=0;n<e;n++){for(let r=0;r<e;r++)t[n*e+r]=0;t[n*e+n]=1}return t}function Jo(e,t){const n=e[0]*e[0],r=e[0]*e[1],o=e[0]*e[2],a=e[0]*e[3],i=e[1]*e[1],s=e[2]*e[2],l=e[3]*e[3],c=e[1]*e[2],u=e[1]*e[3],d=e[2]*e[3],p=i+s+l;let f=1/(n+p);const g=(n-p)*f;f*=2,t[0]=i*f+g,t[3]=(c+a)*f,t[6]=(u-o)*f,t[1]=(c-a)*f,t[4]=s*f+g,t[7]=(d+r)*f,t[2]=(u+o)*f,t[5]=(d-r)*f,t[8]=l*f+g}function ea(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!`${e}`.includes("e"))return+`${Math.round(`${e}e+${t}`)}e-${t}`;const n=`${e}`.split("e");let r="";return+n[1]+t>0&&(r="+"),+`${Math.round(`${+n[0]}e${r}${+n[1]+t}`)}e-${t}`}function ta(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,0,0],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return t[0]=ea(e[0],n),t[1]=ea(e[1],n),t[2]=ea(e[2],n),t}function na(e,t,n,r){let o,a,i,s,l,c,u,d,p,f,g,m,h,v,T,y;const b=To(t),x=To(t),C=(e,t,n)=>{v=e[t],h=e[n],e[t]=v-m*(h+v*f),e[n]=h+m*(v-h*f)};for(Qo(t,r),l=0;l<t;l++)b[l]=n[l]=e[l+l*t],x[l]=0;for(o=0;o<20;o++){for(g=0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)g+=Math.abs(e[l*t+s]);if(0===g)break;for(u=o<3?.2*g/(t*t):0,l=0;l<t-1;l++)for(s=l+1;s<t;s++)if(v=100*Math.abs(e[l*t+s]),o>3&&Math.abs(n[l])+v===Math.abs(n[l])&&Math.abs(n[s])+v===Math.abs(n[s]))e[l*t+s]=0;else if(Math.abs(e[l*t+s])>u){for(h=n[s]-n[l],Math.abs(h)+v===Math.abs(h)?p=e[l*t+s]/h:(d=.5*h/e[l*t+s],p=1/(Math.abs(d)+Math.sqrt(1+d*d)),d<0&&(p=-p)),T=1/Math.sqrt(1+p*p),m=p*T,f=m/(1+T),h=p*e[l*t+s],x[l]-=h,x[s]+=h,n[l]-=h,n[s]+=h,e[l*t+s]=0,a=0;a<=l-1;a++)C(e,a*t+l,a*t+s);for(a=l+1;a<=s-1;a++)C(e,l*t+a,a*t+s);for(a=s+1;a<t;a++)C(e,l*t+a,s*t+a);for(a=0;a<t;a++)C(r,a*t+l,a*t+s)}for(l=0;l<t;l++)b[l]+=x[l],n[l]=b[l],x[l]=0}if(o>=20)return fo("vtkMath::Jacobi: Error extracting eigenfunctions"),0;for(a=0;a<t-1;a++){for(i=a,y=n[i],o=a+1;o<t;o++)(n[o]>=y||Math.abs(n[o]-y)<uo)&&(i=o,y=n[i]);i!==a&&(n[i]=n[a],n[a]=y,vo(r,t,a,i))}const S=(t>>1)+(1&t);for(c=0,o=0;o<t*t;o++)r[o]>=0&&c++;if(c<S)for(o=0;o<t;o++)r[o*t+a]*=-1;return 1}function ra(e,t){const n=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];n[0]=e[0]+e[4]+e[8],n[5]=e[0]-e[4]-e[8],n[10]=-e[0]+e[4]-e[8],n[15]=-e[0]-e[4]+e[8],n[1]=n[4]=e[7]-e[5],n[2]=n[8]=e[2]-e[6],n[3]=n[12]=e[3]-e[1],n[6]=n[9]=e[3]+e[1],n[7]=n[13]=e[2]+e[6],n[11]=n[14]=e[7]+e[5];const r=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];na([...n],4,[0,0,0,0],r),t[0]=r[0],t[1]=r[4],t[2]=r[8],t[3]=r[12]}function oa(e,t){for(let n=0;n<9;n++)t[n]=e[n];const n=To(3),r=To(3);let o;for(let e=0;e<3;e++){const r=Math.abs(t[3*e]),a=Math.abs(t[3*e+1]),i=Math.abs(t[3*e+2]);o=a>r?a:r,o=i>o?i:o,n[e]=1,0!==o&&(n[e]/=o)}const a=Math.abs(t[0])*n[0],i=Math.abs(t[3])*n[1],s=Math.abs(t[6])*n[2];r[0]=0,o=a,i>=o&&(o=i,r[0]=1),s>=o&&(r[0]=2),0!==r[0]&&(vo(t,3,r[0],0),n[r[0]]=n[0]);const l=Math.abs(t[4])*n[1],c=Math.abs(t[7])*n[2];r[1]=1,o=l,c>=o&&(r[1]=2,vo(t,3,1,2)),r[2]=2;let u=0;if(qo(t)<0){u=1;for(let e=0;e<9;e++)t[e]=-t[e]}const d=To(4);if(ra(t,d),Jo(d,t),u)for(let e=0;e<9;e++)t[e]=-t[e];1!==r[1]&&vo(t,3,r[1],1),0!==r[0]&&vo(t,3,r[0],0)}function aa(e,t,n){let r,o,a,i,s,l;if(na([...e],3,t,n),t[0]!==t[1]||t[0]!==t[2]){for($o(n,n),r=0;r<3;r++)if(t[(r+1)%3]===t[(r+2)%3]){for(l=Math.abs(n[3*r]),i=0,o=1;o<3;o++)l<(s=Math.abs(n[3*r+o]))&&(l=s,i=o);i!==r&&(s=t[i],t[i]=t[r],t[r]=s,ho(n,3,r,i)),n[3*i+i]<0&&(n[3*i]=-n[3*i],n[3*i+1]=-n[3*i+1],n[3*i+2]=-n[3*i+2]),o=(i+1)%3,a=(i+2)%3,n[3*o]=0,n[3*o+1]=0,n[3*o+2]=0,n[3*o+o]=1;const e=Fo([n[3*i],n[3*i+1],n[3*i+2]],[n[3*o],n[3*o+1],n[3*o+2]],[]);Go(e);const c=Fo(e,[n[3*i],n[3*i+1],n[3*i+2]],[]);for(let t=0;t<3;t++)n[3*a+t]=e[t],n[3*o+t]=c[t];return void $o(n,n)}for(l=Math.abs(n[0]),i=0,r=1;r<3;r++)l<(s=Math.abs(n[3*r]))&&(l=s,i=r);if(0!==i){const e=t[i];t[i]=t[0],t[0]=e,ho(n,3,i,0)}if(Math.abs(n[4])<Math.abs(n[7])){const e=t[2];t[2]=t[1],t[1]=e,ho(n,3,1,2)}for(r=0;r<2;r++)n[3*r+r]<0&&(n[3*r]=-n[3*r],n[3*r+1]=-n[3*r+1],n[3*r+2]=-n[3*r+2]);qo(n)<0&&(n[6]=-n[6],n[7]=-n[7],n[8]=-n[8]),$o(n,n)}else Zo(n)}function ia(e,t,n){let r,o,a,i,s,l,c,u=0;const d=To(n);for(r=0;r<n;r++){for(i=0,o=0;o<n;o++)(c=Math.abs(e[r*n+o]))>i&&(i=c);if(0===i)return fo("Unable to factor linear system"),0;d[r]=1/i}for(o=0;o<n;o++){for(r=0;r<o;r++){for(s=e[r*n+o],a=0;a<r;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s}for(i=0,r=o;r<n;r++){for(s=e[r*n+o],a=0;a<o;a++)s-=e[r*n+a]*e[a*n+o];e[r*n+o]=s,(l=d[r]*Math.abs(s))>=i&&(i=l,u=r)}if(o!==u){for(a=0;a<n;a++)l=e[u*n+a],e[u*n+a]=e[o*n+a],e[o*n+a]=l;d[u]=d[o]}if(t[o]=u,Math.abs(e[o*n+o])<=uo)return fo("Unable to factor linear system"),0;if(o!==n-1)for(l=1/e[o*n+o],r=o+1;r<n;r++)e[r*n+o]*=l}return 1}function sa(e,t,n,r){let o,a,i,s,l;for(i=-1,o=0;o<r;o++){if(s=t[o],l=n[s],n[s]=n[o],i>=0)for(a=i;a<=o-1;a++)l-=e[o*r+a]*n[a];else 0!==l&&(i=o);n[o]=l}for(o=r-1;o>=0;o--){for(l=n[o],a=o+1;a<r;a++)l-=e[o*r+a]*n[a];n[o]=l/e[o*r+o]}}function la(e,t,n){if(2===n){const n=To(2),r=Ho(e[0],e[1],e[2],e[3]);return 0===r?0:(n[0]=(e[3]*t[0]-e[1]*t[1])/r,n[1]=(-e[2]*t[0]+e[0]*t[1])/r,t[0]=n[0],t[1]=n[1],1)}if(1===n)return 0===e[0]?0:(t[0]/=e[0],1);const r=To(n);return 0===ia(e,r,n)?0:(sa(e,r,t,n),1)}function ca(e,t,n){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const o=(arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)||To(n),a=r||To(n);if(0===ia(e,o,n))return null;for(let r=0;r<n;r++){for(let e=0;e<n;e++)a[e]=0;a[r]=1,sa(e,o,a,n);for(let e=0;e<n;e++)t[e*n+r]=a[e]}return t}function ua(e,t,n,r){if(e<n)return fo("Insufficient number of samples. Underdetermined."),0;let o,a,i;const s=To(n*n),l=To(n),c=To(n*n);for(i=0;i<e;i++)for(o=0;o<n;o++)for(a=o;a<n;a++)s[o*n+a]+=t[i*n+o]*t[i*n+a];for(o=0;o<n;o++)for(a=0;a<o;a++)s[o*n+a]=s[a*n+o];for(na(s,n,l,c),o=0;o<n;o++)r[o]=c[o*n+n-1];return 1}function da(e,t){let n,r;const[o,a,i]=e,s=1/6;let l=o,c=o;a>l?l=a:a<c&&(c=a),i>l?l=i:i<c&&(c=i);const u=l;r=u>0?(l-c)/l:0,r>0?(n=o===l?s*(a-i)/(l-c):a===l?1/3+s*(i-o)/(l-c):2/3+s*(o-a)/(l-c),n<0&&(n+=1)):n=0,t[0]=n,t[1]=r,t[2]=u}function pa(e,t){const[n,r,o]=e,a=1/3,i=1/6,s=2/3,l=5/6;let c,u,d;n>i&&n<=a?(u=1,c=(a-n)/i,d=0):n>a&&n<=.5?(u=1,d=(n-a)/i,c=0):n>.5&&n<=s?(d=1,u=(s-n)/i,c=0):n>s&&n<=l?(d=1,c=(n-s)/i,u=0):n>l&&n<=1?(c=1,d=(1-n)/i,u=0):(c=1,u=n/i,d=0),c=r*c+(1-r),u=r*u+(1-r),d=r*d+(1-r),c*=o,u*=o,d*=o,t[0]=c,t[1]=u,t[2]=d}function fa(e,t){const[n,r,o]=e;let a=(n+16)/116,i=r/500+a,s=a-o/200;a**3>.008856?a**=3:a=(a-16/116)/7.787,i**3>.008856?i**=3:i=(i-16/116)/7.787,s**3>.008856?s**=3:s=(s-16/116)/7.787,t[0]=.9505*i,t[1]=1*a,t[2]=1.089*s}function ga(e,t){const[n,r,o]=e;let a=n/.9505,i=r/1,s=o/1.089;a>.008856?a**=1/3:a=7.787*a+16/116,i>.008856?i**=1/3:i=7.787*i+16/116,s>.008856?s**=1/3:s=7.787*s+16/116,t[0]=116*i-16,t[1]=500*(a-i),t[2]=200*(i-s)}function ma(e,t){const[n,r,o]=e;let a=3.2406*n+-1.5372*r+-.4986*o,i=-.9689*n+1.8758*r+.0415*o,s=.0557*n+-.204*r+1.057*o;a>.0031308?a=1.055*a**(1/2.4)-.055:a*=12.92,i>.0031308?i=1.055*i**(1/2.4)-.055:i*=12.92,s>.0031308?s=1.055*s**(1/2.4)-.055:s*=12.92;let l=a;l<i&&(l=i),l<s&&(l=s),l>1&&(a/=l,i/=l,s/=l),a<0&&(a=0),i<0&&(i=0),s<0&&(s=0),t[0]=a,t[1]=i,t[2]=s}function ha(e,t){let[n,r,o]=e;n>.04045?n=((n+.055)/1.055)**2.4:n/=12.92,r>.04045?r=((r+.055)/1.055)**2.4:r/=12.92,o>.04045?o=((o+.055)/1.055)**2.4:o/=12.92,t[0]=.4124*n+.3576*r+.1805*o,t[1]=.2126*n+.7152*r+.0722*o,t[2]=.0193*n+.1192*r+.9505*o}function va(e,t){const n=[0,0,0];ha(e,n),ga(n,t)}function Ta(e,t){const n=[0,0,0];fa(e,n),ma(n,t)}function ya(e){return e[0]=1,e[1]=-1,e[2]=1,e[3]=-1,e[4]=1,e[5]=-1,e}function ba(e){return!(e[1]-e[0]<0)}function xa(e,t,n){return e<t?t:e>n?n:e}function Ca(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[0,0,0];return r[0]=xa(e[0],t[0],n[0]),r[1]=xa(e[1],t[1],n[1]),r[2]=xa(e[2],t[2],n[2]),r}const Sa=mo("GetScalarTypeFittingRange"),Aa=mo("GetAdjustedScalarRange");const Ia=e=>!Number.isFinite(e),{isFinite:wa,isNaN:Oa}=Number,Pa=Oa;function Ra(){return[].concat([Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE])}function Ma(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;const n=new Array(t),r=new Array(t);for(let e=0;e<t;++e)n[e]=e,r[e]=e;for(let o=t-1;o>0;o--){let a=-1/0,i=0,s=0;for(let l=0;l<=o;++l){const c=n[l];for(let n=0;n<=o;++n){const o=r[n],u=Math.abs(e[c+t*o]);u>a&&(a=u,i=l,s=n)}}[n[o],n[i]]=[n[i],n[o]],[r[o],r[s]]=[r[s],r[o]]}const o=new Array(t*t).fill(0);for(let a=0;a<t;++a){const i=n[a]+t*r[a];o[i]=e[i]<0?-1:1}return o}function Ea(e){const t=Math.floor(255*e);return t>15?t.toString(16):`0${t.toString(16)}`}function Va(e){return Math.round(255*e)}var Da,La={Pi:()=>Math.PI,ldexp:function(e,t){return t>1023?e*2**1023*2**(t-1023):t<-1074?5e-324*e*2**(t+1074):e*2**t},radiansFromDegrees:yo,degreesFromRadians:bo,round:xo,floor:Co,ceil:So,ceilLog2:wo,min:Ao,max:Io,arrayMin:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=1/0;for(let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=e.length;r<o;r+=t)e[r]<n&&(n=e[r]);return n},arrayMax:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=-1/0;for(let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,o=e.length;r<o;r+=t)n<e[r]&&(n=e[r]);return n},arrayRange:function(e){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,n=1/0,r=-1/0;for(let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,a=e.length;o<a;o+=t)e[o]<n&&(n=e[o]),r<e[o]&&(r=e[o]);return[n,r]},isPowerOfTwo:Ro,nearestPowerOfTwo:Po,factorial:Oo,binomial:function(e,t){let n=1;for(let r=1;r<=t;++r)n*=(e-r+1)/r;return Math.floor(n)},beginCombination:function(e,t){if(e<t)return 0;const n=To(t);for(let e=0;e<t;++e)n[e]=e;return n},nextCombination:function(e,t,n){let r=0;for(let o=t-1;o>=0;--o)if(n[o]<e-t+o){let e=n[o]+1;for(;o<t;)n[o++]=e++;r=1;break}return r},randomSeed:function(e){io()(`${e}`,{global:!0}),go=e},getSeed:function(){return go},random:function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e+((arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)-e)*Math.random()},gaussian:Mo,add:Eo,subtract:Vo,multiplyScalar:Do,multiplyScalar2D:Lo,multiplyAccumulate:Bo,multiplyAccumulate2D:function(e,t,n,r){return r[0]=e[0]+t[0]*n,r[1]=e[1]+t[1]*n,r},dot:No,outer:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[0]*t[2],n[3]=e[1]*t[0],n[4]=e[1]*t[1],n[5]=e[1]*t[2],n[6]=e[2]*t[0],n[7]=e[2]*t[1],n[8]=e[2]*t[2]},cross:Fo,norm:_o,normalize:Go,perpendiculars:function(e,t,n,r){const o=e[0]*e[0],a=e[1]*e[1],i=e[2]*e[2],s=Math.sqrt(o+a+i);let l,c,u;o>a&&o>i?(l=0,c=1,u=2):a>i?(l=1,c=2,u=0):(l=2,c=0,u=1);const d=e[l]/s,p=e[c]/s,f=e[u]/s,g=Math.sqrt(d*d+f*f);if(0!==r){const e=Math.sin(r),o=Math.cos(r);t&&(t[l]=(f*o-d*p*e)/g,t[c]=e*g,t[u]=(-d*o-p*f*e)/g),n&&(n[l]=(-f*e-d*p*o)/g,n[c]=o*g,n[u]=(d*e-p*f*o)/g)}else t&&(t[l]=f/g,t[c]=0,t[u]=-d/g),n&&(n[l]=-d*p/g,n[c]=g,n[u]=-p*f/g)},projectVector:function(e,t,n){const r=No(t,t);if(0===r)return n[0]=0,n[1]=0,n[2]=0,!1;const o=No(e,t)/r;for(let e=0;e<3;e++)n[e]=t[e];return Do(n,o),!0},projectVector2D:function(e,t,n){const r=ko(t,t);if(0===r)return n[0]=0,n[1]=0,!1;const o=ko(e,t)/r;for(let e=0;e<2;e++)n[e]=t[e];return Lo(n,o),!0},distance2BetweenPoints:Uo,angleBetweenVectors:function(e,t){const n=[0,0,0];return Fo(e,t,n),Math.atan2(_o(n),No(e,t))},gaussianAmplitude:function(e,t,n){const r=Math.abs(e-n);return 1/Math.sqrt(2*Math.PI*t)*Math.exp(-(r**2)/(2*t))},gaussianWeight:function(e,t,n){const r=Math.abs(e-n);return Math.exp(-(r**2)/(2*t))},dot2D:ko,outer2D:function(e,t,n){n[0]=e[0]*t[0],n[1]=e[0]*t[1],n[2]=e[1]*t[0],n[3]=e[1]*t[1]},norm2D:zo,normalize2D:Wo,determinant2x2:Ho,LUFactor3x3:function(e,t){let n,r,o;const a=[0,0,0];for(let t=0;t<3;t++)o=Math.abs(e[3*t]),(r=Math.abs(e[3*t+1]))>o&&(o=r),(r=Math.abs(e[3*t+2]))>o&&(o=r),a[t]=1/o;o=a[0]*Math.abs(e[0]),n=0,(r=a[1]*Math.abs(e[3]))>=o&&(o=r,n=1),(r=a[2]*Math.abs(e[6]))>=o&&(n=2),0!==n&&(ho(e,3,n,0),a[n]=a[0]),t[0]=n,e[3]/=e[0],e[6]/=e[0],e[4]-=e[3]*e[1],e[7]-=e[6]*e[1],o=a[1]*Math.abs(e[4]),n=1,(r=a[2]*Math.abs(e[7]))>=o&&(n=2,ho(e,3,1,2),a[2]=a[1]),t[1]=n,e[7]/=e[4],e[5]-=e[3]*e[2],e[8]-=e[6]*e[2]+e[7]*e[5],t[2]=2},LUSolve3x3:function(e,t,n){let r=n[t[0]];n[t[0]]=n[0],n[0]=r,r=n[t[1]],n[t[1]]=n[1],n[1]=r-e[3]*n[0],r=n[t[2]],n[t[2]]=n[2],n[2]=r-e[6]*n[0]-e[7]*n[1],n[2]/=e[8],n[1]=(n[1]-e[5]*n[2])/e[4],n[0]=(n[0]-e[1]*n[1]-e[2]*n[2])/e[0]},linearSolve3x3:function(e,t,n){const r=e[0],o=e[1],a=e[2],i=e[3],s=e[4],l=e[5],c=e[6],u=e[7],d=e[8],p=+Ho(s,u,l,d),f=-Ho(i,c,l,d),g=+Ho(i,c,s,u),m=-Ho(o,u,a,d),h=+Ho(r,c,a,d),v=-Ho(r,c,o,u),T=+Ho(o,s,a,l),y=-Ho(r,i,a,l),b=+Ho(r,i,o,s),x=r*p+o*f+a*g,C=p*t[0]+m*t[1]+T*t[2],S=f*t[0]+h*t[1]+y*t[2],A=g*t[0]+v*t[1]+b*t[2];n[0]=C/x,n[1]=S/x,n[2]=A/x},multiply3x3_vect3:jo,multiply3x3_mat3:Ko,multiplyMatrix:function(e,t,n,r,o,a,i){r!==o&&po("Number of columns of A must match number of rows of B.");const s=[...e],l=[...t];for(let e=0;e<n;e++)for(let t=0;t<a;t++){i[e*a+t]=0;for(let n=0;n<r;n++)i[e*a+t]+=s[e*r+n]*l[t+a*n]}},transpose3x3:$o,invert3x3:function(e,t){const n=e[0],r=e[1],o=e[2],a=e[3],i=e[4],s=e[5],l=e[6],c=e[7],u=e[8],d=+Ho(i,c,s,u),p=-Ho(a,l,s,u),f=+Ho(a,l,i,c),g=-Ho(r,c,o,u),m=+Ho(n,l,o,u),h=-Ho(n,l,r,c),v=+Ho(r,i,o,s),T=-Ho(n,a,o,s),y=+Ho(n,a,r,i),b=n*d+r*p+o*f;0===b&&fo("Matrix has 0 determinant"),t[0]=d/b,t[3]=p/b,t[6]=f/b,t[1]=g/b,t[4]=m/b,t[7]=h/b,t[2]=v/b,t[5]=T/b,t[8]=y/b},identity3x3:Zo,identity:Qo,isIdentity:function(e){return Yo(e,so,arguments.length>1&&void 0!==arguments[1]?arguments[1]:co)},isIdentity3x3:function(e){return Yo(e,lo,arguments.length>1&&void 0!==arguments[1]?arguments[1]:co)},determinant3x3:qo,quaternionToMatrix3x3:Jo,areEquals:Xo,areMatricesEqual:Yo,roundNumber:ea,roundVector:ta,matrix3x3ToQuaternion:ra,multiplyQuaternion:function(e,t,n){const r=e[0]*t[0],o=e[0]*t[1],a=e[0]*t[2],i=e[0]*t[3],s=e[1]*t[0],l=e[1]*t[1],c=e[1]*t[2],u=e[1]*t[3],d=e[2]*t[0],p=e[2]*t[1],f=e[2]*t[2],g=e[2]*t[3],m=e[3]*t[0],h=e[3]*t[1],v=e[3]*t[2],T=e[3]*t[3];n[0]=r-l-f-T,n[1]=o+s+g-v,n[2]=a-u+d+h,n[3]=i+c-p+m},orthogonalize3x3:oa,diagonalize3x3:aa,singularValueDecomposition3x3:function(e,t,n,r){let o;const a=[...e],i=qo(a);if(i<0)for(o=0;o<9;o++)a[o]=-a[o];oa(a,t),$o(a,a),Ko(a,t,r),aa(r,n,r),Ko(t,r,t),$o(r,r),i<0&&(n[0]=-n[0],n[1]=-n[1],n[2]=-n[2])},solveLinearSystem:la,invertMatrix:ca,luFactorLinearSystem:ia,luSolveLinearSystem:sa,estimateMatrixCondition:function(e,t){let n=+Number.MAX_VALUE,r=-Number.MAX_VALUE;for(let n=0;n<t;n++)for(let o=n;o<t;o++)Math.abs(e[n*t+o])>r&&(r=Math.abs(e[n*t+o]));for(let r=0;r<t;r++)Math.abs(e[r*t+r])<n&&(n=Math.abs(e[r*t+r]));return 0===n?Number.MAX_VALUE:r/n},jacobi:function(e,t,n){return na(e,3,t,n)},jacobiN:na,solveHomogeneousLeastSquares:ua,solveLeastSquares:function(e,t,n,r,o,a){let i=!(arguments.length>6&&void 0!==arguments[6])||arguments[6];if(e<n||e<o)return fo("Insufficient number of samples. Underdetermined."),0;const s=To(o);let l,c,u,d,p=1,f=0,g=0;if(i){for(u=0;u<o;u++)s[u]=1;for(c=0;c<e;c++)for(u=0;u<o;u++)Math.abs(r[c*o+u])>uo&&(p=0,s[u]=0);if(p&&1===o)return fo("Detected homogeneous system (Y=0), calling SolveHomogeneousLeastSquares()"),ua(e,t,n,a);if(p)g=1;else for(u=0;u<o;u++)s[u]&&(g=1)}g&&(l=To(n),f=ua(e,t,n,l));const m=To(n*n),h=To(n*n),v=To(n*o);for(d=0;d<e;d++)for(c=0;c<n;c++){for(u=c;u<n;u++)m[c*n+u]+=t[d*n+c]*t[d*n+u];for(u=0;u<o;u++)v[c*o+u]+=t[d*n+c]*r[d*o+u]}for(c=0;c<n;c++)for(u=0;u<c;u++)m[c*n+u]=m[u*n+c];const T=ca(m,h,n);if(T)for(c=0;c<n;c++)for(u=0;u<o;u++)for(a[c*o+u]=0,d=0;d<n;d++)a[c*o+u]+=h[c*n+d]*v[d*o+u];if(g)for(u=0;u<o;u++)if(s[u])for(c=0;c<n;c++)a[c*o+u]=l[c*o];return g?f&&T:T},hex2float:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[0,.5,1];switch(e.length){case 3:return t[0]=17*parseInt(e[0],16)/255,t[1]=17*parseInt(e[1],16)/255,t[2]=17*parseInt(e[2],16)/255,t;case 4:return t[0]=17*parseInt(e[1],16)/255,t[1]=17*parseInt(e[2],16)/255,t[2]=17*parseInt(e[3],16)/255,t;case 6:return t[0]=parseInt(e.substr(0,2),16)/255,t[1]=parseInt(e.substr(2,2),16)/255,t[2]=parseInt(e.substr(4,2),16)/255,t;case 7:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t;case 9:return t[0]=parseInt(e.substr(1,2),16)/255,t[1]=parseInt(e.substr(3,2),16)/255,t[2]=parseInt(e.substr(5,2),16)/255,t[3]=parseInt(e.substr(7,2),16)/255,t;default:return t}},rgb2hsv:da,hsv2rgb:pa,lab2xyz:fa,xyz2lab:ga,xyz2rgb:ma,rgb2xyz:ha,rgb2lab:va,lab2rgb:Ta,uninitializeBounds:ya,areBoundsInitialized:ba,computeBoundsFromPoints:function(e,t,n){return n[0]=Math.min(e[0],t[0]),n[1]=Math.max(e[0],t[0]),n[2]=Math.min(e[1],t[1]),n[3]=Math.max(e[1],t[1]),n[4]=Math.min(e[2],t[2]),n[5]=Math.max(e[2],t[2]),n},clampValue:xa,clampVector:Ca,clampAndNormalizeValue:function(e,t){let n=0;return t[0]!==t[1]&&(n=e<t[0]?t[0]:e>t[1]?t[1]:e,n=(n-t[0])/(t[1]-t[0])),n},getScalarTypeFittingRange:Sa,getAdjustedScalarRange:Aa,extentIsWithinOtherExtent:function(e,t){if(!e||!t)return 0;for(let n=0;n<6;n+=2)if(e[n]<t[n]||e[n]>t[n+1]||e[n+1]<t[n]||e[n+1]>t[n+1])return 0;return 1},boundsIsWithinOtherBounds:function(e,t,n){if(!e||!t)return 0;for(let r=0;r<6;r+=2)if(e[r]+n[r/2]<t[r]||e[r]-n[r/2]>t[r+1]||e[r+1]+n[r/2]<t[r]||e[r+1]-n[r/2]>t[r+1])return 0;return 1},pointIsWithinBounds:function(e,t,n){if(!e||!t||!n)return 0;for(let r=0;r<3;r++)if(e[r]+n[r]<t[2*r]||e[r]-n[r]>t[2*r+1])return 0;return 1},solve3PointCircle:function(e,t,n,r){const o=To(3),a=To(3),i=To(3),s=To(3),l=To(3),c=To(3);for(let r=0;r<3;++r)o[r]=e[r]-t[r],a[r]=t[r]-n[r],i[r]=n[r]-e[r],s[r]=-o[r],l[r]=-a[r],c[r]=-i[r];const u=_o(s),d=_o(l),p=_o(i),f=To(3);Fo(o,a,f);const g=_o(f),m=u*d*p/(2*g),h=2*g*g,v=d*d*No(o,c)/h,T=p*p*No(s,a)/h,y=u*u*No(i,l)/h;for(let o=0;o<3;++o)r[o]=v*e[o]+T*t[o]+y*n[o];return m},inf:1/0,negInf:-1/0,isInf:Ia,isNan:Oa,isNaN:Oa,isFinite:wa,createUninitializedBounds:Ra,getMajorAxisIndex:function(e){let t=-1,n=-1;for(let r=0;r<e.length;r++){const o=Math.abs(e[r]);o>t&&(n=r,t=o)}return n},getSparseOrthogonalMatrix:Ma,floatToHex2:Ea,floatRGB2HexCode:function(e){return`${arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#"}${e.map(Ea).join("")}`},float2CssRGBA:function(e){return 3===e.length?`rgb(${e.map(Va).join(", ")})`:`rgba(${Va(e[0]||0)}, ${Va(e[1]||0)}, ${Va(e[2]||0)}, ${e[3]||0})`}};function Ba(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3];return e[0]=n[0]*r+n[4]*o+n[8]*a+n[12]*i,e[1]=n[1]*r+n[5]*o+n[9]*a+n[13]*i,e[2]=n[2]*r+n[6]*o+n[10]*a+n[14]*i,e[3]=n[3]*r+n[7]*o+n[11]*a+n[15]*i,e}function Na(){var e=new i(4);return i!=Float32Array&&(e[0]=0,e[1]=0,e[2]=0),e[3]=1,e}function Fa(e,t,n){n*=.5;var r=Math.sin(n);return e[0]=r*t[0],e[1]=r*t[1],e[2]=r*t[2],e[3]=Math.cos(n),e}function _a(e,t,n){var r=t[0],o=t[1],a=t[2],i=t[3],s=n[0],l=n[1],c=n[2],u=n[3];return e[0]=r*u+i*s+o*c-a*l,e[1]=o*u+i*l+a*s-r*c,e[2]=a*u+i*c+r*l-o*s,e[3]=i*u-r*s-o*l-a*c,e}Da=new i(4),i!=Float32Array&&(Da[0]=0,Da[1]=0,Da[2]=0,Da[3]=0);var Ga=function(e,t,n,r){var o=new i(4);return o[0]=e,o[1]=t,o[2]=n,o[3]=r,o};gn(),hn(1,0,0),hn(0,1,0),Na(),Na(),ie();const ka={};function Ua(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ka,n),Ht.obj(e,t),Ht.setGet(e,t,["transform"]),function(e,t){t.classHierarchy.push("vtkImplicitFunction"),e.functionValue=n=>{if(!t.transform)return e.evaluateFunction(n);const r=[];return t.transform.transformPoint(n,r),e.evaluateFunction(r)},e.evaluateFunction=e=>{Ht.vtkErrorMacro("not implemented")}}(e,t)}var za={newInstance:Ht.newInstance(Ua,"vtkImplicitFunction"),extend:Ua};const Wa=1e-6,Ha="coincide",ja="disjoint";function Ka(e,t,n){const r=n[0]*(e[0]-t[0])+n[1]*(e[1]-t[1])+n[2]*(e[2]-t[2]);return Math.abs(r)}function $a(e,t,n,r){const o=[];Vo(e,t,o);const a=No(n,o);r[0]=e[0]-a*n[0],r[1]=e[1]-a*n[1],r[2]=e[2]-a*n[2]}function qa(e,t,n){const r=No(e,t);let o=No(t,t);return 0===o&&(o=1),n[0]=e[0]-r*t[0]/o,n[1]=e[1]-r*t[1]/o,n[2]=e[2]-r*t[2]/o,n}function Xa(e,t,n,r){const o=[];Vo(e,t,o);const a=No(n,o),i=No(n,n);0!==i?(r[0]=e[0]-a*n[0]/i,r[1]=e[1]-a*n[1]/i,r[2]=e[2]-a*n[2]/i):(r[0]=e[0],r[1]=e[1],r[2]=e[2])}function Ya(e,t,n,r){const o={intersection:!1,betweenPoints:!1,t:Number.MAX_VALUE,x:[]},a=[],i=[];Vo(t,e,a),Vo(n,e,i);const s=No(r,i),l=No(r,a);let c,u;return c=l<0?-l:l,u=s<0?-s*Wa:s*Wa,c<=u||(o.t=s/l,o.x[0]=e[0]+o.t*a[0],o.x[1]=e[1]+o.t*a[1],o.x[2]=e[2]+o.t*a[2],o.intersection=!0,o.betweenPoints=o.t>=0&&o.t<=1),o}function Za(e,t,n,r){const o={intersection:!1,l0:[],l1:[],error:null},a=[];Fo(t,r,a);const i=a.map((e=>Math.abs(e)));if(i[0]+i[1]+i[2]<Wa){const r=[];return Vo(e,n,r),0===No(t,r)?o.error=Ha:o.error=ja,o}let s;s=i[0]>i[1]&&i[0]>i[2]?"x":i[1]>i[2]?"y":"z";const l=[],c=-No(t,e),u=-No(r,n);switch(s){case"x":l[0]=0,l[1]=(u*t[2]-c*r[2])/a[0],l[2]=(c*r[1]-u*t[1])/a[0];break;case"y":l[0]=(c*r[2]-u*t[2])/a[1],l[1]=0,l[2]=(u*t[0]-c*r[0])/a[1];break;case"z":l[0]=(u*t[1]-c*r[1])/a[2],l[1]=(c*r[0]-u*t[0])/a[2],l[2]=0}return o.l0=l,Eo(l,a,o.l1),o.intersection=!0,o}const Qa={evaluate:function(e,t,n){return e[0]*(n[0]-t[0])+e[1]*(n[1]-t[1])+e[2]*(n[2]-t[2])},distanceToPlane:Ka,projectPoint:$a,projectVector:qa,generalizedProjectPoint:Xa,intersectWithLine:Ya,intersectWithPlane:Za,DISJOINT:ja,COINCIDE:Ha},Ja={normal:[0,0,1],origin:[0,0,0]};function ei(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ja,n),za.extend(e,t,n),Ht.setGetArray(e,t,["normal","origin"],3),function(e,t){t.classHierarchy.push("vtkPlane"),e.distanceToPlane=e=>Ka(e,t.origin,t.normal),e.projectPoint=(e,n)=>{$a(e,t.origin,t.normal,n)},e.projectVector=(e,n)=>qa(e,t.normal,n),e.push=e=>{if(0!==e)for(let n=0;n<3;n++)t.origin[n]+=e*t.normal[n]},e.generalizedProjectPoint=(e,n)=>{Xa(e,t.origin,t.normal,n)},e.evaluateFunction=(e,n,r)=>Array.isArray(e)?t.normal[0]*(e[0]-t.origin[0])+t.normal[1]*(e[1]-t.origin[1])+t.normal[2]*(e[2]-t.origin[2]):t.normal[0]*(e-t.origin[0])+t.normal[1]*(n-t.origin[1])+t.normal[2]*(r-t.origin[2]),e.evaluateGradient=e=>[t.normal[0],t.normal[1],t.normal[2]],e.intersectWithLine=(e,n)=>Ya(e,n,t.origin,t.normal),e.intersectWithPlane=(e,n)=>Za(e,n,t.origin,t.normal)}(e,t)}var ti={newInstance:Ht.newInstance(ei,"vtkPlane"),extend:ei,...Qa};const ni=[Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE,Number.MAX_VALUE,-Number.MAX_VALUE];function ri(e,t){return e[0]===t[0]&&e[1]===t[1]&&e[2]===t[2]&&e[3]===t[3]&&e[4]===t[4]&&e[5]===t[5]}function oi(e){return e?.length>=6&&e[0]<=e[1]&&e[2]<=e[3]&&e[4]<=e[5]}function ai(e,t){return e[0]=t[0],e[1]=t[1],e[2]=t[2],e[3]=t[3],e[4]=t[4],e[5]=t[5],e}function ii(e){return ai(e,ni)}function si(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=o<t?o:t,e[1]=a>t?a:t,e[2]=i<n?i:n,e[3]=s>n?s:n,e[4]=l<r?l:r,e[5]=c>r?c:r,e}function li(e,t){if(0===t.length)return e;if(Array.isArray(t[0]))for(let n=0;n<t.length;++n)si(e,...t[n]);else for(let n=0;n<t.length;n+=3)si(e,...t.slice(n,n+3));return e}function ci(e,t,n,r,o,a,i){const[s,l,c,u,d,p]=e;return void 0===i?(e[0]=Math.min(t[0],s),e[1]=Math.max(t[1],l),e[2]=Math.min(t[2],c),e[3]=Math.max(t[3],u),e[4]=Math.min(t[4],d),e[5]=Math.max(t[5],p)):(e[0]=Math.min(t,s),e[1]=Math.max(n,l),e[2]=Math.min(r,c),e[3]=Math.max(o,u),e[4]=Math.min(a,d),e[5]=Math.max(i,p)),e}function ui(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t,e[1]=t>a?t:a,e[2]=n,e[3]=n>s?n:s,e[4]=r,e[5]=r>c?r:c,o!==t||i!==n||l!==r}function di(e,t,n,r){const[o,a,i,s,l,c]=e;return e[0]=t<o?t:o,e[1]=t,e[2]=n<i?n:i,e[3]=n,e[4]=r<l?r:l,e[5]=r,a!==t||s!==n||c!==r}function pi(e,t){return e[0]-=t,e[1]+=t,e[2]-=t,e[3]+=t,e[4]-=t,e[5]+=t,e}function fi(e,t,n,r){return!!oi(e)&&(t>=0?(e[0]*=t,e[1]*=t):(e[0]=t*e[1],e[1]=t*e[0]),n>=0?(e[2]*=n,e[3]*=n):(e[2]=n*e[3],e[3]=n*e[2]),r>=0?(e[4]*=r,e[5]*=r):(e[4]=r*e[5],e[5]=r*e[4]),!0)}function gi(e){return[.5*(e[0]+e[1]),.5*(e[2]+e[3]),.5*(e[4]+e[5])]}function mi(e,t){return e[2*t+1]-e[2*t]}function hi(e){return[mi(e,0),mi(e,1),mi(e,2)]}function vi(e){return e.slice(0,2)}function Ti(e){return e.slice(2,4)}function yi(e){return e.slice(4,6)}function bi(e){const t=hi(e);return t[0]>t[1]?t[0]>t[2]?t[0]:t[2]:t[1]>t[2]?t[1]:t[2]}function xi(e){if(oi(e)){const t=hi(e);return Math.sqrt(t[0]*t[0]+t[1]*t[1]+t[2]*t[2])}return null}function Ci(e){return[e[0],e[2],e[4]]}function Si(e){return[e[1],e[3],e[5]]}function Ai(e,t){return e<=0&&t>=0||e>=0&&t<=0}function Ii(e,t){let n=0;for(let r=0;r<2;r++)for(let o=2;o<4;o++)for(let a=4;a<6;a++)t[n++]=[e[r],e[o],e[a]];return t}function wi(e,t,n){return t[0]=e[0],t[1]=e[2],t[2]=e[4],n[0]=e[1],n[1]=e[3],n[2]=e[5],t}function Oi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[];const r=Ii(e,[]);for(let e=0;e<r.length;++e)wn(r[e],r[e],t);return ii(n),li(n,r)}function Pi(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return t[0]=.5*(e[1]-e[0]),t[1]=.5*(e[3]-e[2]),t[2]=.5*(e[5]-e[4]),t}function Ri(e,t,n,r){const o=[].concat(ni),a=e.getData();for(let e=0;e<a.length;e+=3){const i=[a[e],a[e+1],a[e+2]],s=No(i,t);o[0]=Math.min(s,o[0]),o[1]=Math.max(s,o[1]);const l=No(i,n);o[2]=Math.min(l,o[2]),o[3]=Math.max(l,o[3]);const c=No(i,r);o[4]=Math.min(c,o[4]),o[5]=Math.max(c,o[5])}return o}function Mi(e,t,n,r,o){let a=!0;const i=[];let s=0;const l=[],c=[0,0,0];for(let n=0;n<3;n++)t[n]<e[2*n]?(i[n]=1,c[n]=e[2*n],a=!1):t[n]>e[2*n+1]?(i[n]=0,c[n]=e[2*n+1],a=!1):i[n]=2;if(a)return r[0]=t[0],r[1]=t[1],r[2]=t[2],o[0]=0,1;for(let e=0;e<3;e++)2!==i[e]&&0!==n[e]?l[e]=(c[e]-t[e])/n[e]:l[e]=-1;for(let e=0;e<3;e++)l[s]<l[e]&&(s=e);if(l[s]>1||l[s]<0)return 0;o[0]=l[s];for(let o=0;o<3;o++)if(s!==o){if(r[o]=t[o]+l[s]*n[o],r[o]<e[2*o]||r[o]>e[2*o+1])return 0}else r[o]=c[o];return 1}function Ei(e,t,n){const r=[];let o=0,a=1,i=1;for(let s=4;s<=5;++s){r[2]=e[s];for(let s=2;s<=3;++s){r[1]=e[s];for(let s=0;s<=1;++s)if(r[0]=e[s],o=ti.evaluate(n,t,r),i&&(a=o>=0?1:-1,i=0),0===o||a>0&&o<0||a<0&&o>0)return 1}}return 0}function Vi(e,t){if(!oi(e)||!oi(t))return!1;const n=[0,0,0,0,0,0];let r;for(let o=0;o<3;o++)if(r=!1,t[2*o]>=e[2*o]&&t[2*o]<=e[2*o+1]?(r=!0,n[2*o]=t[2*o]):e[2*o]>=t[2*o]&&e[2*o]<=t[2*o+1]&&(r=!0,n[2*o]=e[2*o]),t[2*o+1]>=e[2*o]&&t[2*o+1]<=e[2*o+1]?(r=!0,n[2*o+1]=t[2*o+1]):e[2*o+1]>=t[2*o]&&e[2*o+1]<=t[2*o+1]&&(r=!0,n[2*o+1]=e[2*o+1]),!r)return!1;return e[0]=n[0],e[1]=n[1],e[2]=n[2],e[3]=n[3],e[4]=n[4],e[5]=n[5],!0}function Di(e,t){if(!oi(e)||!oi(t))return!1;for(let n=0;n<3;n++)if(!(t[2*n]>=e[2*n]&&t[2*n]<=e[2*n+1]||e[2*n]>=t[2*n]&&e[2*n]<=t[2*n+1]||t[2*n+1]>=e[2*n]&&t[2*n+1]<=e[2*n+1]||e[2*n+1]>=t[2*n]&&e[2*n+1]<=t[2*n+1]))return!1;return!0}function Li(e,t,n,r){return!(t<e[0]||t>e[1]||n<e[2]||n>e[3]||r<e[4]||r>e[5])}function Bi(e,t,n){const r=[[0,1,2,3,4,5,6,7],[0,1,4,5,2,3,6,7],[0,2,4,6,1,3,5,7]],o=[0,0,0,0,0,0,0,0];let a=0;for(let r=0;r<2;r++)for(let i=2;i<4;i++)for(let s=4;s<6;s++){const l=[e[r],e[i],e[s]];o[a++]=ti.evaluate(n,t,l)}let i=2;for(;i--&&!(Ai(o[r[i][0]],o[r[i][4]])&&Ai(o[r[i][1]],o[r[i][5]])&&Ai(o[r[i][2]],o[r[i][6]])&&Ai(o[r[i][3]],o[r[i][7]])););if(i<0)return!1;const s=Math.sign(n[i]),l=Math.abs((e[2*i+1]-e[2*i])*n[i]);let c=s>0?1:0;for(let e=0;e<4;e++){if(0===l)continue;const t=Math.abs(o[r[i][e]])/l;s>0&&t<c&&(c=t),s<0&&t>c&&(c=t)}const u=(1-c)*e[2*i]+c*e[2*i+1];return s>0?e[2*i]=u:e[2*i+1]=u,!0}class Ni{constructor(e){this.bounds=e,this.bounds||(this.bounds=new Float64Array(ni))}getBounds(){return this.bounds}equals(e){return ri(this.bounds,e)}isValid(){return oi(this.bounds)}setBounds(e){return ai(this.bounds,e)}reset(){return ii(this.bounds)}addPoint(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return si(this.bounds,...t)}addPoints(e){return li(this.bounds,e)}addBounds(e,t,n,r,o,a){return ci(this.bounds,e,t,n,r,o,a)}setMinPoint(e,t,n){return ui(this.bounds,e,t,n)}setMaxPoint(e,t,n){return di(this.bounds,e,t,n)}inflate(e){return pi(this.bounds,e)}scale(e,t,n){return fi(this.bounds,e,t,n)}getCenter(){return gi(this.bounds)}getLength(e){return mi(this.bounds,e)}getLengths(){return hi(this.bounds)}getMaxLength(){return bi(this.bounds)}getDiagonalLength(){return xi(this.bounds)}getMinPoint(){return Ci(this.bounds)}getMaxPoint(){return Si(this.bounds)}getXRange(){return vi(this.bounds)}getYRange(){return Ti(this.bounds)}getZRange(){return yi(this.bounds)}getCorners(e){return Ii(this.bounds,e)}computeCornerPoints(e,t){return wi(this.bounds,e,t)}computeLocalBounds(e,t,n){return Ri(this.bounds,e,t,n)}transformBounds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Oi(this.bounds,e,t)}computeScale3(e){return Pi(this.bounds,e)}cutWithPlane(e,t){return Bi(this.bounds,e,t)}intersectBox(e,t,n,r){return Mi(this.bounds,e,t,n,r)}intersectPlane(e,t){return Ei(this.bounds,e,t)}intersect(e){return Vi(this.bounds,e)}intersects(e){return Di(this.bounds,e)}containsPoint(e,t,n){return Li(this.bounds,e,t,n)}contains(e){return Di(this.bounds,e)}}var Fi={newInstance:function(e){const t=e&&e.bounds;return new Ni(t)},equals:ri,isValid:oi,setBounds:ai,reset:ii,addPoint:si,addPoints:li,addBounds:ci,setMinPoint:ui,setMaxPoint:di,inflate:pi,scale:fi,scaleAboutCenter:function(e,t,n,r){if(!oi(e))return!1;const o=gi(e);return e[0]-=o[0],e[1]-=o[0],e[2]-=o[1],e[3]-=o[1],e[4]-=o[2],e[5]-=o[2],fi(e,t,n,r),e[0]+=o[0],e[1]+=o[0],e[2]+=o[1],e[3]+=o[1],e[4]+=o[2],e[5]+=o[2],!0},getCenter:gi,getLength:mi,getLengths:hi,getMaxLength:bi,getDiagonalLength:xi,getMinPoint:Ci,getMaxPoint:Si,getXRange:vi,getYRange:Ti,getZRange:yi,getCorners:Ii,computeCornerPoints:wi,computeLocalBounds:Ri,transformBounds:Oi,computeScale3:Pi,cutWithPlane:Bi,intersectBox:Mi,intersectPlane:Ei,intersect:Vi,intersects:Di,containsPoint:Li,contains:function(e,t){return!!Di(e,t)&&!!Li(e,...Ci(t))&&!!Li(e,...Si(t))},INIT_BOUNDS:ni},_i={CoordinateSystem:{DISPLAY:0,WORLD:1}};const{CoordinateSystem:Gi}=_i;function ki(e){return()=>Ht.vtkErrorMacro(`vtkProp::${e} - NOT IMPLEMENTED`)}const Ui={allocatedRenderTime:10,coordinateSystem:Gi.WORLD,dragable:!0,estimatedRenderTime:0,paths:null,pickable:!0,renderTimeMultiplier:1,savedEstimatedRenderTime:0,textures:[],useBounds:!0,visibility:!0};function zi(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ui,n),Ht.obj(e,t),Ht.get(e,t,["estimatedRenderTime","allocatedRenderTime"]),Ht.setGet(e,t,["_parentProp","coordinateSystem","dragable","pickable","renderTimeMultiplier","useBounds","visibility"]),Ht.moveToProtected(e,t,["parentProp"]),function(e,t){t.classHierarchy.push("vtkProp"),e.getMTime=()=>{let e=t.mtime;for(let n=0;n<t.textures.length;++n){const r=t.textures[n].getMTime();r>e&&(e=r)}return e},e.processSelectorPixelBuffers=(e,t)=>{},e.getNestedProps=()=>null,e.getActors=()=>[],e.getActors2D=()=>[],e.getVolumes=()=>[],e.pick=ki("pick"),e.hasKey=ki("hasKey"),e.getNestedVisibility=()=>t.visibility&&(!t._parentProp||t._parentProp.getNestedVisibility()),e.getNestedPickable=()=>t.pickable&&(!t._parentProp||t._parentProp.getNestedPickable()),e.getNestedDragable=()=>t.dragable&&(!t._parentProp||t._parentProp.getNestedDragable()),e.getRedrawMTime=()=>t.mtime,e.setEstimatedRenderTime=e=>{t.estimatedRenderTime=e,t.savedEstimatedRenderTime=e},e.restoreEstimatedRenderTime=()=>{t.estimatedRenderTime=t.savedEstimatedRenderTime},e.addEstimatedRenderTime=e=>{t.estimatedRenderTime+=e},e.setAllocatedRenderTime=e=>{t.allocatedRenderTime=e,t.savedEstimatedRenderTime=t.estimatedRenderTime,t.estimatedRenderTime=0},e.getSupportsSelection=()=>!1,e.getTextures=()=>t.textures,e.hasTexture=e=>-1!==t.textures.indexOf(e),e.addTexture=n=>{n&&!e.hasTexture(n)&&(t.textures=t.textures.concat(n),e.modified())},e.removeTexture=n=>{const r=t.textures.filter((e=>e!==n));t.textures.length!==r.length&&(t.textures=r,e.modified())},e.removeAllTextures=()=>{t.textures=[],e.modified()},e.setCoordinateSystemToWorld=()=>e.setCoordinateSystem(Gi.WORLD),e.setCoordinateSystemToDisplay=()=>e.setCoordinateSystem(Gi.DISPLAY)}(e,t)}var Wi={newInstance:Ht.newInstance(zi,"vtkProp"),extend:zi,..._i};const Hi={origin:[0,0,0],position:[0,0,0],orientation:[0,0,0],rotation:null,scale:[1,1,1],bounds:[...Fi.INIT_BOUNDS],properties:[],userMatrix:null,userMatrixMTime:null,cachedProp3D:null,isIdentity:!0,matrixMTime:null};function ji(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hi,n),Wi.extend(e,t,n),t.matrixMTime={},Ht.obj(t.matrixMTime),Ht.get(e,t,["isIdentity"]),Ht.getArray(e,t,["orientation"]),Ht.setGetArray(e,t,["origin","position","scale"],3),Ht.setGet(e,t,["properties"]),t.matrix=g(new Float64Array(16)),t.rotation=g(new Float64Array(16)),t.userMatrix=g(new Float64Array(16)),t.transform=null,function(e,t){t.classHierarchy.push("vtkProp3D"),e.addPosition=n=>{t.position=t.position.map(((e,t)=>e+n[t])),e.modified()},e.getOrientationWXYZ=()=>{const e=Na();N(e,t.rotation);const n=new Float64Array(3),r=function(e,t){var n=2*Math.acos(t[3]),r=Math.sin(n/2);return r>a?(e[0]=t[0]/r,e[1]=t[1]/r,e[2]=t[2]/r):(e[0]=1,e[1]=0,e[2]=0),n}(n,e);return[bo(r),n[0],n[1],n[2]]},e.getOrientationQuaternion=function(){return N(arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t.rotation)},e.rotateX=n=>{0!==n&&(S(t.rotation,t.rotation,yo(n)),e.modified())},e.rotateY=n=>{0!==n&&(A(t.rotation,t.rotation,yo(n)),e.modified())},e.rotateZ=n=>{0!==n&&(I(t.rotation,t.rotation,yo(n)),e.modified())},e.rotateWXYZ=(n,r,o,a)=>{if(0===n||0===r&&0===o&&0===a)return;const i=yo(n),s=Na();Fa(s,[r,o,a],i);const l=new Float64Array(16);G(l,s),y(t.rotation,t.rotation,l),e.modified()},e.rotateQuaternion=n=>{if(Math.abs(n[3])>=.999999)return;const r=G(new Float64Array(16),n);y(t.rotation,t.rotation,r),e.modified()},e.setOrientation=(n,r,o)=>(n!==t.orientation[0]||r!==t.orientation[1]||o!==t.orientation[2])&&(t.orientation=[n,r,o],g(t.rotation),e.rotateZ(o),e.rotateX(n),e.rotateY(r),e.modified(),!0),e.setUserMatrix=n=>!Yo(t.userMatrix,n)&&(d(t.userMatrix,n),e.modified(),!0),e.getMatrix=()=>(e.computeMatrix(),t.matrix),e.computeMatrix=()=>{if(e.getMTime()>t.matrixMTime.getMTime()){g(t.matrix),t.userMatrix&&y(t.matrix,t.matrix,t.userMatrix),b(t.matrix,t.matrix,t.origin),b(t.matrix,t.matrix,t.position),y(t.matrix,t.matrix,t.rotation),x(t.matrix,t.matrix,t.scale),b(t.matrix,t.matrix,[-t.origin[0],-t.origin[1],-t.origin[2]]),m(t.matrix,t.matrix),t.isIdentity=!0;for(let e=0;e<4;++e)for(let n=0;n<4;++n)(e===n?1:0)!==t.matrix[e+4*n]&&(t.isIdentity=!1);t.matrixMTime.modified()}},e.getBoundsByReference=()=>{if(null===t.mapper)return t.bounds;const n=t.mapper.getBounds();if(!n||6!==n.length)return n;if(n[0]>n[1])return t.mapperBounds=n,t.bounds=[...Fi.INIT_BOUNDS],t.boundsMTime.modified(),n;if(!t.mapperBounds||!n.every(((e,r)=>n[r]===t.mapperBounds[r]))||e.getMTime()>t.boundsMTime.getMTime()){Ht.vtkDebugMacro("Recomputing bounds..."),t.mapperBounds=n,e.computeMatrix();const r=new Float64Array(16);m(r,t.matrix),Fi.transformBounds(n,r,t.bounds),t.boundsMTime.modified()}return t.bounds},e.getBounds=()=>{const t=e.getBoundsByReference();try{return[...t]}catch{return t}},e.getCenter=()=>Fi.getCenter(t.bounds),e.getLength=()=>Fi.getLength(t.bounds),e.getXRange=()=>Fi.getXRange(t.bounds),e.getYRange=()=>Fi.getYRange(t.bounds),e.getZRange=()=>Fi.getZRange(t.bounds),e.getUserMatrix=()=>t.userMatrix,e.onModified((function(){e.computeMatrix()})),e.getProperty=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null==t.properties[n]&&(t.properties[n]=e.makeProperty?.()),t.properties[n]},e.setProperty=(e,n)=>{const r=Number.isInteger(e),[o,a]=r?[e,n]:[0,e];return t.properties[o]!==a&&(t.properties[o]=a,!0)},e.getMTime=()=>{let e=t.mtime;return t.properties.forEach((t=>{if(null!==t){const n=t.getMTime();e=n>e?n:e}})),e}}(e,t)}var Ki={newInstance:Ht.newInstance(ji,"vtkProp3D"),extend:ji};const $i={FLAT:0,GOURAUD:1,PHONG:2},qi={POINTS:0,WIREFRAME:1,SURFACE:2};var Xi={Shading:$i,Representation:qi,Interpolation:$i};const{Representation:Yi,Interpolation:Zi}=Xi;function Qi(e){return()=>Ht.vtkErrorMacro(`vtkProperty::${e} - NOT IMPLEMENTED`)}const Ji={color:[1,1,1],ambientColor:[1,1,1],diffuseColor:[1,1,1],specularColor:[1,1,1],edgeColor:[0,0,0],ambient:0,diffuse:1,metallic:0,roughness:.6,normalStrength:1,emission:1,baseIOR:1.45,specular:0,specularPower:1,opacity:1,interpolation:Zi.GOURAUD,representation:Yi.SURFACE,edgeVisibility:!1,backfaceCulling:!1,frontfaceCulling:!1,pointSize:1,lineWidth:1,lighting:!0,shading:!1,materialName:null,ORMTexture:null,RMTexture:null};function es(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ji,n),Ht.obj(e,t),Ht.setGet(e,t,["lighting","interpolation","ambient","diffuse","metallic","roughness","normalStrength","emission","baseIOR","specular","specularPower","opacity","edgeVisibility","lineWidth","pointSize","backfaceCulling","frontfaceCulling","representation","diffuseTexture","metallicTexture","roughnessTexture","normalTexture","ambientOcclusionTexture","emissionTexture","ORMTexture","RMTexture"]),Ht.setGetArray(e,t,["ambientColor","specularColor","diffuseColor","edgeColor"],3),function(e,t){t.classHierarchy.push("vtkProperty"),e.setColor=(n,r,o)=>{Array.isArray(n)?t.color[0]===n[0]&&t.color[1]===n[1]&&t.color[2]===n[2]||(t.color[0]=n[0],t.color[1]=n[1],t.color[2]=n[2],e.modified()):t.color[0]===n&&t.color[1]===r&&t.color[2]===o||(t.color[0]=n,t.color[1]=r,t.color[2]=o,e.modified()),e.setDiffuseColor(t.color),e.setAmbientColor(t.color),e.setSpecularColor(t.color)},e.computeCompositeColor=Qi("ComputeCompositeColor"),e.getColor=()=>{let e=0;t.ambient+t.diffuse+t.specular>0&&(e=1/(t.ambient+t.diffuse+t.specular));for(let n=0;n<3;n++)t.color[n]=e*(t.ambient*t.ambientColor[n]+t.diffuse*t.diffuseColor[n]+t.specular*t.specularColor[n]);return[].concat(t.color)},e.setSpecularPower=n=>{const r=1/Math.max(1,n);t.roughness===r&&t.specularPower===n||(t.specularPower=n,t.roughness=r,e.modified())},e.addShaderVariable=Qi("AddShaderVariable"),e.setInterpolationToFlat=()=>e.setInterpolation(Zi.FLAT),e.setInterpolationToGouraud=()=>e.setInterpolation(Zi.GOURAUD),e.setInterpolationToPhong=()=>e.setInterpolation(Zi.PHONG),e.getInterpolationAsString=()=>Ht.enumToString(Zi,t.interpolation),e.setRepresentationToWireframe=()=>e.setRepresentation(Yi.WIREFRAME),e.setRepresentationToSurface=()=>e.setRepresentation(Yi.SURFACE),e.setRepresentationToPoints=()=>e.setRepresentation(Yi.POINTS),e.getRepresentationAsString=()=>Ht.enumToString(Yi,t.representation)}(e,t)}var ts={newInstance:Ht.newInstance(es,"vtkProperty"),extend:es,...Xi};const ns={mapper:null,backfaceProperty:null,forceOpaque:!1,forceTranslucent:!1};function rs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ns,n),Ki.extend(e,t,n),t.boundsMTime={},Ht.obj(t.boundsMTime),Ht.setGet(e,t,["backfaceProperty","forceOpaque","forceTranslucent","mapper"]),function(e,t){t.classHierarchy.push("vtkActor");const n={...e};e.getActors=()=>[e],e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.properties[0]||e.getProperty();let n=t.properties[0].getOpacity()>=1;return n=n&&(!t.texture||!t.texture.isTranslucent()),n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>null!==t.mapper&&(t.properties[0]||e.getProperty(),!e.getIsOpaque()),e.makeProperty=ts.newInstance,e.getMTime=()=>{let e=n.getMTime();if(null!==t.backfaceProperty){const n=t.backfaceProperty.getMTime();e=n>e?n:e}return e},e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection(),e.processSelectorPixelBuffers=(e,n)=>{t.mapper&&t.mapper.processSelectorPixelBuffers&&t.mapper.processSelectorPixelBuffers(e,n)}}(e,t)}var os={newInstance:Ht.newInstance(rs,"vtkActor"),extend:rs};const as={Int8Array:1,Uint8Array:1,Uint8ClampedArray:1,Int16Array:2,Uint16Array:2,Int32Array:4,Uint32Array:4,Float32Array:4,Float64Array:8},is={VOID:"",CHAR:"Int8Array",SIGNED_CHAR:"Int8Array",UNSIGNED_CHAR:"Uint8Array",UNSIGNED_CHAR_CLAMPED:"Uint8ClampedArray",SHORT:"Int16Array",UNSIGNED_SHORT:"Uint16Array",INT:"Int32Array",UNSIGNED_INT:"Uint32Array",FLOAT:"Float32Array",DOUBLE:"Float64Array"};var ss={DefaultDataType:is.FLOAT,DataTypeByteSize:as,VtkDataTypes:is};const{vtkErrorMacro:ls}=jt,{DefaultDataType:cs}=ss;function us(e,t,n){const r=e.length;let o,a,i=Number.MAX_VALUE,s=-Number.MAX_VALUE;for(a=t;a<r;a+=n)if(!Number.isNaN(e[a])){i=e[a],s=i;break}for(;a<r;a+=n)o=e[a],o<i?i=o:o>s&&(s=o);return{min:i,max:s}}function ds(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;if(t<0&&n>1){const t=e.length/n,r=new Float64Array(t);for(let o=0,a=0;o<t;++o){for(let t=a+n;a<t;++a)r[o]+=e[a]*e[a];r[o]**=.5}return us(r,0,1)}return us(e,t<0?0:t,n)}function ps(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=e||[];for(;n.length<=t;)n.push(null);return n}function fs(e){return Object.prototype.toString.call(e).slice(8,-1)}const gs={computeRange:ds,createRangeHelper:function(){let e=Number.MAX_VALUE,t=-Number.MAX_VALUE,n=0,r=0;return{add(o){e>o&&(e=o),t<o&&(t=o),n++,r+=o},get(){return{min:e,max:t,count:n,sum:r,mean:r/n}},getRange(){return{min:e,max:t}}}},fastComputeRange:us,getDataType:fs,getMaxNorm:function(e){const t=e.getNumberOfComponents();let n=0;const r=new Array(t);for(let o=0;o<e.getNumberOfTuples();++o){e.getTuple(o,r);const a=_o(r,t);a>n&&(n=a)}return n}},ms={name:"",numberOfComponents:1,dataType:cs,rangeTuple:[0,0]};function hs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,ms,n),Array.isArray(n.values)&&void 0===n.dataType&&console.warn("vtkDataArray.newInstance: no dataType provided, converting to Float32Array"),!t.empty&&!t.values&&!t.size)throw new TypeError("Cannot create vtkDataArray object without: size > 0, values");if(t.values?Array.isArray(t.values)&&(t.values=st(t.dataType,t.values)):t.values=it(t.dataType,t.size),t.values&&(t.size=t.size??t.values.length,t.dataType=fs(t.values)),vt(e,t),Ct(e,t,["name","numberOfComponents"]),t.size%t.numberOfComponents!=0)throw new RangeError("model.size is not a multiple of model.numberOfComponents");!function(e,t){function n(n){if(n<0)return!1;const r=e.getNumberOfComponents(),o=t.values.length/(r>0?r:1);if(n===o)return!0;if(n>o){const e=t.values;return t.values=it(t.dataType,(n+o)*r),t.values.set(e),!0}return t.size>n*r&&(t.size=n*r,e.dataChange()),!0}t.classHierarchy.push("vtkDataArray"),e.dataChange=()=>{t.ranges=null,e.modified()},e.allocate=t=>{n(e.getNumberOfTuples()+t)},e.resize=r=>{n(r);const o=r*e.getNumberOfComponents();return t.size!==o&&(t.size=o,e.dataChange(),!0)},e.initialize=()=>{e.resize(0)},e.getElementComponentSize=()=>t.values.BYTES_PER_ELEMENT,e.getComponent=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return t.values[e*t.numberOfComponents+n]},e.setComponent=(n,r,o)=>{o!==t.values[n*t.numberOfComponents+r]&&(t.values[n*t.numberOfComponents+r]=o,e.dataChange())},e.getValue=n=>{const r=n/t.numberOfComponents,o=n%t.numberOfComponents;return e.getComponent(r,o)},e.setValue=(n,r)=>{const o=n/t.numberOfComponents,a=n%t.numberOfComponents;e.setComponent(o,a,r)},e.getData=()=>t.size===t.values.length?t.values:t.values.subarray(0,t.size),e.getRange=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:-1,r=n;r<0&&(r=1===t.numberOfComponents?0:t.numberOfComponents);let o=null;return t.ranges||(t.ranges=ps(t.ranges,t.numberOfComponents)),o=t.ranges[r],o?(t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple):(o=ds(e.getData(),n,t.numberOfComponents),t.ranges[r]=o,t.rangeTuple[0]=o.min,t.rangeTuple[1]=o.max,t.rangeTuple)},e.setRange=(e,n)=>{t.ranges||(t.ranges=ps(t.ranges,t.numberOfComponents));const r={min:e.min,max:e.max};return t.ranges[n]=r,t.rangeTuple[0]=r.min,t.rangeTuple[1]=r.max,t.rangeTuple},e.getRanges=function(){if(arguments.length>0&&void 0!==arguments[0]&&!arguments[0])return structuredClone(t.ranges);const n=[];for(let r=0;r<t.numberOfComponents;r++){const[t,o]=e.getRange(r),a={min:t,max:o};n.push(a)}if(t.numberOfComponents>1){const[t,r]=e.getRange(-1),o={min:t,max:r};n.push(o)}return n},e.setTuple=(e,n)=>{const r=e*t.numberOfComponents;for(let e=0;e<t.numberOfComponents;e++)t.values[r+e]=n[e]},e.setTuples=(e,n)=>{let r=e*t.numberOfComponents;const o=Math.min(n.length,t.size-r);for(let e=0;e<o;)t.values[r++]=n[e++]},e.insertTuple=(r,o)=>(t.size<=r*t.numberOfComponents&&(t.size=(r+1)*t.numberOfComponents,n(r+1)),e.setTuple(r,o),r),e.insertTuples=(r,o)=>{const a=r+o.length/t.numberOfComponents;return t.size<a*t.numberOfComponents&&(t.size=a*t.numberOfComponents,n(a)),e.setTuples(r,o),a},e.insertNextTuple=n=>{const r=t.size/t.numberOfComponents;return e.insertTuple(r,n)},e.insertNextTuples=n=>{const r=t.size/t.numberOfComponents;return e.insertTuples(r,n)},e.findTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e-6;for(let r=0;r<t.size;r+=t.numberOfComponents)if(Math.abs(e[0]-t.values[r])<=n){let o=!0;for(let a=1;a<t.numberOfComponents;++a)if(Math.abs(e[a]-t.values[r+a])>n){o=!1;break}if(o)return r/t.numberOfComponents}return-1},e.getTuple=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const r=t.numberOfComponents||1,o=e*r;switch(r){case 4:n[3]=t.values[o+3];case 3:n[2]=t.values[o+2];case 2:n[1]=t.values[o+1];case 1:n[0]=t.values[o];break;default:for(let e=r-1;e>=0;--e)n[e]=t.values[o+e]}return n},e.getTuples=(n,r)=>{const o=(n??0)*t.numberOfComponents,a=(r??e.getNumberOfTuples())*t.numberOfComponents,i=e.getData().subarray(o,a);return i.length>0?i:null},e.getTupleLocation=function(){return(arguments.length>0&&void 0!==arguments[0]?arguments[0]:1)*t.numberOfComponents},e.getNumberOfComponents=()=>t.numberOfComponents,e.getNumberOfValues=()=>t.size,e.getNumberOfTuples=()=>t.size/t.numberOfComponents,e.getDataType=()=>t.dataType,e.newClone=()=>vs({empty:!0,name:t.name,dataType:t.dataType,numberOfComponents:t.numberOfComponents}),e.getName=()=>(t.name||(e.modified(),t.name=`vtkDataArray${e.getMTime()}`),t.name),e.setData=(n,r)=>{t.values=n,t.size=n.length,t.dataType=fs(n),r&&(t.numberOfComponents=r),t.size%t.numberOfComponents!=0&&(t.numberOfComponents=1),e.dataChange()},e.getState=()=>{if(t.deleted)return null;const n={...t,vtkClass:e.getClassName()};n.values=Array.from(n.values),delete n.buffer,Object.keys(n).forEach((e=>{n[e]||delete n[e]}));const r={};return Object.keys(n).sort().forEach((e=>{r[e]=n[e]})),r.mtime&&delete r.mtime,r},e.deepCopy=n=>{const r=e.getDataType(),o=t.values;e.shallowCopy(n),t.ranges=structuredClone(n.getRanges()),o?.length>=n.getNumberOfValues()&&r===n.getDataType()?(o.set(n.getData()),t.values=o,e.dataChange()):e.setData(n.getData().slice())},e.interpolateTuple=(n,r,o,a,i,s)=>{const l=t.numberOfComponents||1;l===r.getNumberOfComponents()&&l===a.getNumberOfComponents()||ls("numberOfComponents must match");const c=r.getTuple(o),u=a.getTuple(i),d=[];switch(d.length=l,l){case 4:d[3]=c[3]+(u[3]-c[3])*s;case 3:d[2]=c[2]+(u[2]-c[2])*s;case 2:d[1]=c[1]+(u[1]-c[1])*s;case 1:d[0]=c[0]+(u[0]-c[0])*s;break;default:for(let e=0;e<l;e++)d[e]=c[e]+(u[e]-c[e])*s}return e.insertTuple(n,d)}}(e,t)}const vs=Et(hs,"vtkDataArray");var Ts={newInstance:vs,extend:hs,...gs,...ss};const ys={clippingPlanes:[]};var bs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ys,n),Ht.obj(e,t),Ht.algo(e,t,1,0),t.clippingPlanes||(t.clippingPlanes=[]),function(e,t){t.classHierarchy.push("vtkAbstractMapper"),e.update=()=>{e.getInputData()},e.addClippingPlane=n=>!!n.isA("vtkPlane")&&!t.clippingPlanes.includes(n)&&(t.clippingPlanes.push(n),e.modified(),!0),e.getNumberOfClippingPlanes=()=>t.clippingPlanes.length,e.removeAllClippingPlanes=()=>0!==t.clippingPlanes.length&&(t.clippingPlanes.length=0,e.modified(),!0),e.removeClippingPlane=n=>{const r=t.clippingPlanes.indexOf(n);return-1!==r&&(t.clippingPlanes.splice(r,1),e.modified(),!0)},e.getClippingPlanes=()=>t.clippingPlanes,e.setClippingPlanes=t=>{if(t)if(Array.isArray(t)){const n=t.length;for(let r=0;r<n&&r<6;r++)e.addClippingPlane(t[r])}else e.addClippingPlane(t)},e.getClippingPlaneInDataCoords=(e,n,r)=>{const o=t.clippingPlanes,a=e;if(o){const e=o.length;if(n>=0&&n<e){const e=o[n],t=e.getNormal(),i=e.getOrigin(),s=t[0],l=t[1],c=t[2],u=-(s*i[0]+l*i[1]+c*i[2]);return r[0]=s*a[0]+l*a[4]+c*a[8]+u*a[12],r[1]=s*a[1]+l*a[5]+c*a[9]+u*a[13],r[2]=s*a[2]+l*a[6]+c*a[10]+u*a[14],void(r[3]=s*a[3]+l*a[7]+c*a[11]+u*a[15])}}Ht.vtkErrorMacro(`Clipping plane index ${n} is out of range.`)}}(e,t)},xs=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,(e=>({bounds:[...Fi.INIT_BOUNDS],center:[0,0,0],viewSpecificProperties:{},...e}))(n)),bs(e,t,n),Ht.setGet(e,t,["viewSpecificProperties"]),function(e,t){e.getBounds=()=>(Ht.vtkErrorMacro("vtkAbstractMapper3D.getBounds - NOT IMPLEMENTED"),Ra()),e.getCenter=()=>{const n=e.getBounds();return t.center=Fi.isValid(n)?Fi.getCenter(n):null,t.center?.slice()},e.getLength=()=>{const t=e.getBounds();return Fi.getDiagonalLength(t)}}(e,t)};const{vtkErrorMacro:Cs,vtkWarningMacro:Ss}=Ht,As={arrays:[],copyFieldFlags:[],doCopyAllOn:!0,doCopyAllOff:!1};function Is(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,As,n),Ht.obj(e,t),function(e,t){t.classHierarchy.push("vtkFieldData");const n=e.getState;t.arrays&&(t.arrays=t.arrays.map((e=>({data:We(e.data)})))),e.initialize=()=>{e.initializeFields(),e.copyAllOn(),e.clearFieldFlags()},e.initializeFields=()=>{t.arrays=[],t.copyFieldFlags={},e.modified()},e.copyStructure=n=>{e.initializeFields(),t.copyFieldFlags=n.getCopyFieldFlags().map((e=>e)),t.arrays=n.arrays().map((e=>({array:e})))},e.getNumberOfArrays=()=>t.arrays.length,e.getNumberOfActiveArrays=()=>t.arrays.length,e.addArray=n=>{const r=n.getName(),{array:o,index:a}=e.getArrayWithIndex(r);return null!=o?(t.arrays[a]={data:n},a):(t.arrays=[].concat(t.arrays,{data:n}),t.arrays.length-1)},e.removeAllArrays=()=>{t.arrays=[]},e.removeArray=n=>{const r=t.arrays.findIndex((e=>e.data.getName()===n));return e.removeArrayByIndex(r)},e.removeArrayByIndex=e=>-1!==e&&e<t.arrays.length&&(t.arrays.splice(e,1),!0),e.getArrays=()=>t.arrays.map((e=>e.data)),e.getArray=t=>"number"==typeof t?e.getArrayByIndex(t):e.getArrayByName(t),e.getArrayByName=e=>t.arrays.reduce(((t,n,r)=>n.data.getName()===e?n.data:t),null),e.getArrayWithIndex=e=>{const n=t.arrays.findIndex((t=>t.data.getName()===e));return{array:-1!==n?t.arrays[n].data:null,index:n}},e.getArrayByIndex=e=>e>=0&&e<t.arrays.length?t.arrays[e].data:null,e.hasArray=t=>e.getArrayWithIndex(t).index>=0,e.getArrayName=e=>{const n=t.arrays[e];return n?n.data.getName():""},e.getCopyFieldFlags=()=>t.copyFieldFlags,e.getFlag=e=>t.copyFieldFlags[e],e.passData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;n.getArrays().forEach((a=>{const i=e.getFlag(a.getName());if(!1!==i&&(!t.doCopyAllOff||!0===i)&&a){let t=e.getArrayByName(a.getName());if(t)if(a.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<a.getNumberOfTuples()){const e=o>-1?o:r;t.insertTuple(e,a.getTuple(r))}else t.insertTuples(0,a.getTuples());else Cs("Unhandled case in passData");else if(r<0||r>a.getNumberOfTuples())e.addArray(a),n.getAttributes(a).forEach((t=>{e.setAttribute(a,t)}));else{const i=a.getNumberOfComponents();let s=a.getNumberOfValues();const l=o>-1?o:r;s<=l*i&&(s=(l+1)*i),t=Ts.newInstance({name:a.getName(),dataType:a.getDataType(),numberOfComponents:i,values:Ht.newTypedArray(a.getDataType(),s),size:0}),t.insertTuple(l,a.getTuple(r)),e.addArray(t),n.getAttributes(a).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.interpolateData=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;n.getArrays().forEach((s=>{const l=e.getFlag(s.getName());if(!1!==l&&(!t.doCopyAllOff||!0===l)&&s){let t=e.getArrayByName(s.getName());if(t)if(s.getNumberOfComponents()===t.getNumberOfComponents())if(r>-1&&r<s.getNumberOfTuples()){const e=a>-1?a:r;t.interpolateTuple(e,s,r,s,o,i),Ss("Unexpected case in interpolateData")}else t.insertTuples(s.getTuples());else Cs("Unhandled case in interpolateData");else if(r<0||o<0||r>s.getNumberOfTuples())e.addArray(s),n.getAttributes(s).forEach((t=>{e.setAttribute(s,t)}));else{const l=s.getNumberOfComponents();let c=s.getNumberOfValues();const u=a>-1?a:r;c<=u*l&&(c=(u+1)*l),t=Ts.newInstance({name:s.getName(),dataType:s.getDataType(),numberOfComponents:l,values:Ht.newTypedArray(s.getDataType(),c),size:0}),t.interpolateTuple(u,s,r,s,o,i),e.addArray(t),n.getAttributes(s).forEach((n=>{e.setAttribute(t,n)}))}}}))},e.copyFieldOn=e=>{t.copyFieldFlags[e]=!0},e.copyFieldOff=e=>{t.copyFieldFlags[e]=!1},e.copyAllOn=()=>{t.doCopyAllOn&&!t.doCopyAllOff||(t.doCopyAllOn=!0,t.doCopyAllOff=!1,e.modified())},e.copyAllOff=()=>{!t.doCopyAllOn&&t.doCopyAllOff||(t.doCopyAllOn=!1,t.doCopyAllOff=!0,e.modified())},e.clearFieldFlags=()=>{t.copyFieldFlags={}},e.deepCopy=e=>{t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.deepCopy(e),{data:t}}))},e.copyFlags=e=>e.getCopyFieldFlags().map((e=>e)),e.reset=()=>t.arrays.forEach((e=>e.data.reset())),e.getMTime=()=>t.arrays.reduce(((e,t)=>t.data.getMTime()>e?t.data.getMTime():e),t.mtime),e.getNumberOfComponents=()=>t.arrays.reduce(((e,t)=>e+t.data.getNumberOfComponents()),0),e.getNumberOfTuples=()=>t.arrays.length>0?t.arrays[0].getNumberOfTuples():0,e.getState=()=>{const e=n();return e&&(e.arrays=t.arrays.map((e=>({data:e.data.getState()})))),e}}(e,t)}var ws={newInstance:Ht.newInstance(Is,"vtkFieldData"),extend:Is};const Os={DEFAULT:0,SINGLE:1,DOUBLE:2};var Ps={AttributeCopyOperations:{COPYTUPLE:0,INTERPOLATE:1,PASSDATA:2,ALLCOPY:3},AttributeLimitTypes:{MAX:0,EXACT:1,NOLIMIT:2},AttributeTypes:{SCALARS:0,VECTORS:1,NORMALS:2,TCOORDS:3,TENSORS:4,GLOBALIDS:5,PEDIGREEIDS:6,EDGEFLAG:7,NUM_ATTRIBUTES:8},CellGhostTypes:{DUPLICATECELL:1,HIGHCONNECTIVITYCELL:2,LOWCONNECTIVITYCELL:4,REFINEDCELL:8,EXTERIORCELL:16,HIDDENCELL:32},DesiredOutputPrecision:Os,PointGhostTypes:{DUPLICATEPOINT:1,HIDDENPOINT:2},ghostArrayName:"vtkGhostType"};const{AttributeTypes:Rs,AttributeCopyOperations:Ms}=Ps,{vtkWarningMacro:Es}=Ht,Vs={activeScalars:-1,activeVectors:-1,activeTensors:-1,activeNormals:-1,activeTCoords:-1,activeGlobalIds:-1,activePedigreeIds:-1};function Ds(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vs,n),ws.extend(e,t,n),Ht.setGet(e,t,["activeScalars","activeNormals","activeTCoords","activeVectors","activeTensors","activeGlobalIds","activePedigreeIds"]),t.arrays||(t.arrays={}),function(e,t){const n=["Scalars","Vectors","Normals","TCoords","Tensors","GlobalIds","PedigreeIds"];function r(e){let t=n.find((t=>Rs[t.toUpperCase()]===e||"number"!=typeof e&&t.toLowerCase()===e.toLowerCase()));return void 0===t&&(t=null),t}t.classHierarchy.push("vtkDataSetAttributes");const o={...e};e.checkNumberOfComponents=e=>!0,e.setAttribute=(n,o)=>{const a=r(o);if(n&&"PEDIGREEIDS"===a.toUpperCase()&&!n.isA("vtkDataArray"))return Es(`Cannot set attribute ${a}. The attribute must be a vtkDataArray.`),-1;if(n&&!e.checkNumberOfComponents(n,a))return Es(`Cannot set attribute ${a}. Incorrect number of components.`),-1;let i=t[`active${a}`];if(i>=0&&i<t.arrays.length){if(t.arrays[i]===n)return i;e.removeArrayByIndex(i)}return n?(i=e.addArray(n),t[`active${a}`]=i):t[`active${a}`]=-1,e.modified(),t[`active${a}`]},e.getAttributes=t=>n.filter((n=>e[`get${n}`]()===t)),e.setActiveAttributeByName=(t,n)=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e.setActiveAttributeByIndex=(n,o)=>{const a=r(o);if(n>=0&&n<t.arrays.length){if("PEDIGREEIDS"!==a.toUpperCase()){const t=e.getArrayByIndex(n);if(!t.isA("vtkDataArray"))return Es(`Cannot set attribute ${a}. Only vtkDataArray subclasses can be set as active attributes.`),-1;if(!e.checkNumberOfComponents(t,a))return Es(`Cannot set attribute ${a}. Incorrect number of components.`),-1}return t[`active${a}`]=n,e.modified(),n}return-1===n&&(t[`active${a}`]=n,e.modified()),-1},e.getActiveAttribute=t=>{const n=r(t);return e[`get${n}`]()},e.removeAllArrays=()=>{n.forEach((e=>{t[`active${e}`]=-1})),o.removeAllArrays()},e.removeArrayByIndex=e=>(-1!==e&&n.forEach((n=>{e===t[`active${n}`]?t[`active${n}`]=-1:e<t[`active${n}`]&&(t[`active${n}`]-=1)})),o.removeArrayByIndex(e)),n.forEach((n=>{const r=`active${n}`;e[`get${n}`]=()=>e.getArrayByIndex(t[r]),e[`set${n}`]=t=>e.setAttribute(t,n),e[`setActive${n}`]=t=>e.setActiveAttributeByIndex(e.getArrayWithIndex(t).index,n),e[`copy${n}Off`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Ms.PASSDATA][Rs[e]]=!1},e[`copy${n}On`]=()=>{const e=n.toUpperCase();t.copyAttributeFlags[Ms.PASSDATA][Rs[e]]=!0}})),e.initializeAttributeCopyFlags=()=>{t.copyAttributeFlags=[],Object.keys(Ms).filter((e=>"ALLCOPY"!==e)).forEach((e=>{t.copyAttributeFlags[Ms[e]]=Object.keys(Rs).filter((e=>"NUM_ATTRIBUTES"!==e)).reduce(((e,t)=>(e[Rs[t]]=!0,e)),[])})),t.copyAttributeFlags[Ms.COPYTUPLE][Rs.GLOBALIDS]=!1,t.copyAttributeFlags[Ms.INTERPOLATE][Rs.GLOBALIDS]=!1,t.copyAttributeFlags[Ms.COPYTUPLE][Rs.PEDIGREEIDS]=!1},e.initialize=Ht.chain(e.initialize,e.initializeAttributeCopyFlags),t.dataArrays&&Object.keys(t.dataArrays).length&&Object.keys(t.dataArrays).forEach((n=>{t.dataArrays[n].ref||"vtkDataArray"!==t.dataArrays[n].type||e.addArray(Ts.newInstance(t.dataArrays[n]))}));const a=e.shallowCopy;e.shallowCopy=(e,n)=>{a(e,n),t.arrays=e.getArrays().map((e=>{const t=e.newClone();return t.shallowCopy(e,n),{data:t}}))},e.initializeAttributeCopyFlags()}(e,t)}var Ls={newInstance:Ht.newInstance(Ds,"vtkDataSetAttributes"),extend:Ds,...Ps};const Bs=["pointData","cellData","fieldData"],Ns={};function Fs(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ns,n),Ht.obj(e,t),Ht.setGet(e,t,Bs),function(e,t){t.classHierarchy.push("vtkDataSet"),Bs.forEach((e=>{t[e]?t[e]=We(t[e]):t[e]=Ls.newInstance()}));const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),Bs.forEach((n=>{t[n]=Ls.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))}}(e,t)}var _s={newInstance:Ht.newInstance(Fs,"vtkDataSet"),extend:Fs,FieldDataTypes:{UNIFORM:0,DATA_OBJECT_FIELD:0,COORDINATE:1,POINT_DATA:1,POINT:2,POINT_FIELD_DATA:2,CELL:3,CELL_FIELD_DATA:3,VERTEX:4,VERTEX_FIELD_DATA:4,EDGE:5,EDGE_FIELD_DATA:5,ROW:6,ROW_DATA:6},FieldAssociations:{FIELD_ASSOCIATION_POINTS:0,FIELD_ASSOCIATION_CELLS:1,FIELD_ASSOCIATION_NONE:2,FIELD_ASSOCIATION_POINTS_THEN_CELLS:3,FIELD_ASSOCIATION_VERTICES:4,FIELD_ASSOCIATION_EDGES:5,FIELD_ASSOCIATION_ROWS:6,NUMBER_OF_ASSOCIATIONS:7}};const Gs={UNCHANGED:0,SINGLE_POINT:1,X_LINE:2,Y_LINE:3,Z_LINE:4,XY_PLANE:5,YZ_PLANE:6,XZ_PLANE:7,XYZ_GRID:8,EMPTY:9};var ks={StructuredType:Gs};const{StructuredType:Us}=ks;var zs={getDataDescriptionFromExtent:function(e){let t=0;for(let n=0;n<3;++n)e[2*n]<e[2*n+1]&&t++;return e[0]>e[1]||e[2]>e[3]||e[4]>e[5]?Us.EMPTY:3===t?Us.XYZ_GRID:2===t?e[0]===e[1]?Us.YZ_PLANE:e[2]===e[3]?Us.XZ_PLANE:Us.XY_PLANE:1===t?e[0]<e[1]?Us.X_LINE:e[2]<e[3]?Us.Y_LINE:Us.Z_LINE:Us.SINGLE_POINT},...ks};const{vtkErrorMacro:Ws}=Ht,Hs={direction:null,indexToWorld:null,worldToIndex:null,spacing:[1,1,1],origin:[0,0,0],extent:[0,-1,0,-1,0,-1],dataDescription:Gs.EMPTY};function js(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hs,n),_s.extend(e,t,n),t.direction?Array.isArray(t.direction)&&(t.direction=new Float64Array(t.direction.slice(0,9))):t.direction=pe(new Float64Array(9)),t.indexToWorld=new Float64Array(16),t.worldToIndex=new Float64Array(16),Ht.get(e,t,["indexToWorld","worldToIndex"]),Ht.setGetArray(e,t,["origin","spacing"],3),Ht.setGetArray(e,t,["direction"],9),Ht.getArray(e,t,["extent"],6),function(e,t){t.classHierarchy.push("vtkImageData"),e.setExtent=function(){if(t.deleted)return Ws("instance deleted - cannot call any method"),!1;for(var n=arguments.length,r=new Array(n),o=0;o<n;o++)r[o]=arguments[o];const a=1===r.length?r[0]:r;if(6!==a.length)return!1;const i=t.extent.some(((e,t)=>e!==a[t]));return i&&(t.extent=a.slice(),t.dataDescription=zs.getDataDescriptionFromExtent(t.extent),e.modified()),i},e.setDimensions=function(){let n,r,o;if(t.deleted)Ws("instance deleted - cannot call any method");else{if(1===arguments.length){const e=arguments.length<=0?void 0:arguments[0];n=e[0],r=e[1],o=e[2]}else{if(3!==arguments.length)return void Ws("Bad dimension specification");n=arguments.length<=0?void 0:arguments[0],r=arguments.length<=1?void 0:arguments[1],o=arguments.length<=2?void 0:arguments[2]}e.setExtent(0,n-1,0,r-1,0,o-1)}},e.getDimensions=()=>[t.extent[1]-t.extent[0]+1,t.extent[3]-t.extent[2]+1,t.extent[5]-t.extent[4]+1],e.getNumberOfCells=()=>{const t=e.getDimensions();let n=1;for(let e=0;e<3;e++){if(0===t[e])return 0;t[e]>1&&(n*=t[e]-1)}return n},e.getNumberOfPoints=()=>{const t=e.getDimensions();return t[0]*t[1]*t[2]},e.getPoint=n=>{const r=e.getDimensions();if(0===r[0]||0===r[1]||0===r[2])return Ws("Requesting a point from an empty image."),null;const o=new Float64Array(3);switch(t.dataDescription){case Gs.EMPTY:return null;case Gs.SINGLE_POINT:break;case Gs.X_LINE:o[0]=n;break;case Gs.Y_LINE:o[1]=n;break;case Gs.Z_LINE:o[2]=n;break;case Gs.XY_PLANE:o[0]=n%r[0],o[1]=n/r[0];break;case Gs.YZ_PLANE:o[1]=n%r[1],o[2]=n/r[1];break;case Gs.XZ_PLANE:o[0]=n%r[0],o[2]=n/r[0];break;case Gs.XYZ_GRID:o[0]=n%r[0],o[1]=n/r[0]%r[1],o[2]=n/(r[0]*r[1]);break;default:Ws("Invalid dataDescription")}const a=[0,0,0];return e.indexToWorld(o,a),a},e.getBounds=()=>e.extentToBounds(e.getSpatialExtent()),e.extentToBounds=e=>Fi.transformBounds(e,t.indexToWorld),e.getSpatialExtent=()=>Fi.inflate([...t.extent],.5),e.computeTransforms=()=>{w(t.indexToWorld,t.origin),t.indexToWorld[0]=t.direction[0],t.indexToWorld[1]=t.direction[1],t.indexToWorld[2]=t.direction[2],t.indexToWorld[4]=t.direction[3],t.indexToWorld[5]=t.direction[4],t.indexToWorld[6]=t.direction[5],t.indexToWorld[8]=t.direction[6],t.indexToWorld[9]=t.direction[7],t.indexToWorld[10]=t.direction[8],x(t.indexToWorld,t.indexToWorld,t.spacing),h(t.worldToIndex,t.indexToWorld)},e.indexToWorld=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return wn(n,e,t.indexToWorld),n},e.indexToWorldVec3=e.indexToWorld,e.worldToIndex=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return wn(n,e,t.worldToIndex),n},e.worldToIndexVec3=e.worldToIndex,e.indexToWorldBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Fi.transformBounds(e,t.indexToWorld,n)},e.worldToIndexBounds=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return Fi.transformBounds(e,t.worldToIndex,n)},e.onModified(e.computeTransforms),e.computeTransforms(),e.getCenter=()=>Fi.getCenter(e.getBounds()),e.computeHistogram=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=[0,0,0,0,0,0];e.worldToIndexBounds(t,r);const o=[0,0,0],a=[0,0,0];Fi.computeCornerPoints(r,o,a),ta(o,o),ta(a,a);const i=e.getDimensions();Ca(o,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],o),Ca(a,[0,0,0],[i[0]-1,i[1]-1,i[2]-1],a);const s=i[0],l=i[0]*i[1],c=e.getPointData().getScalars().getData();let u=-1/0,d=1/0,p=0,f=0,g=0;for(let e=o[2];e<=a[2];e++)for(let t=o[1];t<=a[1];t++){let i=o[0]+t*s+e*l;for(let s=o[0];s<=a[0];s++){if(!n||n([s,t,e],r)){const e=c[i];e>u&&(u=e),e<d&&(d=e),p+=e*e,f+=e,g+=1}++i}}const m=g>0?f/g:0,h=g?Math.abs(p/g-m*m):0;return{minimum:d,maximum:u,average:m,variance:h,sigma:Math.sqrt(h),count:g}},e.computeIncrements=function(e){const t=[];let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;for(let r=0;r<3;++r)t[r]=n,n*=e[2*r+1]-e[2*r]+1;return t},e.computeOffsetIndex=t=>{let[n,r,o]=t;const a=e.getExtent(),i=e.getPointData().getScalars().getNumberOfComponents(),s=e.computeIncrements(a,i);return Math.floor((Math.round(n)-a[0])*s[0]+(Math.round(r)-a[2])*s[1]+(Math.round(o)-a[4])*s[2])},e.getOffsetIndexFromWorld=t=>{const n=e.getExtent(),r=e.worldToIndex(t);for(let e=0;e<3;++e)if(r[e]<n[2*e]||r[e]>n[2*e+1])return Ws(`GetScalarPointer: Pixel ${r} is not in memory. Current extent = ${n}`),NaN;return e.computeOffsetIndex(r)},e.getScalarValueFromWorld=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=e.getPointData().getScalars().getNumberOfComponents();if(n<0||n>=r)return Ws(`GetScalarPointer: Scalar Component ${n} is not within bounds. Current Scalar numberOfComponents: ${r}`),NaN;const o=e.getOffsetIndexFromWorld(t);return Number.isNaN(o)?o:e.getPointData().getScalars().getComponent(o,n)}}(e,t)}var Ks={newInstance:Ht.newInstance(js,"vtkImageData"),extend:js};const $s={LUMINANCE:1,LUMINANCE_ALPHA:2,RGB:3,RGBA:4};var qs={VectorMode:{MAGNITUDE:0,COMPONENT:1,RGBCOLORS:2},ScalarMappingTarget:$s,Scale:{LINEAR:0,LOG10:1}},Xs={ColorMode:{DEFAULT:0,MAP_SCALARS:1,DIRECT_SCALARS:2},GetArray:{BY_ID:0,BY_NAME:1},ScalarMode:{DEFAULT:0,USE_POINT_DATA:1,USE_CELL_DATA:2,USE_POINT_FIELD_DATA:3,USE_CELL_FIELD_DATA:4,USE_FIELD_DATA:5}};const{ScalarMappingTarget:Ys,Scale:Zs,VectorMode:Qs}=qs,{VtkDataTypes:Js}=Ts,{ColorMode:el}=Xs,{vtkErrorMacro:tl}=Ht;function nl(e){return e}function rl(e){return Math.floor(255*e+.5)}const ol={alpha:1,vectorComponent:0,vectorSize:-1,vectorMode:Qs.COMPONENT,mappingRange:null,annotationArray:null,annotatedValueMap:null,indexedLookup:!1,scale:Zs.LINEAR};function al(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ol,n),Ht.obj(e,t),t.mappingRange=[0,255],t.annotationArray=[],t.annotatedValueMap=[],Ht.setGet(e,t,["vectorSize","vectorComponent","vectorMode","alpha","indexedLookup"]),Ht.setArray(e,t,["mappingRange"],2),Ht.getArray(e,t,["mappingRange"]),function(e,t){t.classHierarchy.push("vtkScalarsToColors"),e.setVectorModeToMagnitude=()=>e.setVectorMode(Qs.MAGNITUDE),e.setVectorModeToComponent=()=>e.setVectorMode(Qs.COMPONENT),e.setVectorModeToRGBColors=()=>e.setVectorMode(Qs.RGBCOLORS),e.build=()=>{},e.isOpaque=()=>!0,e.setAnnotations=(n,r)=>{if(!(n&&!r||!n&&r))if(n&&r&&n.length!==r.length)tl("Values and annotations do not have the same number of tuples so ignoring");else{if(t.annotationArray=[],r&&n){const e=r.length;for(let o=0;o<e;o++)t.annotationArray.push({value:n[o],annotation:String(r[o])})}e.updateAnnotatedValueMap(),e.modified()}},e.setAnnotation=(n,r)=>{let o=e.checkForAnnotatedValue(n),a=!1;return o>=0?t.annotationArray[o].annotation!==r&&(t.annotationArray[o].annotation=r,a=!0):(t.annotationArray.push({value:n,annotation:r}),o=t.annotationArray.length-1,a=!0),a&&(e.updateAnnotatedValueMap(),e.modified()),o},e.getNumberOfAnnotatedValues=()=>t.annotationArray.length,e.getAnnotatedValue=e=>e<0||e>=t.annotationArray.length?null:t.annotationArray[e].value,e.getAnnotation=e=>void 0===t.annotationArray[e]?null:t.annotationArray[e].annotation,e.getAnnotatedValueIndex=n=>t.annotationArray.length?e.checkForAnnotatedValue(n):-1,e.removeAnnotation=n=>{const r=e.checkForAnnotatedValue(n),o=r>=0;return o&&(t.annotationArray.splice(r,1),e.updateAnnotatedValueMap(),e.modified()),o},e.resetAnnotations=()=>{t.annotationArray=[],t.annotatedValueMap=[],e.modified()},e.getAnnotationColor=(n,r)=>{if(t.indexedLookup){const t=e.getAnnotatedValueIndex(n);e.getIndexedColor(t,r)}else e.getColor(parseFloat(n),r),r[3]=1},e.checkForAnnotatedValue=t=>e.getAnnotatedValueIndexInternal(t),e.getAnnotatedValueIndexInternal=e=>{if(void 0!==t.annotatedValueMap[e]){const n=t.annotationArray.length;return t.annotatedValueMap[e]%n}return-1},e.getIndexedColor=(e,t)=>{t[0]=0,t[1]=0,t[2]=0,t[3]=0},e.updateAnnotatedValueMap=()=>{t.annotatedValueMap=[];const e=t.annotationArray.length;for(let n=0;n<e;n++)t.annotatedValueMap[t.annotationArray[n].value]=n},e.mapScalars=(t,n,r)=>{const o=t.getNumberOfComponents();let a=null;if(n===el.DEFAULT&&(t.getDataType()===Js.UNSIGNED_CHAR||t.getDataType()===Js.UNSIGNED_CHAR_CLAMPED)||n===el.DIRECT_SCALARS&&t)a=e.convertToRGBA(t,o,t.getNumberOfTuples());else{const n={type:"vtkDataArray",name:"temp",numberOfComponents:4,dataType:Js.UNSIGNED_CHAR},i=Ht.newTypedArray(n.dataType,4*t.getNumberOfTuples());n.values=i,n.size=i.length,a=Ts.newInstance(n);let s=r;s<0&&o>1?e.mapVectorsThroughTable(t,a,Ys.RGBA,-1,-1):(s<0&&(s=0),s>=o&&(s=o-1),e.mapScalarsThroughTable(t,a,Ys.RGBA,s))}return a},e.mapVectorsToMagnitude=(e,t,n)=>{const r=e.getNumberOfTuples(),o=e.getNumberOfComponents(),a=t.getData(),i=e.getData();for(let e=0;e<r;e++){let t=0;for(let r=0;r<n;r++)t+=i[e*o+r]*i[e*o+r];a[e]=Math.sqrt(t)}},e.mapVectorsThroughTable=(t,n,r,o,a)=>{let i=e.getVectorMode(),s=a,l=o;const c=t.getNumberOfComponents();i===Qs.COMPONENT?(-1===l&&(l=e.getVectorComponent()),l<0&&(l=0),l>=c&&(l=c-1)):(-1===s&&(s=e.getVectorSize()),s<=0?(l=0,s=c):(l<0&&(l=0),l>=c&&(l=c-1),l+s>c&&(s=c-l)),i!==Qs.MAGNITUDE||1!==c&&1!==s||(i=Qs.COMPONENT));let u=0;switch(l>0&&(u=l),i){case Qs.COMPONENT:e.mapScalarsThroughTable(t,n,r,u);break;case Qs.RGBCOLORS:break;case Qs.MAGNITUDE:default:{const o=Ts.newInstance({numberOfComponents:1,values:new Float32Array(t.getNumberOfTuples())});e.mapVectorsToMagnitude(t,o,s),e.mapScalarsThroughTable(o,n,r,0);break}}},e.luminanceToRGBA=(e,t,n,r)=>{const o=r(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=1){const t=r(a[e]);i[4*l]=t,i[4*l+1]=t,i[4*l+2]=t,i[4*l+3]=o,l++}},e.luminanceAlphaToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=2){const t=r(o[e]);a[s]=t,a[s+1]=t,a[s+2]=t,a[s+3]=r(o[e+1])*n,s+=4}},e.rGBToRGBA=(e,t,n,r)=>{const o=rl(n),a=t.getData(),i=e.getData(),s=a.length;let l=0;for(let e=0;e<s;e+=3)i[4*l]=r(a[e]),i[4*l+1]=r(a[e+1]),i[4*l+2]=r(a[e+2]),i[4*l+3]=o,l++},e.rGBAToRGBA=(e,t,n,r)=>{const o=t.getData(),a=e.getData(),i=o.length;let s=0;for(let e=0;e<i;e+=4)a[4*s]=r(o[e]),a[4*s+1]=r(o[e+1]),a[4*s+2]=r(o[e+2]),a[4*s+3]=r(o[e+3])*n,s++},e.convertToRGBA=(n,r,o)=>{let{alpha:a}=t;if(4===r&&a>=1&&n.getDataType()===Js.UNSIGNED_CHAR)return n;const i=Ts.newInstance({numberOfComponents:4,empty:!0,size:4*o,dataType:Js.UNSIGNED_CHAR});if(o<=0)return i;a=a>0?a:0,a=a<1?a:1;let s=nl;switch(n.getDataType()!==Js.FLOAT&&n.getDataType()!==Js.DOUBLE||(s=rl),r){case 1:e.luminanceToRGBA(i,n,a,s);break;case 2:e.luminanceAlphaToRGBA(i,n,s);break;case 3:e.rGBToRGBA(i,n,a,s);break;case 4:e.rGBAToRGBA(i,n,a,s);break;default:return tl("Cannot convert colors"),null}return i},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>16777216,e.setRange=(t,n)=>e.setMappingRange(t,n),e.getRange=()=>e.getMappingRange(),e.areScalarsOpaque=(n,r,o)=>{if(!n)return e.isOpaque();const a=n.getNumberOfComponents();return(r!==el.DEFAULT||n.getDataType()!==Js.UNSIGNED_CHAR)&&r!==el.DIRECT_SCALARS||(3===a||1===a?t.alpha>=1:255===n.getRange(a-1)[0])}}(e,t)}var il={newInstance:Ht.newInstance(al,"vtkScalarsToColors"),extend:al,...qs};const{vtkErrorMacro:sl}=Ht,ll={numberOfColors:256,hueRange:[0,.66667],saturationRange:[1,1],valueRange:[1,1],alphaRange:[1,1],nanColor:[.5,0,0,1],belowRangeColor:[0,0,0,1],aboveRangeColor:[1,1,1,1],useAboveRangeColor:!1,useBelowRangeColor:!1,alpha:1};function cl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ll,n),il.extend(e,t,n),t.table||(t.table=[]),t.buildTime={},Ht.obj(t.buildTime),t.opaqueFlagBuildTime={},Ht.obj(t.opaqueFlagBuildTime,{mtime:0}),t.insertTime={},Ht.obj(t.insertTime,{mtime:0}),Ht.get(e,t,["buildTime"]),Ht.setGet(e,t,["numberOfColors","useAboveRangeColor","useBelowRangeColor"]),Ht.setArray(e,t,["alphaRange","hueRange","saturationRange","valueRange"],2),Ht.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),Ht.getArray(e,t,["hueRange","saturationRange","valueRange","alphaRange","nanColor","belowRangeColor","aboveRangeColor"]),function(e,t){t.classHierarchy.push("vtkLookupTable"),e.isOpaque=()=>{if(t.opaqueFlagBuildTime.getMTime()<e.getMTime()){let e=!0;t.nanColor[3]<1&&(e=0),t.useBelowRangeColor&&t.belowRangeColor[3]<1&&(e=0),t.useAboveRangeColor&&t.aboveRangeColor[3]<1&&(e=0);for(let n=3;n<t.table.length&&e;n+=4)t.table[n]<255&&(e=!1);t.opaqueFlag=e,t.opaqueFlagBuildTime.modified()}return t.opaqueFlag},e.usingLogScale=()=>!1,e.getNumberOfAvailableColors=()=>t.table.length/4-3,e.linearIndexLookup=(e,t)=>{let n=0;const r=Number(e);return r<t.range[0]?n=t.maxIndex+0+1.5:r>t.range[1]?n=t.maxIndex+1+1.5:(n=(r+t.shift)*t.scale,n=n<t.maxIndex?n:t.maxIndex),Math.floor(n)},e.linearLookup=(t,n,r)=>{let o=0;o=Pa(t)?Math.floor(r.maxIndex+1.5+2):e.linearIndexLookup(t,r);const a=4*o;return n.slice(a,a+4)},e.indexedLookupFunction=(n,r,o)=>{let a=e.getAnnotatedValueIndexInternal(n);-1===a&&(a=t.numberOfColors+2);const i=4*a;return[r[i],r[i+1],r[i+2],r[i+3]]},e.lookupShiftAndScale=(e,t)=>{t.shift=-e[0],t.scale=Number.MAX_VALUE,e[1]>e[0]&&(t.scale=(t.maxIndex+1)/(e[1]-e[0]))},e.mapScalarsThroughTable=(n,r,o,a)=>{let i=e.linearLookup;t.indexedLookup&&(i=e.indexedLookupFunction);const s=e.getMappingRange(),l={maxIndex:e.getNumberOfColors()-1,range:s,shift:0,scale:0};e.lookupShiftAndScale(s,l);const c=e.getAlpha(),u=n.getNumberOfTuples(),d=n.getNumberOfComponents(),p=r.getData(),f=n.getData();if(c>=1){if(o===$s.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=n[3]}}else if(o===$s.RGBA)for(let e=0;e<u;e++){const n=i(f[e*d+a],t.table,l);p[4*e]=n[0],p[4*e+1]=n[1],p[4*e+2]=n[2],p[4*e+3]=Math.floor(n[3]*c+.5)}},e.forceBuild=()=>{let n=0,r=0,o=0,a=0;const i=t.numberOfColors-1;i&&(n=(t.hueRange[1]-t.hueRange[0])/i,r=(t.saturationRange[1]-t.saturationRange[0])/i,o=(t.valueRange[1]-t.valueRange[0])/i,a=(t.alphaRange[1]-t.alphaRange[0])/i),t.table.length=4*i+16;const s=[],l=[];for(let e=0;e<=i;e++)s[0]=t.hueRange[0]+e*n,s[1]=t.saturationRange[0]+e*r,s[2]=t.valueRange[0]+e*o,pa(s,l),l[3]=t.alphaRange[0]+e*a,t.table[4*e]=255*l[0]+.5,t.table[4*e+1]=255*l[1]+.5,t.table[4*e+2]=255*l[2]+.5,t.table[4*e+3]=255*l[3]+.5;e.buildSpecialColors(),t.buildTime.modified()},e.setTable=n=>{if(Array.isArray(n)){const r=n[0].length;t.numberOfColors=n.length;const o=4-r;let a=0;for(let e=0;e<t.numberOfColors;e++)t.table[4*e]=255,t.table[4*e+1]=255,t.table[4*e+2]=255,t.table[4*e+3]=255;for(let e=0;e<n.length;e++){const i=n[e];for(let e=0;e<r;e++)t.table[a++]=i[e];a+=o}return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0}if(4!==n.getNumberOfComponents())return sl("Expected 4 components for RGBA colors"),!1;if(n.getDataType()!==is.UNSIGNED_CHAR)return sl("Expected unsigned char values for RGBA colors"),!1;t.numberOfColors=n.getNumberOfTuples();const r=n.getData();t.table.length=r.length;for(let e=0;e<r.length;e++)t.table[e]=r[e];return e.buildSpecialColors(),t.insertTime.modified(),e.modified(),!0},e.buildSpecialColors=()=>{const{numberOfColors:e}=t,n=t.table;let r=4*(e+0);t.useBelowRangeColor||0===e?(n[r]=255*t.belowRangeColor[0]+.5,n[r+1]=255*t.belowRangeColor[1]+.5,n[r+2]=255*t.belowRangeColor[2]+.5,n[r+3]=255*t.belowRangeColor[3]+.5):(n[r]=n[0],n[r+1]=n[1],n[r+2]=n[2],n[r+3]=n[3]),r=4*(e+1),t.useAboveRangeColor||0===e?(n[r]=255*t.aboveRangeColor[0]+.5,n[r+1]=255*t.aboveRangeColor[1]+.5,n[r+2]=255*t.aboveRangeColor[2]+.5,n[r+3]=255*t.aboveRangeColor[3]+.5):(n[r]=n[4*(e-1)+0],n[r+1]=n[4*(e-1)+1],n[r+2]=n[4*(e-1)+2],n[r+3]=n[4*(e-1)+3]),r=4*(e+2),n[r]=255*t.nanColor[0]+.5,n[r+1]=255*t.nanColor[1]+.5,n[r+2]=255*t.nanColor[2]+.5,n[r+3]=255*t.nanColor[3]+.5},e.build=()=>{(t.table.length<1||e.getMTime()>t.buildTime.getMTime()&&t.insertTime.getMTime()<=t.buildTime.getMTime())&&e.forceBuild()},t.table.length>0&&(e.buildSpecialColors(),t.insertTime.modified())}(e,t)}var ul={newInstance:Ht.newInstance(cl,"vtkLookupTable"),extend:cl};const dl={Off:0,PolygonOffset:1};let pl=dl.PolygonOffset,fl=dl.Off;const gl=["VTK_RESOLVE_OFF","VTK_RESOLVE_POLYGON_OFFSET"];function ml(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const t=fl===e;return fl=e,t}var hl={Resolve:dl,getResolveCoincidentTopologyAsString:function(){return gl[fl]},getResolveCoincidentTopologyPolygonOffsetFaces:function(){return pl},getResolveCoincidentTopology:function(){return fl},setResolveCoincidentTopology:ml,setResolveCoincidentTopologyPolygonOffsetFaces:function(e){const t=pl===e;return pl=e,t},setResolveCoincidentTopologyToDefault:function(){return ml(dl.Off)},setResolveCoincidentTopologyToOff:function(){return ml(dl.Off)},setResolveCoincidentTopologyToPolygonOffset:function(){return ml(dl.PolygonOffset)}};function vl(e,t,n){n.forEach((n=>{e[`get${n.method}`]=()=>t[n.key],e[`set${n.method}`]=Ht.objectSetterMap.object(e,t,{name:n.key,params:["factor","offset"]})}))}const Tl=["Polygon","Line","Point"],yl={modified:()=>{}};vl(yl,{Polygon:{factor:2,offset:0},Line:{factor:1,offset:-1},Point:{factor:0,offset:-2}},Tl.map((e=>({key:e,method:`ResolveCoincidentTopology${e}OffsetParameters`}))));var bl={implementCoincidentTopologyMethods:function(e,t){void 0===t.resolveCoincidentTopology&&(t.resolveCoincidentTopology=!1),Ht.setGet(e,t,["resolveCoincidentTopology"]),t.topologyOffset={Polygon:{factor:0,offset:0},Line:{factor:0,offset:0},Point:{factor:0,offset:0}},Object.keys(hl).forEach((t=>{e[t]=hl[t]})),Object.keys(yl).filter((e=>"modified"!==e)).forEach((t=>{e[t]=yl[t]})),vl(e,t.topologyOffset,Tl.map((e=>({key:e,method:`RelativeCoincidentTopology${e}OffsetParameters`})))),e.getCoincidentTopologyPolygonOffsetParameters=()=>{const t=yl.getResolveCoincidentTopologyPolygonOffsetParameters(),n=e.getRelativeCoincidentTopologyPolygonOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyLineOffsetParameters=()=>{const t=yl.getResolveCoincidentTopologyLineOffsetParameters(),n=e.getRelativeCoincidentTopologyLineOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}},e.getCoincidentTopologyPointOffsetParameter=()=>{const t=yl.getResolveCoincidentTopologyPointOffsetParameters(),n=e.getRelativeCoincidentTopologyPointOffsetParameters();return{factor:t.factor+n.factor,offset:t.offset+n.offset}}},staticOffsetAPI:yl,otherStaticMethods:hl,CATEGORIES:Tl,Resolve:dl};const xl={MIN_KNOWN_PASS:0,ACTOR_PASS:0,COMPOSITE_INDEX_PASS:1,ID_LOW24:2,ID_HIGH24:3,MAX_KNOWN_PASS:3};var Cl={PassTypes:xl};const{FieldAssociations:Sl}=_s,{staticOffsetAPI:Al,otherStaticMethods:Il}=bl,{ColorMode:wl,ScalarMode:Ol,GetArray:Pl}=Xs,{VectorMode:Rl}=qs,{VtkDataTypes:Ml}=Ts;function El(e){return()=>Ht.vtkErrorMacro(`vtkMapper::${e} - NOT IMPLEMENTED`)}function Vl(e,t){const n=e[1]%2==0?1:-1;if(e[0]+=n,e[0]>=t[0]||e[0]<0){const r=e[2]%2==0?1:-1;e[0]-=n,e[1]+=r,(e[1]>=t[1]||e[1]<0)&&(e[1]-=r,e[2]++)}}function Dl(e,t,n){const r=Math.floor(t),o=r%(2*n[0]);let a,i;o<n[0]?(e[0]=o,a=1,i=e[0]===n[0]-1):(e[0]=2*n[0]-1-o,a=-1,i=0===e[0]);const s=Math.floor(r/n[0]),l=s%(2*n[1]);let c,u;l<n[1]?(e[1]=l,c=1,u=e[1]===n[1]-1):(e[1]=2*n[1]-1-l,c=-1,u=0===e[1]),e[2]=Math.floor(s/n[1]);const d=t-r;i?u?e[2]+=d:e[1]+=c*d:e[0]+=a*d,e[0]=(e[0]+.5)/n[0],e[1]=(e[1]+.5)/n[1],e[2]=(e[2]+.5)/n[2]}const Ll=new WeakMap;const Bl={colorMapColors:null,areScalarsMappedFromCells:!1,static:!1,lookupTable:null,scalarVisibility:!0,scalarRange:[0,1],useLookupTableScalarRange:!1,colorMode:0,scalarMode:0,arrayAccessMode:1,renderTime:0,colorByArrayName:null,fieldDataTupleId:-1,populateSelectionSettings:!0,selectionWebGLIdsToVTKIds:null,interpolateScalarsBeforeMapping:!1,colorCoordinates:null,colorTextureMap:null,numberOfColorsInRange:0,forceCompileOnly:0,useInvertibleColors:!1,invertibleScalars:null,customShaderAttributes:[]};function Nl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Bl,n),xs(e,t,n),Ht.get(e,t,["areScalarsMappedFromCells","colorCoordinates","colorMapColors","colorTextureMap","numberOfColorsInRange","selectionWebGLIdsToVTKIds"]),Ht.setGet(e,t,["colorByArrayName","arrayAccessMode","colorMode","fieldDataTupleId","interpolateScalarsBeforeMapping","lookupTable","populateSelectionSettings","renderTime","scalarMode","scalarVisibility","static","useLookupTableScalarRange","customShaderAttributes"]),Ht.setGetArray(e,t,["scalarRange"],2),bl.implementCoincidentTopologyMethods(e,t),function(e,t){t.classHierarchy.push("vtkMapper"),e.getBounds=()=>{const n=e.getInputData();return n?(t.static||e.update(),t.bounds=n.getBounds()):t.bounds=Ra(),t.bounds},e.setForceCompileOnly=e=>{t.forceCompileOnly=e},e.setSelectionWebGLIdsToVTKIds=e=>{t.selectionWebGLIdsToVTKIds=e},e.createDefaultLookupTable=()=>{t.lookupTable=ul.newInstance()},e.getColorModeAsString=()=>Ht.enumToString(wl,t.colorMode),e.setColorModeToDefault=()=>e.setColorMode(0),e.setColorModeToMapScalars=()=>e.setColorMode(1),e.setColorModeToDirectScalars=()=>e.setColorMode(2),e.getScalarModeAsString=()=>Ht.enumToString(Ol,t.scalarMode),e.setScalarModeToDefault=()=>e.setScalarMode(0),e.setScalarModeToUsePointData=()=>e.setScalarMode(1),e.setScalarModeToUseCellData=()=>e.setScalarMode(2),e.setScalarModeToUsePointFieldData=()=>e.setScalarMode(3),e.setScalarModeToUseCellFieldData=()=>e.setScalarMode(4),e.setScalarModeToUseFieldData=()=>e.setScalarMode(5),e.getAbstractScalars=(e,n,r,o,a)=>{if(!e||!t.scalarVisibility)return{scalars:null,cellFlag:!1};let i=null,s=!1;if(n===Ol.DEFAULT)i=e.getPointData().getScalars(),i||(i=e.getCellData().getScalars(),s=!0);else if(n===Ol.USE_POINT_DATA)i=e.getPointData().getScalars();else if(n===Ol.USE_CELL_DATA)i=e.getCellData().getScalars(),s=!0;else if(n===Ol.USE_POINT_FIELD_DATA){const t=e.getPointData();i=r===Pl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Ol.USE_CELL_FIELD_DATA){const t=e.getCellData();s=!0,i=r===Pl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}else if(n===Ol.USE_FIELD_DATA){const t=e.getFieldData();i=r===Pl.BY_ID?t.getArrayByIndex(o):t.getArrayByName(a)}return{scalars:i,cellFlag:s}},e.mapScalars=(n,r)=>{const{scalars:o,cellFlag:a}=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName);if(t.areScalarsMappedFromCells=a,!o)return t.colorCoordinates=null,t.colorTextureMap=null,void(t.colorMapColors=null);const i=`${e.getMTime()}${o.getMTime()}${r}`;if(t.colorBuildString!==i){if(t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),e.canUseTextureMapForColoring(o,a))t.mapScalarsToTexture(o,a,r);else{t.colorCoordinates=null,t.colorTextureMap=null;const n=e.getLookupTable();n&&(n.build(),t.colorMapColors=n.mapScalars(o,t.colorMode,t.fieldDataTupleId))}t.colorBuildString=`${e.getMTime()}${o.getMTime()}${r}`}},t.mapScalarsToTexture=(n,r,o)=>{const a=t.lookupTable.getRange(),i=t.lookupTable.usingLogScale(),s=t.lookupTable.getAlpha(),l=i?[Math.log10(a[0]),Math.log10(a[1])]:a;if(t.colorMapColors=null,null==t.colorTextureMap||e.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getMTime()>t.colorTextureMap.getMTime()||t.lookupTable.getAlpha()!==o){t.lookupTable.setAlpha(o),t.colorTextureMap=null,t.lookupTable.build();const e=t.lookupTable.getNumberOfAvailableColors(),n=2048,a=2,d=r?n**3-3:4094;t.numberOfColorsInRange=Math.min(Math.max(e,a),d);const p=t.numberOfColorsInRange+3,f=t.numberOfColorsInRange+2,g=r?[Math.min(Math.ceil(p/n**0),n),Math.min(Math.ceil(p/n**1),n),Math.min(Math.ceil(p/n**2),n)]:[f,2,1],m=g[0]*g[1]*g[2],h=new Float64Array(m);h.fill(NaN);const v=t.numberOfColorsInRange,T=v+2,y=[0,0,0],b=l[0],x=l[1]-l[0];for(let e=0;e<T;++e){const t=b+x*(e-1)/(v-1),n=i?10**t:t;h[(u=g,(c=y)[0]+u[0]*(c[1]+u[1]*c[2]))]=n,Vl(y,g)}const C=Ts.newInstance({numberOfComponents:1,values:h}),S=t.lookupTable.mapScalars(C,t.colorMode,0);t.colorTextureMap=Ks.newInstance(),t.colorTextureMap.setDimensions(g),t.colorTextureMap.getPointData().setScalars(S),t.lookupTable.setAlpha(s)}var c,u;const d=t.lookupTable.getVectorMode()===Rl.MAGNITUDE&&n.getNumberOfComponents()>1?-1:t.lookupTable.getVectorComponent();t.colorCoordinates=function(e,t,n,r,o,a,i){const s=new Array(arguments.length);for(let e=0;e<arguments.length;++e){const t=arguments[e];s[e]=t.getMTime?.()??t}const l=s.join("/"),c=Ll.get(e);if(c&&c.stringHash===l)return c.textureCoordinates;const u=(n[1]-n[0])/(o-1),[d,p]=[n[0]-u,n[1]+u],f=d-.5*u,g=1/(p-d+u),m=d,h=(o+1)/(p-d),v=e.getData(),T=e.getNumberOfTuples(),y=e.getNumberOfComponents(),b=t<0||t>=y,x=a[2]<=1?2:3,C=Ts.newInstance({numberOfComponents:x,values:new Float32Array(T*x)}),S=C.getData(),A=[0,0,0];Dl(A,o+2,a);let I=0,w=0;const O=[.5,.5,.5];for(let e=0;e<T;++e){let e;if(b){let t=0;for(let e=0;e<y;++e){const n=v[I+e];t+=n*n}e=Math.sqrt(t)}else e=v[I+t];if(r&&(e=Math.log10(e)),I+=y,Pa(e))O[0]=A[0],O[1]=A[1],O[2]=A[2];else if(i){let t=(e-m)*h;t<1?t=0:t>o&&(t=o+1),Dl(O,t,a)}else{O[1]=.49;const t=(e-f)*g;O[0]=t>1e3?1e3:t<-1e3?-1e3:t}for(let e=0;e<x;++e)S[w++]=O[e]}return Ll.set(e,{stringHash:l,textureCoordinates:C}),C}(n,d,l,i,t.numberOfColorsInRange,t.colorTextureMap.getDimensions(),r)},e.getIsOpaque=()=>{const n=e.getInputData(),r=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;if(!t.scalarVisibility||null==r)return!0;const o=e.getLookupTable();return!o||(o.build(),o.areScalarsOpaque(r,t.colorMode,-1))},e.canUseTextureMapForColoring=(e,n)=>!((!n||t.colorMode===wl.DIRECT_SCALARS)&&(!t.interpolateScalarsBeforeMapping||t.lookupTable&&t.lookupTable.getIndexedLookup()||!e||t.colorMode===wl.DEFAULT&&e.getDataType()===Ml.UNSIGNED_CHAR||t.colorMode===wl.DIRECT_SCALARS)),e.clearColorArrays=()=>{t.colorMapColors=null,t.colorCoordinates=null,t.colorTextureMap=null},e.getLookupTable=()=>(t.lookupTable||e.createDefaultLookupTable(),t.lookupTable),e.getMTime=()=>{let e=t.mtime;if(null!==t.lookupTable){const n=t.lookupTable.getMTime();e=n>e?n:e}return e},e.getPrimitiveCount=()=>{const t=e.getInputData();return{points:t.getPoints().getNumberOfValues()/3,verts:t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells(),lines:t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells(),triangles:t.getPolys().getNumberOfValues()-3*t.getPolys().getNumberOfCells()}},e.acquireInvertibleLookupTable=El("AcquireInvertibleLookupTable"),e.valueToColor=El("ValueToColor"),e.colorToValue=El("ColorToValue"),e.useInvertibleColorFor=El("UseInvertibleColorFor"),e.clearInvertibleColor=El("ClearInvertibleColor"),e.processSelectorPixelBuffers=(e,n)=>{if(!e||!t.selectionWebGLIdsToVTKIds||!t.populateSelectionSettings)return;const r=e.getRawPixelBuffer(xl.ID_LOW24),o=e.getRawPixelBuffer(xl.ID_HIGH24),a=e.getCurrentPass(),i=e.getFieldAssociation();let s=null;i===Sl.FIELD_ASSOCIATION_POINTS?s=t.selectionWebGLIdsToVTKIds.points:i===Sl.FIELD_ASSOCIATION_CELLS&&(s=t.selectionWebGLIdsToVTKIds.cells),s&&n.forEach((t=>{if(a===xl.ID_LOW24){let n=0;o&&(n+=o[t],n*=256),n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n],i=e.getPixelBuffer(xl.ID_LOW24);i[t]=255&a,i[t+1]=(65280&a)>>8,i[t+2]=(16711680&a)>>16}else if(a===xl.ID_HIGH24&&o){let n=0;n+=o[t],n*=256,n+=r[t+2],n*=256,n+=r[t+1],n*=256,n+=r[t];const a=s[n];e.getPixelBuffer(xl.ID_HIGH24)[t]=(4278190080&a)>>24}}))}}(e,t)}var Fl={newInstance:Ht.newInstance(Nl,"vtkMapper"),extend:Nl,...Al,...Il,...Xs};const{isVtkObject:_l}=Ht;function Gl(e){let t=0;return e.filter(((e,n)=>n===t&&(t+=e+1,!0)))}function kl(e){let t=0;for(let n=0;n<e.length;)n+=e[n]+1,t++;return t}const Ul={extractCellSizes:Gl,getNumberOfCells:kl};function zl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Ts.extend(e,t,function(e){return{empty:!0,numberOfComponents:1,dataType:is.UNSIGNED_INT,...e}}(n)),function(e,t){t.classHierarchy.push("vtkCellArray");const n={...e};e.getNumberOfCells=n=>void 0===t.numberOfCells||n?(t.cellSizes?t.numberOfCells=t.cellSizes.length:t.numberOfCells=kl(e.getData()),t.numberOfCells):t.numberOfCells,e.getCellSizes=n=>void 0===t.cellSizes||n?(t.cellSizes=Gl(e.getData()),t.cellSizes):t.cellSizes,e.resize=r=>{const o=e.getNumberOfTuples();n.resize(r);const a=e.getNumberOfTuples();a<o&&(0===a?(t.numberOfCells=0,t.cellSizes=[]):(t.numberOfCells=void 0,t.cellSizes=void 0))},e.setData=e=>{n.setData(e,1),t.numberOfCells=void 0,t.cellSizes=void 0},e.getCell=e=>{let n=e;const r=t.values[n++];return t.values.subarray(n,n+r)},e.insertNextCell=n=>{let r;r=_l(n)?n.getPointsIds():n;const o=e.getNumberOfCells();return e.insertNextTuples([r.length,...r]),++t.numberOfCells,null!=t.cellSizes&&t.cellSizes.push(r.length),o}}(e,t)}var Wl={newInstance:Ht.newInstance(zl,"vtkCellArray"),extend:zl,...Ul};const{vtkErrorMacro:Hl}=Ht,jl=[1,-1,1,-1,1,-1],Kl={empty:!0,numberOfComponents:3,dataType:is.FLOAT,bounds:[1,-1,1,-1,1,-1]};function $l(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kl,n),Ts.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkPoints"),e.getNumberOfPoints=e.getNumberOfTuples,e.setNumberOfPoints=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;e.getNumberOfPoints()!==n&&(t.size=n*r,t.values=Ht.newTypedArray(t.dataType,t.size),e.setNumberOfComponents(r),e.modified())},e.setPoint=function(t){for(var n=arguments.length,r=new Array(n>1?n-1:0),o=1;o<n;o++)r[o-1]=arguments[o];e.setTuple(t,r)},e.getPoint=e.getTuple,e.findPoint=e.findTuple,e.insertNextPoint=(t,n,r)=>e.insertNextTuple([t,n,r]),e.getBounds=()=>{if(3===e.getNumberOfComponents()){const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);t.bounds[2]=r[0],t.bounds[3]=r[1];const o=e.getRange(2);return t.bounds[4]=o[0],t.bounds[5]=o[1],t.bounds}if(2!==e.getNumberOfComponents())return Hl(`getBounds called on an array with components of\n        ${e.getNumberOfComponents()}`),jl;const n=e.getRange(0);t.bounds[0]=n[0],t.bounds[1]=n[1];const r=e.getRange(1);return t.bounds[2]=r[0],t.bounds[3]=r[1],t.bounds[4]=0,t.bounds[5]=0,t.bounds},e.computeBounds=e.getBounds,e.setNumberOfComponents(t.numberOfComponents<2?3:t.numberOfComponents)}(e,t)}var ql={newInstance:Ht.newInstance($l,"vtkPoints"),extend:$l};const Xl={bounds:[-1,-1,-1,-1,-1,-1],pointsIds:[]};function Yl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xl,n),Ht.obj(e,t),t.points||(t.points=ql.newInstance()),Ht.get(e,t,["points","pointsIds"]),function(e,t){t.classHierarchy.push("vtkCell"),e.initialize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(n){t.pointsIds=n;let r=t.points.getData();r.length!==3*t.pointsIds.length&&(r=Ht.newTypedArray(e.getDataType(),3*t.pointsIds.length));const o=e.getData();t.pointsIds.forEach(((e,t)=>{let n=3*e,a=3*t;r[a]=o[n],r[++a]=o[++n],r[++a]=o[++n]})),t.points.setData(r)}else{t.points=e,t.pointsIds=new Array(e.getNumberOfPoints());for(let n=e.getNumberOfPoints()-1;n>=0;--n)t.pointsIds[n]=n}},e.getBounds=()=>{const e=t.points.getNumberOfPoints(),n=[];if(e){t.points.getPoint(0,n),t.bounds[0]=n[0],t.bounds[1]=n[0],t.bounds[2]=n[1],t.bounds[3]=n[1],t.bounds[4]=n[2],t.bounds[5]=n[2];for(let r=1;r<e;r++)t.points.getPoint(r,n),t.bounds[0]=n[0]<t.bounds[0]?n[0]:t.bounds[0],t.bounds[1]=n[0]>t.bounds[1]?n[0]:t.bounds[1],t.bounds[2]=n[1]<t.bounds[2]?n[1]:t.bounds[2],t.bounds[3]=n[1]>t.bounds[3]?n[1]:t.bounds[3],t.bounds[4]=n[2]<t.bounds[4]?n[2]:t.bounds[4],t.bounds[5]=n[2]>t.bounds[5]?n[2]:t.bounds[5]}else ya(t.bounds);return t.bounds},e.getLength2=()=>{e.getBounds();let n=0,r=0;for(let e=0;e<3;e++)r=t.bounds[2*e+1]-t.bounds[2*e],n+=r*r;return n},e.getParametricDistance=e=>{let t,n=0;for(let r=0;r<3;r++)t=e[r]<0?-e[r]:e[r]>1?e[r]-1:0,t>n&&(n=t);return n},e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.deepCopy=e=>{e.initialize(t.points,t.pointsIds)},e.getCellDimension=()=>{},e.intersectWithLine=(e,t,n,r,o,a,i)=>{},e.evaluatePosition=(e,t,n,r,o,a)=>{Ht.vtkErrorMacro("vtkCell.evaluatePosition is not implemented.")}}(e,t)}var Zl={newInstance:Ht.newInstance(Yl,"vtkCell"),extend:Yl};const Ql={array:null,maxId:0,extend:0};function Jl(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ql,n),Ht.obj(e,t),function(e,t){t.classHierarchy.push("vtkCellLinks"),e.buildLinks=n=>{const r=n.getPoints().getNumberOfPoints(),o=n.getNumberOfCells(),a=new Uint32Array(r);if(n.isA("vtkPolyData")){for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((t=>{e.incrementLinkCount(t)}))}e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t){const{cellPointIds:r}=n.getCellPoints(t);r.forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}}else{for(let t=0;t<o;t++)Zl.newInstance().getPointsIds().forEach((t=>{e.incrementLinkCount(t)}));e.allocateLinks(r),t.maxId=r-1;for(let t=0;t<o;++t)Zl.newInstance().getPointsIds().forEach((n=>{e.insertCellReference(n,a[n]++,t)}))}},e.allocate=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.array=Array(e).fill().map((()=>({ncells:0,cells:null}))),t.extend=n,t.maxId=-1},e.initialize=()=>{t.array=null},e.getLink=e=>t.array[e],e.getNcells=e=>t.array[e].ncells,e.getCells=e=>t.array[e].cells,e.insertNextPoint=e=>{t.array.push({ncells:e,cells:Array(e)}),++t.maxId},e.insertNextCellReference=(e,n)=>{t.array[e].cells[t.array[e].ncells++]=n},e.deletePoint=e=>{t.array[e].ncells=0,t.array[e].cells=null},e.removeCellReference=(e,n)=>{t.array[n].cells=t.array[n].cells.filter((t=>t!==e)),t.array[n].ncells=t.array[n].cells.length},e.addCellReference=(e,n)=>{t.array[n].cells[t.array[n].ncells++]=e},e.resizeCellList=(e,n)=>{t.array[e].cells.length=n},e.squeeze=()=>{!function(e,t){let n=t;for(t>=e.array.length&&(n+=e.array.length);n>e.array.length;)e.array.push({ncells:0,cells:null});e.array.length=n}(t,t.maxId+1)},e.reset=()=>{t.maxId=-1},e.deepCopy=e=>{t.array=[...e.array],t.extend=e.extend,t.maxId=e.maxId},e.incrementLinkCount=e=>{++t.array[e].ncells},e.allocateLinks=e=>{for(let n=0;n<e;++n)t.array[n].cells=new Array(t.array[n].ncells)},e.insertCellReference=(e,n,r)=>{t.array[e].cells[n]=r}}(e,t)}var ec={newInstance:Ht.newInstance(Jl,"vtkCellLinks"),extend:Jl};const tc=0,nc=1,rc=2,oc=3,ac=4,ic=5,sc=6,lc=7,cc=9,uc=21,dc=41,pc=42,fc=["vtkEmptyCell","vtkVertex","vtkPolyVertex","vtkLine","vtkPolyLine","vtkTriangle","vtkTriangleStrip","vtkPolygon","vtkPixel","vtkQuad","vtkTetra","vtkVoxel","vtkHexahedron","vtkWedge","vtkPyramid","vtkPentagonalPrism","vtkHexagonalPrism","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkQuadraticEdge","vtkQuadraticTriangle","vtkQuadraticQuad","vtkQuadraticTetra","vtkQuadraticHexahedron","vtkQuadraticWedge","vtkQuadraticPyramid","vtkBiQuadraticQuad","vtkTriQuadraticHexahedron","vtkQuadraticLinearQuad","vtkQuadraticLinearWedge","vtkBiQuadraticQuadraticWedge","vtkBiQuadraticQuadraticHexahedron","vtkBiQuadraticTriangle","vtkCubicLine","vtkQuadraticPolygon","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkConvexPointSet","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","UnknownClass","vtkParametricCurve","vtkParametricSurface","vtkParametricTriSurface","vtkParametricQuadSurface","vtkParametricTetraRegion","vtkParametricHexRegion","UnknownClass","UnknownClass","UnknownClass","vtkHigherOrderEdge","vtkHigherOrderTriangle","vtkHigherOrderQuad","vtkHigherOrderPolygon","vtkHigherOrderTetrahedron","vtkHigherOrderWedge","vtkHigherOrderPyramid","vtkHigherOrderHexahedron"],gc={getClassNameFromTypeId:function(e){return e<fc.length?fc[e]:"UnknownClass"},getTypeIdFromClassName:function(e){return fc.findIndex(e)},isLinear:function(e){return e<uc||e===dc||e===pc},hasSubCells:function(e){return e===sc||e===ac||e===rc}},mc={size:0,maxId:-1,extend:1e3};function hc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,mc,n),Ht.obj(e,t),Ht.get(e,t,["size","maxId","extend"]),Ht.getArray(e,t,["typeArray","locationArray"]),function(e,t){t.classHierarchy.push("vtkCellTypes"),e.allocate=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:512,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1e3;t.size=e>0?e:1,t.extend=n>0?n:1,t.maxId=-1,t.typeArray=new Uint8Array(e),t.locationArray=new Uint32Array(e)},e.insertCell=(e,n,r)=>{t.typeArray[e]=n,t.locationArray[e]=r,e>t.maxId&&(t.maxId=e)},e.insertNextCell=(n,r)=>(e.insertCell(++t.maxId,n,r),t.maxId),e.setCellTypes=(e,n,r)=>{t.size=e,t.typeArray=n,t.locationArray=r,t.maxId=e-1},e.getCellLocation=e=>t.locationArray[e],e.deleteCell=e=>{t.typeArray[e]=tc},e.getNumberOfTypes=()=>t.maxId+1,e.isType=t=>{const n=e.getNumberOfTypes();for(let r=0;r<n;++r)if(t===e.getCellType(r))return!0;return!1},e.insertNextType=t=>e.insertNextCell(t,-1),e.getCellType=e=>t.typeArray[e],e.reset=()=>{t.maxId=-1},e.deepCopy=n=>{e.allocate(n.getSize(),n.getExtend()),t.typeArray.set(n.getTypeArray()),t.locationArray.set(n.getLocationArray()),t.maxId=n.getMaxId()}}(e,t)}var vc={newInstance:Ht.newInstance(hc,"vtkCellTypes"),extend:hc,...gc},Tc={IntersectionState:{NO_INTERSECTION:0,YES_INTERSECTION:1,ON_LINE:2}};const{IntersectionState:yc}=Tc;function bc(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const o={t:Number.MIN_VALUE,distance:0},a=[];let i;a[0]=n[0]-t[0],a[1]=n[1]-t[1],a[2]=n[2]-t[2];const s=a[0]*(e[0]-t[0])+a[1]*(e[1]-t[1])+a[2]*(e[2]-t[2]),l=No(a,a);let c=1e-5*s;return 0!==l&&(o.t=s/l),c<0&&(c=-c),-c<l&&l<c||l<=0||o.t<0?i=t:o.t>1?i=n:(i=a,a[0]=t[0]+o.t*a[0],a[1]=t[1]+o.t*a[1],a[2]=t[2]+o.t*a[2]),r&&(r[0]=i[0],r[1]=i[1],r[2]=i[2]),o.distance=Uo(i,e),o}function xc(e,t,n,r,o,a){const i=[],s=[],l=[];o[0]=0,a[0]=0,Vo(t,e,i),Vo(r,n,s),Vo(n,e,l);const c=[No(i,i),-No(i,s),-No(i,s),No(s,s)],u=[];if(u[0]=No(i,l),u[1]=-No(s,l),0===la(c,u,2)){let i=Number.MAX_VALUE;const s=[e,t,n,r],l=[n,n,e,e],c=[r,r,t,t];let u;a[0],a[0],o[0],o[0],o[0],o[0],a[0],a[0];for(let e=0;e<4;e++)u=bc(s[e],l[e],c[e]),u.distance<i&&(i=u.distance,u.t);return yc.ON_LINE}return o[0]=u[0],a[0]=u[1],o[0]>=0&&o[0]<=1&&a[0]>=0&&a[0]<=1?yc.YES_INTERSECTION:yc.NO_INTERSECTION}const Cc={distanceToLine:bc,intersection:xc},Sc={orientations:null};function Ac(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Sc,n),Zl.extend(e,t,n),Ht.setGet(e,t,["orientations"]),function(e,t){t.classHierarchy.push("vtkLine"),e.getCellDimension=()=>1,e.intersectWithLine=(e,n,r,o,a)=>{const i={intersect:0,t:Number.MAX_VALUE,subId:0,betweenPoints:null};a[1]=0,a[2]=0;const s=[],l=[],c=[];t.points.getPoint(0,l),t.points.getPoint(1,c);const u=[],d=[],p=xc(e,n,l,c,u,d);var f;if(i.t=u[0],i.betweenPoints=(f=i.t)>=0&&f<=1,a[0]=d[0],p===yc.YES_INTERSECTION){for(let t=0;t<3;t++)o[t]=l[t]+a[0]*(c[t]-l[t]),s[t]=e[t]+i.t*(n[t]-e[t]);if(Uo(o,s)<=r*r)return i.intersect=1,i}else{let t;if(i.t<0)return t=bc(e,l,c,o),t.distance<=r*r?(i.t=0,i.intersect=1,i.betweenPoints=!0,i):i;if(i.t>1)return t=bc(n,l,c,o),t.distance<=r*r?(i.t=1,i.intersect=1,i.betweenPoints=!0,i):i;if(a[0]<0)return a[0]=0,t=bc(l,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i;if(a[0]>1)return a[0]=1,t=bc(c,e,n,o),i.t=t.t,t.distance<=r*r?(i.intersect=1,i):i}return i},e.evaluateLocation=(e,n,r)=>{const o=[],a=[];t.points.getPoint(0,o),t.points.getPoint(1,a);for(let t=0;t<3;t++)n[t]=o[t]+e[0]*(a[t]-o[t]);r[0]=1-e[0],r[1]=e[0]},e.evaluateOrientation=(e,n,r)=>!!t.orientations&&(function(e,t,n,r){var o,i,s,l,c,u=t[0],d=t[1],p=t[2],f=t[3],g=n[0],m=n[1],h=n[2],v=n[3];(i=u*g+d*m+p*h+f*v)<0&&(i=-i,g=-g,m=-m,h=-h,v=-v),1-i>a?(o=Math.acos(i),s=Math.sin(o),l=Math.sin((1-r)*o)/s,c=Math.sin(r*o)/s):(l=1-r,c=r),e[0]=l*u+c*g,e[1]=l*d+c*m,e[2]=l*p+c*h,e[3]=l*f+c*v}(n,t.orientations[0],t.orientations[1],e[0]),r[0]=1-e[0],r[1]=e[0],!0)}(e,t)}var Ic={newInstance:Ht.newInstance(Ac,"vtkLine"),extend:Ac,...Cc,...Tc};const wc={};function Oc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wc,n),_s.extend(e,t,n),Ht.setGet(e,t,["points"]),function(e,t){t.classHierarchy.push("vtkPointSet"),t.points?t.points=We(t.points):t.points=ql.newInstance(),e.getNumberOfPoints=()=>t.points.getNumberOfPoints(),e.getBounds=()=>t.points.getBounds(),e.computeBounds=()=>{e.getBounds()};const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),t.points=ql.newInstance(),t.points.shallowCopy(e.getPoints())}}(e,t)}var Pc={newInstance:Ht.newInstance(Oc,"vtkPointSet"),extend:Oc};function Rc(e,t,n,r){const o=n[0]-t[0],a=n[1]-t[1],i=n[2]-t[2],s=e[0]-t[0],l=e[1]-t[1],c=e[2]-t[2];r[0]=a*c-i*l,r[1]=i*s-o*c,r[2]=o*l-a*s}function Mc(e,t,n,r){Rc(e,t,n,r);const o=Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);0!==o&&(r[0]/=o,r[1]/=o,r[2]/=o)}function Ec(e){e[0]=-1,e[1]=1,e[2]=0,e[3]=-1,e[4]=0,e[5]=1}const Vc={computeNormalDirection:Rc,computeNormal:Mc,interpolationDerivs:Ec,intersectWithTriangle:function(e,t,n,r,o,a){let i=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1e-6,s=!1;const l=[],c=[],u=[],d=[],p=[];Mc(e,t,n,d),Mc(r,o,a,p);const f=-No(d,e),g=-No(p,r),m=[No(p,e)+g,No(p,t)+g,No(p,n)+g];if(m[0]*m[1]>i&&m[0]*m[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const h=[No(d,r)+f,No(d,o)+f,No(d,a)+f];if(h[0]*h[1]>i&&h[0]*h[2]>i)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Math.abs(d[0]-p[0])<1e-9&&Math.abs(d[1]-p[1])<1e-9&&Math.abs(d[2]-p[2])<1e-9&&Math.abs(f-g)<1e-9)return s=!0,{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};const v=[e,t,n],T=[r,o,a],y=No(d,p),b=(f-g*y)/(y*y-1),x=(g-f*y)/(y*y-1),C=[b*d[0]+x*p[0],b*d[1]+x*p[1],b*d[2]+x*p[2]],S=Fo(d,p,[]);Go(S);let A=0,I=0;const w=[],O=[];let P,R,M=50,E=50;for(let t=0;t<3;t++){const n=t,o=(t+1)%3,a=ti.intersectWithLine(v[n],v[o],r,p);a.intersection&&a.t>0-i&&a.t<1+i&&(a.t<1+i&&a.t>1-i&&(M=A),w[A++]=No(a.x,S)-No(C,S));const s=ti.intersectWithLine(T[n],T[o],e,d);s.intersection&&s.t>0-i&&s.t<1+i&&(s.t<1+i&&s.t>1-i&&(E=I),O[I++]=No(s.x,S)-No(C,S))}if(A>2){A--;const e=w[2];w[2]=w[M],w[M]=e}if(I>2){I--;const e=O[2];O[2]=O[E],O[E]=e}if(2!==A||2!==I)return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(Number.isNaN(w[0])||Number.isNaN(w[1])||Number.isNaN(O[0])||Number.isNaN(O[1]))return{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u};if(w[0]>w[1]){const e=w[1];w[1]=w[0],w[0]=e}if(O[0]>O[1]){const e=O[1];O[1]=O[0],O[0]=e}return w[1]<O[0]||O[1]<w[0]?{intersect:!1,coplanar:s,pt1:l,pt2:c,surfaceId:u}:(w[0]<O[0]?w[1]<O[1]?(u[0]=2,u[1]=1,P=O[0],R=w[1]):(u[0]=2,u[1]=2,P=O[0],R=O[1]):w[1]<O[1]?(u[0]=1,u[1]=1,P=w[0],R=w[1]):(u[0]=1,u[1]=2,P=w[0],R=O[1]),Bo(C,S,P,l),Bo(C,S,R,c),{intersect:!0,coplanar:s,pt1:l,pt2:c,surfaceId:u})}},Dc={};function Lc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dc,n),Zl.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkTriangle"),e.getCellDimension=()=>2,e.intersectWithLine=(n,r,o,a,i)=>{const s={subId:0,t:Number.MAX_VALUE,intersect:0,betweenPoints:!1};i[2]=0;const l=[],c=o*o,u=[],d=[],p=[];t.points.getPoint(0,u),t.points.getPoint(1,d),t.points.getPoint(2,p);const f=[],g=[];if(Mc(u,d,p,f),0!==f[0]||0!==f[1]||0!==f[2]){const t=ti.intersectWithLine(n,r,u,f);if(s.betweenPoints=t.betweenPoints,s.t=t.t,a[0]=t.x[0],a[1]=t.x[1],a[2]=t.x[2],!t.intersection)return i[0]=0,i[1]=0,s.intersect=0,s;const o=e.evaluatePosition(a,l,i,g);if(o.evaluation>=0)return o.dist2<=c?(s.intersect=1,s):(s.intersect=o.evaluation,s)}const m=Uo(u,d),h=Uo(d,p),v=Uo(p,u);t.line||(t.line=Ic.newInstance()),m>h&&m>v?(t.line.getPoints().setPoint(0,u),t.line.getPoints().setPoint(1,d)):h>v&&h>m?(t.line.getPoints().setPoint(0,d),t.line.getPoints().setPoint(1,p)):(t.line.getPoints().setPoint(0,p),t.line.getPoints().setPoint(1,u));const T=t.line.intersectWithLine(n,r,o,a,i);if(s.betweenPoints=T.betweenPoints,s.t=T.t,T.intersect){const e=[],t=[],n=[];for(let r=0;r<3;r++)e[r]=u[r]-p[r],t[r]=d[r]-p[r],n[r]=a[r]-p[r];return i[0]=No(n,e)/v,i[1]=No(n,t)/h,s.intersect=1,s}return i[0]=0,i[1]=0,s.intersect=0,s},e.evaluatePosition=(e,n,r,o)=>{const a={subId:0,dist2:0,evaluation:-1};let i,s;const l=[],c=[],u=[],d=[];let p;const f=[],g=[],m=[];let h=0,v=0;const T=[];let y,b,x,C=[];const S=[],A=[],I=[];a.subId=0,r[2]=0,t.points.getPoint(1,l),t.points.getPoint(2,c),t.points.getPoint(0,u),Rc(l,c,u,d),ti.generalizedProjectPoint(e,l,d,I);let w=0;for(i=0;i<3;i++)p=d[i]<0?-d[i]:d[i],p>w&&(w=p,v=i);for(s=0,i=0;i<3;i++)i!==v&&(T[s++]=i);for(i=0;i<2;i++)f[i]=I[T[i]]-u[T[i]],g[i]=l[T[i]]-u[T[i]],m[i]=c[T[i]]-u[T[i]];if(h=Ho(g,m),0===h)return r[0]=0,r[1]=0,a.evaluation=-1,a;if(r[0]=Ho(f,m)/h,r[1]=Ho(g,f)/h,o[0]=1-(r[0]+r[1]),o[1]=r[0],o[2]=r[1],o[0]>=0&&o[0]<=1&&o[1]>=0&&o[1]<=1&&o[2]>=0&&o[2]<=1)n&&(a.dist2=Uo(I,e),n[0]=I[0],n[1]=I[1],n[2]=I[2]),a.evaluation=1;else{let t;if(n)if(o[1]<0&&o[2]<0)for(y=Uo(e,u),b=Ic.distanceToLine(e,l,u,t,S),x=Ic.distanceToLine(e,u,c,t,A),y<b?(a.dist2=y,C=u):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[2]<0&&o[0]<0)for(y=Uo(e,l),b=Ic.distanceToLine(e,l,u,t,S),x=Ic.distanceToLine(e,l,c,t,A),y<b?(a.dist2=y,C=l):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[1]<0&&o[0]<0)for(y=Uo(e,c),b=Ic.distanceToLine(e,c,u,t,S),x=Ic.distanceToLine(e,l,c,t,A),y<b?(a.dist2=y,C=c):(a.dist2=b,C=S),x<a.dist2&&(a.dist2=x,C=A),i=0;i<3;i++)n[i]=C[i];else if(o[0]<0){const t=Ic.distanceToLine(e,l,c,n);a.dist2=t.distance}else if(o[1]<0){const t=Ic.distanceToLine(e,c,u,n);a.dist2=t.distance}else if(o[2]<0){const t=Ic.distanceToLine(e,l,u,n);a.dist2=t.distance}a.evaluation=0}return a},e.evaluateLocation=(e,n,r)=>{const o=[],a=[],i=[];t.points.getPoint(0,o),t.points.getPoint(1,a),t.points.getPoint(2,i);const s=1-e[0]-e[1];for(let t=0;t<3;t++)n[t]=o[t]*s+a[t]*e[0]+i[t]*e[1];r[0]=s,r[1]=e[0],r[2]=e[1]},e.getParametricDistance=e=>{let t,n=0;const r=[];r[0]=e[0],r[1]=e[1],r[2]=1-e[0]-e[1];for(let e=0;e<3;e++)t=r[e]<0?-r[e]:r[e]>1?r[e]-1:0,t>n&&(n=t);return n},e.derivatives=(e,n,r,o,a)=>{const i=[],s=[],l=[];t.points.getPoint(0,i),t.points.getPoint(1,s),t.points.getPoint(2,l);const c=[],u=[],d=[],p=[];Mc(i,s,l,c);for(let e=0;e<3;e++)u[e]=s[e]-i[e],p[e]=l[e]-i[e];Fo(c,u,d);const f=Go(u);if(f<=0||Go(d)<=0){for(let e=0;e<o;e++)for(let t=0;t<3;t++)a[e*o+t]=0;return}const g=[0,0],m=[f,0],h=[No(p,u),No(p,d)],v=new Array(6);Ec(v);const T=[m[0]-g[0],m[1]-g[1],h[0]-g[0],h[1]-g[1]],y=new Array(4).fill(0);ca(T,y,2);for(let e=0;e<o;e++){let t=0,n=0;for(let a=0;a<3;a++)t+=v[a]*r[o*a+e],n+=v[3+a]*r[o*a+e];const i=t*y[0]+n*y[1],s=t*y[2]+n*y[3];a[3*e]=i*u[0]+s*d[0],a[3*e+1]=i*u[1]+s*d[1],a[3*e+2]=i*u[2]+s*d[2]}},e.cellBoundary=(e,n,r)=>{const o=n[0]-n[1],a=.5*(1-n[0])-n[1],i=2*n[0]+n[1]-1;return o>=0&&a>=0?(r[0]=t.pointsIds[0],r[1]=t.pointsIds[1]):a<0&&i>=0?(r[0]=t.pointsIds[1],r[1]=t.pointsIds[2]):(r[0]=t.pointsIds[2],r[1]=t.pointsIds[0]),!(n[0]<0||n[1]<0||n[0]>1||n[1]>1||1-n[0]-n[1]<0)}}(e,t)}var Bc={newInstance:Ht.newInstance(Lc,"vtkTriangle"),extend:Lc,...Vc};const Nc=["verts","lines","polys","strips"],{vtkWarningMacro:Fc}=Ht,_c={[oc]:Ic,[ac]:Ic,[ic]:Bc},Gc={};function kc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gc,n),Pc.extend(e,t,n),Ht.get(e,t,["cells","links"]),Ht.setGet(e,t,["verts","lines","polys","strips"]),function(e,t){t.classHierarchy.push("vtkPolyData"),Nc.forEach((n=>{e[`getNumberOf${function(e){return e.replace(/(?:^\w|[A-Z]|\b\w)/g,(e=>e.toUpperCase())).replace(/\s+/g,"")}(n)}`]=()=>t[n].getNumberOfCells(),t[n]?t[n]=We(t[n]):t[n]=Wl.newInstance()})),e.getNumberOfCells=()=>Nc.reduce(((e,n)=>e+t[n].getNumberOfCells()),0);const n=e.shallowCopy;e.shallowCopy=function(e){n(e,arguments.length>1&&void 0!==arguments[1]&&arguments[1]),Nc.forEach((n=>{t[n]=Wl.newInstance(),t[n].shallowCopy(e.getReferenceByName(n))}))},e.buildCells=()=>{const n=e.getNumberOfVerts(),r=e.getNumberOfLines(),o=e.getNumberOfPolys(),a=e.getNumberOfStrips(),i=n+r+o+a,s=new Uint8Array(i);let l=s;const c=new Uint32Array(i);let u=c;if(n){let e=0;t.verts.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>1?rc:nc,e+=t+1})),u=u.subarray(n),l=l.subarray(n)}if(r){let e=0;t.lines.getCellSizes().forEach(((t,n)=>{u[n]=e,l[n]=t>2?ac:oc,1===t&&Fc("Building VTK_LINE ",n," with only one point, but VTK_LINE needs at least two points. Check the input."),e+=t+1})),u=u.subarray(r),l=l.subarray(r)}if(o){let e=0;t.polys.getCellSizes().forEach(((t,n)=>{switch(u[n]=e,t){case 3:l[n]=ic;break;case 4:l[n]=cc;break;default:l[n]=lc}t<3&&Fc("Building VTK_TRIANGLE ",n," with less than three points, but VTK_TRIANGLE needs at least three points. Check the input."),e+=t+1})),u+=u.subarray(o),l+=l.subarray(o)}if(a){let e=0;l.fill(sc,0,a),t.strips.getCellSizes().forEach(((t,n)=>{u[n]=e,e+=t+1}))}t.cells=vc.newInstance(),t.cells.setCellTypes(i,s,c)},e.buildLinks=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;void 0===t.cells&&e.buildCells(),t.links=ec.newInstance(),n>0?t.links.allocate(n):t.links.allocate(e.getPoints().getNumberOfPoints()),t.links.buildLinks(e)},e.getCellType=e=>t.cells.getCellType(e),e.getCellPoints=n=>{const r=e.getCellType(n);let o=null;switch(r){case nc:case rc:o=t.verts;break;case oc:case ac:o=t.lines;break;case ic:case cc:case lc:o=t.polys;break;case sc:o=t.strips;break;default:return o=null,{type:0,cellPointIds:null}}const a=t.cells.getCellLocation(n);return{cellType:r,cellPointIds:o.getCell(a)}},e.getPointCells=e=>t.links.getCells(e),e.getCellEdgeNeighbors=(e,n,r)=>{const o=t.links.getLink(n),a=t.links.getLink(r);return o.cells.filter((t=>t!==e&&-1!==a.cells.indexOf(t)))},e.getCell=function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const r=e.getCellPoints(t),o=n||_c[r.cellType].newInstance();return o.initialize(e.getPoints(),r.cellPointIds),o}}(e,t)}var Uc={newInstance:Ht.newInstance(kc,"vtkPolyData"),extend:kc};const zc={image:null,canvas:null,jsImageData:null,imageBitmap:null,imageLoaded:!1,repeat:!1,interpolate:!1,edgeClamp:!1,mipLevel:0,resizable:!1};function Wc(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zc,n),Ht.obj(e,t),Ht.algo(e,t,6,0),Ht.get(e,t,["canvas","image","jsImageData","imageBitmap","imageLoaded","resizable"]),Ht.setGet(e,t,["repeat","edgeClamp","interpolate","mipLevel"]),function(e,t){t.classHierarchy.push("vtkTexture"),e.imageLoaded=()=>{t.image.removeEventListener("load",e.imageLoaded),t.imageLoaded=!0,e.modified()},e.setJsImageData=n=>{t.jsImageData!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null,t.imageBitmap=null),t.jsImageData=n,t.imageLoaded=!0,e.modified())},e.setImageBitmap=n=>{t.imageBitmap!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.canvas=null,t.jsImageData=null),t.imageBitmap=n,t.imageLoaded=!0,e.modified())},e.setCanvas=n=>{t.canvas!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.image=null,t.imageBitmap=null,t.jsImageData=null),t.canvas=n,e.modified())},e.setImage=n=>{t.image!==n&&(null!==n&&(e.setInputData(null),e.setInputConnection(null),t.canvas=null,t.jsImageData=null,t.imageBitmap=null),t.image=n,t.imageLoaded=!1,n.complete?e.imageLoaded():n.addEventListener("load",e.imageLoaded),e.modified())},e.getDimensionality=()=>{let n=0,r=0,o=1;if(e.getInputData()){const t=e.getInputData();n=t.getDimensions()[0],r=t.getDimensions()[1],o=t.getDimensions()[2]}return t.jsImageData&&(n=t.jsImageData.width,r=t.jsImageData.height),t.canvas&&(n=t.canvas.width,r=t.canvas.height),t.image&&(n=t.image.width,r=t.image.height),t.imageBitmap&&(n=t.imageBitmap.width,r=t.imageBitmap.height),(n>1)+(r>1)+(o>1)},e.getInputAsJsImageData=()=>{if(!t.imageLoaded||e.getInputData())return null;if(t.jsImageData)return t.jsImageData;if(t.imageBitmap)return t.imageBitmap;if(t.canvas)return t.canvas.getContext("2d").getImageData(0,0,t.canvas.width,t.canvas.height);if(t.image){const e=t.image.width,n=t.image.height,r=new OffscreenCanvas(e,n).getContext("2d");return r.translate(0,n),r.scale(1,-1),r.drawImage(t.image,0,0,e,n),r.getImageData(0,0,e,n)}return null}}(e,t)}var Hc={newInstance:Ht.newInstance(Wc,"vtkTexture"),extend:Wc,generateMipmaps:(e,t,n)=>{const r=e.createShaderModule({code:"\n    @group(0) @binding(0) var inputTexture: texture_2d<f32>;\n    @group(0) @binding(1) var outputTexture: texture_storage_2d<rgba8unorm, write>;\n\n    @compute @workgroup_size(8, 8)\n    fn main(@builtin(global_invocation_id) global_id: vec3<u32>) {\n      let texelCoord = vec2<i32>(global_id.xy);\n      let outputSize = textureDimensions(outputTexture);\n\n      if (texelCoord.x >= i32(outputSize.x) || texelCoord.y >= i32(outputSize.y)) {\n        return;\n      }\n\n      let inputSize = textureDimensions(inputTexture);\n      let scale = vec2<f32>(inputSize) / vec2<f32>(outputSize);\n\n      // Compute the floating-point source coordinate\n      let srcCoord = (vec2<f32>(texelCoord) + 0.5) * scale - 0.5;\n\n      // Get integer coordinates for the four surrounding texels\n      let x0 = i32(floor(srcCoord.x));\n      let x1 = min(x0 + 1, i32(inputSize.x) - 1);\n      let y0 = i32(floor(srcCoord.y));\n      let y1 = min(y0 + 1, i32(inputSize.y) - 1);\n\n      // Compute the weights\n      let wx = srcCoord.x - f32(x0);\n      let wy = srcCoord.y - f32(y0);\n\n      // Fetch the four texels\n      let c00 = textureLoad(inputTexture, vec2<i32>(x0, y0), 0);\n      let c10 = textureLoad(inputTexture, vec2<i32>(x1, y0), 0);\n      let c01 = textureLoad(inputTexture, vec2<i32>(x0, y1), 0);\n      let c11 = textureLoad(inputTexture, vec2<i32>(x1, y1), 0);\n\n      // Bilinear interpolation\n      let color = mix(\n        mix(c00, c10, wx),\n        mix(c01, c11, wx),\n        wy\n      );\n\n      textureStore(outputTexture, texelCoord, color);\n    }\n  "}),o=e.createBindGroupLayout({entries:[{binding:0,visibility:GPUShaderStage.COMPUTE,texture:{sampleType:"float"}},{binding:1,visibility:GPUShaderStage.COMPUTE,storageTexture:{format:"rgba8unorm",access:"write-only"}},{binding:2,visibility:GPUShaderStage.COMPUTE,sampler:{type:"filtering"}}]}),a=e.createPipelineLayout({bindGroupLayouts:[o]}),i=e.createComputePipeline({label:"ComputeMipmapPipeline",layout:a,compute:{module:r,entryPoint:"main"}}),s=e.createSampler({magFilter:"linear",minFilter:"linear"});for(let r=1;r<n;r++){const n=t.createView({baseMipLevel:r-1,mipLevelCount:1}),o=t.createView({baseMipLevel:r,mipLevelCount:1}),a=e.createBindGroup({layout:i.getBindGroupLayout(0),entries:[{binding:0,resource:n},{binding:1,resource:o},{binding:2,resource:s}]}),l=e.createCommandEncoder({label:"MipmapGenerateCommandEncoder"}),c=l.beginComputePass();c.setPipeline(i),c.setBindGroup(0,a);const u=Math.max(1,t.width>>r),d=Math.max(1,t.height>>r),p=Math.ceil(u/8),f=Math.ceil(d/8);c.dispatchWorkgroups(p,f),c.end(),e.queue.submit([l.finish()])}}};const jc=[[-1,0,0],[1,0,0],[0,-1,0],[0,1,0],[0,0,-1],[0,0,1]],Kc=[[8,7,11,3],[9,1,10,5],[4,9,0,8],[2,11,6,10],[0,3,2,1],[4,5,6,7]],$c=[[0,1],[1,3],[2,3],[0,2],[4,5],[5,7],[6,7],[4,6],[0,4],[1,5],[3,7],[2,6]],qc=[0,1,0,1,0,1,0,1,2,2,2,2],Xc=[[1,2],[1,2],[0,2],[0,2],[0,1],[0,1]],Yc=new Float64Array(3),Zc=new Float64Array(3),Qc=new Float64Array(3),Jc=new Float64Array(3),eu=new Float64Array(3),tu=new Float64Array(3),nu=new Float64Array(16);function ru(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function ou(e){const t=[],n=[];for(let r=0;r<3;r++){const o=oo().domain([e[2*r],e[2*r+1]]);t[r]=o.ticks(5);const a=o.tickFormat(5);n[r]=t[r].map(a)}return{ticks:t,tickStrings:n}}const au=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),Ht.obj(e,t),t.tmPolyData=Uc.newInstance(),t.tmMapper=Fl.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmActor=os.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),Ht.setGet(e,t,["renderable"]),Ht.get(e,t,["lastSize","lastAspectRatio","axisTextStyle","tickTextStyle","tmActor","ticks"]),t.forceUpdate=!1,t.lastRedrawTime={},Ht.obj(t.lastRedrawTime,{mtime:0}),t.lastRebuildTime={},Ht.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.lastTickBounds=[],function(e,t){t.classHierarchy.push("vtkCubeAxesActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.tmActor.addTexture(t.renderable.getTmTexture()),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),e.modified())},e.createPolyDataForOneLabel=(e,n,r,o,a,i,s)=>{const l=t.renderable.get_tmAtlas().get(e);if(!l)return;const c=t.renderable.getTextPolyData().getPoints().getData(),u=t.lastSize;Yc[0]=c[3*n],Yc[1]=c[3*n+1],Yc[2]=c[3*n+2],wn(Qc,Yc,r),Qc[0]+=.1,wn(Zc,Qc,o),yn(eu,Zc,Yc),Qc[0]-=.1,Qc[1]+=.1,wn(Zc,Qc,o),yn(tu,Zc,Yc);for(let e=0;e<3;e++)eu[e]/=.05*u[0],tu[e]/=.05*u[1];let d=s.ptIdx,p=s.cellIdx;Yc[0]=c[3*n],Yc[1]=c[3*n+1],Yc[2]=c[3*n+2],a[0]<-.5?xn(Qc,eu,a[0]*i-l.width):a[0]>.5?xn(Qc,eu,a[0]*i):xn(Qc,eu,a[0]*i-l.width/2),Tn(Yc,Yc,Qc),xn(Qc,tu,a[1]*i-l.height/2),Tn(Yc,Yc,Qc),s.points[3*d]=Yc[0],s.points[3*d+1]=Yc[1],s.points[3*d+2]=Yc[2],s.tcoords[2*d]=l.tcoords[0],s.tcoords[2*d+1]=l.tcoords[1],d++,xn(Qc,eu,l.width),Tn(Yc,Yc,Qc),s.points[3*d]=Yc[0],s.points[3*d+1]=Yc[1],s.points[3*d+2]=Yc[2],s.tcoords[2*d]=l.tcoords[2],s.tcoords[2*d+1]=l.tcoords[3],d++,xn(Qc,tu,l.height),Tn(Yc,Yc,Qc),s.points[3*d]=Yc[0],s.points[3*d+1]=Yc[1],s.points[3*d+2]=Yc[2],s.tcoords[2*d]=l.tcoords[4],s.tcoords[2*d+1]=l.tcoords[5],d++,xn(Qc,eu,l.width),yn(Yc,Yc,Qc),s.points[3*d]=Yc[0],s.points[3*d+1]=Yc[1],s.points[3*d+2]=Yc[2],s.tcoords[2*d]=l.tcoords[6],s.tcoords[2*d+1]=l.tcoords[7],d++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-3,s.polys[4*p+3]=d-2,p++,s.polys[4*p]=3,s.polys[4*p+1]=d-4,s.polys[4*p+2]=d-2,s.polys[4*p+3]=d-1,s.ptIdx+=4,s.cellIdx+=2},e.updateTexturePolyData=()=>{const n=t.camera.getCompositeProjectionMatrix(t.lastAspectRatio,-1,1);m(n,n);const r=t.renderable.getTextValues().length,o=4*r,a=2*r,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o);h(nu,n);const c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l};let u=0,d=0,p=0;const f=t.renderable.getTextPolyData().getPoints().getData(),g=t.renderable.getTextValues();for(;u<f.length/3;){Yc[0]=f[3*u],Yc[1]=f[3*u+1],Yc[2]=f[3*u+2],wn(Qc,Yc,n),Yc[0]=f[3*u+3],Yc[1]=f[3*u+4],Yc[2]=f[3*u+5],wn(Jc,Yc,n),yn(Qc,Qc,Jc);const r=[Qc[0],Qc[1]];Wo(r),e.createPolyDataForOneLabel(g[d],u,n,nu,r,t.renderable.getAxisTitlePixelOffset(),c),u+=2,d++;for(let o=0;o<t.renderable.getTickCounts()[p];o++)e.createPolyDataForOneLabel(g[d],u,n,nu,r,t.renderable.getTickLabelPixelOffset(),c),u++,d++;p++}const v=Ts.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(v),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0),t.camera=r,e.updateTexturePolyData()}}(e,t)}),"vtkCubeAxesActorHelper");function iu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};os.extend(e,t,function(e,t,n){return{boundsScaleFactor:1.3,camera:null,dataBounds:[...Fi.INIT_BOUNDS],faceVisibilityAngle:8,gridLines:!0,axisLabels:null,axisTitlePixelOffset:35,tickLabelPixelOffset:12,generateTicks:ou,...n,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif",...n?.axisTextStyle},tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif",...n?.tickTextStyle}}}(0,0,n)),t.lastFacesToDraw=[!1,!1,!1,!1,!1,!1],t.axisLabels=["X-Axis","Y-Axis","Z-Axis"],t.tickCounts=[],t.textValues=[],t.lastTickBounds=[],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.tmTexture=Hc.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),t.gridMapper=Fl.newInstance(),t.polyData=Uc.newInstance(),t.gridMapper.setInputData(t.polyData),t.gridActor=os.newInstance(),t.gridActor.setMapper(t.gridMapper),t.gridActor.setProperty(e.getProperty()),t.gridActor.setParentProp(e),t.textPolyData=Uc.newInstance(),Ht.setGet(e,t,["axisTitlePixelOffset","boundsScaleFactor","faceVisibilityAngle","gridLines","tickLabelPixelOffset","generateTicks"]),Ht.setGetArray(e,t,["dataBounds"],6),Ht.setGetArray(e,t,["axisLabels"],3),Ht.get(e,t,["axisTextStyle","tickTextStyle","camera","tmTexture","textValues","textPolyData","tickCounts","gridActor"]),function(e,t){t.classHierarchy.push("vtkCubeAxesActor"),e.setCamera=n=>{t.camera!==n&&(t.cameraModifiedSub&&(t.cameraModifiedSub.unsubscribe(),t.cameraModifiedSub=null),t.camera=n,n&&(t.cameraModifiedSub=n.onModified(e.update)),e.update(),e.modified())},e.computeFacesToDraw=()=>{const e=t.camera.getViewMatrix();m(e,e);let n=!1;const r=Fi.getDiagonalLength(t.dataBounds),o=Math.sin(t.faceVisibilityAngle*Math.PI/180);for(let a=0;a<6;a++){let i=!1;const s=Math.floor(a/2),l=(s+1)%3,c=(s+2)%3;t.dataBounds[2*l]!==t.dataBounds[2*l+1]&&t.dataBounds[2*c]!==t.dataBounds[2*c+1]&&(Yc[s]=t.dataBounds[a]-.1*r*jc[a][s],Yc[l]=.5*(t.dataBounds[2*l]+t.dataBounds[2*l+1]),Yc[c]=.5*(t.dataBounds[2*c]+t.dataBounds[2*c+1]),wn(Qc,Yc,e),Yc[s]=t.dataBounds[a],wn(Jc,Yc,e),yn(Qc,Jc,Qc),Sn(Qc,Qc),i=Qc[2]>o,t.camera.getParallelProjection()||(Sn(Jc,Jc),i=An(Jc,Qc)>o)),i!==t.lastFacesToDraw[a]&&(t.lastFacesToDraw[a]=i,n=!0)}return n},e.updatePolyData=(e,n,r)=>{let o=0,a=0;o+=8;let i=0;for(let e=0;e<12;e++)n[e]>0&&i++;if(a+=i,t.gridLines)for(let t=0;t<6;t++)e[t]&&(o+=2*r[Xc[t][0]].length+2*r[Xc[t][1]].length,a+=r[Xc[t][0]].length+r[Xc[t][1]].length);const s=new Float64Array(3*o),l=new Uint32Array(3*a);let c=0,u=0;for(let e=0;e<2;e++)for(let n=0;n<2;n++)for(let r=0;r<2;r++)s[3*c]=t.dataBounds[r],s[3*c+1]=t.dataBounds[2+n],s[3*c+2]=t.dataBounds[4+e],c++;for(let e=0;e<12;e++)n[e]>0&&(l[3*u]=2,l[3*u+1]=$c[e][0],l[3*u+2]=$c[e][1],u++);if(t.gridLines)for(let n=0;n<6;n++)if(e[n]){const e=Math.floor(n/2);let o=r[Xc[n][0]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Xc[n][0]]=o[r],s[3*c+Xc[n][1]]=t.dataBounds[2*Xc[n][1]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Xc[n][0]]=o[r],s[3*c+Xc[n][1]]=t.dataBounds[2*Xc[n][1]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++;o=r[Xc[n][1]];for(let r=0;r<o.length;r++)s[3*c+e]=t.dataBounds[n],s[3*c+Xc[n][1]]=o[r],s[3*c+Xc[n][0]]=t.dataBounds[2*Xc[n][0]],c++,s[3*c+e]=t.dataBounds[n],s[3*c+Xc[n][1]]=o[r],s[3*c+Xc[n][0]]=t.dataBounds[2*Xc[n][0]+1],c++,l[3*u]=2,l[3*u+1]=c-2,l[3*u+2]=c-1,u++}t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getLines().setData(l,1),t.polyData.getLines().modified(),t.polyData.modified()},e.updateTextData=(e,n,r,o)=>{let a=0;for(let e=0;e<12;e++)1===n[e]&&(a+=2,a+=r[qc[e]].length);const i=t.polyData.getPoints().getData(),s=new Float64Array(3*a);let l=0,c=0,u=0;for(let a=0;a<6;a++)if(e[a])for(let e=0;e<4;e++){const d=Kc[a][e];if(1===n[d]){const e=qc[d],n=3*$c[d][0],p=3*$c[d][1];s[3*l]=.5*(i[n]+i[p]),s[3*l+1]=.5*(i[n+1]+i[p+1]),s[3*l+2]=.5*(i[n+2]+i[p+2]),l++,s[3*l+Math.floor(a/2)]=t.dataBounds[a],s[3*l+Xc[a][0]]=.5*(t.dataBounds[2*Xc[a][0]]+t.dataBounds[2*Xc[a][0]+1]),s[3*l+Xc[a][1]]=.5*(t.dataBounds[2*Xc[a][1]]+t.dataBounds[2*Xc[a][1]+1]),l++,t.textValues[c]=t.axisLabels[e],c++;const f=(e+1)%3,g=(e+2)%3,m=r[e],h=o[e];t.tickCounts[u]=m.length;for(let r=0;r<m.length;r++)s[3*l+e]=m[r],s[3*l+f]=i[n+f],s[3*l+g]=i[n+g],l++,t.textValues[c]=h[r],c++;u++}}t.textPolyData.getPoints().setData(s,3),t.textPolyData.modified()},e.update=()=>{if(!t.camera)return;const n=e.computeFacesToDraw(),r=t.lastFacesToDraw;let o=!1;for(let e=0;e<6;e++)t.dataBounds[e]!==t.lastTickBounds[e]&&(o=!0,t.lastTickBounds[e]=t.dataBounds[e]);if(n||o||t.forceUpdate){const n=new Array(12).fill(0);for(let e=0;e<6;e++)if(r[e])for(let t=0;t<4;t++)n[Kc[e][t]]++;const a=t.generateTicks(t.dataBounds);e.updatePolyData(r,n,a.ticks),e.updateTextData(r,n,a.ticks,a.tickStrings),(o||t.forceUpdate)&&e.updateTextureAtlas(a.tickStrings)}t.forceUpdate=!1},e.updateTextureAtlas=e=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t._tmAtlas.clear();let n=0,r=1;for(let o=0;o<3;o++){if(!t._tmAtlas.has(t.axisLabels[o])){ru(t.tmContext,t.axisTextStyle);const e=t.tmContext.measureText(t.axisLabels[o]),a={height:e.actualBoundingBoxAscent+2,startingHeight:r,width:e.width+2,textStyle:t.axisTextStyle};t._tmAtlas.set(t.axisLabels[o],a),r+=a.height,n<a.width&&(n=a.width)}ru(t.tmContext,t.tickTextStyle);for(let a=0;a<e[o].length;a++)if(!t._tmAtlas.has(e[o][a])){const i=t.tmContext.measureText(e[o][a]),s={height:i.actualBoundingBoxAscent+2,startingHeight:r,width:i.width+2,textStyle:t.tickTextStyle};t._tmAtlas.set(e[o][a],s),r+=s.height,n<s.width&&(n=s.width)}}n=Po(n),r=Po(r),t._tmAtlas.forEach((e=>{e.tcoords=[0,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight-e.height)/r,e.width/n,(r-e.startingHeight)/r,0,(r-e.startingHeight)/r]})),t.tmCanvas.width=n,t.tmCanvas.height=r,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,n,r),t._tmAtlas.forEach(((e,n)=>{ru(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified()},e.onModified((()=>{t.forceUpdate=!0,e.update()})),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.get_tmAtlas=()=>t._tmAtlas,e.getBounds=()=>(e.update(),Fi.setBounds(t.bounds,t.gridActor.getBounds()),Fi.scaleAboutCenter(t.bounds,t.boundsScaleFactor,t.boundsScaleFactor,t.boundsScaleFactor),t.bounds);const n=Ht.chain(e.setProperty,t.gridActor.setProperty);e.setProperty=e=>n(e)[0]}(e,t)}var su={newInstance:Ht.newInstance(iu,"vtkCubeAxesActor"),extend:iu,newCubeAxesActorHelper:au,defaultGenerateTicks:ou};const lu={};const cu=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lu,n),Xt.extend(e,t,n),t.CubeAxesActorHelper=su.newCubeAxesActorHelper(),function(e,t){t.classHierarchy.push("vtkOpenGLCubeAxesActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.CubeAxesActorHelper.getRenderable()||t.CubeAxesActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.CubeAxesActorHelper.getTmActor()),e.addMissingNode(t.renderable.getGridActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.CubeAxesActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}(e,t)}),"vtkOpenGLCubeAxesActor");en("vtkCubeAxesActor",cu);const uu={ARRAY_BUFFER:0,ELEMENT_ARRAY_BUFFER:1,TEXTURE_BUFFER:2};var du={ObjectType:uu};const{ObjectType:pu}=du,fu={objectType:pu.ARRAY_BUFFER,context:null,allocatedGPUMemoryInBytes:0};function gu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fu,n),Ht.obj(e,t),Ht.get(e,t,["_openGLRenderWindow","allocatedGPUMemoryInBytes"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){function n(e){switch(e){case pu.ELEMENT_ARRAY_BUFFER:return t.context.ELEMENT_ARRAY_BUFFER;case pu.TEXTURE_BUFFER:if("TEXTURE_BUFFER"in t.context)return t.context.TEXTURE_BUFFER;case pu.ARRAY_BUFFER:default:return t.context.ARRAY_BUFFER}}t.classHierarchy.push("vtkOpenGLBufferObject");let r=null,o=null,a=!0,i="";e.getType=()=>r,e.setType=e=>{r=e},e.getHandle=()=>o,e.isReady=()=>!1===a,e.generateBuffer=e=>{const a=n(e);return null===o&&(o=t.context.createBuffer(),r=e),n(r)===a},e.upload=(s,l)=>e.generateBuffer(l)?(t.context.bindBuffer(n(r),o),t.context.bufferData(n(r),s,t.context.STATIC_DRAW),t.allocatedGPUMemoryInBytes=s.length*s.BYTES_PER_ELEMENT,a=!1,!0):(i="Trying to upload array buffer to incompatible buffer.",!1),e.bind=()=>!!o&&(t.context.bindBuffer(n(r),o),!0),e.release=()=>!!o&&(t.context.bindBuffer(n(r),null),!0),e.releaseGraphicsResources=()=>{null!==o&&(t.context.bindBuffer(n(r),null),t.context.deleteBuffer(o),o=null,t.allocatedGPUMemoryInBytes=0)},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getError=()=>i}(e,t)}var mu={newInstance:Ht.newInstance(gu),extend:gu,...du};function hu(e){let t=0,n=0;for(let r=0;r<3;++r){const o=e.getRange(r),a=o[1]-o[0];t+=a*a;const i=.5*(o[1]+o[0]);n+=i*i}const r=t>0&&(Math.abs(n)/t>1e6||Math.abs(Math.log10(t))>3||0===t&&n>1e6);if(r){const t=new Float64Array(3),n=new Float64Array(3);for(let r=0;r<3;++r){const o=e.getRange(r),a=o[1]-o[0];t[r]=.5*(o[1]+o[0]),n[r]=a>0?1/a:1}return{useShiftAndScale:r,coordShift:t,coordScale:n}}return{useShiftAndScale:r,coordShift:new Float32Array([0,0,0]),coordScale:new Float32Array([1,1,1])}}const{vtkErrorMacro:vu}=Ht;const Tu={elementCount:0,stride:0,colorBOStride:0,vertexOffset:0,normalOffset:0,tCoordOffset:0,tCoordComponents:0,colorOffset:0,colorComponents:0,tcoordBO:null,customData:[],coordShift:null,coordScale:null,coordShiftAndScaleEnabled:!1,inverseShiftAndScaleMatrix:null};function yu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tu,n),mu.extend(e,t,n),Ht.setGet(e,t,["colorBO","elementCount","stride","colorBOStride","vertexOffset","normalOffset","tCoordOffset","tCoordComponents","colorOffset","colorComponents","customData"]),Ht.get(e,t,["coordShift","coordScale","coordShiftAndScaleEnabled","inverseShiftAndScaleMatrix"]),function(e,t){t.classHierarchy.push("vtkOpenGLCellArrayBufferObject"),e.setType(uu.ARRAY_BUFFER),e.createVBO=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;if(!n.getData()||!n.getData().length)return t.elementCount=0,0;t.blockSize=3,t.vertexOffset=0,t.normalOffset=0,t.tCoordOffset=0,t.tCoordComponents=0,t.colorComponents=0,t.colorOffset=0,t.customData=[];const s=a.points.getData();let l=null,c=null,u=null;const d=a.colors?a.colors.getNumberOfComponents():0,p=a.tcoords?a.tcoords.getNumberOfComponents():0;a.normals&&(t.normalOffset=4*t.blockSize,t.blockSize+=3,l=a.normals.getData()),a.customAttributes&&a.customAttributes.forEach((e=>{e&&(t.customData.push({data:e.getData(),offset:4*t.blockSize,components:e.getNumberOfComponents(),name:e.getName()}),t.blockSize+=e.getNumberOfComponents())})),a.tcoords&&(t.tCoordOffset=4*t.blockSize,t.tCoordComponents=p,t.blockSize+=p,c=a.tcoords.getData()),a.colors?(t.colorComponents=a.colors.getNumberOfComponents(),t.colorOffset=0,u=a.colors.getData(),t.colorBO||(t.colorBO=mu.newInstance()),t.colorBO.setOpenGLRenderWindow(t._openGLRenderWindow)):t.colorBO=null,t.stride=4*t.blockSize;let f,g=0,m=0,h=0,v=0,T=0,y=0;const b={anythingToPoints(e,t,n,r){for(let o=0;o<e;++o)f(t[n+o],r)},linesToWireframe(e,t,n,r){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r)},polysToWireframe(e,t,n,r){if(e>2)for(let o=0;o<e;++o)f(t[n+o],r),f(t[n+(o+1)%e],r)},stripsToWireframe(e,t,n,r){if(e>2){for(let o=0;o<e-1;++o)f(t[n+o],r),f(t[n+o+1],r);for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+2],r)}},polysToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+0],r),f(t[n+o+1],r),f(t[n+o+2],r)},stripsToSurface(e,t,n,r){for(let o=0;o<e-2;o++)f(t[n+o],r),f(t[n+o+1+o%2],r),f(t[n+o+1+(o+1)%2],r)}},x={anythingToPoints(e,t){return e},linesToWireframe(e,t){return e>1?2*(e-1):0},polysToWireframe(e,t){return e>2?2*e:0},stripsToWireframe(e,t){return e>2?4*e-6:0},polysToSurface(e,t){return e>2?3*(e-2):0},stripsToSurface(e,t,n){return e>2?3*(e-2):0}};let C=null,S=null;o===qi.POINTS||"verts"===r?(C=b.anythingToPoints,S=x.anythingToPoints):o===qi.WIREFRAME||"lines"===r?(C=b[`${r}ToWireframe`],S=x[`${r}ToWireframe`]):(C=b[`${r}ToSurface`],S=x[`${r}ToSurface`]);const A=n.getData(),I=A.length;let w=0;for(let e=0;e<I;)w+=S(A[e],A),e+=A[e]+1;let O=null;const P=new Float32Array(w*t.blockSize);u&&(O=new Uint8Array(4*w));let R=0,M=0;const{useShiftAndScale:E,coordShift:V,coordScale:D}=hu(a.points);if(E?e.setCoordShiftAndScale(V,D):!0===t.coordShiftAndScaleEnabled&&e.setCoordShiftAndScale(null,null),i)if(i.points||i.cells){const e=new Int32Array(w+i.points.length);e.set(i.points),i.points=e;const t=new Int32Array(w+i.cells.length);t.set(i.cells),i.cells=t}else i.points=new Int32Array(w),i.cells=new Int32Array(w);let L=a.vertexOffset;f=function(e,n){if(i&&(i.points[L]=e,i.cells[L]=y+a.cellOffset),++L,g=3*e,t.coordShiftAndScaleEnabled?(P[R++]=(s[g++]-t.coordShift[0])*t.coordScale[0],P[R++]=(s[g++]-t.coordShift[1])*t.coordScale[1],P[R++]=(s[g++]-t.coordShift[2])*t.coordScale[2]):(P[R++]=s[g++],P[R++]=s[g++],P[R++]=s[g++]),null!==l&&(m=a.haveCellNormals?3*(y+a.cellOffset):3*e,P[R++]=l[m++],P[R++]=l[m++],P[R++]=l[m++]),t.customData.forEach((t=>{T=e*t.components;for(let e=0;e<t.components;++e)P[R++]=t.data[T++]})),null!==c){h=a.useTCoordsPerCell?n*p:e*p;for(let e=0;e<p;++e)P[R++]=c[h++]}null!==u&&(v=a.haveCellScalars?(y+a.cellOffset)*d:e*d,O[M++]=u[v++],O[M++]=u[v++],O[M++]=u[v++],O[M++]=4===d?u[v++]:255)};for(let e=0;e<I;e+=A[e]+1,y++)C(A[e],A,e+1,y+a.cellOffset);return t.elementCount=w,e.upload(P,uu.ARRAY_BUFFER),t.colorBO&&(t.colorBOStride=4,t.colorBO.upload(O,uu.ARRAY_BUFFER)),y},e.setCoordShiftAndScale=(e,n)=>{null===e||e.constructor===Float64Array&&3===e.length?null===n||n.constructor===Float64Array&&3===n.length?(null!==t.coordShift&&null!==e&&Rn(e,t.coordShift)||(t.coordShift=e),null!==t.coordScale&&null!==n&&Rn(n,t.coordScale)||(t.coordScale=n),t.coordShiftAndScaleEnabled=function(e,t){return null!==e&&null!==t&&!(Pn(e,[0,0,0])&&Pn(t,[1,1,1]))}(t.coordShift,t.coordScale),t.coordShiftAndScaleEnabled?t.inverseShiftAndScaleMatrix=function(e,t){const n=new Float64Array(3);Cn(n,t);const r=new Float64Array(16);return F(r,Na(),e,n),r}(t.coordShift,t.coordScale):t.inverseShiftAndScaleMatrix=null):vu("Wrong type for coordScale, expected vec3 or null"):vu("Wrong type for coordShift, expected vec3 or null")}}(e,t)}var bu={newInstance:Ht.newInstance(yu),extend:yu};const{vtkErrorMacro:xu}=Ht,Cu={shaderType:"Unknown",source:"",error:"",handle:0,dirty:!1,context:null};function Su(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cu,n),Ht.obj(e,t),Ht.setGet(e,t,["shaderType","source","error","handle","context"]),function(e,t){t.classHierarchy.push("vtkShader"),e.compile=()=>{let e=t.context.VERTEX_SHADER;if(!t.source||!t.source.length||"Unknown"===t.shaderType)return!1;if(0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0),e="Fragment"===t.shaderType?t.context.FRAGMENT_SHADER:t.context.VERTEX_SHADER,t.handle=t.context.createShader(e),t.context.shaderSource(t.handle,t.source),t.context.compileShader(t.handle),!t.context.getShaderParameter(t.handle,t.context.COMPILE_STATUS)){const e=t.context.getShaderInfoLog(t.handle);return xu(`Error compiling shader '${t.source}': ${e}`),t.context.deleteShader(t.handle),t.handle=0,!1}return!0},e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(t.context.deleteShader(t.handle),t.handle=0,t.dirty=!0)}}(e,t)}var Au={newInstance:Ht.newInstance(Su,"vtkShader"),extend:Su};const{vtkErrorMacro:Iu}=Ht,wu={vertexShaderHandle:0,fragmentShaderHandle:0,geometryShaderHandle:0,vertexShader:null,fragmentShader:null,geometryShader:null,linked:!1,bound:!1,compiled:!1,error:"",handle:0,numberOfOutputs:0,attributesLocs:null,uniformLocs:null,md5Hash:0,context:null,lastCameraMTime:null};function Ou(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wu,n),t.attributesLocs={},t.uniformLocs={},t.vertexShader=Au.newInstance(),t.vertexShader.setShaderType("Vertex"),t.fragmentShader=Au.newInstance(),t.fragmentShader.setShaderType("Fragment"),t.geometryShader=Au.newInstance(),t.geometryShader.setShaderType("Geometry"),Ht.obj(e,t),Ht.get(e,t,["lastCameraMTime"]),Ht.setGet(e,t,["error","handle","compiled","bound","md5Hash","vertexShader","fragmentShader","geometryShader","linked"]),function(e,t){t.classHierarchy.push("vtkShaderProgram"),e.compileShader=()=>t.vertexShader.compile()?t.fragmentShader.compile()?e.attachShader(t.vertexShader)&&e.attachShader(t.fragmentShader)?e.link()?(e.setCompiled(!0),1):(Iu(`Links failed: ${t.error}`),0):(Iu(t.error),0):(Iu(t.fragmentShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),Iu(t.fragmentShader.getError()),0):(Iu(t.vertexShader.getSource().split("\n").map(((e,t)=>`${t}: ${e}`)).join("\n")),Iu(t.vertexShader.getError()),0),e.cleanup=()=>{"Unknown"!==t.shaderType&&0!==t.handle&&(e.release(),0!==t.vertexShaderHandle&&(t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=0),0!==t.fragmentShaderHandle&&(t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=0),t.context.deleteProgram(t.handle),t.handle=0,e.setCompiled(!1))},e.bind=()=>!(!t.linked&&!e.link()||(t.context.useProgram(t.handle),e.setBound(!0),0)),e.isBound=()=>!!t.bound,e.release=()=>{t.context.useProgram(null),e.setBound(!1)},e.setContext=e=>{t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.link=()=>{if(t.linked)return!0;if(0===t.handle)return t.error="Program has not been initialized, and/or does not have shaders.",!1;if(t.uniformLocs={},t.context.linkProgram(t.handle),!t.context.getProgramParameter(t.handle,t.context.LINK_STATUS)){const e=t.context.getProgramInfoLog(t.handle);return Iu(`Error linking shader ${e}`),t.handle=0,!1}return e.setLinked(!0),t.attributeLocs={},!0},e.setUniformMatrix=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix4fv(o,!1,a),!0},e.setUniformMatrix3x3=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;const a=new Float32Array(r);return t.context.uniformMatrix3fv(o,!1,a),!0},e.setUniformf=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1f(o,r),!0)},e.setUniformfv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1fv(o,r),!0)},e.setUniformi=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1i(o,r),!0)},e.setUniformiv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform1iv(o,r),!0)},e.setUniform2f=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2f(a,r,o),!0},e.setUniform2fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2fv(o,r),!0)},e.setUniform2i=(n,r,o)=>{const a=e.findUniform(n);if(-1===a)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===o)throw new RangeError("Invalid number of values for array");return t.context.uniform2i(a,r,o),!0},e.setUniform2iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform2iv(o,r),!0)},e.setUniform3f=(n,r,o,a)=>{const i=e.findUniform(n);if(-1===i)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(void 0===a)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(i,r,o,a),!0},e.setUniform3fArray=(n,r)=>{const o=e.findUniform(n);if(-1===o)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;if(!Array.isArray(r)||3!==r.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3f(o,r[0],r[1],r[2]),!0},e.setUniform3fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3fv(o,r),!0)},e.setUniform3i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),3!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform3i(r,s[0],s[1],s[2]),!0},e.setUniform3iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform3iv(o,r),!0)},e.setUniform4f=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4f(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4fv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4fv(o,r),!0)},e.setUniform4i=function(n){const r=e.findUniform(n);if(-1===r)return t.error=`Could not set uniform ${n} . No such uniform.`,!1;for(var o=arguments.length,a=new Array(o>1?o-1:0),i=1;i<o;i++)a[i-1]=arguments[i];let s=a;if(1===s.length&&Array.isArray(s[0])&&(s=s[0]),4!==s.length)throw new RangeError("Invalid number of values for array");return t.context.uniform4i(r,s[0],s[1],s[2],s[3]),!0},e.setUniform4iv=(n,r)=>{const o=e.findUniform(n);return-1===o?(t.error=`Could not set uniform ${n} . No such uniform.`,!1):(t.context.uniform4iv(o,r),!0)},e.findUniform=e=>{if(!e||!t.linked)return-1;let n=t.uniformLocs[e];return void 0!==n?n:(n=t.context.getUniformLocation(t.handle,e),null===n?(t.error=`Uniform ${e} not found in current shader program.`,t.uniformLocs[e]=-1,-1):(t.uniformLocs[e]=n,n))},e.isUniformUsed=e=>{if(!e)return!1;let n=t.uniformLocs[e];return void 0!==n?null!==n:t.linked?(n=t.context.getUniformLocation(t.handle,e),t.uniformLocs[e]=n,null!==n):(Iu("attempt to find uniform when the shader program is not linked"),!1)},e.isAttributeUsed=e=>{if(!e)return!1;if(e in t.attributeLocs)return!0;if(!t.linked)return Iu("attempt to find uniform when the shader program is not linked"),!1;const n=t.context.getAttribLocation(t.handle,e);return-1!==n&&(t.attributeLocs[e]=n,!0)},e.attachShader=n=>{if(0===n.getHandle())return t.error="Shader object was not initialized, cannot attach it.",!1;if("Unknown"===n.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;if(0===t.handle){const e=t.context.createProgram();if(0===e)return t.error="Could not create shader program.",!1;t.handle=e,t.linked=!1}return"Vertex"===n.getShaderType()&&(0!==t.vertexShaderHandle&&t.context.detachShader(t.handle,t.vertexShaderHandle),t.vertexShaderHandle=n.getHandle()),"Fragment"===n.getShaderType()&&(0!==t.fragmentShaderHandle&&t.context.detachShader(t.handle,t.fragmentShaderHandle),t.fragmentShaderHandle=n.getHandle()),t.context.attachShader(t.handle,n.getHandle()),e.setLinked(!1),!0},e.detachShader=e=>{if(0===e.getHandle())return t.error="shader object was not initialized, cannot attach it.",!1;if("Unknown"===e.getShaderType())return t.error="Shader object is of type Unknown and cannot be used.",!1;switch(0===t.handle&&(t.error="This shader program has not been initialized yet."),e.getShaderType()){case"Vertex":return t.vertexShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.vertexShaderHandle=0,t.linked=!1,!0);case"Fragment":return t.fragmentShaderHandle!==e.getHandle()?(t.error="The supplied shader was not attached to this program.",!1):(t.context.detachShader(t.handle,e.getHandle()),t.fragmentShaderHandle=0,t.linked=!1,!0);default:return!1}},e.setContext=e=>{t.context=e,t.vertexShader.setContext(e),t.fragmentShader.setContext(e),t.geometryShader.setContext(e)},e.setLastCameraMTime=e=>{t.lastCameraMTime=e}}(e,t)}var Pu={newInstance:Ht.newInstance(Ou,"vtkShaderProgram"),extend:Ou,substitute:function(e,t,n,r){const o="string"==typeof n?n:n.join("\n"),a=!1===r?t:new RegExp(t,"g"),i=e.replace(a,o);return{replace:i!==o,result:i}}};const Ru={forceEmulation:!1,handleVAO:0,handleProgram:0,supported:!0,buffers:null,context:null};function Mu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ru,n),t.buffers=[],Ht.obj(e,t),Ht.get(e,t,["supported"]),Ht.setGet(e,t,["forceEmulation"]),function(e,t){t.classHierarchy.push("vtkOpenGLVertexArrayObject"),e.exposedMethod=()=>{},e.initialize=()=>{t.instancingExtension=null,t._openGLRenderWindow.getWebgl2()||(t.instancingExtension=t.context.getExtension("ANGLE_instanced_arrays")),!t.forceEmulation&&t._openGLRenderWindow&&t._openGLRenderWindow.getWebgl2()?(t.extension=null,t.supported=!0,t.handleVAO=t.context.createVertexArray()):(t.extension=t.context.getExtension("OES_vertex_array_object"),!t.forceEmulation&&t.extension?(t.supported=!0,t.handleVAO=t.extension.createVertexArrayOES()):t.supported=!1)},e.isReady=()=>0!==t.handleVAO||!1===t.supported,e.bind=()=>{if(e.isReady()||e.initialize(),e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(t.handleVAO):t.context.bindVertexArray(t.handleVAO);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,1):e.vertexAttribDivisor(o.index+n,1))}}}},e.release=()=>{if(e.isReady()&&t.supported)t.extension?t.extension.bindVertexArrayOES(null):t.context.bindVertexArray(null);else if(e.isReady()){const e=t.context;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];t.context.bindBuffer(e.ARRAY_BUFFER,r.buffer);for(let n=0;n<r.attributes.length;++n){const o=r.attributes[n],a=o.isMatrix?o.size:1;for(let n=0;n<a;++n)e.enableVertexAttribArray(o.index+n),e.vertexAttribPointer(o.index+n,o.size,o.type,o.normalize,o.stride,o.offset+o.stride*n/o.size),o.divisor>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(o.index+n,0):e.vertexAttribDivisor(o.index+n,0)),e.disableVertexAttribArray(o.index+n)}}}},e.shaderProgramChanged=()=>{e.release(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.handleProgram=0},e.releaseGraphicsResources=()=>{e.shaderProgramChanged(),t.handleVAO&&(t.extension?t.extension.deleteVertexArrayOES(t.handleVAO):t.context.deleteVertexArray(t.handleVAO)),t.handleVAO=0,t.supported=!0,t.handleProgram=0},e.addAttributeArray=(t,n,r,o,a,i,s,l)=>e.addAttributeArrayWithDivisor(t,n,r,o,a,i,s,l,0,!1),e.addAttributeArrayWithDivisor=(n,r,o,a,i,s,l,c,u,d)=>{if(!n)return!1;if(!n.isBound()||0===r.getHandle()||r.getType()!==uu.ARRAY_BUFFER)return!1;if(0===t.handleProgram&&(t.handleProgram=n.getHandle()),e.isReady()||e.initialize(),!e.isReady()||t.handleProgram!==n.getHandle())return!1;const p=t.context,f={};if(f.name=o,f.index=p.getAttribLocation(t.handleProgram,o),f.offset=a,f.stride=i,f.type=s,f.size=l,f.normalize=c,f.isMatrix=d,f.divisor=u,-1===f.Index)return!1;if(r.bind(),p.enableVertexAttribArray(f.index),p.vertexAttribPointer(f.index,f.size,f.type,f.normalize,f.stride,f.offset),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f.index,1):p.vertexAttribDivisor(f.index,1)),f.buffer=r.getHandle(),!t.supported){let e=!1;for(let n=0;n<t.buffers.length;++n){const r=t.buffers[n];if(r.buffer===f.buffer){e=!0;let t=!1;for(let e=0;e<r.attributes.length;++e)r.attributes[e].name===o&&(t=!0,r.attributes[e]=f);t||r.attributes.push(f)}}e||t.buffers.push({buffer:f.buffer,attributes:[f]})}return!0},e.addAttributeMatrixWithDivisor=(n,r,o,a,i,s,l,c,u)=>{const d=e.addAttributeArrayWithDivisor(n,r,o,a,i,s,l,c,u,!0);if(!d)return d;const p=t.context,f=p.getAttribLocation(t.handleProgram,o);for(let e=1;e<l;e++)p.enableVertexAttribArray(f+e),p.vertexAttribPointer(f+e,l,s,c,i,a+i*e/l),u>0&&(t.instancingExtension?t.instancingExtension.vertexAttribDivisorANGLE(f+e,1):p.vertexAttribDivisor(f+e,1));return!0},e.removeAttributeArray=n=>{if(!e.isReady()||0===t.handleProgram)return!1;if(!t.supported)for(let e=0;e<t.buffers.length;++e){const r=t.buffers[e];for(let o=0;o<r.attributes.length;++o)if(r.attributes[o].name===n)return r.attributes.splice(o,1),r.attributes.length||t.buffers.splice(e,1),!0}return!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))}}(e,t)}var Eu={newInstance:Ht.newInstance(Mu,"vtkOpenGLVertexArrayObject"),extend:Mu};const Vu={Start:0,Points:0,Lines:1,Tris:2,TriStrips:3,TrisEdges:4,TriStripsEdges:5,End:6},Du={context:null,program:null,shaderSourceTime:null,VAO:null,attributeUpdateTime:null,CABO:null,primitiveType:0,pointPicking:!1};function Lu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Du,n),Ht.obj(e,t),t.shaderSourceTime={},Ht.obj(t.shaderSourceTime),t.attributeUpdateTime={},Ht.obj(t.attributeUpdateTime),Ht.setGet(e,t,["program","shaderSourceTime","VAO","attributeUpdateTime","CABO","primitiveType","pointPicking"]),t.program=Pu.newInstance(),t.VAO=Eu.newInstance(),t.CABO=bu.newInstance(),function(e,t){t.classHierarchy.push("vtkOpenGLHelper"),e.setOpenGLRenderWindow=e=>{t.context=e.getContext(),t.program.setContext(t.context),t.VAO.setOpenGLRenderWindow(e),t.CABO.setOpenGLRenderWindow(e)},e.releaseGraphicsResources=e=>{t.VAO.releaseGraphicsResources(),t.CABO.releaseGraphicsResources(),t.CABO.setElementCount(0)},e.drawArrays=(n,r,o,a)=>{if(t.CABO.getElementCount()){const i=e.getOpenGLMode(o),s=e.haveWideLines(n,r),l=t.context,c=l.getParameter(l.DEPTH_WRITEMASK);t.pointPicking&&l.depthMask(!1),i===l.LINES&&s?(e.updateShaders(n,r,a),l.drawArraysInstanced(i,0,t.CABO.getElementCount(),2*Math.ceil(r.getProperty().getLineWidth()))):(l.lineWidth(r.getProperty().getLineWidth()),e.updateShaders(n,r,a),l.drawArrays(i,0,t.CABO.getElementCount()),l.lineWidth(1));const u=(i===l.POINTS?1:0)||(i===l.LINES?2:3);return t.pointPicking&&l.depthMask(c),t.CABO.getElementCount()/u}return 0},e.getOpenGLMode=e=>{if(t.pointPicking)return t.context.POINTS;const n=t.primitiveType;return e===qi.POINTS||n===Vu.Points?t.context.POINTS:e===qi.WIREFRAME||n===Vu.Lines||n===Vu.TrisEdges||n===Vu.TriStripsEdges?t.context.LINES:t.context.TRIANGLES},e.haveWideLines=(e,n)=>n.getProperty().getLineWidth()>1&&!(t.CABO.getOpenGLRenderWindow()&&t.CABO.getOpenGLRenderWindow().getHardwareMaximumLineWidth()>=n.getProperty().getLineWidth()),e.getNeedToRebuildShaders=(t,n,r)=>!!(r.getNeedToRebuildShaders(e,t,n)||0===e.getProgram()||e.getShaderSourceTime().getMTime()<r.getMTime()||e.getShaderSourceTime().getMTime()<n.getMTime()),e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};o.buildShaders(a,n,r);const i=t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==e.getProgram()&&(e.setProgram(i),e.getVAO().releaseGraphicsResources()),e.getShaderSourceTime().modified()}else t.CABO.getOpenGLRenderWindow().getShaderCache().readyShaderProgram(e.getProgram());e.getVAO().bind(),o.setMapperShaderParameters(e,n,r),o.setPropertyShaderParameters(e,n,r),o.setCameraShaderParameters(e,n,r),o.setLightingShaderParameters(e,n,r),o.invokeShaderCallbacks(e,n,r)},e.setMapperShaderParameters=(n,r,o)=>{if(e.haveWideLines(n,r)){e.getProgram().setUniform2f("viewportSize",o.usize,o.vsize);const t=parseFloat(r.getProperty().getLineWidth()),n=t/2;e.getProgram().setUniformf("lineWidthStepSize",t/Math.ceil(t)),e.getProgram().setUniformf("halfLineWidth",n)}t.primitiveType===Vu.Points||r.getProperty().getRepresentation()===qi.POINTS?e.getProgram().setUniformf("pointSize",r.getProperty().getPointSize()):t.pointPicking&&e.getProgram().setUniformf("pointSize",e.getPointPickingPrimitiveSize())},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;a=Pu.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform float pointSize;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl","  gl_PointSize = pointSize;"],!1).result,e.getOpenGLMode(o.getProperty().getRepresentation())===t.context.LINES&&e.haveWideLines(r,o)&&(a=Pu.substitute(a,"//VTK::PositionVC::Dec",["//VTK::PositionVC::Dec","uniform vec2 viewportSize;","uniform float lineWidthStepSize;","uniform float halfLineWidth;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Impl",["//VTK::PositionVC::Impl"," if (halfLineWidth > 0.0)","   {","   float offset = float(gl_InstanceID / 2) * lineWidthStepSize - halfLineWidth;","   vec4 tmpPos = gl_Position;","   vec3 tmpPos2 = tmpPos.xyz / tmpPos.w;","   tmpPos2.x = tmpPos2.x + 2.0 * mod(float(gl_InstanceID), 2.0) * offset / viewportSize[0];","   tmpPos2.y = tmpPos2.y + 2.0 * mod(float(gl_InstanceID + 1), 2.0) * offset / viewportSize[1];","   gl_Position = vec4(tmpPos2.xyz * tmpPos.w, tmpPos.w);","   }"]).result),n.Vertex=a},e.getPointPickingPrimitiveSize=()=>t.primitiveType===Vu.Points?2:t.primitiveType===Vu.Lines?4:6,e.getAllocatedGPUMemoryInBytes=()=>e.getCABO().getAllocatedGPUMemoryInBytes()}(e,t)}var Bu={newInstance:Ht.newInstance(Lu),extend:Lu,primTypes:Vu};const Nu={CLAMP_TO_EDGE:0,REPEAT:1,MIRRORED_REPEAT:2},Fu={NEAREST:0,LINEAR:1,NEAREST_MIPMAP_NEAREST:2,NEAREST_MIPMAP_LINEAR:3,LINEAR_MIPMAP_NEAREST:4,LINEAR_MIPMAP_LINEAR:5};var _u={Wrap:Nu,Filter:Fu};const Gu=new Float32Array(1),ku=new Int32Array(Gu.buffer);var Uu={fromHalf:function(e){const t=(32768&e)>>15,n=(31744&e)>>10,r=1023&e;return 0===n?(t?-1:1)*2**-14*(r/1024):31===n?r?NaN:1/0*(t?-1:1):(t?-1:1)*2**(n-15)*(1+r/1024)},toHalf:function(e){Gu[0]=e;const t=ku[0];let n=t>>16&32768,r=t>>12&2047;const o=t>>23&255;return o<103?n:o>142?(n|=31744,n|=(255===o?0:1)&&8388607&t,n):o<113?(r|=2048,n|=(r>>114-o)+(r>>113-o&1),n):(n|=o-112<<10|r>>1,n+=1&r,n)}};let zu;const{Wrap:Wu,Filter:Hu}=_u,{VtkDataTypes:ju}=Ts,{vtkDebugMacro:Ku,vtkErrorMacro:$u,vtkWarningMacro:qu,requiredParam:Xu}=jt,{toHalf:Yu}=Uu;function Zu(e,t){function n(){return{internalFormat:t.internalFormat,format:t.format,openGLDataType:t.openGLDataType,width:t.width,height:t.height}}t.classHierarchy.push("vtkOpenGLTexture"),e.render=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;if(n?t._openGLRenderWindow=n:(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow")),t.context=t._openGLRenderWindow.getContext(),t.renderable.getInterpolate()?(t.generateMipmap?e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR):e.setMinificationFilter(Hu.LINEAR),e.setMagnificationFilter(Hu.LINEAR)):(e.setMinificationFilter(Hu.NEAREST),e.setMagnificationFilter(Hu.NEAREST)),t.renderable.getRepeat()&&(e.setWrapR(Wu.REPEAT),e.setWrapS(Wu.REPEAT),e.setWrapT(Wu.REPEAT)),t.renderable.getInputData()&&t.renderable.setImage(null),!t.handle||t.renderable.getMTime()>t.textureBuildTime.getMTime()){if(null!==t.renderable.getImageBitmap()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR)),t.renderable.getImageBitmap()&&t.renderable.getImageLoaded()&&(e.create2DFromImageBitmap(t.renderable.getImageBitmap()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getImage()&&(t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR)),t.renderable.getImage()&&t.renderable.getImageLoaded()&&(e.create2DFromImage(t.renderable.getImage()),e.activate(),e.sendParameters(),t.textureBuildTime.modified())),null!==t.renderable.getCanvas()){t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR));const n=t.renderable.getCanvas();e.create2DFromRaw({width:n.width,height:n.height,numComps:4,dataType:ju.UNSIGNED_CHAR,data:n,flip:!0}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}if(null!==t.renderable.getJsImageData()){const n=t.renderable.getJsImageData();t.renderable.getInterpolate()&&(t.generateMipmap=!0,e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR)),e.create2DFromRaw({width:n.width,height:n.height,numComps:4,dataType:ju.UNSIGNED_CHAR,data:n.data,flip:!0}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}const n=t.renderable.getInputData(0);if(n&&n.getPointData().getScalars()){const r=n.getExtent(),o=n.getPointData().getScalars(),a=[];for(let e=0;e<t.renderable.getNumberOfInputPorts();++e){const n=t.renderable.getInputData(e),r=n?n.getPointData().getScalars().getData():null;r&&a.push(r)}t.renderable.getInterpolate()&&4===o.getNumberOfComponents()&&(t.generateMipmap=!0,e.setMinificationFilter(Hu.LINEAR_MIPMAP_LINEAR)),a.length%6==0?e.createCubeFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:a}):e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),t.textureBuildTime.modified()}}t.handle&&e.activate()};const r=()=>{if(t.minificationFilter!==Hu.LINEAR&&t.magnificationFilter!==Hu.LINEAR||(void 0===zu&&(zu=function(){try{const e=4,t=2,n=1,r=new Int16Array([0,32767]),o=[1,1],a=document.createElement("canvas");a.width=e,a.height=e;const i=a.getContext("webgl2");if(!i)return!1;const s=i.getExtension("EXT_texture_norm16");if(!s)return!1;const l=`#version 300 es\n    void main() {\n      gl_PointSize = ${e.toFixed(1)};\n      gl_Position = vec4(0, 0, 0, 1);\n    }\n  `,c="#version 300 es\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n\n    uniform sampler2D u_image;\n\n    out vec4 color;\n\n    void main() {\n        vec4 intColor = texture(u_image, gl_PointCoord.xy);\n        color = vec4(vec3(intColor.rrr), 1);\n    }\n    ",u=i.createShader(i.VERTEX_SHADER);if(i.shaderSource(u,l),i.compileShader(u),!i.getShaderParameter(u,i.COMPILE_STATUS))return!1;const d=i.createShader(i.FRAGMENT_SHADER);if(i.shaderSource(d,c),i.compileShader(d),!i.getShaderParameter(d,i.COMPILE_STATUS))return!1;const p=i.createProgram();if(i.attachShader(p,u),i.attachShader(p,d),i.linkProgram(p),!i.getProgramParameter(p,i.LINK_STATUS))return!1;const f=i.createTexture();i.bindTexture(i.TEXTURE_2D,f),i.texImage2D(i.TEXTURE_2D,0,s.R16_SNORM_EXT,t,n,0,i.RED,i.SHORT,r),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MAG_FILTER,i.LINEAR),i.texParameteri(i.TEXTURE_2D,i.TEXTURE_MIN_FILTER,i.LINEAR),i.useProgram(p),i.drawArrays(i.POINTS,0,1);const g=new Uint8Array(4);i.readPixels(o[0],o[1],1,1,i.RGBA,i.UNSIGNED_BYTE,g);const[m,h,v]=g,T=i.getExtension("WEBGL_lose_context");return T&&T.loseContext(),m===h&&h===v&&0!==m}catch(e){return!1}}()),zu))return t.oglNorm16Ext};function o(e){const[t,n,r,o,a,i]=e;return[n-t+1,o-r+1,i-a+1]}function a(e){const[t,n,r]=o(e);return t*n*r}function i(e,n){const r=new((arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)||e.constructor)(n.reduce(((e,t)=>e+a(t)),0)),o=[t.width,t.height,t.depth];let i=0;return n.forEach((t=>{!function(e,t,n,r,o){const[a,i,s,l,c,u]=n,[d,p]=t,f=d*p;let g=o;for(let t=c;t<=u;t++){const n=t*f;for(let t=s;t<=l;t++){const o=n+t*d;for(let t=o+a,n=o+i;t<=n;t++,g++)r[g]=e[t]}}}(e,o,t,r,i),i+=a(t)})),r}function s(e){if(t._openGLRenderWindow.getWebgl2())return e;const n=[],r=t.width,o=t.height,a=t.components;if(e&&(!Ro(r)||!Ro(o))){const i=t.context.getExtension("OES_texture_half_float"),s=Po(r),l=Po(o),c=s*l*t.components;for(let u=0;u<e.length;u++)if(null!==e[u]){let d=null;const p=o/l,f=r/s;let g=!1;t.openGLDataType===t.context.FLOAT?d=new Float32Array(c):i&&t.openGLDataType===i.HALF_FLOAT_OES?(d=new Uint16Array(c),g=!0):d=new Uint8Array(c);for(let t=0;t<l;t++){const n=t*s*a,i=t*p;let l=Math.floor(i),c=Math.ceil(i);c>=o&&(c=o-1);const m=i-l,h=1-m;l=l*r*a,c=c*r*a;for(let t=0;t<s;t++){const o=t*a,i=t*f;let s=Math.floor(i),p=Math.ceil(i);p>=r&&(p=r-1);const v=i-s;s*=a,p*=a;for(let t=0;t<a;t++)d[n+o+t]=g?Uu.toHalf(Uu.fromHalf(e[u][l+s+t])*h*(1-v)+Uu.fromHalf(e[u][l+p+t])*h*v+Uu.fromHalf(e[u][c+s+t])*m*(1-v)+Uu.fromHalf(e[u][c+p+t])*m*v):e[u][l+s+t]*h*(1-v)+e[u][l+p+t]*h*v+e[u][c+s+t]*m*(1-v)+e[u][c+p+t]*m*v}}n.push(d),t.width=s,t.height=l}else n.push(null)}if(0===n.length)for(let t=0;t<e.length;t++)n.push(e[t]);return n}function l(e){return!!t._openGLRenderWindow&&(!t.resizable&&!t.renderable?.getResizable()&&(!!t._openGLRenderWindow.getWebgl2()&&(!(t._openGLRenderWindow.getGLInformations().RENDERER.value.match(/WebKit/gi)&&navigator.platform.match(/Mac/gi)&&r())||e!==ju.UNSIGNED_SHORT&&e!==ju.SHORT)))}function c(n,r){const o=n.getNumberOfComponents(),a=n.getDataType(),i=n.getData(),s=new Array(o),l=new Array(o);for(let e=0;e<o;++e){const[t,r]=n.getRange(e);s[e]=t,l[e]=r}const c=function(e,t,n){const r=new Array(n),o=new Array(n);for(let a=0;a<n;++a)r[a]=e[a],o[a]=t[a]-e[a]||1;return{scale:o,offset:r}}(s,l,o);return function(n,r,o,a){e.getOpenGLDataType(n);const i=function(e,t){for(let n=0;n<e.length;n++){const r=e[n],o=t[n]+r;if(r<-2048||r>2048||o<-2048||o>2048)return!1}return!0}(r,o)||a;let s=!1;if(t._openGLRenderWindow.getWebgl2())s=t.openGLDataType===t.context.FLOAT&&null===t.context.getExtension("OES_texture_float_linear")&&i||t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");s=e&&t.openGLDataType===e.HALF_FLOAT_OES}t.canUseHalfFloat=s&&i}(a,c.offset,c.scale,r),e.useHalfFloat()||e.getOpenGLDataType(a,!0),{numComps:o,dataType:a,data:i,scaleOffsets:c}}e.destroyTexture=()=>{e.deactivate(),t.context&&t.handle&&t.context.deleteTexture(t.handle),t._prevTexParams=null,t.handle=0,t.numberOfDimensions=0,t.target=0,t.components=0,t.width=0,t.height=0,t.depth=0,e.resetFormatAndType()},e.createTexture=()=>{t.handle||(t.handle=t.context.createTexture(),t.target&&(t.context.bindTexture(t.target,t.handle),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.bindTexture(t.target,null)))},e.getTextureUnit=()=>t._openGLRenderWindow?t._openGLRenderWindow.getTextureUnitForTexture(e):-1,e.activate=()=>{t._openGLRenderWindow.activateTexture(e),e.bind()},e.deactivate=()=>{t._openGLRenderWindow&&t._openGLRenderWindow.deactivateTexture(e)},e.releaseGraphicsResources=n=>{n&&t.handle&&(n.activateTexture(e),n.deactivateTexture(e),t.context.deleteTexture(t.handle),t._prevTexParams=null,t.handle=0,t.numberOfDimensions=0,t.target=0,t.internalFormat=0,t.format=0,t.openGLDataType=0,t.components=0,t.width=0,t.height=0,t.depth=0,t.allocatedGPUMemoryInBytes=0),t.shaderProgram&&(t.shaderProgram.releaseGraphicsResources(n),t.shaderProgram=null)},e.bind=()=>{t.context.bindTexture(t.target,t.handle),t.autoParameters&&e.getMTime()>t.sendParametersTime.getMTime()&&e.sendParameters()},e.isBound=()=>{let e=!1;if(t.context&&t.handle){let n=0;t.target===t.context.TEXTURE_2D?n=t.context.TEXTURE_BINDING_2D:qu("impossible case"),e=t.context.getIntegerv(n)===t.handle}return e},e.sendParameters=()=>{t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_S,e.getOpenGLWrapMode(t.wrapS)),t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_T,e.getOpenGLWrapMode(t.wrapT)),t._openGLRenderWindow.getWebgl2()&&t.context.texParameteri(t.target,t.context.TEXTURE_WRAP_R,e.getOpenGLWrapMode(t.wrapR)),t.context.texParameteri(t.target,t.context.TEXTURE_MIN_FILTER,e.getOpenGLFilterMode(t.minificationFilter)),t.context.texParameteri(t.target,t.context.TEXTURE_MAG_FILTER,e.getOpenGLFilterMode(t.magnificationFilter)),t._openGLRenderWindow.getWebgl2()&&(t.context.texParameteri(t.target,t.context.TEXTURE_BASE_LEVEL,t.baseLevel),t.context.texParameteri(t.target,t.context.TEXTURE_MAX_LEVEL,t.maxLevel)),t.sendParametersTime.modified()},e.getInternalFormat=(n,r)=>(t._forceInternalFormat||(t.internalFormat=e.getDefaultInternalFormat(n,r)),t.internalFormat||Ku(`Unable to find suitable internal format for T=${n} NC= ${r}`),[t.context.R32F,t.context.RG32F,t.context.RGB32F,t.context.RGBA32F].includes(t.internalFormat)&&!t.context.getExtension("OES_texture_float_linear")&&qu("Failed to load OES_texture_float_linear. Texture filtering is not available for *32F internal formats."),t.internalFormat),e.getDefaultInternalFormat=(n,o)=>{let a=0;return a=t._openGLRenderWindow.getDefaultTextureInternalFormat(n,o,r(),e.useHalfFloat()),a||(a||(Ku("Unsupported internal texture type!"),Ku(`Unable to find suitable internal format for T=${n} NC= ${o}`)),a)},e.useHalfFloat=()=>t.enableUseHalfFloat&&t.canUseHalfFloat,e.setInternalFormat=n=>{t._forceInternalFormat=!0,n!==t.internalFormat&&(t.internalFormat=n,e.modified())},e.getFormat=(n,r)=>(t.format=e.getDefaultFormat(n,r),t.format),e.getDefaultFormat=(e,n)=>{if(t._openGLRenderWindow.getWebgl2())switch(n){case 1:return t.context.RED;case 2:return t.context.RG;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}else switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:default:return t.context.RGB;case 4:return t.context.RGBA}},e.resetFormatAndType=()=>{t._prevTexParams=null,t.format=0,t.internalFormat=0,t._forceInternalFormat=!1,t.openGLDataType=0},e.getDefaultDataType=n=>{const o=e.useHalfFloat();if(t._openGLRenderWindow.getWebgl2())switch(n){case ju.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case r()&&!o&&ju.SHORT:return t.context.SHORT;case r()&&!o&&ju.UNSIGNED_SHORT:return t.context.UNSIGNED_SHORT;case o&&ju.SHORT:case o&&ju.UNSIGNED_SHORT:return t.context.HALF_FLOAT;case ju.FLOAT:case ju.VOID:default:return t.context.FLOAT}switch(n){case ju.UNSIGNED_CHAR:return t.context.UNSIGNED_BYTE;case ju.FLOAT:case ju.VOID:default:if(t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))return t.context.FLOAT;{const e=t.context.getExtension("OES_texture_half_float");if(e&&t.context.getExtension("OES_texture_half_float_linear"))return e.HALF_FLOAT_OES}return t.context.UNSIGNED_BYTE}},e.getOpenGLDataType=function(n){let r=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return t.openGLDataType&&!r||(t.openGLDataType=e.getDefaultDataType(n)),t.openGLDataType},e.getShiftAndScale=()=>{let e=0,n=1;switch(t.openGLDataType){case t.context.BYTE:n=127.5,e=n-128;break;case t.context.UNSIGNED_BYTE:n=255,e=0;break;case t.context.SHORT:n=32767.5,e=n-32768;break;case t.context.UNSIGNED_SHORT:n=65536,e=0;break;case t.context.INT:n=2147483647.5,e=n-2147483648;break;case t.context.UNSIGNED_INT:n=4294967295,e=0;case t.context.FLOAT:}return{shift:e,scale:n}},e.getOpenGLFilterMode=e=>{switch(e){case Hu.NEAREST:return t.context.NEAREST;case Hu.LINEAR:return t.context.LINEAR;case Hu.NEAREST_MIPMAP_NEAREST:return t.context.NEAREST_MIPMAP_NEAREST;case Hu.NEAREST_MIPMAP_LINEAR:return t.context.NEAREST_MIPMAP_LINEAR;case Hu.LINEAR_MIPMAP_NEAREST:return t.context.LINEAR_MIPMAP_NEAREST;case Hu.LINEAR_MIPMAP_LINEAR:return t.context.LINEAR_MIPMAP_LINEAR;default:return t.context.NEAREST}},e.getOpenGLWrapMode=e=>{switch(e){case Wu.CLAMP_TO_EDGE:return t.context.CLAMP_TO_EDGE;case Wu.REPEAT:return t.context.REPEAT;case Wu.MIRRORED_REPEAT:return t.context.MIRRORED_REPEAT;default:return t.context.CLAMP_TO_EDGE}},e.updateArrayDataTypeForGL=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]&&arguments[2],o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[];const a=[];let s=t.width*t.height*t.components;r&&(s*=t.depth);const l=!!o.length;if(e!==ju.FLOAT&&t.openGLDataType===t.context.FLOAT)for(let e=0;e<n.length;e++)if(n[e])if(l)a.push(i(n[e],o,Float32Array));else{const t=n[e].length>s?n[e].subarray(0,s):n[e];a.push(new Float32Array(t))}else a.push(null);if(e!==ju.UNSIGNED_CHAR&&t.openGLDataType===t.context.UNSIGNED_BYTE)for(let e=0;e<n.length;e++)if(n[e])if(l)a.push(i(n[e],o,Uint8Array));else{const t=n[e].length>s?n[e].subarray(0,s):n[e];a.push(new Uint8Array(t))}else a.push(null);let c=!1;if(t._openGLRenderWindow.getWebgl2())c=t.openGLDataType===t.context.HALF_FLOAT;else{const e=t.context.getExtension("OES_texture_half_float");c=e&&t.openGLDataType===e.HALF_FLOAT_OES}if(c)for(let e=0;e<n.length;e++)if(n[e]){const t=l?i(n[e],o):n[e],r=new Uint16Array(l?t.length:s),c=r.length;for(let e=0;e<c;e++)r[e]=Yu(t[e]);a.push(r)}else a.push(null);if(0===a.length)for(let e=0;e<n.length;e++)a.push(l&&n[e]?i(n[e],o):n[e]);return a},e.create2DFromRaw=function(){let{width:n=Xu("width"),height:o=Xu("height"),numComps:a=Xu("numComps"),dataType:i=Xu("dataType"),data:c=Xu("data"),flip:u=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.getOpenGLDataType(i,!0),e.getInternalFormat(i,a),e.getFormat(i,a),!t.internalFormat||!t.format||!t.openGLDataType)return $u("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=a,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const d=[c],p=s(e.updateArrayDataTypeForGL(i,d));return t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,u),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(i)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=p[0]&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,p[0])):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,p[0]),t.generateMipmap&&t.context.generateMipmap(t.target),u&&t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,!1),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*a*t._openGLRenderWindow.getDefaultTextureByteSize(i,r(),e.useHalfFloat()),e.deactivate(),!0},e.createCubeFromRaw=function(){let{width:n=Xu("width"),height:o=Xu("height"),numComps:a=Xu("numComps"),dataType:i=Xu("dataType"),data:c=Xu("data")}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};if(e.getOpenGLDataType(i),e.getInternalFormat(i,a),e.getFormat(i,a),!t.internalFormat||!t.format||!t.openGLDataType)return $u("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_CUBE_MAP,t.components=a,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),t.maxLevel=c.length/6-1,e.createTexture(),e.bind();const u=s(e.updateArrayDataTypeForGL(i,c)),d=[];let p=t.width,f=t.height;for(let e=0;e<u.length;e++){e%6==0&&0!==e&&(p/=2,f/=2),d[e]=it(i,f*p*t.components);for(let n=0;n<f;++n){const r=n*p*t.components,o=(f-n-1)*p*t.components;d[e].set(u[e].slice(o,o+p*t.components),r)}}t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(i)&&t.context.texStorage2D(t.target,6,t.internalFormat,t.width,t.height);for(let e=0;e<6;e++){let n=0,r=t.width,o=t.height;for(;r>=1&&o>=1;){let a=null;n<=t.maxLevel&&(a=d[6*n+e]),l(i)?null!=a&&t.context.texSubImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,0,0,r,o,t.format,t.openGLDataType,a):t.context.texImage2D(t.context.TEXTURE_CUBE_MAP_POSITIVE_X+e,n,t.internalFormat,r,o,0,t.format,t.openGLDataType,a),n++,r/=2,o/=2}}return t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*a*t._openGLRenderWindow.getDefaultTextureByteSize(i,r(),e.useHalfFloat()),e.deactivate(),!0},e.createDepthFromRaw=function(){let{width:n=Xu("width"),height:o=Xu("height"),dataType:a=Xu("dataType"),data:i=Xu("data")}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.getOpenGLDataType(a),t.format=t.context.DEPTH_COMPONENT,t._openGLRenderWindow.getWebgl2()?a===ju.FLOAT?t.internalFormat=t.context.DEPTH_COMPONENT32F:t.internalFormat=t.context.DEPTH_COMPONENT16:t.internalFormat=t.context.DEPTH_COMPONENT,t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=1,t.width=n,t.height=o,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(a)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=i&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,i)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,i),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(a,r(),e.useHalfFloat()),e.deactivate(),!0):($u("Failed to determine texture parameters."),!1)},e.create2DFromImage=n=>{if(e.getOpenGLDataType(ju.UNSIGNED_CHAR),e.getInternalFormat(ju.UNSIGNED_CHAR,4),e.getFormat(ju.UNSIGNED_CHAR,4),!t.internalFormat||!t.format||!t.openGLDataType)return $u("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const o=!(t._openGLRenderWindow.getWebgl2()||Ro(n.width)&&Ro(n.height));let a=n,i=n.width,s=n.height,c=!0;const u=window.chrome;if(o||u){const e=new OffscreenCanvas(Po(n.width),Po(n.height));i=e.width,s=e.height;const t=e.getContext("2d");t.translate(0,e.height),t.scale(1,-1),t.drawImage(n,0,0,n.width,n.height,0,0,e.width,e.height),a=e,c=!1}return t.width=i,t.height=s,t.context.pixelStorei(t.context.UNPACK_FLIP_Y_WEBGL,c),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(ju.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,a)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,a),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(ju.UNSIGNED_CHAR,r(),e.useHalfFloat()),e.deactivate(),!0},e.create2DFromImageBitmap=n=>(e.getOpenGLDataType(ju.UNSIGNED_CHAR),e.getInternalFormat(ju.UNSIGNED_CHAR,4),e.getFormat(ju.UNSIGNED_CHAR,4),t.internalFormat&&t.format&&t.openGLDataType?(t.target=t.context.TEXTURE_2D,t.components=4,t.depth=1,t.numberOfDimensions=2,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),t.width=n.width,t.height=n.height,l(ju.UNSIGNED_CHAR)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,n)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,n),t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(ju.UNSIGNED_CHAR,r(),e.useHalfFloat()),e.deactivate(),!0):($u("Failed to determine texture parameters."),!1)),e.create2DFilterableFromRaw=function(){let{width:t=Xu("width"),height:n=Xu("height"),numComps:r=Xu("numComps"),dataType:o=Xu("dataType"),data:a=Xu("data"),preferSizeOverAccuracy:i=!1,ranges:s}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.create2DFilterableFromDataArray({width:t,height:n,dataArray:Ts.newInstance({numComps:r,dataType:o,values:a,ranges:s}),preferSizeOverAccuracy:i})},e.create2DFilterableFromDataArray=function(){let{width:t=Xu("width"),height:n=Xu("height"),dataArray:r=Xu("dataArray"),preferSizeOverAccuracy:o=!1}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{numComps:a,dataType:i,data:s}=c(r,o);e.create2DFromRaw({width:t,height:n,numComps:a,dataType:i,data:s})},e.updateVolumeInfoForGL=(n,o)=>{let a=!1;const i=e.useHalfFloat();t.volumeInfo?.scale&&t.volumeInfo?.offset||(t.volumeInfo={scale:new Array(o),offset:new Array(o)});for(let e=0;e<o;++e)t.volumeInfo.scale[e]=1,t.volumeInfo.offset[e]=0;if(r()&&!i&&n===ju.SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=32767;a=!0}if(r()&&!i&&n===ju.UNSIGNED_SHORT){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=65535;a=!0}if(n===ju.UNSIGNED_CHAR){for(let e=0;e<o;++e)t.volumeInfo.scale[e]=255;a=!0}return(n===ju.FLOAT||i&&(n===ju.SHORT||n===ju.UNSIGNED_SHORT))&&(a=!0),a},e.create3DFromRaw=function(){let{width:i=Xu("width"),height:c=Xu("height"),depth:u=Xu("depth"),numComps:d=Xu("numComps"),dataType:p=Xu("dataType"),data:f=Xu("data"),updatedExtents:g=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},m=p,h=f;if(!e.updateVolumeInfoForGL(m,d)&&h){const e=i*c*u,n=structuredClone(t.volumeInfo),r=new Float32Array(e*d);t.volumeInfo.offset=n.offset,t.volumeInfo.scale=n.scale;let o=0;const a=n.scale.map((e=>1/e));for(let t=0;t<e;t++)for(let e=0;e<d;e++)r[o]=(h[o]-n.offset[e])*a[e],o++;m=ju.FLOAT,h=r}if(e.getOpenGLDataType(m),e.getInternalFormat(m,d),e.getFormat(m,d),!t.internalFormat||!t.format||!t.openGLDataType)return $u("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_3D,t.components=d,t.width=i,t.height=c,t.depth=u,t.numberOfDimensions=3,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind();const v=g.length>0,T=!v||!Ge()(t._prevTexParams,n()),y=[h],b=s(e.updateArrayDataTypeForGL(m,y,!0,T?[]:g));if(t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),T)l(m)?(t.context.texStorage3D(t.target,1,t.internalFormat,t.width,t.height,t.depth),null!=b[0]&&t.context.texSubImage3D(t.target,0,0,0,0,t.width,t.height,t.depth,t.format,t.openGLDataType,b[0])):t.context.texImage3D(t.target,0,t.internalFormat,t.width,t.height,t.depth,0,t.format,t.openGLDataType,b[0]),t._prevTexParams=n();else if(v){const e=b[0];let n=0;for(let r=0;r<g.length;r++){const i=g[r],s=o(i),l=a(i),c=new e.constructor(e.buffer,n,l);n+=c.byteLength,t.context.texSubImage3D(t.target,0,i[0],i[2],i[4],s[0],s[1],s[2],t.format,t.openGLDataType,c)}}return t.generateMipmap&&t.context.generateMipmap(t.target),t.allocatedGPUMemoryInBytes=t.width*t.height*t.depth*t.components*t._openGLRenderWindow.getDefaultTextureByteSize(m,r(),e.useHalfFloat()),e.deactivate(),!0},e.create3DFilterableFromRaw=function(){let{width:t=Xu("width"),height:n=Xu("height"),depth:r=Xu("depth"),numComps:o=Xu("numComps"),dataType:a=Xu("dataType"),data:i=Xu("data"),preferSizeOverAccuracy:s=!1,ranges:l,updatedExtents:c=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return e.create3DFilterableFromDataArray({width:t,height:n,depth:r,dataArray:Ts.newInstance({numComps:o,dataType:a,values:i,ranges:l}),preferSizeOverAccuracy:s,updatedExtents:c})},e.create3DFilterableFromDataArray=function(){let{width:n=Xu("width"),height:r=Xu("height"),depth:o=Xu("depth"),dataArray:a=Xu("dataArray"),preferSizeOverAccuracy:i=!1,updatedExtents:s=[]}=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const{numComps:u,dataType:d,data:p,scaleOffsets:f}=c(a,i),g=[],m=[];for(let e=0;e<u;++e)g[e]=0,m[e]=1;if(t.volumeInfo={scale:m,offset:g,dataComputedScale:f.scale,dataComputedOffset:f.offset,width:n,height:r,depth:o},t._openGLRenderWindow.getWebgl2())return e.create3DFromRaw({width:n,height:r,depth:o,numComps:u,dataType:d,data:p,updatedExtents:s});const h=n*r*o,v=structuredClone(f);let T=(e,t,n,r,o)=>{e[t]=n},y=ju.UNSIGNED_CHAR;if(d===ju.UNSIGNED_CHAR)for(let e=0;e<u;++e)v.offset[e]=0,v.scale[e]=255;else t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear")?(y=ju.FLOAT,T=(e,t,n,r,o)=>{e[t]=(n-r)/o}):(y=ju.UNSIGNED_CHAR,T=(e,t,n,r,o)=>{e[t]=255*(n-r)/o});if(e.getOpenGLDataType(y),e.getInternalFormat(y,u),e.getFormat(y,u),!t.internalFormat||!t.format||!t.openGLDataType)return $u("Failed to determine texture parameters."),!1;t.target=t.context.TEXTURE_2D,t.components=u,t.depth=1,t.numberOfDimensions=2;let b=t.context.getParameter(t.context.MAX_TEXTURE_SIZE);b>4096&&(y===ju.FLOAT||u>=3)&&(b=4096);let x=1,C=1;h>b*b&&(x=Math.ceil(Math.sqrt(h/(b*b))),C=x);let S=Math.sqrt(h)/x;S=Po(S);const A=Math.floor(S*x/n),I=Math.ceil(o/A),w=Po(r*I/C);let O;t.width=S,t.height=w,t._openGLRenderWindow.activateTexture(e),e.createTexture(),e.bind(),t.volumeInfo.xreps=A,t.volumeInfo.yreps=I,t.volumeInfo.xstride=x,t.volumeInfo.ystride=C,t.volumeInfo.offset=v.offset,t.volumeInfo.scale=v.scale;const P=S*w*u;O=y===ju.FLOAT?new Float32Array(P):new Uint8Array(P);let R=0;const M=Math.floor(n/x),E=Math.floor(r/C);for(let e=0;e<I;e++){const a=Math.min(A,o-e*A),i=u*(t.width-a*Math.floor(n/x));for(let t=0;t<E;t++){for(let o=0;o<a;o++){const a=u*((e*A+o)*n*r+C*t*n);for(let e=0;e<M;e++)for(let t=0;t<u;t++)T(O,R,p[a+x*e*u+t],v.offset[t],v.scale[t]),R++}R+=i}}return t.context.pixelStorei(t.context.UNPACK_ALIGNMENT,1),l(y)?(t.context.texStorage2D(t.target,1,t.internalFormat,t.width,t.height),null!=O&&t.context.texSubImage2D(t.target,0,0,0,t.width,t.height,t.format,t.openGLDataType,O)):t.context.texImage2D(t.target,0,t.internalFormat,t.width,t.height,0,t.format,t.openGLDataType,O),e.deactivate(),!0},e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.getMaximumTextureSize=e=>e&&e.isCurrent()?e.getIntegerv(e.MAX_TEXTURE_SIZE):-1,e.enableUseHalfFloat=e=>{t.enableUseHalfFloat=e}}const Qu={_openGLRenderWindow:null,_forceInternalFormat:!1,_prevTexParams:null,context:null,handle:0,sendParametersTime:null,textureBuildTime:null,numberOfDimensions:0,target:0,format:0,openGLDataType:0,components:0,width:0,height:0,depth:0,autoParameters:!0,wrapS:Wu.CLAMP_TO_EDGE,wrapT:Wu.CLAMP_TO_EDGE,wrapR:Wu.CLAMP_TO_EDGE,minificationFilter:Hu.NEAREST,magnificationFilter:Hu.NEAREST,minLOD:-1e3,maxLOD:1e3,baseLevel:0,maxLevel:1e3,generateMipmap:!1,oglNorm16Ext:null,allocatedGPUMemoryInBytes:0,enableUseHalfFloat:!0,canUseHalfFloat:!1};function Ju(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qu,n),Xt.extend(e,t,n),t.sendParametersTime={},vt(t.sendParametersTime,{mtime:0}),t.textureBuildTime={},vt(t.textureBuildTime,{mtime:0}),Ct(e,t,["format","openGLDataType"]),St(e,t,["keyMatrixTime","minificationFilter","magnificationFilter","wrapS","wrapT","wrapR","generateMipmap","oglNorm16Ext"]),yt(e,t,["width","height","volumeInfo","components","handle","target","allocatedGPUMemoryInBytes"]),Ot(0,t,["openGLRenderWindow"]),Zu(e,t)}const ed=Et(Ju,"vtkOpenGLTexture");var td={newInstance:ed,extend:Ju,..._u};en("vtkTexture",ed);var nd="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexMC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// picking support\n//VTK::Picking::Dec\n\nvoid main()\n{\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::PrimID::Impl\n\n  //VTK::PositionVC::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::Picking::Impl\n}\n",rd="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the polydata mappers fragment shader\n\nuniform int PrimitiveIDOffset;\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// optional color passed in from the vertex shader, vertexColor\n//VTK::Color::Dec\n\n// optional surface normal declaration\n//VTK::Normal::Dec\n\n// extra lighting parameters\n//VTK::Light::Dec\n\n// define vtkImageLabelOutlineOn\n//VTK::ImageLabelOutlineOn\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// Depth Peeling Support\n//VTK::DepthPeeling::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// label outline \n//VTK::LabelOutline::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n//VTK::LabelOutlineHelperFunction\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Clip::Impl\n\n  //VTK::Color::Impl\n\n  // Generate the normal if we are not passed in one\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Light::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",od=function(e,t){e.replaceShaderCoincidentOffset=(n,r,o)=>{const a=e.getCoincidentParameters(r,o);if(a&&(0!==a.factor||0!==a.offset)){let e=n.Fragment;e=Pu.substitute(e,"//VTK::Coincident::Dec",["uniform float cfactor;","uniform float coffset;"]).result,t.context.getExtension("EXT_frag_depth")&&(0!==a.factor?(e=Pu.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=Pu.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=Pu.substitute(e,"//VTK::Depth::Impl","gl_FragDepthEXT = gl_FragCoord.z + 0.000016*coffset;").result),t._openGLRenderWindow.getWebgl2()&&(0!==a.factor?(e=Pu.substitute(e,"//VTK::UniformFlow::Impl",["float cscale = length(vec2(dFdx(gl_FragCoord.z),dFdy(gl_FragCoord.z)));","//VTK::UniformFlow::Impl"],!1).result,e=Pu.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + cfactor*cscale + 0.000016*coffset;").result):e=Pu.substitute(e,"//VTK::Depth::Impl","gl_FragDepth = gl_FragCoord.z + 0.000016*coffset;").result),n.Fragment=e}}},ad=function(e,t){e.applyShaderReplacements=(e,t,n)=>{let r=null;if(t&&(r=t.ShaderReplacements),r)for(let t=0;t<r.length;t++){const o=r[t];if(n&&o.replaceFirst||!n&&!o.replaceFirst){const t=o.shaderType,n=e[t],r=Pu.substitute(n,o.originalValue,o.replacementValue,o.replaceAll);e[t]=r.result}}},e.buildShaders=(n,r,o)=>{e.getReplacedShaderTemplate(n,r,o),t.lastRenderPassShaderReplacement=t.currentRenderPass?t.currentRenderPass.getShaderReplacement():null,t.lastRenderPassShaderReplacement&&t.lastRenderPassShaderReplacement(n);const a=t.renderable.getViewSpecificProperties().OpenGL;e.applyShaderReplacements(n,a,!0),e.replaceShaderValues(n,r,o),e.applyShaderReplacements(n,a)},e.getReplacedShaderTemplate=(n,r,o)=>{const a=t.renderable.getViewSpecificProperties().OpenGL;e.getShaderTemplate(n,r,o);let i=n.Vertex;if(a){const e=a.VertexShaderCode;void 0!==e&&""!==e&&(i=e)}n.Vertex=i;let s=n.Fragment;if(a){const e=a.FragmentShaderCode;void 0!==e&&""!==e&&(s=e)}n.Fragment=s;let l=n.Geometry;if(a){const e=a.GeometryShaderCode;void 0!==e&&(l=e)}n.Geometry=l}};const{FieldAssociations:id}=_s,{primTypes:sd}=Bu,{Representation:ld,Shading:cd}=ts,{ScalarMode:ud}=Fl,{Filter:dd,Wrap:pd}=td,{vtkErrorMacro:fd}=jt,gd={type:"StartEvent"},md={type:"EndEvent"},{CoordinateSystem:hd}=Wi;const vd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null,tmpMat4:null,ambientColor:[],diffuseColor:[],specularColor:[],lightColor:[],lightDirection:[],lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastSelectionState:xl.MIN_KNOWN_PASS-1,selectionStateChanged:null,selectionWebGLIdsToVTKIds:null,pointPicking:!1};function Td(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vd,n),Xt.extend(e,t,n),od(e,t,n),ad(e,t,n),t.primitives=[],t.primTypes=sd,t.tmpMat3=pe(new Float64Array(9)),t.tmpMat4=g(new Float64Array(16));for(let e=sd.Start;e<sd.End;e++)t.primitives[e]=Bu.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);St(e,t,["context"]),t.VBOBuildTime={},vt(t.VBOBuildTime,{mtime:0}),t.selectionStateChanged={},vt(t.selectionStateChanged,{mtime:0}),function(e,t){function n(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}t.classHierarchy.push("vtkOpenGLPolyDataMapper"),e.buildPass=n=>{n&&(t.currentRenderPass=null,t.openGLActor=e.getFirstAncestorOfType("vtkOpenGLActor"),t._openGLRenderer=t.openGLActor.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=sd.Start;e<sd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=nd,e.Fragment=rd,e.Geometry=""},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment;const s=t.lastBoundBO.getReferenceByName("lastLightComplexity");let l=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity","uniform vec3 ambientColorUniform;","uniform vec3 diffuseColorUniform;"];s&&(l=l.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let c=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];s&&(c=c.concat(["  vec3 specularColor;","  float specularPower;"])),c=c.concat(["  ambientColor = ambientColorUniform;","  diffuseColor = diffuseColorUniform;","  opacity = opacityUniform;"]),s&&(c=c.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges||(l=l.concat(["varying vec4 vertexColorVSOutput;"]),o=Pu.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=Pu.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=Pu.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=Pu.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result),0===t.lastBoundBO.getCABO().getColorComponents()||t.drawingEdges?(t.renderable.getAreScalarsMappedFromCells()||t.renderable.getInterpolateScalarsBeforeMapping())&&t.renderable.getColorCoordinates()&&!t.drawingEdges?i=Pu.substitute(i,"//VTK::Color::Impl",c.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  ambientColor = texColor.rgb;","  opacity = opacity*texColor.a;"])).result:(r.getBackfaceProperty()&&!t.drawingEdges&&(l=l.concat(["uniform float opacityUniformBF; // the fragment opacity","uniform float ambientIntensityBF; // the material ambient","uniform float diffuseIntensityBF; // the material diffuse","uniform vec3 ambientColorUniformBF; // ambient material color","uniform vec3 diffuseColorUniformBF; // diffuse material color"]),s?(l=l.concat(["uniform float specularIntensityBF; // the material specular intensity","uniform vec3 specularColorUniformBF; // intensity weighted color","uniform float specularPowerUniformBF;"]),c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  specularColor = specularIntensityBF * specularColorUniformBF;","  specularPower = specularPowerUniformBF;","  opacity = opacityUniformBF; }"])):c=c.concat(["if (gl_FrontFacing == false) {","  ambientColor = ambientIntensityBF * ambientColorUniformBF;","  diffuseColor = diffuseIntensityBF * diffuseColorUniformBF;","  opacity = opacityUniformBF; }"])),t.haveCellScalars&&!t.drawingEdges&&(l=l.concat(["uniform samplerBuffer texture1;"])),i=Pu.substitute(i,"//VTK::Color::Impl",c).result):i=Pu.substitute(i,"//VTK::Color::Impl",c.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result,i=Pu.substitute(i,"//VTK::Color::Dec",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderLight=(e,n,r)=>{let o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity"),i=t.lastBoundBO.getReferenceByName("lastLightCount");let s=[];switch(a){case 0:o=Pu.substitute(o,"//VTK::Light::Impl",["  gl_FragData[0] = vec4(ambientColor * ambient + diffuseColor * diffuse, opacity);","  //VTK::Light::Impl"],!1).result;break;case 1:o=Pu.substitute(o,"//VTK::Light::Impl",["  float df = max(0.0, normalVCVSOutput.z);","  float sf = pow(df, specularPower);","  vec3 diffuseL = df * diffuseColor;","  vec3 specularL = sf * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"],!1).result;break;case 2:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`]);o=Pu.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  float df;"];for(let e=0;e<i;++e)s=s.concat([`  df = max(0.0, dot(normalVCVSOutput, -lightDirectionVC${e}));`,`  diffuseL += ((df) * lightColor${e});`,`  if (dot(normalVCVSOutput, lightDirectionVC${e}) < 0.0)`,"    {",`    float sf = sign(df)*pow(max(1e-5,\n                                              dot(reflect(lightDirectionVC${e},normalVCVSOutput),\n                                                  normalize(-vertexVC.xyz))),\n                                         specularPower);`,`    specularL += (sf * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=Pu.substitute(o,"//VTK::Light::Impl",s,!1).result;break;case 3:for(let e=0;e<i;++e)s=s.concat([`uniform vec3 lightColor${e};`,`uniform vec3 lightDirectionVC${e}; // normalized`,`uniform vec3 lightHalfAngleVC${e}; // normalized`,`uniform vec3 lightPositionVC${e};`,`uniform vec3 lightAttenuation${e};`,`uniform float lightConeAngle${e};`,`uniform float lightExponent${e};`,`uniform int lightPositional${e};`]);o=Pu.substitute(o,"//VTK::Light::Dec",s).result,s=["vec3 diffuseL = vec3(0,0,0);","  vec3 specularL = vec3(0,0,0);","  vec3 vertLightDirectionVC;","  float attenuation;","  float df;"];for(let e=0;e<i;++e)s=s.concat(["  attenuation = 1.0;",`  if (lightPositional${e} == 0)`,"    {",`      vertLightDirectionVC = lightDirectionVC${e};`,"    }","  else","    {",`    vertLightDirectionVC = vertexVC.xyz - lightPositionVC${e};`,"    float distanceVC = length(vertLightDirectionVC);","    vertLightDirectionVC = normalize(vertLightDirectionVC);","    attenuation = 1.0 /",`      (lightAttenuation${e}.x`,`       + lightAttenuation${e}.y * distanceVC`,`       + lightAttenuation${e}.z * distanceVC * distanceVC);`,"    // per OpenGL standard cone angle is 90 or less for a spot light",`    if (lightConeAngle${e} <= 90.0)`,"      {",`      float coneDot = dot(vertLightDirectionVC, lightDirectionVC${e});`,"      // if inside the cone",`      if (coneDot >= cos(radians(lightConeAngle${e})))`,"        {",`        attenuation = attenuation * pow(coneDot, lightExponent${e});`,"        }","      else","        {","        attenuation = 0.0;","        }","      }","    }","    df = max(0.0, attenuation*dot(normalVCVSOutput, -vertLightDirectionVC));",`    diffuseL += ((df) * lightColor${e});`,"    if (dot(normalVCVSOutput, vertLightDirectionVC) < 0.0)","      {",`      float sf = sign(df)*attenuation*pow(max(1e-5,\n                                                           dot(reflect(lightDirectionVC${e},\n                                                                       normalVCVSOutput),\n                                                               normalize(-vertexVC.xyz))),\n                                                       specularPower);`,`    specularL += ((sf) * lightColor${e});`,"    }"]);s=s.concat(["  diffuseL = diffuseL * diffuseColor;","  specularL = specularL * specularColor;","  gl_FragData[0] = vec4(ambientColor * ambient + diffuseL * diffuse + specularL * specular, opacity);","  //VTK::Light::Impl"]),o=Pu.substitute(o,"//VTK::Light::Impl",s,!1).result;break;default:fd("bad light complexity")}e.Fragment=o},e.replaceShaderNormal=(e,n,r)=>{if(t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex,o=e.Geometry,a=e.Fragment;t.lastBoundBO.getCABO().getNormalOffset()?(n=Pu.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=Pu.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * normalMC;"]).result,o=Pu.substitute(o,"//VTK::Normal::Dec",["in vec3 normalVCVSOutput[];","out vec3 normalVCGSOutput;"]).result,o=Pu.substitute(o,"//VTK::Normal::Impl",["normalVCGSOutput = normalVCVSOutput[i];"]).result,a=Pu.substitute(a,"//VTK::Normal::Dec",["varying vec3 normalVCVSOutput;"]).result,a=Pu.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalVCVSOutput);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.haveCellNormals?(a=Pu.substitute(a,"//VTK::Normal::Dec",["uniform mat3 normalMatrix;","uniform samplerBuffer textureN;"]).result,a=Pu.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput = normalize(normalMatrix *","    texelFetchBuffer(textureN, gl_PrimitiveID + PrimitiveIDOffset).xyz);","  if (gl_FrontFacing == false) { normalVCVSOutput = -normalVCVSOutput; }"]).result):t.lastBoundBO.getOpenGLMode(r.getProperty().getRepresentation())===t.context.LINES?(a=Pu.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=Pu.substitute(a,"//VTK::Normal::Impl",["vec3 normalVCVSOutput;","  if (abs(fdx.x) > 0.0)","    { fdx = normalize(fdx); normalVCVSOutput = normalize(cross(vec3(fdx.y, -fdx.x, 0.0), fdx)); }","  else { fdy = normalize(fdy); normalVCVSOutput = normalize(cross(vec3(fdy.y, -fdy.x, 0.0), fdy));}"]).result):(a=Pu.substitute(a,"//VTK::Normal::Dec",["uniform int cameraParallel;"]).result,a=Pu.substitute(a,"//VTK::UniformFlow::Impl",["  vec3 fdx = dFdx(vertexVC.xyz);","  vec3 fdy = dFdy(vertexVC.xyz);","  //VTK::UniformFlow::Impl"]).result,a=Pu.substitute(a,"//VTK::Normal::Impl",["  fdx = normalize(fdx);","  fdy = normalize(fdy);","  vec3 normalVCVSOutput = normalize(cross(fdx,fdy));","  if (cameraParallel == 1 && normalVCVSOutput.z < 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }","  if (cameraParallel == 0 && dot(normalVCVSOutput,vertexVC.xyz) > 0.0) { normalVCVSOutput = -1.0*normalVCVSOutput; }"]).result),e.Vertex=n,e.Geometry=o,e.Fragment=a}},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r);let o=e.Vertex,a=e.Geometry,i=e.Fragment;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(o=Pu.substitute(o,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,o=Pu.substitute(o,"//VTK::PositionVC::Impl",["vertexVCVSOutput = MCVCMatrix * vertexMC;","  gl_Position = MCPCMatrix * vertexMC;"]).result,o=Pu.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Dec",["in vec4 vertexVCVSOutput[];","out vec4 vertexVCGSOutput;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Impl",["vertexVCGSOutput = vertexVCVSOutput[i];"]).result,i=Pu.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=Pu.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;"]).result):(o=Pu.substitute(o,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,o=Pu.substitute(o,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result),e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;if(t.drawingEdges)return;n=Pu.substitute(n,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result;const a=t.openGLActor.getActiveTextures();let i=2,s=2;if(a&&a.length>0&&(i=a[0].getComponents(),a[0].getTarget()===t.context.TEXTURE_CUBE_MAP&&(s=3)),t.renderable.getColorTextureMap()&&(i=t.renderable.getColorTextureMap().getPointData().getScalars().getNumberOfComponents(),s=2),2===s){if(n=Pu.substitute(n,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result,r=Pu.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];","out vec2 tcoordVCGSOutput;"]).result,r=Pu.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=Pu.substitute(o,"//VTK::TCoord::Dec",["varying vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,a&&a.length>=1)switch(i){case 1:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}}else switch(n=Pu.substitute(n,"//VTK::TCoord::Dec","attribute vec3 tcoordMC; varying vec3 tcoordVCVSOutput;").result,r=Pu.substitute(r,"//VTK::TCoord::Dec",["in vec3 tcoordVCVSOutput[];","out vec3 tcoordVCGSOutput;"]).result,r=Pu.substitute(r,"//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];").result,o=Pu.substitute(o,"//VTK::TCoord::Dec",["varying vec3 tcoordVCVSOutput;","uniform samplerCube texture1;"]).result,i){case 1:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;"]).result;break;case 2:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.r;","  diffuseColor = diffuseColor*tcolor.r;","  opacity = opacity * tcolor.g;"]).result;break;default:o=Pu.substitute(o,"//VTK::TCoord::Impl",["  vec4 tcolor = textureCube(texture1, tcoordVCVSOutput);","  ambientColor = ambientColor*tcolor.rgb;","  diffuseColor = diffuseColor*tcolor.rgb;","  opacity = opacity * tcolor.a;"]).result}e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes();o=Pu.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`uniform vec4 clipPlanes[${e}];`,`varying float clipDistancesVSOutput[${e}];`]).result,o=Pu.substitute(o,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=Pu.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;",`varying float clipDistancesVSOutput[${e}];`]).result,a=Pu.substitute(a,"//VTK::Clip::Impl",[`for (int planeNum = 0; planeNum < ${e}; planeNum++)`,"    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getCoincidentParameters=(e,n)=>{let r={factor:0,offset:0};const o=n.getProperty();if(t.renderable.getResolveCoincidentTopology()==dl.PolygonOffset||o.getEdgeVisibility()&&o.getRepresentation()===ld.SURFACE){const e=t.lastBoundBO.getPrimitiveType();e===sd.Points||o.getRepresentation()===ld.POINTS?r=t.renderable.getCoincidentTopologyPointOffsetParameter():e===sd.Lines||o.getRepresentation()===ld.WIREFRAME?r=t.renderable.getCoincidentTopologyLineOffsetParameters():e!==sd.Tris&&e!==sd.TriStrips||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters()),e!==sd.TrisEdges&&e!==sd.TriStripsEdges||(r=t.renderable.getCoincidentTopologyPolygonOffsetParameters(),r.factor/=2,r.offset/=2)}const a=t._openGLRenderer.getSelector();return a&&a.getFieldAssociation()===id.FIELD_ASSOCIATION_POINTS&&(r.offset-=2),r},e.replaceShaderPicking=(e,n,r)=>{let o=e.Fragment,a=e.Vertex;if(o=Pu.substitute(o,"//VTK::Picking::Dec",["uniform int picking;","//VTK::Picking::Dec"]).result,t._openGLRenderer.getSelector()){switch(t.lastSelectionState!==xl.ID_LOW24&&t.lastSelectionState!==xl.ID_HIGH24||(a=Pu.substitute(a,"//VTK::Picking::Dec",["flat out int vertexIDVSOutput;\n","uniform int VertexIDOffset;\n"]).result,a=Pu.substitute(a,"//VTK::Picking::Impl","  vertexIDVSOutput = gl_VertexID + VertexIDOffset;\n").result,o=Pu.substitute(o,"//VTK::Picking::Dec","flat in int vertexIDVSOutput;\n").result,o=Pu.substitute(o,"//VTK::Picking::Impl",["  int idx = vertexIDVSOutput;","//VTK::Picking::Impl"]).result),t.lastSelectionState){case xl.ID_LOW24:o=Pu.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float(idx%256)/255.0, float((idx/256)%256)/255.0, float((idx/65536)%256)/255.0, 1.0);").result;break;case xl.ID_HIGH24:o=Pu.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = vec4(float((idx/16777216)%256)/255.0, 0.0, 0.0, 1.0);").result;break;default:o=Pu.substitute(o,"//VTK::Picking::Dec","uniform vec3 mapperIndex;").result,o=Pu.substitute(o,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result}e.Fragment=o,e.Vertex=a}},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderColor(n,r,o),e.replaceShaderNormal(n,r,o),e.replaceShaderLight(n,r,o),e.replaceShaderTCoord(n,r,o),e.replaceShaderPicking(n,r,o),e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=Pu.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=Pu.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}},e.getNeedToRebuildShaders=(e,n,r)=>{let o=0,a=0;const i=e.getPrimitiveType(),s=t.currentInput;let l=!1;const c=s.getPointData().getNormals(),u=s.getCellData().getNormals(),d=r.getProperty().getInterpolation()===cd.FLAT,p=r.getProperty().getRepresentation(),f=e.getOpenGLMode(p,i);if(f===t.context.TRIANGLES||u&&!c||!d&&c?l=!0:d||f!==t.context.LINES||(l=!0),r.getProperty().getLighting()&&l){o=0;const e=n.getLightsByReference();for(let t=0;t<e.length;++t){const n=e[t];n.getSwitch()>0&&(a++,0===o&&(o=1)),1===o&&(a>1||1!==n.getIntensity()||!n.lightTypeIsHeadLight())&&(o=2),o<3&&n.getPositional()&&(o=3)}}let g=!1;const m=t.lastBoundBO.getReferenceByName("lastLightComplexity"),h=t.lastBoundBO.getReferenceByName("lastLightCount");return m===o&&h===a||(t.lastBoundBO.set({lastLightComplexity:o},!0),t.lastBoundBO.set({lastLightCount:a},!0),g=!0),(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(g=!0),!!(t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<t.selectionStateChanged.getMTime()||g)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,!0)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(n,r,o)=>{if(n.getProgram().isUniformUsed("PrimitiveIDOffset")&&n.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),n.getProgram().isUniformUsed("VertexIDOffset")&&n.getProgram().setUniformi("VertexIDOffset",t.vertexIDOffset),n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){const e=t.lastBoundBO.getReferenceByName("lastLightComplexity");n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||fd("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("normalMC")&&n.getCABO().getNormalOffset()&&e>0?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"normalMC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,!1)||fd("Error setting normalMC in shader VAO."):n.getVAO().removeAttributeArray("normalMC"),t.renderable.getCustomShaderAttributes().forEach(((e,r)=>{n.getProgram().isAttributeUsed(`${e}MC`)&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),`${e}MC`,n.getCABO().getCustomData()[r].offset,n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getCustomData()[r].components,!1)||fd(`Error setting ${e}MC in shader VAO.`))})),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),!1)||fd("Error setting tcoordMC in shader VAO."):n.getVAO().removeAttributeArray("tcoordMC"),n.getProgram().isAttributeUsed("scalarColor")&&n.getCABO().getColorComponents()?n.getVAO().addAttributeArray(n.getProgram(),n.getCABO().getColorBO(),"scalarColor",n.getCABO().getColorOffset(),n.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||fd("Error setting scalarColor in shader VAO."):n.getVAO().removeAttributeArray("scalarColor"),n.getAttributeUpdateTime().modified()}if(t.renderable.getNumberOfClippingPlanes()){const e=t.renderable.getNumberOfClippingPlanes(),r=[],a=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,i=a?d(t.tmpMat4,o.getMatrix()):o.getMatrix();a&&(m(i,i),y(i,i,a),m(i,i));for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(i,n,e);for(let t=0;t<4;t++)r.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",r)}t.internalColorTexture&&n.getProgram().isUniformUsed("texture1")&&n.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const a=t.openGLActor.getActiveTextures();if(a)for(let e=0;e<a.length;++e){const t=a[e].getTextureUnit(),r=`texture${t+1}`;n.getProgram().isUniformUsed(r)&&n.getProgram().setUniformi(r,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}n.setMapperShaderParameters(r,o,t._openGLRenderer.getTiledSizeAndOrigin());const i=t._openGLRenderer.getSelector();n.getProgram().setUniform3fArray("mapperIndex",i?i.getPropColorValue():[0,0,0]),n.getProgram().setUniformi("picking",i?i.getCurrentPass()+1:0)},e.setLightingShaderParameters=(e,n,r)=>{const o=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(o<2)return;const a=e.getProgram();let i=0;const s=n.getLightsByReference();for(let e=0;e<s.length;++e){const r=s[e];if(r.getSwitch()>0){const e=r.getColorByReference(),o=r.getIntensity();t.lightColor[0]=e[0]*o,t.lightColor[1]=e[1]*o,t.lightColor[2]=e[2]*o;const s=r.getDirection(),l=n.getActiveCamera().getViewMatrix(),c=[...s];r.lightTypeIsSceneLight()&&(c[0]=l[0]*s[0]+l[1]*s[1]+l[2]*s[2],c[1]=l[4]*s[0]+l[5]*s[1]+l[6]*s[2],c[2]=l[8]*s[0]+l[9]*s[1]+l[10]*s[2],Go(c)),t.lightDirection[0]=c[0],t.lightDirection[1]=c[1],t.lightDirection[2]=c[2],Go(t.lightDirection),a.setUniform3fArray(`lightColor${i}`,t.lightColor),a.setUniform3fArray(`lightDirectionVC${i}`,t.lightDirection),i++}}if(o<3)return;const l=n.getActiveCamera().getViewMatrix();m(l,l),i=0;for(let e=0;e<s.length;++e){const t=s[e];if(t.getSwitch()>0){const e=t.getTransformedPosition(),n=new Float64Array(3);wn(n,e,l),a.setUniform3fArray(`lightAttenuation${i}`,t.getAttenuationValuesByReference()),a.setUniformi(`lightPositional${i}`,t.getPositional()),a.setUniformf(`lightExponent${i}`,t.getExponent()),a.setUniformf(`lightConeAngle${i}`,t.getConeAngle()),a.setUniform3fArray(`lightPositionVC${i}`,[n[0],n[1],n[2]]),i++}}},e.setCameraShaderParameters=(e,a,i)=>{const s=e.getProgram(),l=t.openGLCamera.getKeyMatrices(a),c=a.getActiveCamera(),u=t.openGLCamera.getKeyMatrixTime().getMTime(),d=s.getLastCameraMTime(),p=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,f=i.getIsIdentity(),m=f?{mcwc:null,normalMatrix:null}:t.openGLActor.getKeyMatrices();if(i.getCoordinateSystem()===hd.DISPLAY){const e=t._openGLRenderer.getTiledSizeAndOrigin();g(t.tmpMat4),t.tmpMat4[0]=2/e.usize,t.tmpMat4[12]=-1,t.tmpMat4[5]=2/e.vsize,t.tmpMat4[13]=-1,y(t.tmpMat4,t.tmpMat4,p),s.setUniformMatrix("MCPCMatrix",t.tmpMat4)}else s.setUniformMatrix("MCPCMatrix",n([l.wcpc,m.mcwc,p],r,t.tmpMat4));s.isUniformUsed("MCVCMatrix")&&s.setUniformMatrix("MCVCMatrix",n([l.wcvc,m.mcwc,p],r,t.tmpMat4)),s.isUniformUsed("normalMatrix")&&s.setUniformMatrix3x3("normalMatrix",n([l.normalMatrix,m.normalMatrix],o,t.tmpMat3)),d!==u&&(s.isUniformUsed("cameraParallel")&&s.setUniformi("cameraParallel",c.getParallelProjection()),s.setLastCameraMTime(u)),f||s.setLastCameraMTime(0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();let a=r.getProperty(),i=a.getOpacity(),s=t.drawingEdges?a.getEdgeColorByReference():a.getAmbientColorByReference(),l=t.drawingEdges?a.getEdgeColorByReference():a.getDiffuseColorByReference(),c=t.drawingEdges?1:a.getAmbient(),u=t.drawingEdges?0:a.getDiffuse(),d=t.drawingEdges?0:a.getSpecular();const p=a.getSpecularPower();o.setUniformf("opacityUniform",i),o.setUniform3fArray("ambientColorUniform",s),o.setUniform3fArray("diffuseColorUniform",l),o.setUniformf("ambient",c),o.setUniformf("diffuse",u);const f=t.lastBoundBO.getReferenceByName("lastLightComplexity");if(f<1)return;let g=a.getSpecularColorByReference();if(o.setUniform3fArray("specularColorUniform",g),o.setUniformf("specularPowerUniform",p),o.setUniformf("specular",d),o.isUniformUsed("ambientIntensityBF")){if(a=r.getBackfaceProperty(),i=a.getOpacity(),s=a.getAmbientColor(),c=a.getAmbient(),l=a.getDiffuseColor(),u=a.getDiffuse(),g=a.getSpecularColor(),d=a.getSpecular(),o.setUniformf("ambientIntensityBF",c),o.setUniformf("diffuseIntensityBF",u),o.setUniformf("opacityUniformBF",i),o.setUniform3fArray("ambientColorUniformBF",s),o.setUniform3fArray("diffuseColorUniformBF",l),f<1)return;o.setUniformf("specularIntensityBF",d),o.setUniform3fArray("specularColorUniformBF",g),o.setUniformf("specularPowerUniformBF",p)}},e.updateMaximumPointCellIds=(e,n)=>{const r=t._openGLRenderer.getSelector();if(r){if(t.selectionWebGLIdsToVTKIds?.points?.length){const e=t.selectionWebGLIdsToVTKIds.points.length;r.setMaximumPointId(e-1)}if(t.selectionWebGLIdsToVTKIds?.cells?.length){const e=t.selectionWebGLIdsToVTKIds.cells.length;r.setMaximumCellId(e-1)}r.getFieldAssociation()===id.FIELD_ASSOCIATION_POINTS&&(t.pointPicking=!0)}},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t.vertexIDOffset=0;const o=function(e){const t=e.getSelector();return t?t.getCurrentPass():xl.MIN_KNOWN_PASS-1}(t._openGLRenderer);t.lastSelectionState!==o&&(t.selectionStateChanged.modified(),t.lastSelectionState=o),t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().renderProp(r),e.updateBufferObjects(n,r),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=r.getProperty().getEdgeVisibility()&&o===ld.SURFACE,i=t._openGLRenderer.getSelector(),s=i&&i.getFieldAssociation()===id.FIELD_ASSOCIATION_POINTS&&(t.lastSelectionState===xl.ID_LOW24||t.lastSelectionState===xl.ID_HIGH24);for(let i=sd.Start;i<sd.End;i++)t.primitives[i].setPointPicking(s),t.primitives[i].getCABO().getElementCount()&&(t.drawingEdges=a&&(i===sd.TrisEdges||i===sd.TriStripsEdges),t.drawingEdges&&(t.renderDepth||t.lastSelectionState>=0)||(t.lastBoundBO=t.primitives[i],t.primitiveIDOffset+=t.primitives[i].drawArrays(n,r,o,e),t.vertexIDOffset+=t.primitives[i].getCABO().getElementCount()))},e.renderPieceFinish=(e,n)=>{t.LastBoundBO&&t.LastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.renderPiece=(n,r)=>{if(e.invokeEvent(gd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(md),!t.currentInput)return void fd("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context,a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n),e.updateMaximumPointCellIds()},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors();t.haveCellScalars=!1;const a=t.renderable.getScalarMode();t.renderable.getScalarVisibility()&&(a!==ud.USE_CELL_DATA&&a!==ud.USE_CELL_FIELD_DATA&&a!==ud.USE_FIELD_DATA&&r.getPointData().getScalars()||a===ud.USE_POINT_FIELD_DATA||!o||(t.haveCellScalars=!0));let i=n.getProperty().getInterpolation()!==cd.FLAT?r.getPointData().getNormals():null;null===i&&r.getCellData().getNormals()&&(t.haveCellNormals=!0,i=r.getCellData().getNormals());const s=n.getProperty().getRepresentation();let l=r.getPointData().getTCoords();t.openGLActor.getActiveTextures()||(l=null);let c=!1;if(t.renderable.getColorCoordinates()){l=t.renderable.getColorCoordinates(),c=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=td.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(dd.NEAREST),e.setMagnificationFilter(dd.NEAREST),e.setWrapS(pd.CLAMP_TO_EDGE),e.setWrapT(pd.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),e.deactivate()}const u=`${r.getMTime()}A${s}B${r.getMTime()}C${i?i.getMTime():1}D${o?o.getMTime():1}E${n.getProperty().getEdgeVisibility()}F${l?l.getMTime():1}`;if(t.VBOBuildString!==u){const e={points:r.getPoints(),normals:i,tcoords:l,colors:o,cellOffset:0,vertexOffset:0,useTCoordsPerCell:c,haveCellScalars:t.haveCellScalars,haveCellNormals:t.haveCellNormals,customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};t.renderable.getPopulateSelectionSettings()&&(t.selectionWebGLIdsToVTKIds={points:null,cells:null});const a=[{inRep:"verts",cells:r.getVerts()},{inRep:"lines",cells:r.getLines()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()},{inRep:"polys",cells:r.getPolys()},{inRep:"strips",cells:r.getStrips()}],d=n.getProperty().getEdgeVisibility()&&s===ld.SURFACE;for(let n=sd.Start;n<sd.End;n++)n!==sd.TrisEdges&&n!==sd.TriStripsEdges?(e.cellOffset+=t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,s,e,t.selectionWebGLIdsToVTKIds),e.vertexOffset+=t.primitives[n].getCABO().getElementCount()):d?t.primitives[n].getCABO().createVBO(a[n].cells,a[n].inRep,ld.WIREFRAME,{...e,tcoords:null,colors:null,haveCellScalars:!1,haveCellNormals:!1}):t.primitives[n].releaseGraphicsResources();t.renderable.getPopulateSelectionSettings()&&t.renderable.setSelectionWebGLIdsToVTKIds(t.selectionWebGLIdsToVTKIds),t.VBOBuildString=u}t.VBOBuildTime.modified()},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}(e,t)}const yd=Et(Td,"vtkOpenGLPolyDataMapper");var bd={newInstance:yd,extend:Td};en("vtkMapper",yd);const xd=1,{primTypes:Cd}=Bu,{Filter:Sd,Wrap:Ad}=td,{vtkErrorMacro:Id}=jt,wd={type:"StartEvent"},Od={type:"EndEvent"},Pd={context:null,VBOBuildTime:0,VBOBuildString:null,primitives:null,primTypes:null,shaderRebuildString:null};const Rd=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pd,n),Xt.extend(e,t,n),od(e,t,n),ad(e,t,n),t.primitives=[],t.primTypes=Cd,t.tmpMat4=g(new Float64Array(16));for(let e=Cd.Start;e<Cd.End;e++)t.primitives[e]=Bu.newInstance(),t.primitives[e].setPrimitiveType(e),t.primitives[e].set({lastLightComplexity:0,lastLightCount:0,lastSelectionPass:!1},!0);St(e,t,["context"]),t.VBOBuildTime={},vt(t.VBOBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkOpenGLPolyDataMapper2D"),e.buildPass=n=>{n&&(t.openGLActor2D=e.getFirstAncestorOfType("vtkOpenGLActor2D"),t._openGLRenderer=t.openGLActor2D.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()))},e.overlayPass=t=>{t&&e.render()},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model Coordinates\n// WC - WC world coordinates\n// VC - View Coordinates\n// DC - Display Coordinates\n\nin vec4 vertexWC;\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// material property values\n//VTK::Color::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nuniform mat4 WCVCMatrix;  // World to view matrix\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  gl_Position = WCVCMatrix*vertexWC;\n\n  //VTK::TCoord::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::PositionVC::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyData2DFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nuniform int PrimitiveIDOffset;\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// Scalar coloring\n//VTK::Color::Dec\n\n// Depth Peeling\n//VTK::DepthPeeling::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Apple Bug\n//VTK::PrimID::Dec\n\nvoid main()\n{\n  // Apple Bug\n  //VTK::PrimID::Impl\n\n  //VTK::Color::Impl\n  //VTK::TCoord::Impl\n\n  //VTK::DepthPeeling::Impl\n  //VTK::Picking::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n}\n",e.Geometry=""},e.render=()=>{const n=t._openGLRenderWindow.getContext();if(t.context!==n){t.context=n;for(let e=Cd.Start;e<Cd.End;e++)t.primitives[e].setOpenGLRenderWindow(t._openGLRenderWindow)}const r=t.openGLActor2D.getRenderable(),o=t._openGLRenderer.getRenderable();e.renderPiece(o,r)},e.renderPiece=(n,r)=>{if(e.invokeEvent(wd),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(),e.invokeEvent(Od),!t.currentInput)return void Id("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.renderPieceStart=(n,r)=>{t.primitiveIDOffset=0,t._openGLRenderer.getSelector()&&(t._openGLRenderer.getSelector().getCurrentPass(),t._openGLRenderer.getSelector().renderProp(r)),t.renderable.getColorTextureMap()&&t.internalColorTexture.activate(),e.updateBufferObjects(n,r),t.lastBoundBO=null},e.getNeedToRebuildShaders=(e,n,r)=>e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime(),e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return!!(o<e.getMTime()||o<t._openGLRenderWindow.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentInput.getMTime()||t.renderable.getTransformCoordinate()&&o<n.getMTime())},e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,n.getProperty().getOpacity());const o=t.renderable.getColorMapColors(),a=n.getProperty().getRepresentation();let i=r.getPointData().getTCoords();t.openGLActor2D.getActiveTextures()||(i=null);let s=!1;if(t.renderable.getColorCoordinates()){i=t.renderable.getColorCoordinates(),s=t.renderable.getAreScalarsMappedFromCells(),t.internalColorTexture||(t.internalColorTexture=td.newInstance({resizable:!0}));const e=t.internalColorTexture;e.setMinificationFilter(Sd.NEAREST),e.setMagnificationFilter(Sd.NEAREST),e.setWrapS(Ad.CLAMP_TO_EDGE),e.setWrapT(Ad.CLAMP_TO_EDGE),e.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t.renderable.getColorTextureMap(),r=n.getExtent(),o=n.getPointData().getScalars();e.create2DFromRaw({width:r[1]-r[0]+1,height:r[3]-r[2]+1,numComps:o.getNumberOfComponents(),dataType:o.getDataType(),data:o.getData()}),e.activate(),e.sendParameters(),e.deactivate()}const l=t.renderable.getTransformCoordinate(),c=e.getRenderWindow().getViews()[0].getViewportSize(e),u=`${r.getMTime()}A${a}B${r.getMTime()}C${o?o.getMTime():1}D${i?i.getMTime():1}E${l?e.getMTime():1}F${c}`;if(t.VBOBuildString!==u){let n=r.getPoints();if(l){const t=ql.newInstance(),r=n.getNumberOfPoints();t.setNumberOfPoints(r);const o=[];for(let a=0;a<r;++a){n.getPoint(a,o),l.setValue(o);const r=l.getComputedDoubleViewportValue(e);t.setPoint(a,r[0],r[1],0)}n=t}const c={points:n,tcoords:i,colors:o,cellOffset:0,useTCoordsPerCell:s,haveCellScalars:t.renderable.getAreScalarsMappedFromCells(),customAttributes:t.renderable.getCustomShaderAttributes().map((e=>r.getPointData().getArrayByName(e)))};c.cellOffset+=t.primitives[Cd.Points].getCABO().createVBO(r.getVerts(),"verts",a,c),c.cellOffset+=t.primitives[Cd.Lines].getCABO().createVBO(r.getLines(),"lines",a,c),c.cellOffset+=t.primitives[Cd.Tris].getCABO().createVBO(r.getPolys(),"polys",a,c),c.cellOffset+=t.primitives[Cd.TriStrips].getCABO().createVBO(r.getStrips(),"strips",a,c),t.VBOBuildTime.modified(),t.VBOBuildString=u}},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation();t.context.depthMask(!0);for(let a=Cd.Start;a<Cd.End;a++)t.primitives[a].getCABO().getElementCount()&&(t.lastBoundBO=t.primitives[a],t.primitiveIDOffset+=t.primitives[a].drawArrays(n,r,o,e))},e.renderPieceFinish=(e,n)=>{t.lastBoundBO&&t.lastBoundBO.getVAO().release(),t.renderable.getColorTextureMap()&&t.internalColorTexture.deactivate()},e.replaceShaderValues=(t,n,r)=>{e.replaceShaderColor(t,n,r),e.replaceShaderTCoord(t,n,r),e.replaceShaderPicking(t,n,r),e.replaceShaderPositionVC(t,n,r)},e.replaceShaderColor=(e,n,r)=>{let o=e.Vertex,a=e.Geometry,i=e.Fragment,s=["uniform vec3 diffuseColorUniform;","uniform float opacityUniform;"],l=["vec3 diffuseColor = diffuseColorUniform;","float opacity = opacityUniform;"];0!==t.lastBoundBO.getCABO().getColorComponents()?(s=s.concat(["varying vec4 vertexColorVSOutput;"]),o=Pu.substitute(o,"//VTK::Color::Dec",["attribute vec4 scalarColor;","varying vec4 vertexColorVSOutput;"]).result,o=Pu.substitute(o,"//VTK::Color::Impl",["vertexColorVSOutput =  scalarColor;"]).result,a=Pu.substitute(a,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,a=Pu.substitute(a,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,i=Pu.substitute(i,"//VTK::Color::Impl",l.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])).result):t.renderable.getAreScalarsMappedFromCells()&&(l=l.concat(["  vec4 texColor = texture2D(texture1, tcoordVCVSOutput.st);","  diffuseColor = texColor.rgb;","  opacity = opacity*texColor.a;"])),l=l.concat(["gl_FragData[0] = vec4(diffuseColor, opacity);"]),i=Pu.substitute(i,"//VTK::Color::Dec",s).result,i=Pu.substitute(i,"//VTK::Color::Impl",l).result,e.Vertex=o,e.Geometry=a,e.Fragment=i},e.replaceShaderTCoord=(e,n,r)=>{if(t.lastBoundBO.getCABO().getTCoordOffset()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getCABO().getTCoordComponents();1===a?(n=Pu.substitute(n,"//VTK::TCoord::Dec",["in float tcoordMC;","out float tcoordVCVSOutput;"]).result,n=Pu.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=Pu.substitute(r,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput[];\n","out float tcoordVCGSOutput;"]).result,r=Pu.substitute(r,["//VTK::TCoord::Impl","tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=Pu.substitute(o,"//VTK::TCoord::Dec",["in float tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=Pu.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, vec2(tcoordVCVSOutput,0));"]).result):2===a&&(n=Pu.substitute(n,"//VTK::TCoord::Dec",["in vec2 tcoordMC;","out vec2 tcoordVCVSOutput;"]).result,n=Pu.substitute(n,"//VTK::TCoord::Impl",["tcoordVCVSOutput = tcoordMC;"]).result,r=Pu.substitute(r,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput[];\n","out vec2 tcoordVCGSOutput;"]).result,r=Pu.substitute(r,"//VTK::TCoord::Impl",["tcoordVCGSOutput = tcoordVCVSOutput[i];"]).result,o=Pu.substitute(o,"//VTK::TCoord::Dec",["in vec2 tcoordVCVSOutput;","uniform sampler2D texture1;"]).result,o=Pu.substitute(o,"//VTK::TCoord::Impl",["gl_FragData[0] = gl_FragData[0]*texture2D(texture1, tcoordVCVSOutput.st);"]).result),t.renderable.getAreScalarsMappedFromCells()&&(r=Pu.substitute(r,"//VTK::PrimID::Impl",["gl_PrimitiveID = gl_PrimitiveIDIn;"]).result),e.Vertex=n,e.Geometry=r,e.Fragment=o}},e.replaceShaderPicking=(e,t,n)=>{let r=e.Fragment;r=Pu.substitute(r,"//VTK::Picking::Dec",["uniform vec3 mapperIndex;","uniform int picking;"]).result,r=Pu.substitute(r,"//VTK::Picking::Impl","  gl_FragData[0] = picking != 0 ? vec4(mapperIndex,1.0) : gl_FragData[0];").result,e.Fragment=r},e.replaceShaderPositionVC=(e,n,r)=>{t.lastBoundBO.replaceShaderPositionVC(e,n,r)},e.invokeShaderCallbacks=(e,n,r)=>{const o=t.renderable.getViewSpecificProperties().ShadersCallbacks;o&&o.forEach((t=>{t.callback(t.userData,e,n,r)}))},e.setMapperShaderParameters=(e,n,r)=>{if(e.getProgram().isUniformUsed("PrimitiveIDOffset")&&e.getProgram().setUniformi("PrimitiveIDOffset",t.primitiveIDOffset),e.getProgram().isAttributeUsed("vertexWC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"vertexWC",e.getCABO().getVertexOffset(),e.getCABO().getStride(),t.context.FLOAT,3,!1)||Id("Error setting vertexWC in shader VAO.")),e.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())){t.renderable.getCustomShaderAttributes().forEach(((n,r)=>{e.getProgram().isAttributeUsed(`${n}MC`)&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),`${n}MC`,e.getCABO().getCustomData()[r].offset,e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getCustomData()[r].components,!1)||Id(`Error setting ${n}MC in shader VAO.`))})),e.getProgram().isAttributeUsed("tcoordMC")&&e.getCABO().getTCoordOffset()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"tcoordMC",e.getCABO().getTCoordOffset(),e.getCABO().getStride(),t.context.FLOAT,e.getCABO().getTCoordComponents(),!1)||Id("Error setting tcoordMC in shader VAO."):e.getVAO().removeAttributeArray("tcoordMC"),e.getProgram().isAttributeUsed("scalarColor")&&e.getCABO().getColorComponents()?e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"scalarColor",e.getCABO().getColorOffset(),e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,4,!0)||Id("Error setting scalarColor in shader VAO."):e.getVAO().removeAttributeArray("scalarColor"),t.internalColorTexture&&e.getProgram().isUniformUsed("texture1")&&t.internalColorTexture.getTextureUnit()>-1&&e.getProgram().setUniformi("texture1",t.internalColorTexture.getTextureUnit());const o=t.openGLActor2D.getActiveTextures();if(o)for(let t=0;t<o.length;++t){const n=o[t].getTextureUnit(),r=`texture${n+1}`;e.getProgram().isUniformUsed(r)&&e.getProgram().setUniformi(r,n)}e.setMapperShaderParameters(n,r,t._openGLRenderer.getTiledSizeAndOrigin());const a=t._openGLRenderer.getSelector();e.getProgram().setUniform3fArray("mapperIndex",a?a.getPropColorValue():[0,0,0]),e.getProgram().setUniformi("picking",a?a.getCurrentPass()+1:0)}},e.setPropertyShaderParameters=(e,n,r)=>{const o=t.renderable.getColorMapColors();if(!o||0===o.getNumberOfComponents()){const t=e.getProgram(),n=r.getProperty(),o=n.getOpacity();t.setUniformf("opacityUniform",o);const a=n.getColor();t.setUniform3fArray("diffuseColorUniform",a)}},e.setLightingShaderParameters=(e,t,n)=>{},e.setCameraShaderParameters=(e,n,o)=>{const a=e.getProgram(),i=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,s=n.getRenderWindow().getViews()[0].getViewportSize(n),l=n.getViewport(),c=o.getActualPositionCoordinate().getComputedDoubleViewportValue(n),u=[0,0,1,1],d=[0,0,1,1];if(d[0]=l[0]>=u[0]?l[0]:u[0],d[1]=l[1]>=u[1]?l[1]:u[1],d[2]=l[2]<=u[2]?l[2]:u[2],d[3]=l[3]<=u[3]?l[3]:u[3],d[0]>=d[2])return;if(d[1]>=d[3])return;s[0]=xo(s[0]*(d[2]-d[0])/(l[2]-l[0])),s[1]=xo(s[1]*(d[3]-d[1])/(l[3]-l[1]));const p=t._openGLRenderer.getParent().getSize(),f=xo(c[0]-(d[0]-l[0])*p[0]),h=xo(c[1]-(d[1]-l[1])*p[1]),v=-f;let T=-f+s[0];const y=-h;let b=-h+s[1];v===T&&(T=v+1),y===b&&(b=y+1);const x=g(new Float64Array(16));var C,S,A;x[0]=2/(T-v),x[5]=2/(b-y),x[3]=-1*(T+v)/(T-v),x[7]=-1*(b+y)/(b-y),x[10]=0,x[11]=o.getProperty().getDisplayLocation()===xd?-1:1,x[15]=1,m(x,x),a.setUniformMatrix("WCVCMatrix",(C=[x,i],S=r,A=t.tmpMat4,S.identity(A),C.reduce(((e,t,n)=>0===n?t?S.copy(e,t):S.identity(e):t?S.multiply(e,e,t):e),A)))},e.getAllocatedGPUMemoryInBytes=()=>{let e=0;return t.primitives.forEach((t=>{e+=t.getAllocatedGPUMemoryInBytes()})),e}}(e,t)}),"vtkOpenGLPolyDataMapper2D");en("vtkMapper2D",Rd);const{VectorMode:Md}=il;function Ed(e,t){e.strokeStyle=t.strokeColor,e.lineWidth=t.strokeSize,e.fillStyle=t.fontColor,e.font=`${t.fontStyle} ${t.fontSize}px ${t.fontFamily}`}function Vd(e,t){return e=>{const n=e.getLastSize(),r=(n[0]/700)**.8,o=(n[1]/700)**.8,a=Math.min(r,o),i=e.getAxisTextStyle(),s=e.getTickTextStyle();Object.assign(i,t.axisTextStyle),Object.assign(s,t.tickTextStyle),i.fontSize=Math.max(24*a,12),e.getLastAspectRatio()>1?s.fontSize=Math.max(20*a,10):s.fontSize=Math.max(16*a,10);const l=e.updateTextureAtlas();e.setTopTitle(!1);const c=e.getBoxSizeByReference();if(e.getLastAspectRatio()>1)e.setTickLabelPixelOffset(.3*s.fontSize),l.titleWidth<=l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize?(e.setTopTitle(!0),e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.98-c[0],-.92])):(e.setAxisTitlePixelOffset(.2*s.fontSize),c[0]=2*(l.titleHeight+e.getAxisTitlePixelOffset()+l.tickWidth+e.getTickLabelPixelOffset()+.8*s.fontSize)/n[0],e.setBoxPosition([.99-c[0],-.92])),c[1]=Math.max(1.2,Math.min(1.84/o,1.84));else{e.setAxisTitlePixelOffset(1.2*s.fontSize),e.setTickLabelPixelOffset(.1*s.fontSize);const t=2*(.8*s.fontSize+l.titleHeight+e.getAxisTitlePixelOffset())/n[1],r=2*l.tickWidth/n[0];c[0]=Math.min(1.9,Math.max(1.4,1.4*r*(e.getTicks().length+3))),c[1]=t,e.setBoxPosition([-.5*c[0],-.97])}e.recomputeBarSegments(l)}}function Dd(e,t){return e=>{const t=e.getLastTickBounds(),n=oo().domain([t[0],t[1]]),r=n.ticks(5),o=n.tickFormat(5);e.setTicks(r),e.setTickStrings(r.map(o))}}const Ld=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{renderable:null};Object.assign(t,{},n),Ht.obj(e,t),Ht.setGet(e,t,["axisTitlePixelOffset","tickLabelPixelOffset","renderable","topTitle","ticks","tickStrings","tickPositions"]),Ht.get(e,t,["lastSize","lastAspectRatio","lastTickBounds","axisTextStyle","tickTextStyle","barActor","tmActor"]),Ht.getArray(e,t,["boxPosition","boxSize"]),Ht.setArray(e,t,["boxPosition","boxSize"],2),t.forceUpdate=!1,t.lastRebuildTime={},Ht.obj(t.lastRebuildTime,{mtime:0}),t.lastSize=[-1,-1],t.tmCanvas=document.createElement("canvas"),t.tmContext=t.tmCanvas.getContext("2d"),t._tmAtlas=new Map,t.barMapper=Fl.newInstance(),t.barMapper.setInterpolateScalarsBeforeMapping(!0),t.barMapper.setUseLookupTableScalarRange(!0),t.polyData=Uc.newInstance(),t.barMapper.setInputData(t.polyData),t.barActor=os.newInstance(),t.barActor.setMapper(t.barMapper),t.tmPolyData=Uc.newInstance(),t.tmMapper=Fl.newInstance(),t.tmMapper.setInputData(t.tmPolyData),t.tmTexture=Hc.newInstance({resizable:!0}),t.tmTexture.setInterpolate(!1),t.tmActor=os.newInstance({parentProp:e}),t.tmActor.setMapper(t.tmMapper),t.tmActor.addTexture(t.tmTexture),t.barPosition=[0,0],t.barSize=[0,0],t.boxPosition=[.88,-.92],t.boxSize=[.1,1.1],t.lastTickBounds=[],function(e,t){t.classHierarchy.push("vtkScalarBarActorHelper"),e.setRenderable=n=>{t.renderable!==n&&(t.renderable=n,t.barActor.setProperty(n.getProperty()),t.barActor.setParentProp(n),t.barActor.setCoordinateSystemToDisplay(),t.tmActor.setProperty(n.getProperty()),t.tmActor.setParentProp(n),t.tmActor.setCoordinateSystemToDisplay(),t.generateTicks=n.generateTicks,t.axisTextStyle={...n.getAxisTextStyle()},t.tickTextStyle={...n.getTickTextStyle()},e.modified())},e.updateAPISpecificData=(n,r,o)=>{t.lastSize[0]===n[0]&&t.lastSize[1]===n[1]||(t.lastSize[0]=n[0],t.lastSize[1]=n[1],t.lastAspectRatio=n[0]/n[1],t.forceUpdate=!0);const a=t.renderable.getScalarsToColors();if(a&&t.renderable.getVisibility()&&(t.barMapper.setLookupTable(a),t.camera=r,t.renderWindow=o,t.forceUpdate||Math.max(a.getMTime(),e.getMTime(),t.renderable.getMTime())>t.lastRebuildTime.getMTime())){const n=a.getMappingRange();if(t.lastTickBounds=[...n],t.renderable.getGenerateTicks()(e),t.renderable.getAutomated())t.renderable.getAutoLayout()(e);else{t.axisTextStyle={...t.renderable.getAxisTextStyle()},t.tickTextStyle={...t.renderable.getTickTextStyle()},t.barPosition=[...t.renderable.getBarPosition()],t.barSize=[...t.renderable.getBarSize()],t.boxPosition=[...t.renderable.getBoxPosition()],t.boxSize=[...t.renderable.getBoxSize()],t.axisTitlePixelOffset=t.renderable.getAxisTitlePixelOffset(),t.tickLabelPixelOffset=t.renderable.getTickLabelPixelOffset();const n=e.updateTextureAtlas();e.recomputeBarSegments(n)}e.updatePolyDataForLabels(),e.updatePolyDataForBarSegments(),t.lastRebuildTime.modified(),t.forceUpdate=!1}},e.updateTextureAtlas=()=>{t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left";const n={},r=new Map;let o=0,a=1;Ed(t.tmContext,t.axisTextStyle);let i=t.tmContext.measureText(t.renderable.getAxisLabel()),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.axisTextStyle};r.set(t.renderable.getAxisLabel(),s),a+=s.height,o=s.width,n.titleWidth=s.width,n.titleHeight=s.height,n.tickWidth=0,n.tickHeight=0,Ed(t.tmContext,t.tickTextStyle);const l=[...e.getTickStrings(),"NaN","Below","Above"];for(let e=0;e<l.length;e++)r.has(l[e])||(i=t.tmContext.measureText(l[e]),s={height:i.actualBoundingBoxAscent+2,startingHeight:a,width:i.width+2,textStyle:t.tickTextStyle},r.set(l[e],s),a+=s.height,o<s.width&&(o=s.width),n.tickWidth<s.width&&(n.tickWidth=s.width),n.tickHeight<s.height&&(n.tickHeight=s.height));return o=Po(o),a=Po(a),r.forEach((e=>{e.tcoords=[0,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight-e.height)/a,e.width/o,(a-e.startingHeight)/a,0,(a-e.startingHeight)/a]})),t.tmCanvas.width=o,t.tmCanvas.height=a,t.tmContext.textBaseline="bottom",t.tmContext.textAlign="left",t.tmContext.clearRect(0,0,o,a),r.forEach(((e,n)=>{Ed(t.tmContext,e.textStyle),t.tmContext.fillText(n,1,e.startingHeight+e.height-1)})),t.tmTexture.setCanvas(t.tmCanvas),t.tmTexture.modified(),t._tmAtlas=r,n},e.computeBarSize=e=>{t.vertical=t.boxSize[1]>t.boxSize[0];const n=2*e.tickHeight/t.lastSize[1],r=[1,1];if(t.vertical){const o=2*(e.tickWidth+t.tickLabelPixelOffset)/t.lastSize[0];if(t.topTitle){const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0]-o,t.barSize[1]=t.boxSize[1]-n}else{const n=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[0];t.barSize[0]=t.boxSize[0]-n-o,t.barSize[1]=t.boxSize[1]}t.barPosition[0]=t.boxPosition[0]+o,t.barPosition[1]=t.boxPosition[1],r[1]=n}else{const n=(2*e.tickWidth-8)/t.lastSize[0],o=2*(e.titleHeight+t.axisTitlePixelOffset)/t.lastSize[1];t.barSize[0]=t.boxSize[0],t.barPosition[0]=t.boxPosition[0],t.barSize[1]=t.boxSize[1]-o,t.barPosition[1]=t.boxPosition[1],r[0]=n}return r},e.recomputeBarSegments=n=>{const r=e.computeBarSize(n);t.barSegments=[];const o=[0,0],a=t.vertical?1:0,i=t.vertical?.01:.02;function s(e,n){t.barSegments.push({corners:[[...o],[o[0]+r[0],o[1]],[o[0]+r[0],o[1]+r[1]],[o[0],o[1]+r[1]]],scalars:n,title:e}),o[a]+=r[a]+i}t.renderable.getDrawNanAnnotation()&&t.renderable.getScalarsToColors().getNanColor()&&s("NaN",[NaN,NaN,NaN,NaN]),t.renderable.getDrawBelowRangeSwatch()&&t.renderable.getScalarsToColors().getUseBelowRangeColor?.()&&s("Below",[-.1,-.1,-.1,-.1]);const l=t.renderable.getScalarsToColors().getUseAboveRangeColor?.();o[a]+=i;const c=r[a];r[a]=l?1-2*i-r[a]-o[a]:1-i-o[a],s("ticks",t.vertical?[0,0,.995,.995]:[0,.995,.995,0]),t.renderable.getDrawAboveRangeSwatch()&&l&&(r[a]=c,o[a]+=i,s("Above",[1.1,1.1,1.1,1.1]))};const n=new Float64Array(3);e.createPolyDataForOneLabel=(e,r,o,a,i,s)=>{const l=t._tmAtlas.get(e);if(!l)return;let c=s.ptIdx,u=s.cellIdx;n[0]=(.5*r[0]+.5)*t.lastSize[0],n[1]=(.5*r[1]+.5)*t.lastSize[1],n[2]=r[2],n[0]+=i[0],n[1]+=i[1];const d=[],p="vertical"===a?[1,0]:[0,1];"vertical"===a?(d[0]=l.width,d[1]=-l.height,"middle"===o[0]?n[1]-=l.width/2:"right"===o[0]&&(n[1]-=l.width),"middle"===o[1]?n[0]+=l.height/2:"top"===o[1]&&(n[0]+=l.height)):(d[0]=l.width,d[1]=l.height,"middle"===o[0]?n[0]-=l.width/2:"right"===o[0]&&(n[0]-=l.width),"middle"===o[1]?n[1]-=l.height/2:"top"===o[1]&&(n[1]-=l.height)),s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[0],s.tcoords[2*c+1]=l.tcoords[1],c++,n[p[0]]+=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[2],s.tcoords[2*c+1]=l.tcoords[3],c++,n[p[1]]+=d[1],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[4],s.tcoords[2*c+1]=l.tcoords[5],c++,n[p[0]]-=d[0],s.points[3*c]=n[0],s.points[3*c+1]=n[1],s.points[3*c+2]=n[2],s.tcoords[2*c]=l.tcoords[6],s.tcoords[2*c+1]=l.tcoords[7],c++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-3,s.polys[4*u+3]=c-2,u++,s.polys[4*u]=3,s.polys[4*u+1]=c-4,s.polys[4*u+2]=c-2,s.polys[4*u+3]=c-1,s.ptIdx+=4,s.cellIdx+=2};const r=new Float64Array(3);e.updatePolyDataForLabels=()=>{const n=e.getTickStrings().length+t.barSegments.length,o=4*n,a=2*n,i=new Float64Array(3*o),s=new Uint16Array(4*a),l=new Float32Array(2*o),c={ptIdx:0,cellIdx:0,polys:s,points:i,tcoords:l},u=t.vertical?0:1,d=t.vertical?1:0;r[2]=-.99;const p=t.vertical?["right","middle"]:["middle","bottom"];let f=[0,1];const g=[0,0];t.vertical?(g[0]=-t.tickLabelPixelOffset,t.topTitle?(r[0]=t.boxPosition[0]+.5*t.boxSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)):(r[0]=t.barPosition[0]+t.barSize[0],r[1]=t.barPosition[1]+.5*t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","top"],"vertical",[t.axisTitlePixelOffset,0],c)),f=[-1,0]):(g[1]=t.tickLabelPixelOffset,r[0]=t.barPosition[0]+.5*t.barSize[0],r[1]=t.barPosition[1]+t.barSize[1],e.createPolyDataForOneLabel(t.renderable.getAxisLabel(),r,["middle","bottom"],"horizontal",[0,t.axisTitlePixelOffset],c)),r[u]=t.barPosition[u]+(.5*f[u]+.5)*t.barSize[u],r[d]=t.barPosition[d]+.5*t.barSize[d];let m=null;for(let n=0;n<t.barSegments.length;n++){const o=t.barSegments[n];"ticks"===o.title?m=o:(r[d]=t.barPosition[d]+.5*t.barSize[d]*(o.corners[2][d]+o.corners[0][d]),e.createPolyDataForOneLabel(o.title,r,p,"horizontal",g,c))}const h=t.barPosition[d]+t.barSize[d]*m.corners[0][d],v=t.barSize[d]*(m.corners[2][d]-m.corners[0][d]),T=e.getTicks(),y=e.getTickStrings(),b=e.getTickPositions();for(let n=0;n<T.length;n++){const o=b?b[n]:(T[n]-t.lastTickBounds[0])/(t.lastTickBounds[1]-t.lastTickBounds[0]);r[d]=h+v*o,e.createPolyDataForOneLabel(y[n],r,p,"horizontal",g,c)}const x=Ts.newInstance({numberOfComponents:2,values:l,name:"TextureCoordinates"});t.tmPolyData.getPointData().setTCoords(x),t.tmPolyData.getPoints().setData(i,3),t.tmPolyData.getPoints().modified(),t.tmPolyData.getPolys().setData(s,1),t.tmPolyData.getPolys().modified(),t.tmPolyData.modified()},e.updatePolyDataForBarSegments=()=>{const e=t.renderable.getScalarsToColors();let n=0;t.renderable.getDrawNanAnnotation()&&e.getNanColor()&&(n+=1),t.renderable.getDrawBelowRangeSwatch()&&e.getUseBelowRangeColor?.()&&(n+=1),t.renderable.getDrawAboveRangeSwatch()&&e.getUseAboveRangeColor?.()&&(n+=1);const o=4*(1+n),a=o;let i=1;e.getVectorMode()===Md.COMPONENT&&(i=e.getVectorComponent()+1);const s=new Float64Array(3*o),l=new Uint16Array(5*a),c=new Float32Array(o*i);let u=0,d=0;for(let e=0;e<t.barSegments.length;e++){const n=t.barSegments[e];for(let e=0;e<4;e++){r[0]=t.barPosition[0]+n.corners[e][0]*t.barSize[0],r[1]=t.barPosition[1]+n.corners[e][1]*t.barSize[1],s[3*u]=(.5*r[0]+.5)*t.lastSize[0],s[3*u+1]=(.5*r[1]+.5)*t.lastSize[1],s[3*u+2]=r[2];for(let r=0;r<i;r++)c[u*i+r]=t.lastTickBounds[0]+n.scalars[e]*(t.lastTickBounds[1]-t.lastTickBounds[0]);u++}l[5*d]=4,l[5*d+1]=u-4,l[5*d+2]=u-3,l[5*d+3]=u-2,l[5*d+4]=u-1,d++}const p=Ts.newInstance({numberOfComponents:i,values:c,name:"Scalars"});t.polyData.getPointData().setScalars(p),t.polyData.getPoints().setData(s,3),t.polyData.getPoints().modified(),t.polyData.getPolys().setData(l,1),t.polyData.getPolys().modified(),t.polyData.modified()}}(e,t)}),"vtkScalarBarActorHelper");function Bd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,function(e){return{automated:!0,autoLayout:null,axisLabel:"Scalar Value",barPosition:[0,0],barSize:[0,0],boxPosition:[.88,-.92],boxSize:[.1,1.1],scalarToColors:null,axisTitlePixelOffset:36,axisTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:18,fontFamily:"serif"},tickLabelPixelOffset:14,tickTextStyle:{fontColor:"white",fontStyle:"normal",fontSize:14,fontFamily:"serif"},generateTicks:null,drawNanAnnotation:!0,drawBelowRangeSwatch:!0,drawAboveRangeSwatch:!0,...e}}(n)),t.autoLayout||(t.autoLayout=Vd(0,t)),t.generateTicks||(t.generateTicks=Dd()),os.extend(e,t,n),e.getProperty().setDiffuse(0),e.getProperty().setAmbient(1),Ht.setGet(e,t,["automated","autoLayout","axisTitlePixelOffset","axisLabel","scalarsToColors","tickLabelPixelOffset","generateTicks","drawNanAnnotation","drawBelowRangeSwatch","drawAboveRangeSwatch"]),Ht.get(e,t,["axisTextStyle","tickTextStyle"]),Ht.getArray(e,t,["barPosition","barSize","boxPosition","boxSize"]),Ht.setArray(e,t,["barPosition","barSize","boxPosition","boxSize"],2),function(e,t){t.classHierarchy.push("vtkScalarBarActor"),e.setTickTextStyle=n=>{t.tickTextStyle={...t.tickTextStyle,...n},e.modified()},e.setAxisTextStyle=n=>{t.axisTextStyle={...t.axisTextStyle,...n},e.modified()},e.resetAutoLayoutToDefault=()=>{e.setAutoLayout(Vd(0,t))},e.resetGenerateTicksToDefault=()=>{e.setGenerateTicks(Dd())}}(e,t)}var Nd={newInstance:Ht.newInstance(Bd,"vtkScalarBarActor"),extend:Bd,newScalarBarActorHelper:Ld};const Fd={};const _d=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fd,n),Xt.extend(e,t,n),t.scalarBarActorHelper=Nd.newScalarBarActorHelper(),function(e,t){t.classHierarchy.push("vtkOpenGLScalarBarActor"),e.buildPass=n=>{n&&(t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.scalarBarActorHelper.getRenderable()||t.scalarBarActorHelper.setRenderable(t.renderable),e.prepareNodes(),e.addMissingNode(t.scalarBarActorHelper.getBarActor()),e.addMissingNode(t.scalarBarActorHelper.getTmActor()),e.removeUnusedNodes())},e.opaquePass=(e,n)=>{if(e){const e=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,n=t._openGLRenderer.getTiledSizeAndOrigin();t.scalarBarActorHelper.updateAPISpecificData([n.usize,n.vsize],e,t._openGLRenderWindow.getRenderable())}}}(e,t)}),"vtkOpenGLScalarBarActor");en("vtkScalarBarActor",_d);const{vtkErrorMacro:Gd}=jt,kd={context:null};const Ud=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kd,n),Xt.extend(e,t,n),t.openGLTexture=td.newInstance(),t.tris=Bu.newInstance(),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={normalMatrix:pe(new Float64Array(9)),mcwc:g(new Float64Array(16))},St(e,t,["context"]),yt(e,t,["activeTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLSkybox"),e.buildPass=n=>{if(n){t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getParent(),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera())}},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementOpaqueActorCount()}},e.opaquePass=(n,r)=>{if(n&&!t._openGLRenderer.getSelector()){e.updateBufferObjects(),t.context.depthMask(!0),t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.tris.getProgram()),t.openGLTexture.render(t._openGLRenderWindow);const n=t.openGLTexture.getTextureUnit();t.tris.getProgram().setUniformi("sbtexture",n);const r=t._openGLRenderer.getRenderable(),o=t.openGLCamera.getKeyMatrices(r),a=new Float64Array(16);if(h(a,o.wcpc),t.tris.getProgram().setUniformMatrix("IMCPCMatrix",a),"box"===t.lastFormat){const e=r.getActiveCamera().getPosition();t.tris.getProgram().setUniform3f("camPos",e[0],e[1],e[2])}t.tris.getVAO().bind(),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),t.openGLTexture.deactivate()}},e.updateBufferObjects=()=>{if(!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=1;const n=Ts.newInstance({numberOfComponents:3,values:e});n.setName("points");const r=new Uint16Array(8);r[0]=3,r[1]=0,r[2]=1,r[3]=3,r[4]=3,r[5]=0,r[6]=3,r[7]=2;const o=Ts.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(o,"polys",qi.SURFACE,{points:n,cellOffset:0})}t.renderable.getFormat()!==t.lastFormat&&(t.lastFormat=t.renderable.getFormat(),"box"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec3 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = wpos.xyz/wpos.w;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec3 TexCoords;\n             uniform samplerCube sbtexture;\n             uniform vec3 camPos;\n             void main () {\n               // skybox looks from inside out\n               // which means we have to adjust\n               // our tcoords. Otherwise text would\n               // be flipped\n               vec3 tc = normalize(TexCoords - camPos);\n               if (abs(tc.z) < max(abs(tc.x),abs(tc.y)))\n               {\n                 tc = vec3(1.0, 1.0, -1.0) * tc;\n               }\n               else\n               {\n                 tc = vec3(-1.0, 1.0, 1.0) * tc;\n               }\n               gl_FragData[0] = textureCube(sbtexture, tc);\n             }","")),"background"===t.lastFormat&&t.tris.setProgram(t._openGLRenderWindow.getShaderCache().readyShaderProgramArray("//VTK::System::Dec\n             attribute vec3 vertexMC;\n             uniform mat4 IMCPCMatrix;\n             varying vec2 TexCoords;\n             void main () {\n              gl_Position = vec4(vertexMC.xyz, 1.0);\n              vec4 wpos = IMCPCMatrix * gl_Position;\n              TexCoords = vec2(vertexMC.x, vertexMC.y)*0.5 + 0.5;\n             }","//VTK::System::Dec\n             //VTK::Output::Dec\n             varying vec2 TexCoords;\n             uniform sampler2D sbtexture;\n             void main () {\n               gl_FragData[0] = texture2D(sbtexture, TexCoords);\n             }","")),t.tris.getShaderSourceTime().modified(),t.tris.getVAO().bind(),t.tris.getVAO().addAttributeArray(t.tris.getProgram(),t.tris.getCABO(),"vertexMC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Gd("Error setting vertexMC in shader VAO."));const e=t.renderable.getTextures();e.length||Gd("vtkSkybox requires a texture map"),t.openGLTexture.getRenderable()!==e[0]&&(t.openGLTexture.releaseGraphicsResources(t._openGLRenderWindow),t.openGLTexture.setRenderable(e[0]))}}(e,t)}));en("vtkSkybox",Ud);const{FieldAssociations:zd}=_s,Wd={fieldAssociation:zd.FIELD_ASSOCIATION_CELLS,captureZValues:!1};function Hd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wd,n),Ht.obj(e,t),Ht.setGet(e,t,["fieldAssociation","captureZValues"]),function(e,t){t.classHierarchy.push("vtkHardwareSelector"),e.getSourceDataAsync=async(e,t,n,r,o)=>{},e.selectAsync=async(t,n,r,o,a)=>{const i=await e.getSourceDataAsync(t,n,r,o,a);return i?i.generateSelection(n,r,o,a):[]}}(e,t)}var jd={newInstance:Ht.newInstance(Hd,"vtkHardwareSelector"),extend:Hd};const Kd={glFramebuffer:null,colorBuffers:null,depthTexture:null,previousDrawBinding:0,previousReadBinding:0,previousDrawBuffer:0,previousReadBuffer:0,previousActiveFramebuffer:null};function $d(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kd,n),vt(e,t),t.colorBuffers&&tt("you cannot initialize colorBuffers through the constructor. You should call setColorBuffer() instead."),t.colorBuffers=[],At(e,t,["colorBuffers"]),function(e,t){t.classHierarchy.push("vtkFramebuffer"),e.getBothMode=()=>t.context.FRAMEBUFFER,e.saveCurrentBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.saveCurrentBindings(n),e.saveCurrentBuffers(n)},e.saveCurrentBindings=e=>{if(!t.context)return void tt("you must set the OpenGLRenderWindow before calling saveCurrentBindings");const n=t.context;t.previousDrawBinding=n.getParameter(t.context.FRAMEBUFFER_BINDING),t.previousActiveFramebuffer=t._openGLRenderWindow.getActiveFramebuffer()},e.saveCurrentBuffers=e=>{},e.restorePreviousBindingsAndBuffers=t=>{const n=void 0!==t?t:e.getBothMode();e.restorePreviousBindings(n),e.restorePreviousBuffers(n)},e.restorePreviousBindings=e=>{if(!t.context)return void tt("you must set the OpenGLRenderWindow before calling restorePreviousBindings");const n=t.context;n.bindFramebuffer(n.FRAMEBUFFER,t.previousDrawBinding),t._openGLRenderWindow.setActiveFramebuffer(t.previousActiveFramebuffer)},e.restorePreviousBuffers=e=>{},e.bind=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null;null===n&&(n=t.context.FRAMEBUFFER),t.context.bindFramebuffer(n,t.glFramebuffer);for(let e=0;e<t.colorBuffers.length;e++)t.colorBuffers[e].bind();t._openGLRenderWindow.setActiveFramebuffer(e)},e.create=(e,n)=>{t.context?(t.glFramebuffer=t.context.createFramebuffer(),t.glFramebuffer.width=e,t.glFramebuffer.height=n):tt("you must set the OpenGLRenderWindow before calling create")},e.setColorBuffer=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const r=t.context;if(!r)return void tt("you must set the OpenGLRenderWindow before calling setColorBuffer");let o=r.COLOR_ATTACHMENT0;if(n>0){if(!t._openGLRenderWindow.getWebgl2())return void tt("Using multiple framebuffer attachments requires WebGL 2");o+=n}t.colorBuffers[n]=e,r.framebufferTexture2D(r.FRAMEBUFFER,o,r.TEXTURE_2D,e.getHandle(),0)},e.removeColorBuffer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;const n=t.context;if(!n)return void tt("you must set the OpenGLRenderWindow before calling removeColorBuffer");let r=n.COLOR_ATTACHMENT0;if(e>0){if(!t._openGLRenderWindow.getWebgl2())return void tt("Using multiple framebuffer attachments requires WebGL 2");r+=e}n.framebufferTexture2D(n.FRAMEBUFFER,r,n.TEXTURE_2D,null,0),t.colorBuffers=t.colorBuffers.splice(e,1)},e.setDepthBuffer=e=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const n=t.context;n.framebufferTexture2D(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.TEXTURE_2D,e.getHandle(),0)}else tt("Attaching depth buffer textures to fbo requires WebGL 2");else tt("you must set the OpenGLRenderWindow before calling setDepthBuffer")},e.removeDepthBuffer=()=>{if(t.context)if(t._openGLRenderWindow.getWebgl2()){const e=t.context;e.framebufferTexture2D(e.FRAMEBUFFER,e.DEPTH_ATTACHMENT,e.TEXTURE_2D,null,0)}else tt("Attaching depth buffer textures to framebuffers requires WebGL 2");else tt("you must set the OpenGLRenderWindow before calling removeDepthBuffer")},e.getGLFramebuffer=()=>t.glFramebuffer,e.setOpenGLRenderWindow=n=>{t._openGLRenderWindow!==n&&(e.releaseGraphicsResources(),t._openGLRenderWindow=n,t.context=null,n&&(t.context=t._openGLRenderWindow.getContext()))},e.releaseGraphicsResources=()=>{t.glFramebuffer&&t.context.deleteFramebuffer(t.glFramebuffer)},e.getSize=()=>null==t.glFramebuffer?null:[t.glFramebuffer.width,t.glFramebuffer.height],e.populateFramebuffer=()=>{if(!t.context)return void tt("you must set the OpenGLRenderWindow before calling populateFrameBuffer");e.bind();const n=t.context,r=td.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow),r.setMinificationFilter(Fu.LINEAR),r.setMagnificationFilter(Fu.LINEAR),r.create2DFromRaw({width:t.glFramebuffer.width,height:t.glFramebuffer.height,numComps:4,dataType:is.UNSIGNED_CHAR,data:null}),e.setColorBuffer(r),t.depthTexture=n.createRenderbuffer(),n.bindRenderbuffer(n.RENDERBUFFER,t.depthTexture),n.renderbufferStorage(n.RENDERBUFFER,n.DEPTH_COMPONENT16,t.glFramebuffer.width,t.glFramebuffer.height),n.framebufferRenderbuffer(n.FRAMEBUFFER,n.DEPTH_ATTACHMENT,n.RENDERBUFFER,t.depthTexture)},e.getColorTexture=()=>t.colorBuffers[0]}(e,t)}var qd={newInstance:Et($d,"vtkFramebuffer"),extend:$d};const Xd={contentType:-1,fieldType:-1,properties:null,selectionList:[]};function Yd(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xd,n),Ht.obj(e,t),t.properties={},Ht.setGet(e,t,["contentType","fieldType","properties","selectionList"]),function(e,t){t.classHierarchy.push("vtkSelectionNode"),e.getBounds=()=>t.points.getBounds()}(e,t)}var Zd={newInstance:Ht.newInstance(Yd,"vtkSelectionNode"),extend:Yd,SelectionContent:{GLOBALIDS:0,PEDIGREEIDS:1,VALUES:2,INDICES:3,FRUSTUM:4,LOCATIONS:5,THRESHOLDS:6,BLOCKS:7,QUERY:8},SelectionField:{CELL:0,POINT:1,FIELD:2,VERTEX:3,EDGE:4,ROW:5}};const{PassTypes:Qd}=Cl,{SelectionContent:Jd,SelectionField:ep}=Zd,{FieldAssociations:tp}=_s,{vtkErrorMacro:np}=Ht;function rp(e){return`${e.propID} ${e.compositeID}`}function op(e,t,n,r){return n?n[4*(t*(r[2]-r[0]+1)+e)+3]:0}function ap(e,t,n,r){if(!n)return 0;const o=4*(t*(r[2]-r[0]+1)+e),a=n[o],i=n[o+1];return 256*(256*n[o+2]+i)+a}function ip(e,t){let n=t;return n<<=24,n|=e,n}function sp(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<e.area[0]||t[0]>e.area[2]||t[1]<e.area[1]||t[1]>e.area[3])return null;const n=[t[0]-e.area[0],t[1]-e.area[1]],o=ap(n[0],n[1],e.pixBuffer[Qd.ACTOR_PASS],e.area);if(o<=0||o-1>=e.props.length)return null;const a={valid:!0};a.propID=o-1,a.prop=e.props[a.propID];let i=ap(n[0],n[1],e.pixBuffer[Qd.COMPOSITE_INDEX_PASS],e.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,e.captureZValues){const r=4*(n[1]*(e.area[2]-e.area[0]+1)+n[0]);a.zValue=(256*e.zBuffer[r]+e.zBuffer[r+1])/65535,a.displayPosition=t}if(e.pixBuffer[Qd.ID_LOW24]&&0===op(n[0],n[1],e.pixBuffer[Qd.ID_LOW24],e.area))return a;const s=ap(n[0],n[1],e.pixBuffer[Qd.ID_LOW24],e.area),l=ap(n[0],n[1],e.pixBuffer[Qd.ID_HIGH24],e.area);return a.attributeID=ip(s,l),a}const a=[t[0],t[1]],i=[0,0];let s=sp(e,t,0,r);if(s&&s.valid)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=sp(e,i,0,r),s&&s.valid))return s;if(i[0]=a[0]+t,s=sp(e,i,0,r),s&&s.valid)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=sp(e,i,0,r),s&&s.valid))return s;if(i[1]=a[1]+t,s=sp(e,i,0,r),s&&s.valid)return s}}return r[0]=t[0],r[1]=t[1],null}function lp(e,t,n,r,o){const a=[];let i=0;return t.forEach(((t,s)=>{const l=Zd.newInstance();switch(l.setContentType(Jd.INDICES),e){case tp.FIELD_ASSOCIATION_CELLS:l.setFieldType(ep.CELL);break;case tp.FIELD_ASSOCIATION_POINTS:l.setFieldType(ep.POINT);break;default:np("Unknown field association")}l.getProperties().propID=t.info.propID,l.getProperties().prop=t.info.prop,l.getProperties().compositeID=t.info.compositeID,l.getProperties().attributeID=t.info.attributeID,l.getProperties().pixelCount=t.pixelCount,n&&(l.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],l.getProperties().worldPosition=o.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,r)),l.setSelectionList(t.attributeIDs),a[i]=l,i++})),a}const cp={area:void 0,currentPass:-1,propColorValue:null,props:null,maximumPointId:0,maximumCellId:0,idOffset:1};function up(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cp,n),jd.extend(e,t,n),t.propColorValue=[0,0,0],t.props=[],t.area||(t.area=[0,0,0,0]),Ht.setGetArray(e,t,["area"],4),Ht.setGet(e,t,["_renderer","currentPass","_openGLRenderWindow","maximumPointId","maximumCellId"]),Ht.setGetArray(e,t,["propColorValue"],3),Ht.moveToProtected(e,t,["renderer","openGLRenderWindow"]),Ht.event(e,t,"event"),function(e,t){t.classHierarchy.push("vtkOpenGLHardwareSelector"),e.releasePixBuffers=()=>{t.rawPixBuffer=[],t.pixBuffer=[],t.zBuffer=null},e.beginSelection=()=>{t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t.maxAttributeId=0;const n=t._openGLRenderWindow.getSize();if(t.framebuffer){t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers();const e=t.framebuffer.getSize();e&&e[0]===n[0]&&e[1]===n[1]?t.framebuffer.bind():(t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer())}else t.framebuffer=qd.newInstance(),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.create(n[0],n[1]),t.framebuffer.populateFramebuffer();if(t._openGLRenderer.clear(),t._openGLRenderer.setSelector(e),t.hitProps={},t.propPixels={},t.props=[],e.releasePixBuffers(),t.fieldAssociation===tp.FIELD_ASSOCIATION_POINTS){const e=t._openGLRenderWindow.getContext(),n=e.isEnabled(e.BLEND);e.disable(e.BLEND),t._openGLRenderWindow.traverseAllPasses(),n&&e.enable(e.BLEND)}},e.endSelection=()=>{t.hitProps={},t._openGLRenderer.setSelector(null),t.framebuffer.restorePreviousBindingsAndBuffers()},e.preCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending=e.isEnabled(e.BLEND),e.disable(e.BLEND)},e.postCapturePass=()=>{const e=t._openGLRenderWindow.getContext();t.originalBlending&&e.enable(e.BLEND)},e.select=()=>{let n=null;return e.captureBuffers()&&(n=e.generateSelection(t.area[0],t.area[1],t.area[2],t.area[3]),e.releasePixBuffers()),n},e.getSourceDataAsync=async(n,r,o,a,i)=>{if(t._renderer=n,void 0===r){const n=t._openGLRenderWindow.getSize();e.setArea(0,0,n[0]-1,n[1]-1)}else e.setArea(r,o,a,i);if(!e.captureBuffers())return!1;const s={area:[...t.area],pixBuffer:[...t.pixBuffer],captureZValues:t.captureZValues,zBuffer:t.zBuffer,props:[...t.props],fieldAssociation:t.fieldAssociation,renderer:n,openGLRenderWindow:t._openGLRenderWindow,generateSelection:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];return function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=sp(e,[n,t],0,u);if(r&&r.valid){const t=rp(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return lp(e.fieldAssociation,c,e.captureZValues,e.renderer,e.openGLRenderWindow)}(s,...t)}};return s},e.captureBuffers=()=>{if(!t._renderer||!t._openGLRenderWindow)return np("Renderer and view must be set before calling Select."),!1;t._openGLRenderer=t._openGLRenderWindow.getViewNodeFor(t._renderer),t._openGLRenderWindow.getRenderable().preRender(),e.invokeEvent({type:"StartEvent"}),t.originalBackground=t._renderer.getBackgroundByReference(),t._renderer.setBackground(0,0,0,0);const n=t._openGLRenderWindow.getRenderPasses();e.beginSelection();const r=[];for(t.currentPass=Qd.MIN_KNOWN_PASS;t.currentPass<=Qd.MAX_KNOWN_PASS;t.currentPass++)e.passRequired(t.currentPass)&&(e.preCapturePass(t.currentPass),t.captureZValues&&t.currentPass===Qd.ACTOR_PASS&&"function"==typeof n[0].requestDepth&&"function"==typeof n[0].getFramebuffer?(n[0].requestDepth(),t._openGLRenderWindow.traverseAllPasses()):t._openGLRenderWindow.traverseAllPasses(),e.postCapturePass(t.currentPass),e.savePixelBuffer(t.currentPass),r.push(t.currentPass));return r.forEach((n=>{t.currentPass=n,e.processPixelBuffers()})),t.currentPass=Qd.MAX_KNOWN_PASS,e.endSelection(),t._renderer.setBackground(t.originalBackground),e.invokeEvent({type:"EndEvent"}),!0},e.processPixelBuffers=()=>{t.props.forEach(((n,r)=>{e.isPropHit(r)&&n.processSelectorPixelBuffers(e,t.propPixels[r])}))},e.passRequired=e=>{if(e===Qd.ID_HIGH24){if(t.fieldAssociation===tp.FIELD_ASSOCIATION_POINTS)return t.maximumPointId>16777215;if(t.fieldAssociation===tp.FIELD_ASSOCIATION_CELLS)return t.maximumCellId>16777215}return!0},e.savePixelBuffer=n=>{if(t.pixBuffer[n]=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),!t.rawPixBuffer[n]){const e=(t.area[2]-t.area[0]+1)*(t.area[3]-t.area[1]+1)*4;t.rawPixBuffer[n]=new Uint8Array(e),t.rawPixBuffer[n].set(t.pixBuffer[n])}if(n===Qd.ACTOR_PASS){if(t.captureZValues){const e=t._openGLRenderWindow.getRenderPasses();if("function"==typeof e[0].requestDepth&&"function"==typeof e[0].getFramebuffer){const n=e[0].getFramebuffer();n.saveCurrentBindingsAndBuffers(),n.bind(),t.zBuffer=t._openGLRenderWindow.getPixelData(t.area[0],t.area[1],t.area[2],t.area[3]),n.restorePreviousBindingsAndBuffers()}}e.buildPropHitList(t.rawPixBuffer[n])}},e.buildPropHitList=e=>{let n=0;for(let r=0;r<=t.area[3]-t.area[1];r++)for(let o=0;o<=t.area[2]-t.area[0];o++){let a=ap(o,r,e,t.area);a>0&&(a--,a in t.hitProps||(t.hitProps[a]=!0,t.propPixels[a]=[]),t.propPixels[a].push(4*n)),++n}},e.renderProp=n=>{t.currentPass===Qd.ACTOR_PASS&&(e.setPropColorValueFromInt(t.props.length+1),t.props.push(n))},e.renderCompositeIndex=n=>{t.currentPass===Qd.COMPOSITE_INDEX_PASS&&e.setPropColorValueFromInt(n+1)},e.renderAttributeId=e=>{e<0||(t.maxAttributeId=e>t.maxAttributeId?e:t.maxAttributeId)},e.passTypeToString=e=>Ht.enumToString(Qd,e),e.isPropHit=e=>Boolean(t.hitProps[e]),e.setPropColorValueFromInt=e=>{t.propColorValue[0]=e%256/255,t.propColorValue[1]=Math.floor(e/256)%256/255,t.propColorValue[2]=Math.floor(e/65536)%256/255},e.getPixelInformation=(n,r,o)=>{const a=r<0?0:r;if(0===a){if(o[0]=n[0],o[1]=n[1],n[0]<t.area[0]||n[0]>t.area[2]||n[1]<t.area[1]||n[1]>t.area[3])return null;const e=[n[0]-t.area[0],n[1]-t.area[1]],r=ap(e[0],e[1],t.pixBuffer[Qd.ACTOR_PASS],t.area);if(r<=0||r-1>=t.props.length)return null;const a={valid:!0};a.propID=r-1,a.prop=t.props[a.propID];let i=ap(e[0],e[1],t.pixBuffer[Qd.COMPOSITE_INDEX_PASS],t.area);if((i<0||i>16777215)&&(i=0),a.compositeID=i-1,t.captureZValues){const r=4*(e[1]*(t.area[2]-t.area[0]+1)+e[0]);a.zValue=(256*t.zBuffer[r]+t.zBuffer[r+1])/65535,a.displayPosition=n}if(t.pixBuffer[Qd.ID_LOW24]&&0===op(e[0],e[1],t.pixBuffer[Qd.ID_LOW24],t.area))return a;const s=ap(e[0],e[1],t.pixBuffer[Qd.ID_LOW24],t.area),l=ap(e[0],e[1],t.pixBuffer[Qd.ID_HIGH24],t.area);return a.attributeID=ip(s,l),a}const i=[n[0],n[1]],s=[0,0];let l=e.getPixelInformation(n,0,o);if(l&&l.valid)return l;for(let t=1;t<a;++t){for(let n=i[1]>t?i[1]-t:0;n<=i[1]+t;++n){if(s[1]=n,i[0]>=t&&(s[0]=i[0]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[0]=i[0]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}for(let n=i[0]>=t?i[0]-(t-1):0;n<=i[0]+(t-1);++n){if(s[0]=n,i[1]>=t&&(s[1]=i[1]-t,l=e.getPixelInformation(s,0,o),l&&l.valid))return l;if(s[1]=i[1]+t,l=e.getPixelInformation(s,0,o),l&&l.valid)return l}}return o[0]=n[0],o[1]=n[1],null},e.generateSelection=(n,r,o,a)=>{const i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=Math.floor(a),u=new Map,d=[0,0];for(let n=s;n<=c;n++)for(let r=i;r<=l;r++){const o=[r,n],a=e.getPixelInformation(o,0,d);if(a&&a.valid){const e=rp(a);if(u.has(e)){const n=u.get(e);n.pixelCount++,t.captureZValues&&a.zValue<n.info.zValue&&(n.info=a),-1===n.attributeIDs.indexOf(a.attributeID)&&n.attributeIDs.push(a.attributeID)}else u.set(e,{info:a,pixelCount:1,attributeIDs:[a.attributeID]})}}return lp(t.fieldAssociation,u,t.captureZValues,t._renderer,t._openGLRenderWindow)},e.getRawPixelBuffer=e=>t.rawPixBuffer[e],e.getPixelBuffer=e=>t.pixBuffer[e],e.attach=(e,n)=>{t._openGLRenderWindow=e,t._renderer=n};const n=e.setArea;e.setArea=function(){return!!n(...arguments)&&(t.area[0]=Math.floor(t.area[0]),t.area[1]=Math.floor(t.area[1]),t.area[2]=Math.floor(t.area[2]),t.area[3]=Math.floor(t.area[3]),!0)}}(e,t)}var dp={newInstance:Ht.newInstance(up,"vtkOpenGLHardwareSelector"),extend:up,...Cl};const{vtkErrorMacro:pp}=jt,{Representation:fp}=ts,{ObjectType:gp}=mu,{PassTypes:mp}=dp,hp={type:"StartEvent"},vp={type:"EndEvent"},Tp={normalMatrix:null,mcpcMatrix:null,mcwcMatrix:null};const yp=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tp,n),bd.extend(e,t,n),t.tmpMat3=pe(new Float64Array(9)),t.normalMatrix=pe(new Float64Array(9)),t.mcpcMatrix=g(new Float64Array(16)),t.mcvcMatrix=g(new Float64Array(16)),t.tmpColor=[],t.glyphBOBuildTime={},vt(t.glyphBOBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkOpenGLGlyph3DMapper");const n={...e};e.renderPiece=(n,r)=>{if(e.invokeEvent(hp),t.renderable.getStatic()||t.renderable.update(),t.currentInput=t.renderable.getInputData(1),e.invokeEvent(vp),!t.currentInput)return void pp("No input!");if(!t.currentInput.getPoints||!t.currentInput.getPoints().getNumberOfValues())return;const o=t.context;t._openGLRenderWindow.getWebgl2()?(t.hardwareSupport=!0,t.extension=null):t.extension||(t.extension=t.context.getExtension("ANGLE_instanced_arrays"),t.hardwareSupport=!!t.extension);const a=r.getProperty().getBackfaceCulling(),i=r.getProperty().getFrontfaceCulling();a||i?i?(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.FRONT)):(t._openGLRenderWindow.enableCullFace(),o.cullFace(o.BACK)):t._openGLRenderWindow.disableCullFace(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)},e.multiply4x4WithOffset=(e,t,n,r)=>{const o=t[0],a=t[1],i=t[2],s=t[3],l=t[4],c=t[5],u=t[6],d=t[7],p=t[8],f=t[9],g=t[10],m=t[11],h=t[12],v=t[13],T=t[14],y=t[15];let b=n[r],x=n[r+1],C=n[r+2],S=n[r+3];e[0]=b*o+x*l+C*p+S*h,e[1]=b*a+x*c+C*f+S*v,e[2]=b*i+x*u+C*g+S*T,e[3]=b*s+x*d+C*m+S*y,b=n[r+4],x=n[r+5],C=n[r+6],S=n[r+7],e[4]=b*o+x*l+C*p+S*h,e[5]=b*a+x*c+C*f+S*v,e[6]=b*i+x*u+C*g+S*T,e[7]=b*s+x*d+C*m+S*y,b=n[r+8],x=n[r+9],C=n[r+10],S=n[r+11],e[8]=b*o+x*l+C*p+S*h,e[9]=b*a+x*c+C*f+S*v,e[10]=b*i+x*u+C*g+S*T,e[11]=b*s+x*d+C*m+S*y,b=n[r+12],x=n[r+13],C=n[r+14],S=n[r+15],e[12]=b*o+x*l+C*p+S*h,e[13]=b*a+x*c+C*f+S*v,e[14]=b*i+x*u+C*g+S*T,e[15]=b*s+x*d+C*m+S*y},e.replaceShaderNormal=(e,r,o)=>{if(t.hardwareSupport&&t.lastBoundBO.getReferenceByName("lastLightComplexity")>0){let n=e.Vertex;t.lastBoundBO.getCABO().getNormalOffset()&&(n=Pu.substitute(n,"//VTK::Normal::Dec",["attribute vec3 normalMC;","attribute mat3 gNormal;","uniform mat3 normalMatrix;","varying vec3 normalVCVSOutput;"]).result,n=Pu.substitute(n,"//VTK::Normal::Impl",["normalVCVSOutput = normalMatrix * gNormal * normalMC;"]).result),e.Vertex=n}n.replaceShaderNormal(e,r,o)},e.replaceShaderColor=(e,r,o)=>{if(t.hardwareSupport&&t.renderable.getColorArray()){let n=e.Vertex,r=e.Geometry,o=e.Fragment;const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=["uniform float ambient;","uniform float diffuse;","uniform float specular;","uniform float opacityUniform; // the fragment opacity"];a&&(i=i.concat(["uniform vec3 specularColorUniform;","uniform float specularPowerUniform;"]));let s=["vec3 ambientColor;","  vec3 diffuseColor;","  float opacity;"];a&&(s=s.concat(["  vec3 specularColor;","  float specularPower;"])),s=s.concat(["  opacity = opacityUniform;"]),a&&(s=s.concat(["  specularColor = specularColorUniform;","  specularPower = specularPowerUniform;"])),t.drawingEdges||(i=i.concat(["varying vec4 vertexColorVSOutput;"]),n=Pu.substitute(n,"//VTK::Color::Dec",["attribute vec4 gColor;","varying vec4 vertexColorVSOutput;"]).result,n=Pu.substitute(n,"//VTK::Color::Impl",["vertexColorVSOutput = gColor;"]).result,r=Pu.substitute(r,"//VTK::Color::Dec",["in vec4 vertexColorVSOutput[];","out vec4 vertexColorGSOutput;"]).result,r=Pu.substitute(r,"//VTK::Color::Impl",["vertexColorGSOutput = vertexColorVSOutput[i];"]).result,s=s.concat(["  diffuseColor = vertexColorVSOutput.rgb;","  ambientColor = vertexColorVSOutput.rgb;","  opacity = opacity*vertexColorVSOutput.a;"])),o=Pu.substitute(o,"//VTK::Color::Impl",s).result,o=Pu.substitute(o,"//VTK::Color::Dec",i).result,e.Vertex=n,e.Geometry=r,e.Fragment=o}n.replaceShaderColor(e,r,o)},e.replaceShaderPositionVC=(e,r,o)=>{if(t.hardwareSupport){let n=e.Vertex;t.lastBoundBO.getReferenceByName("lastLightComplexity")>0?(n=Pu.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","vertexVCVSOutput = MCVCMatrix * gVertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result,n=Pu.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result):(n=Pu.substitute(n,"//VTK::Camera::Dec",["attribute mat4 gMatrix;","uniform mat4 MCPCMatrix;"]).result,n=Pu.substitute(n,"//VTK::PositionVC::Impl",["vec4 gVertexMC = gMatrix * vertexMC;","  gl_Position = MCPCMatrix * gVertexMC;"]).result),e.Vertex=n}n.replaceShaderPositionVC(e,r,o)},e.replaceShaderPicking=(e,r,o)=>{if(t.hardwareSupport){let t=e.Fragment,n=e.Vertex;n=Pu.substitute(n,"//VTK::Picking::Dec",["attribute vec3 mapperIndexVS;","varying vec3 mapperIndexVSOutput;"]).result,n=Pu.substitute(n,"//VTK::Picking::Impl","  mapperIndexVSOutput = mapperIndexVS;").result,e.Vertex=n,t=Pu.substitute(t,"//VTK::Picking::Dec",["varying vec3 mapperIndexVSOutput;","uniform vec3 mapperIndex;","uniform int picking;"]).result,t=Pu.substitute(t,"//VTK::Picking::Impl",["  vec4 pickColor = picking == 2 ? vec4(mapperIndexVSOutput,1.0) : vec4(mapperIndex,1.0);","  gl_FragData[0] = picking != 0 ? pickColor : gl_FragData[0];"]).result,e.Fragment=t}else n.replaceShaderPicking(e,r,o)},e.updateGlyphShaderParameters=(n,r,o,a,i,s,l,c)=>{const u=o.getProgram();if(n){const e=t.normalMatrix,n=s,r=9*l,o=t.tmpMat3,a=e[0],i=e[1],c=e[2],d=e[3],p=e[4],f=e[5],g=e[6],m=e[7],h=e[8],v=n[r],T=n[r+1],y=n[r+2],b=n[r+3],x=n[r+4],C=n[r+5],S=n[r+6],A=n[r+7],I=n[r+8];o[0]=v*a+T*d+y*g,o[1]=v*i+T*p+y*m,o[2]=v*c+T*f+y*h,o[3]=b*a+x*d+C*g,o[4]=b*i+x*p+C*m,o[5]=b*c+x*f+C*h,o[6]=S*a+A*d+I*g,o[7]=S*i+A*p+I*m,o[8]=S*c+A*f+I*h,u.setUniformMatrix3x3("normalMatrix",t.tmpMat3)}if(e.multiply4x4WithOffset(t.tmpMat4,t.mcpcMatrix,i,16*l),u.setUniformMatrix("MCPCMatrix",t.tmpMat4),r&&(e.multiply4x4WithOffset(t.tmpMat4,t.mcvcMatrix,i,16*l),u.setUniformMatrix("MCVCMatrix",t.tmpMat4)),a){const e=a.getData();t.tmpColor[0]=e[4*l]/255,t.tmpColor[1]=e[4*l+1]/255,t.tmpColor[2]=e[4*l+2]/255,u.setUniform3fArray("ambientColorUniform",t.tmpColor),u.setUniform3fArray("diffuseColorUniform",t.tmpColor)}c&&u.setUniform3fArray("mapperIndex",c.getPropColorValue())},e.renderPieceDraw=(n,r)=>{const o=r.getProperty().getRepresentation(),a=t.context,i=r.getProperty().getEdgeVisibility()&&o===fp.SURFACE,s=t.openGLCamera.getKeyMatrices(n),l=t.openGLActor.getKeyMatrices();ve(t.normalMatrix,s.normalMatrix,l.normalMatrix),y(t.mcpcMatrix,s.wcpc,l.mcwc),y(t.mcvcMatrix,s.wcvc,l.mcwc);const c=t.renderable.getMatrixArray(),u=t.renderable.getNormalArray(),d=t.renderable.getColorArray(),p=c.length/16;let f=!1;t._openGLRenderer.getSelector()&&t._openGLRenderer.getSelector().getCurrentPass()===mp.COMPOSITE_INDEX_PASS&&(f=!0);for(let s=t.primTypes.Start;s<t.primTypes.End;s++){const l=t.primitives[s].getCABO();if(l.getElementCount()){t.drawingEdges=i&&(s===t.primTypes.TrisEdges||s===t.primTypes.TriStripsEdges),t.lastBoundBO=t.primitives[s],t.primitives[s].updateShaders(n,r,e);const g=t.primitives[s].getProgram(),m=t.primitives[s].getOpenGLMode(o),h=g.isUniformUsed("normalMatrix"),v=g.isUniformUsed("MCVCMatrix");if(t.hardwareSupport)t.extension?t.extension.drawArraysInstancedANGLE(m,0,l.getElementCount(),p):a.drawArraysInstanced(m,0,l.getElementCount(),p);else for(let n=0;n<p;++n)f&&t._openGLRenderer.getSelector().renderCompositeIndex(n),e.updateGlyphShaderParameters(h,v,t.primitives[s],d,c,u,n,f?t._openGLRenderer.getSelector():null),a.drawArrays(m,0,l.getElementCount())}}},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.glyphBOBuildTime.getMTime()>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime()))return e.getProgram().isAttributeUsed("gMatrix")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.matrixBuffer,"gMatrix",0,64,t.context.FLOAT,4,!1,1)||pp("Error setting gMatrix in shader VAO."):e.getVAO().removeAttributeArray("gMatrix"),e.getProgram().isAttributeUsed("gNormal")?e.getVAO().addAttributeMatrixWithDivisor(e.getProgram(),t.normalBuffer,"gNormal",0,36,t.context.FLOAT,3,!1,1)||pp("Error setting gNormal in shader VAO."):e.getVAO().removeAttributeArray("gNormal"),e.getProgram().isAttributeUsed("gColor")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.colorBuffer,"gColor",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pp("Error setting gColor in shader VAO."):e.getVAO().removeAttributeArray("gColor"),e.getProgram().isAttributeUsed("mapperIndexVS")?e.getVAO().addAttributeArrayWithDivisor(e.getProgram(),t.pickBuffer,"mapperIndexVS",0,4,t.context.UNSIGNED_BYTE,4,!0,1,!1)||pp("Error setting mapperIndexVS in shader VAO."):e.getVAO().removeAttributeArray("mapperIndexVS"),n.setMapperShaderParameters(e,r,o),void e.getAttributeUpdateTime().modified();n.setMapperShaderParameters(e,r,o)},e.getNeedToRebuildBufferObjects=(e,r)=>(t.renderable.buildArrays(),t.VBOBuildTime.getMTime()<t.renderable.getBuildTime().getMTime()||n.getNeedToRebuildBufferObjects(e,r)),e.getNeedToRebuildShaders=(e,r,o)=>!!(n.getNeedToRebuildShaders(e,r,o)||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()),e.buildBufferObjects=(e,r)=>{if(t.hardwareSupport){const e=t.renderable.getMatrixArray(),n=t.renderable.getNormalArray(),r=t.renderable.getColorArray();if(t.matrixBuffer||(t.matrixBuffer=mu.newInstance(),t.matrixBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.normalBuffer=mu.newInstance(),t.normalBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.colorBuffer=mu.newInstance(),t.colorBuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.pickBuffer=mu.newInstance(),t.pickBuffer.setOpenGLRenderWindow(t._openGLRenderWindow)),t.renderable.getBuildTime().getMTime()>t.glyphBOBuildTime.getMTime()){t.matrixBuffer.upload(e,gp.ARRAY_BUFFER),t.normalBuffer.upload(n,gp.ARRAY_BUFFER),r?t.colorBuffer.upload(r.getData(),gp.ARRAY_BUFFER):t.colorBuffer.releaseGraphicsResources();const o=e.length/16,a=new Uint8Array(4*o);for(let e=0;e<o;++e){let t=e+1;const n=4*e;a[n]=t%256,t-=a[n],t/=256,a[n+1]=t%256,t-=a[n+1],t/=256,a[n+2]=t%256,a[n+3]=255}t.pickBuffer.upload(a,gp.ARRAY_BUFFER),t.glyphBOBuildTime.modified()}}return n.buildBufferObjects(e,r)}}(e,t)}),"vtkOpenGLGlyph3DMapper");en("vtkGlyph3DMapper",yp);const{vtkErrorMacro:bp}=Ht;class xp{constructor(){this.segmentMapping={},this.segments=[null],this.faces=[]}addSegment(e){const t=e[0],n=e[e.length-1];if(t===n||e.length<2)return;const r=this.segmentMapping[t],o=this.segmentMapping[n];if(void 0!==r&&void 0!==o)if(Math.abs(r)===Math.abs(o)){const a=r<o?o:r,i=this.segments[a];if(r>0)for(let t=1;t<e.length-1;t++)i.push(e[t]);else for(let t=1;t<e.length-1;t++)i.unshift(e[e.length-1-t]);this.faces.push(i),this.segments[a]=null,this.segmentMapping[t]=void 0,this.segmentMapping[n]=void 0}else{const t=Math.abs(r),n=Math.abs(o),a=this.segments[t],i=this.segments[n];this.segments[t]=null,this.segments[n]=null,this.segmentMapping[a[0]]=void 0,this.segmentMapping[i[0]]=void 0,this.segmentMapping[a[a.length-1]]=void 0,this.segmentMapping[i[i.length-1]]=void 0,this.addSegment(e),this.addSegment(a),this.addSegment(i)}else if(void 0!==r){if(r>0){const t=this.segments[r];for(let n=1;n<e.length;n++)t.push(e[n]);this.segmentMapping[n]=r}else{const t=this.segments[-r];this.segmentMapping[n]=r;for(let n=1;n<e.length;n++)t.unshift(e[n])}this.segmentMapping[t]=void 0}else if(void 0!==o){if(o>0){const n=this.segments[o];for(let t=1;t<e.length;t++)n.push(e[e.length-1-t]);this.segmentMapping[t]=o}else{const n=this.segments[-o];this.segmentMapping[t]=o;for(let t=1;t<e.length;t++)n.unshift(e[e.length-t-1])}this.segmentMapping[n]=void 0}else{const r=this.segments.length;this.segments.push(e),this.segmentMapping[t]=-r,this.segmentMapping[n]=r}}}const Cp={};function Sp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Cp,n),Ht.obj(e,t),Ht.algo(e,t,1,1),function(e,t){t.classHierarchy.push("vtkClosedPolyLineToSurfaceFilter"),e.requestData=(e,t)=>{const n=e[0];if(!n)return void bp("Invalid or missing input");const r=Uc.newInstance();r.shallowCopy(n);const o=new xp,a=n.getLines().getData();let i=0;for(;i<a.length;){const e=a[i++],t=[];for(let n=0;n<e;n++)t.push(a[i+n]);o.addSegment(t),i+=e}const{faces:s}=o;let l=s.length;for(let e=0;e<s.length;e++)l+=s[e].length;const c=new Uint16Array(l);i=0;for(let e=0;e<s.length;e++){const t=s[e];c[i++]=t.length;for(let e=0;e<t.length;e++)c[i++]=t[e]}r.setPolys(Wl.newInstance({values:c,name:"faces"})),t[0]=r}}(e,t)}var Ap={newInstance:Ht.newInstance(Sp,"vtkClosedPolyLineToSurfaceFilter"),extend:Sp};const{vtkErrorMacro:Ip}=jt;function wp(e,t){t.classHierarchy.push("vtkCutter");const n={...e};e.getMTime=()=>{let e=n.getMTime();return t.cutFunction?(e=Math.max(e,t.cutFunction.getMTime()),e):e},e.requestData=(e,n)=>{const r=e[0];if(!r)return void Ip("Invalid or missing input");if(!t.cutFunction)return void Ip("Missing cut function");const o=Uc.newInstance();(function(e,n){const r=e.getPoints(),o=r.getData(),a=e.getPointData(),i=r.getNumberOfPoints(),s=[],l=[],c=[],u={},d=a.getNumberOfArrays();for(let e=0;e<d;e++)u[a.getArrayName(e)]=[];(!t.cutScalars||t.cutScalars.length<i)&&(t.cutScalars=new Float32Array(i));let p=0,f=0;for(;p<o.length;)t.cutScalars[f++]=t.cutFunction.evaluateFunction(o[p++],o[p++],o[p++]);const g=[],m=new Array(3),h=new Array(3),v=[];for(const n=function(e){const t=e.getPolys().getData(),n=e.getStrips().getData(),r={cellSize:0,cell:[],done:!1,polyIdx:0,stripIdx:0,remainingStripLength:0,next(){if(r.polyIdx<t.length){r.cellSize=t[r.polyIdx];const e=r.polyIdx+1,n=e+r.cellSize;r.polyIdx=n;let o=0;for(let a=e;a<n;++a)r.cell[o++]=t[a]}else if(r.stripIdx<n.length){r.cellSize=3,0===r.remainingStripLength&&(r.remainingStripLength=n[r.stripIdx]-2,r.stripIdx+=3);const e=r.stripIdx-2,t=r.stripIdx+1;r.stripIdx++,r.remainingStripLength--;let o=0;for(let a=e;a<t;++a)r.cell[o++]=n[a]}else{if(r.done)throw new Error("Iterator is done");r.done=!0}}};return r.next(),r}(e);!n.done;n.next()){if(n.cellSize<=2)continue;for(let e=0;e<n.cellSize;)v[e]=t.cutScalars[n.cell[e++]];const e=v[0]>0;let r=!0;for(let t=1;t<n.cell.length;t++)if(v[t]>0!==e){r=!1;break}if(r)continue;const i=[];for(let e=0;e<n.cellSize;e++){const r=e+1===n.cellSize?0:e+1,s=v[e]>0;if(v[r]>0===s)continue;let l=e,c=r,u=v[c]-v[l];u<=0&&(l=r,c=e,u*=-1);let p=0;0!==u&&(p=(t.cutValue-v[l])/u);const f=n.cell[l],g=n.cell[c];m[0]=o[3*f],m[1]=o[3*f+1],m[2]=o[3*f+2],h[0]=o[3*g],h[1]=o[3*g+1],h[2]=o[3*g+2];const T=[m[0]+p*(h[0]-m[0]),m[1]+p*(h[1]-m[1]),m[2]+p*(h[2]-m[2])],y={};for(let e=0;e<d;e++){const t=a.getArrayByIndex(e),n=a.getArrayName(e),r=t.getData(),o=t.getNumberOfComponents(),i=new Array(o);for(let e=0;e<o;e++){const t=r[o*f+e],n=r[o*g+e];i.push(t+p*(n-t))}y[n]=i}i.push({pointEdge1:f,pointEdge2:g,intersectedPoint:T,intersectedArrays:y,newPointID:-1})}for(let e=0;e<i.length;e++){const t=i[e];let n=!1;for(let r=0;r<g.length;r++){const o=g[r],a=t.pointEdge1===o.pointEdge1&&t.pointEdge2===o.pointEdge2,s=t.intersectedPoint[0]===o.intersectedPoint[0]&&t.intersectedPoint[1]===o.intersectedPoint[1]&&t.intersectedPoint[2]===o.intersectedPoint[2];if(a||s){n=!0,i[e].newPointID=g[r].newPointID;break}}n||(s.push(t.intersectedPoint[0]),s.push(t.intersectedPoint[1]),s.push(t.intersectedPoint[2]),Object.keys(t.intersectedArrays).forEach((e=>{u[e].push(...t.intersectedArrays[e])})),i[e].newPointID=s.length/3-1,g.push(i[e]))}const p=i.length;2===p?l.push(p,i[0].newPointID,i[1].newPointID):p>2&&(c.push(p),i.forEach((e=>{c.push(e.newPointID)})))}n.getPoints().setData(st(r.getDataType(),s),3);const T=n.getPointData();for(let e=0;e<d;e++){const t=a.getArrayName(e),n=Ts.newInstance({name:t,values:u[t],numberOfComponents:a.getArrayByIndex(e).getNumberOfComponents()});T.addArray(n)}0!==l.length&&n.getLines().setData(Uint16Array.from(l)),0!==c.length&&n.getPolys().setData(Uint16Array.from(c))})(r,o),n[0]=o}}const Op={cutFunction:null,cutScalars:null,cutValue:0};function Pp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Op,n),vt(e,t),Pt(e,t,1,1),St(e,t,["cutFunction","cutValue"]),wp(e,t)}var Rp={newInstance:Et(Pp,"vtkCutter"),extend:Pp};const Mp=e=>e,Ep=1e-6;class Vp{constructor(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];this.matrix=g(new Float64Array(16)),this.tmp=new Float64Array(3),this.angleConv=e?l:Mp}rotateFromDirections(e,t){const n=new Float64Array(3),r=new Float64Array(3),o=new Float64Array(16);vn(n,e[0],e[1],e[2]),vn(r,t[0],t[1],t[2]),Sn(n,n),Sn(r,r);const a=An(n,r);return a>=1||(In(this.tmp,n,r),mn(this.tmp)<Ep&&(In(this.tmp,[1,0,0],e),mn(this.tmp)<Ep&&In(this.tmp,[0,1,0],e)),P(o,Math.acos(a),this.tmp),y(this.matrix,this.matrix,o)),this}rotate(e,t){return vn(this.tmp,...t),Sn(this.tmp,this.tmp),C(this.matrix,this.matrix,this.angleConv(e),this.tmp),this}rotateX(e){return S(this.matrix,this.matrix,this.angleConv(e)),this}rotateY(e){return A(this.matrix,this.matrix,this.angleConv(e)),this}rotateZ(e){return I(this.matrix,this.matrix,this.angleConv(e)),this}translate(e,t,n){return vn(this.tmp,e,t,n),b(this.matrix,this.matrix,this.tmp),this}scale(e,t,n){return vn(this.tmp,e,t,n),x(this.matrix,this.matrix,this.tmp),this}multiply(e){return y(this.matrix,this.matrix,e),this}multiply3x3(e){return y(this.matrix,this.matrix,[e[0],e[1],e[2],0,e[3],e[4],e[5],0,e[6],e[7],e[8],0,0,0,0,1]),this}invert(){return h(this.matrix,this.matrix),this}identity(){return g(this.matrix),this}apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(Yo(so,this.matrix))return this;const r=-1===n?e.length:t+3*n;for(let n=t;n<r;n+=3)vn(this.tmp,e[n],e[n+1],e[n+2]),wn(this.tmp,this.tmp,this.matrix),e[n]=this.tmp[0],e[n+1]=this.tmp[1],e[n+2]=this.tmp[2];return this}getMatrix(){return this.matrix}setMatrix(e){return e&&16===e.length&&d(this.matrix,e),this}}var Dp=function(){return new Vp(!0)},Lp=function(){return new Vp(!1)};const Bp=[2,0,1,2,2,3,2,4,5,2,6,7,2,0,2,2,1,3,2,4,6,2,5,7,2,0,4,2,1,5,2,2,6,2,3,7],Np=[4,0,1,3,2,4,4,6,7,5,4,8,10,11,9,4,12,13,15,14,4,16,18,19,17,4,20,21,23,22],Fp={xLength:1,yLength:1,zLength:1,pointType:"Float64Array",generate3DTextureCoordinates:!1,generateFaces:!0,generateLines:!1};function _p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fp,n),Ht.obj(e,t),Ht.setGet(e,t,["xLength","yLength","zLength","generate3DTextureCoordinates","generateFaces","generateLines"]),Ht.setGetArray(e,t,["center","rotations"],3),Ht.setGetArray(e,t,["matrix"],16),t._polys=Wl.newInstance({values:Uint16Array.from(Np)}),t._lineCells=Wl.newInstance({values:Uint16Array.from(Bp)}),Ht.moveToProtected(e,t,["polys","lineCells"]),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkCubeSource"),e.setBounds=function(){let t=[];if(Array.isArray(arguments.length<=0?void 0:arguments[0]))t=arguments.length<=0?void 0:arguments[0];else for(let e=0;e<arguments.length;e++)t.push(e<0||arguments.length<=e?void 0:arguments[e]);6===t.length&&(e.setXLength(t[1]-t[0]),e.setYLength(t[3]-t[2]),e.setZLength(t[5]-t[4]),e.setCenter([(t[0]+t[1])/2,(t[2]+t[3])/2,(t[4]+t[5])/2]))},e.requestData=function(e,n){if(t.deleted)return;const r=Uc.newInstance();n[0]=r;const o=Ht.newTypedArray(t.pointType,72);r.getPoints().setData(o,3);const a=Ht.newTypedArray(t.pointType,72),i=Ts.newInstance({name:"Normals",values:a,numberOfComponents:3});r.getPointData().setNormals(i);let s=2;!0===t.generate3DTextureCoordinates&&(s=3);const l=Ht.newTypedArray(t.pointType,24*s),c=Ts.newInstance({name:"TextureCoordinates",values:l,numberOfComponents:s});r.getPointData().setTCoords(c);const u=[0,0,0],d=[0,0,0],p=[0,0];let f=0;u[0]=-t.xLength/2,d[0]=-1,d[1]=0,d[2]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[0]=(u[2]+.5)*(1-2*e),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*e-1,l[f*s+1]=2*n-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[1]+=t.yLength}u[0]+=t.xLength,d[0]+=2}u[1]=-t.yLength/2,d[1]=-1,d[0]=0,d[2]=0;for(let e=0;e<2;e++){u[0]=-t.xLength/2;for(let n=0;n<2;n++){p[0]=(u[0]+.5)*(2*e-1),u[2]=-t.zLength/2;for(let r=0;r<2;r++)p[1]=-1*(u[2]+.5),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*n-1,l[f*s+1]=2*e-1,l[f*s+2]=2*r-1),f++,u[2]+=t.zLength;u[0]+=t.xLength}u[1]+=t.yLength,d[1]+=2}u[2]=-t.zLength/2,d[2]=-1,d[0]=0,d[1]=0;for(let e=0;e<2;e++){u[1]=-t.yLength/2;for(let n=0;n<2;n++){p[1]=u[1]+.5,u[0]=-t.xLength/2;for(let r=0;r<2;r++)p[0]=(u[0]+.5)*(2*e-1),o[3*f]=u[0],o[3*f+1]=u[1],o[3*f+2]=u[2],a[3*f]=d[0],a[3*f+1]=d[1],a[3*f+2]=d[2],2===s?(l[f*s]=p[0],l[f*s+1]=p[1]):(l[f*s]=2*r-1,l[f*s+1]=2*n-1,l[f*s+2]=2*e-1),f++,u[0]+=t.xLength;u[1]+=t.yLength}u[2]+=t.zLength,d[2]+=2}if(t.rotations&&Dp().rotateX(t.rotations[0]).rotateY(t.rotations[1]).rotateZ(t.rotations[2]).apply(o).apply(a),t.center&&Lp().translate(...t.center).apply(o),t.matrix){Lp().setMatrix(t.matrix).apply(o);const e=[t.matrix[0],t.matrix[1],t.matrix[2],0,t.matrix[4],t.matrix[5],t.matrix[6],0,t.matrix[8],t.matrix[9],t.matrix[10],0,0,0,0,1];Lp().setMatrix(e).apply(a)}t.generateFaces?r.getPolys().deepCopy(t._polys):r.getPolys().initialize(),t.generateLines?(r.getLines().deepCopy(t._lineCells),r.getPointData().setNormals(null)):r.getLines().initialize(),r.modified()}}(e,t)}var Gp={newInstance:Ht.newInstance(_p,"vtkCubeSource"),extend:_p};const{vtkErrorMacro:kp}=Ht,Up={};function zp(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Up,n),Ht.obj(e,t),Ht.algo(e,t,1,1),t._cubeSource=Gp.newInstance(),Ht.moveToProtected(e,t,["cubeSource","tmpOut"]),function(e,t){t.classHierarchy.push("vtkImageDataOutlineFilter");const n={...e};e.requestData=(e,n)=>{const r=e[0];if(!r||!r.isA("vtkImageData"))return void kp("Invalid or missing input");const o=r.getSpatialExtent();o?(t._cubeSource.setBounds(o),t._cubeSource.setMatrix(r.getIndexToWorld()),n[0]=t._cubeSource.getOutputData()):kp("Unable to fetch spatial extents of input image.")},e.getMTime=()=>Math.max(n.getMTime(),t._cubeSource.getMTime()),e.setGenerateFaces=t._cubeSource.setGenerateFaces,e.setGenerateLines=t._cubeSource.setGenerateLines,e.getGenerateFaces=t._cubeSource.getGenerateFaces,e.getGenerateLines=t._cubeSource.getGenerateLines}(e,t)}var Wp={newInstance:Ht.newInstance(zp,"vtkImageDataOutlineFilter"),extend:zp};const{vtkWarningMacro:Hp}=Ht;let jp;const Kp={preMultiplyFlag:!1,matrix:[...so]};function $p(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kp,n),Ht.obj(e,t),Ht.setGet(e,t,["preMultiplyFlag"]),Ht.setGetArray(e,t,["matrix"],16),function(e,t){t.classHierarchy.push("vtkAbstractTransform","vtkHomogeneousTransform","vtkTransform"),e.transformPoint=(e,n)=>(wn(n,e,t.matrix),n),e.transformPoints=(e,n)=>{const r=new Float64Array(3),o=new Float64Array(3);for(let a=0;a<e.length;a+=3)r[0]=e[a],r[1]=e[a+1],r[2]=e[a+2],wn(o,r,t.matrix),n[a]=o[0],n[a+1]=o[1],n[a+2]=o[2];return n},e.preMultiply=()=>{e.setPreMultiplyFlag(!0)},e.postMultiply=()=>{e.setPreMultiplyFlag(!1)},e.transformMatrix=(e,n)=>(t.preMultiplyFlag?y(n,t.matrix,e):y(n,e,t.matrix),n),e.transformMatrices=(e,n)=>{const r=new Float64Array(16),o=new Float64Array(16),a=t.preMultiplyFlag?()=>y(o,t.matrix,r):()=>y(o,r,t.matrix);for(let t=0;t<e.length;t+=16){for(let n=0;n<16;++n)r[n]=e[t+n];a();for(let e=0;e<16;++e)n[t+e]=o[e]}return n},e.getInverse=()=>jp({matrix:La.invertMatrix(Array.from(t.matrix),[],4),preMultiplyFlag:t.preMultiplyFlag}),e.translate=(n,r,o)=>{if(0===n&&0===r&&0===o)return;const a=c();w(a,[n,r,o]),t.preMultiplyFlag?y(t.matrix,t.matrix,a):y(t.matrix,a,t.matrix),e.modified()},e.rotateWXYZ=(n,r,o,a)=>{if(0===r&&0===o&&0===a)return void Hp("No rotation applied, axis is zero vector.");if(0===n)return;const i=La.radiansFromDegrees(n),s=Na();Fa(s,[r,o,a],i);const l=new Float64Array(16);G(l,s),t.preMultiplyFlag?y(t.matrix,t.matrix,l):y(t.matrix,l,t.matrix),e.modified()},e.rotateX=t=>{e.rotateWXYZ(t,1,0,0)},e.rotateY=t=>{e.rotateWXYZ(t,0,1,0)},e.rotateZ=t=>{e.rotateWXYZ(t,0,0,1)},e.scale=(n,r,o)=>{if(1===n&&1===r&&1===o)return;const a=c();O(a,[n,r,o]),t.preMultiplyFlag?y(t.matrix,t.matrix,a):y(t.matrix,a,t.matrix),e.modified()},e.transformNormal=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];const o=se(ie(),t.matrix),a=ie();ge(a,o);const i=ie();return fe(i,a),e.transformVector(n,r,i),La.normalize(r),r},e.transformNormals=(n,r)=>{const o=n.getData(),a=r.getData(),i=[0,0,0],s=se(ie(),t.matrix),l=ie();ge(l,s);const c=ie();fe(c,l);for(let t=0;t<o.length;t+=3)i[0]=o[t],i[1]=o[t+1],i[2]=o[t+2],e.transformVector(i,i,c),La.normalize(i),a[t]=i[0],a[t+1]=i[1],a[t+2]=i[2]},e.transformVector=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return On(n,e,(arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)||se(ie(),t.matrix)),n},e.transformVectors=(t,n)=>{const r=t.getData(),o=n.getData(),a=[0,0,0];for(let t=0;t<r.length;t+=3)a[0]=r[t],a[1]=r[t+1],a[2]=r[t+2],e.transformVector(a,a),La.normalize(a),o[t]=a[0],o[t+1]=a[1],o[t+2]=a[2]},e.transformPointsNormalsVectors=function(t,n,r,o,a,i){let s=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,l=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;const c=t.getNumberOfPoints(),u=s?.length??0,d=new Float64Array(3),p=new Float64Array(3),f=new Float64Array(3),g=new Float64Array(3);let m=!1,h=!1,v=!1;const T=[];for(let y=0;y<c;y++){if(t.getPoint(y,d),p.set(d),e.transformPoint(d,d),n.setPoint(y,...d),La.areEquals(p,d)||(m=!0),a){const t=a.getData(),n=i.getData();d[0]=t[3*y],d[1]=t[3*y+1],d[2]=t[3*y+2],f.set(d),e.transformVector(d,d),n[3*y]=d[0],n[3*y+1]=d[1],n[3*y+2]=d[2],La.areEquals(f,d)||(h=!0)}if(r){const t=r.getData(),n=o.getData();d[0]=t[3*y],d[1]=t[3*y+1],d[2]=t[3*y+2],g.set(d),e.transformNormal(d,d),n[3*y]=d[0],n[3*y+1]=d[1],n[3*y+2]=d[2],La.areEquals(g,d)||(v=!0)}if(s)for(let t=0;t<u;t++){const n=s[t].getData(),r=l[t].getData();d[0]=n[3*y],d[1]=n[3*y+1],d[2]=n[3*y+2],f.set(d),e.transformVector(d,d),r[3*y]=d[0],r[3*y+1]=d[1],r[3*y+2]=d[2],La.arrayEqual(f,d)||T.includes(t)||T.push(t)}}m&&n.modified(),h&&i.modified(),v&&o.modified(),T.forEach((e=>l[e].modified()))}}(e,t)}jp=Ht.newInstance($p,"vtkTransform");var qp={newInstance:jp,extend:$p};function Xp(e,t,n){return e.length>0?`${e.map((e=>e?.getMTime()??"x")).join("/")}-${t}-${n}`:"0"}function Yp(e,t){return`${t.getMTime()}`}const Zp={NEAREST:0,LINEAR:1};var Qp={InterpolationType:Zp};const{vtkErrorMacro:Jp}=jt;function ef(e,t,n){return t.identity(n),e.reduce(((e,n,r)=>0===r?n?t.copy(e,n):t.identity(e):n?t.multiply(e,e,n):e),n)}const tf={VBOBuildTime:{},VBOBuildString:null,haveSeenDepthRequest:!1,lastHaveSeenDepthRequest:!1,lastIndependentComponents:!1,lastNumberOfComponents:0,lastMultiTexturePerVolumeEnabled:!1,lastSlabThickness:0,lastSlabTrapezoidIntegration:0,lastSlabType:-1,scalarTextures:[],_scalarTexturesCore:[],colorTexture:null,_colorTextureCore:null,pwfTexture:null,_pwfTextureCore:null,_externalOpenGLTexture:!1,resliceGeom:null,resliceGeomUpdateString:null,tris:null};const nf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,tf,n),Xt.extend(e,t,n),od(e,t,n),ad(e,t,n),t.tris=Bu.newInstance(),t.scalarTextures=[],t.colorTexture=null,t.pwfTexture=null,t.VBOBuildTime={},vt(t.VBOBuildTime),t.tmpMat4=g(new Float64Array(16)),t.outlineFilter=Wp.newInstance(),t.outlineFilter.setGenerateFaces(!0),t.outlineFilter.setGenerateLines(!1),t.cubePolyData=Uc.newInstance(),t.cutter=Rp.newInstance(),t.lineToSurfaceFilter=Ap.newInstance(),t.transform=qp.newInstance(),yt(e,t,["scalarTextures"]),function(e,t){t.classHierarchy.push("vtkOpenGLImageResliceMapper");const n=new Map;function o(t,r,o){r!==o&&(function(t,r){if(!r)return;const o=(n.get(r)??0)-1;o<=0?(t.unregisterGraphicsResourceUser(r,e),n.delete(r)):n.set(r,o)}(t,r),function(t,r){if(!r)return;const o=n.get(r)??0,a=o+1;n.set(r,a),o<=0&&t.registerGraphicsResourceUser(r,e)}(t,o))}function a(t){[...n.keys()].forEach((n=>t.unregisterGraphicsResourceUser(n,e)))}e.buildPass=n=>{if(n){t.currentRenderPass=null,t._openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const n=t._openGLRenderer.getRenderable();t._openGLCamera=t._openGLRenderer.getViewNodeFor(n.getActiveCamera());const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&a(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==dl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t._openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update();const o=t.renderable.getNumberOfInputPorts();t.currentValidInputs=[];for(let e=0;e<o;++e){const n=t.renderable.getInputData(e);n&&!n.isDeleted()&&t.currentValidInputs.push({imageData:n,inputIndex:e})}const a=t.currentValidInputs.length;if(a<=0)return void Jp("No input!");const i=t.currentValidInputs[0].imageData.getPointData().getScalars();t.multiTexturePerVolumeEnabled=a>1,t.numberOfComponents=t.multiTexturePerVolumeEnabled?a:i.getNumberOfComponents(),e.updateResliceGeometry(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r),e.invokeEvent({type:"EndEvent"})},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r);const o=r.getProperties();t.currentValidInputs.forEach((e=>{let{inputIndex:n}=e;const r=o[n].getInterpolationType(),a=t.scalarTextures[n];r===Zp.NEAREST?(a.setMinificationFilter(Fu.NEAREST),a.setMagnificationFilter(Fu.NEAREST)):(a.setMinificationFilter(Fu.LINEAR),a.setMagnificationFilter(Fu.LINEAR))}));const a=t.currentValidInputs[0];o[a.inputIndex].getInterpolationType()===Zp.NEAREST?(t.colorTexture.setMinificationFilter(Fu.NEAREST),t.colorTexture.setMagnificationFilter(Fu.NEAREST),t.pwfTexture.setMinificationFilter(Fu.NEAREST),t.pwfTexture.setMagnificationFilter(Fu.NEAREST)):(t.colorTexture.setMinificationFilter(Fu.LINEAR),t.colorTexture.setMagnificationFilter(Fu.LINEAR),t.pwfTexture.setMinificationFilter(Fu.LINEAR),t.pwfTexture.setMagnificationFilter(Fu.LINEAR)),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context,a=[...t.scalarTextures,t.colorTexture,t.pwfTexture];a.forEach((e=>e.activate())),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),a.forEach((e=>e.deactivate()))},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty(t.currentValidInputs[0].inputIndex)?.getMTime()||t.currentValidInputs.some((e=>{let{imageData:n}=e;return t.VBOBuildTime.getMTime()<n.getMTime()}))||t.VBOBuildTime.getMTime()<t.resliceGeom.getMTime()||t.scalarTextures.length!==t.currentValidInputs.length||!t.scalarTextures.every((e=>!!e?.getHandle()))||!t.colorTexture?.getHandle()||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(e,n)=>{const r=n.getProperties();t.currentValidInputs.forEach(((e,n)=>{let{imageData:a}=e;const i=a.getPointData().getScalars(),s=t._openGLRenderWindow.getGraphicsResourceForObject(i),l=Yp(0,i),c=!s?.oglObject?.getHandle()||s?.hash!==l,u=r[n],d=u.getUpdatedExtents(),p=!!d.length;if(c&&!p){const e=td.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);const r=a.getDimensions();e.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),e.resetFormatAndType(),e.create3DFilterableFromDataArray({width:r[0],height:r[1],depth:r[2],dataArray:i}),t._openGLRenderWindow.setGraphicsResourceForObject(i,e,l),t.scalarTextures[n]=e}else t.scalarTextures[n]=s.oglObject;if(p){u.setUpdatedExtents([]);const e=a.getDimensions();t.scalarTextures[n].create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:i,updatedExtents:d})}o(t._openGLRenderWindow,t._scalarTexturesCore[n],i),t._scalarTexturesCore[n]=i}));const a=t.currentValidInputs[0],i=r[a.inputIndex],s=i.getIndependentComponents(),l=s?t.numberOfComponents:1,c=s?2*l:1,u=[];for(let e=0;e<l;++e)u.push(i.getRGBTransferFunction(e));const d=Xp(u,s,l),p=i.getRGBTransferFunction(),f=t._openGLRenderWindow.getGraphicsResourceForObject(p);if(f?.oglObject?.getHandle()&&f?.hash===d)t.colorTexture=f.oglObject;else{let e=t.renderable.getColorTextureWidth();e<=0&&(e=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const n=new Uint8ClampedArray(e*c*3),r=td.newInstance();if(r.setOpenGLRenderWindow(t._openGLRenderWindow),p){const t=new Float32Array(3*e);for(let r=0;r<l;r++){const o=i.getRGBTransferFunction(r),a=o.getRange();if(o.getTable(a[0],a[1],e,t,1),s)for(let o=0;o<3*e;o++)n[r*e*6+o]=255*t[o],n[r*e*6+o+3*e]=255*t[o];else for(let o=0;o<3*e;o++)n[r*e*3+o]=255*t[o]}r.resetFormatAndType(),r.create2DFromRaw({width:e,height:c,numComps:3,dataType:is.UNSIGNED_CHAR,data:n})}else{for(let t=0;t<3*e;++t){const r=255*t/(3*(e-1));for(let o=0;o<c;++o)n[o*e*3+t+0]=r,n[o*e*3+t+1]=r,n[o*e*3+t+2]=r}r.resetFormatAndType(),r.create2DFromRaw({width:e,height:1,numComps:3,dataType:is.UNSIGNED_CHAR,data:n})}p&&t._openGLRenderWindow.setGraphicsResourceForObject(p,r,d),t.colorTexture=r}o(t._openGLRenderWindow,t._colorTextureCore,p),t._colorTextureCore=p;const g=[];for(let e=0;e<l;++e)g.push(i.getPiecewiseFunction(e));const m=Xp(g,s,l),h=i.getPiecewiseFunction(),v=t._openGLRenderWindow.getGraphicsResourceForObject(h);if(v?.oglObject?.getHandle()&&v?.hash===m)t.pwfTexture=v.oglObject;else{let e=t.renderable.getOpacityTextureWidth();e<=0&&(e=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const n=e*c,r=new Uint8ClampedArray(n),o=td.newInstance();if(o.setOpenGLRenderWindow(t._openGLRenderWindow),h){const t=new Float32Array(n),r=new Float32Array(e);for(let n=0;n<l;++n){const o=i.getPiecewiseFunction(n);if(null===o)t.fill(1);else{const a=o.getRange();if(o.getTable(a[0],a[1],e,r,1),s)for(let o=0;o<e;o++)t[n*e*2+o]=r[o],t[n*e*2+o+e]=r[o];else for(let n=0;n<e;n++)t[n]=r[n]}}o.resetFormatAndType(),o.create2DFromRaw({width:e,height:c,numComps:1,dataType:is.FLOAT,data:t})}else r.fill(255),o.resetFormatAndType(),o.create2DFromRaw({width:e,height:c,numComps:1,dataType:is.UNSIGNED_CHAR,data:r});h&&t._openGLRenderWindow.setGraphicsResourceForObject(h,o,m),t.pwfTexture=o}o(t._openGLRenderWindow,t._pwfTextureCore,h),t._pwfTextureCore=h;const T=`${t.resliceGeom.getMTime()}A${t.renderable.getSlabThickness()}`;if(!t.tris.getCABO().getElementCount()||t.VBOBuildString!==T){const e=Ts.newInstance({numberOfComponents:3,values:t.resliceGeom.getPoints().getData()});e.setName("points");const n=Ts.newInstance({numberOfComponents:1,values:t.resliceGeom.getPolys().getData()}),r={points:e,cellOffset:0};if(t.renderable.getSlabThickness()>0){const e=t.resliceGeom.getPointData().getNormals();e?r.normals=e:Jp("Slab mode requested without normals")}t.tris.getCABO().createVBO(n,"polys",qi.SURFACE,r)}t.VBOBuildString=T,t.VBOBuildTime.modified()},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.currentValidInputs[0].imageData;if(n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())){t.scalarTextures.forEach(((e,t)=>{a.setUniformi(`volumeTexture[${t}]`,e.getTextureUnit())})),a.isAttributeUsed("vertexWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexWC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Jp("Error setting vertexWC in shader VAO.")),a.isAttributeUsed("normalWC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"normalWC",n.getCABO().getNormalOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Jp("Error setting normalWC in shader VAO.")),a.isUniformUsed("slabThickness")&&a.setUniformf("slabThickness",t.renderable.getSlabThickness()),a.isUniformUsed("spacing")&&a.setUniform3fv("spacing",i.getSpacing()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabType")&&a.setUniformi("slabType",t.renderable.getSlabType()),a.isUniformUsed("slabTrapezoid")&&a.setUniformi("slabTrapezoid",t.renderable.getSlabTrapezoidIntegration());const e=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null;if(a.isUniformUsed("WCTCMatrix")){const n=i.getDimensions();d(t.tmpMat4,i.getIndexToWorld()),b(t.tmpMat4,t.tmpMat4,[-.5,-.5,-.5]),x(t.tmpMat4,t.tmpMat4,n),h(t.tmpMat4,t.tmpMat4),e&&y(t.tmpMat4,t.tmpMat4,e),a.setUniformMatrix("WCTCMatrix",t.tmpMat4)}a.isUniformUsed("vboScaling")&&a.setUniform3fv("vboScaling",n.getCABO().getCoordScale()??[1,1,1]),n.getAttributeUpdateTime().modified()}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,o)=>{const a=t._openGLCamera.getKeyMatrices(n),i=t._openGLImageSlice.getKeyMatrices(),s=e.getCABO().getCoordShiftAndScaleEnabled()?e.getCABO().getInverseShiftAndScaleMatrix():null,l=e.getProgram();l.isUniformUsed("MCPCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCPCMatrix",ef([a.wcpc,i.mcwc,s],r,t.tmpMat4))),l.isUniformUsed("MCVCMatrix")&&(g(t.tmpMat4),l.setUniformMatrix("MCVCMatrix",ef([a.wcvc,i.mcwc,s],r,t.tmpMat4)))},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(t.currentValidInputs[0].inputIndex),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.numberOfComponents,l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));for(let e=0;e<s;e++){const n=t.multiTexturePerVolumeEnabled,r=n?e:0,i=n?0:e,s=t.scalarTextures[r].getVolumeInfo(),c=s.scale[i],u=s.offset[i],d=l?e:0;let p=a.getColorWindow(),f=a.getColorLevel();const g=a.getRGBTransferFunction(d);if(g&&a.getUseLookupTableScalarRange()){const e=g.getRange();p=e[1]-e[0],f=.5*(e[1]+e[0])}const m=c/p,h=(u-f)/p+.5;o.setUniformf(`cshift${e}`,h),o.setUniformf(`cscale${e}`,m);let v=1,T=0;const y=a.getPiecewiseFunction(d);if(y){const e=y.getRange(),t=e[1]-e[0];v=c/t,T=(u-.5*(e[0]+e[1]))/t+.5}o.setUniformf(`pwfshift${e}`,T),o.setUniformf(`pwfscale${e}`,v)}const c=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",u),o.setUniform4fv("backgroundColor",t.renderable.getBackgroundColor())},e.getNeedToRebuildShaders=(e,n,r)=>{const o=r.getProperty(t.currentValidInputs[0].inputIndex).getIndependentComponents(),a=t.renderable.getSlabThickness(),i=t.renderable.getSlabType(),s=t.renderable.getSlabTrapezoidIntegration();let l=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(l=!0),!(!l&&t.lastHaveSeenDepthRequest===t.haveSeenDepthRequest&&t.lastNumberOfComponents===t.numberOfComponents&&t.lastMultiTexturePerVolumeEnabled===t.multiTexturePerVolumeEnabled&&0!==e.getProgram()?.getHandle()&&t.lastIndependentComponents===o&&t.lastSlabThickness===a&&t.lastSlabType===i&&t.lastSlabTrapezoidIntegration===s||(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastNumberOfComponents=t.numberOfComponents,t.lastMultiTexturePerVolumeEnabled=t.multiTexturePerVolumeEnabled,t.lastIndependentComponents=o,t.lastSlabThickness=a,t.lastSlabType=i,t.lastSlabTrapezoidIntegration=s,0))},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\n// all variables that represent positions or directions have a suffix\n// indicating the coordinate system they are in. The possible values are\n// MC - Model coordinates\n// WC - World coordinates\n// VC - View coordinates\n// DC - Display coordinates\n// TC - Texture coordinates\n\n// frag position in VC\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvoid main()\n{\n  //VTK::PositionVC::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Picking::Impl\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkImageResliceMapperFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the gpu image mapper fragment shader\n\n// VC position of this fragment\n//VTK::PositionVC::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\n// picking support\n//VTK::Picking::Dec\n\n// handle coincident offsets\n//VTK::Coincident::Dec\n\n//VTK::ZBuffer::Dec\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  // VC position of this fragment. This should not branch/return/discard.\n  //VTK::PositionVC::Impl\n\n  // Place any calls that require uniform flow (e.g. dFdx) here.\n  //VTK::UniformFlow::Impl\n\n  // Set gl_FragDepth here (gl_FragCoord.z by default)\n  //VTK::Depth::Impl\n\n  // Early depth peeling abort:\n  //VTK::DepthPeeling::PreColor\n\n  //VTK::TCoord::Impl\n\n  if (gl_FragData[0].a <= 0.0)\n    {\n    discard;\n    }\n\n  //VTK::DepthPeeling::Impl\n\n  //VTK::Picking::Impl\n\n  // handle coincident offsets\n  //VTK::Coincident::Impl\n\n  //VTK::ZBuffer::Impl\n\n  //VTK::RenderPassFragmentShader::Impl\n}\n",e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{if(e.replaceShaderTCoord(n,r,o),e.replaceShaderPositionVC(n,r,o),t.haveSeenDepthRequest){let e=n.Fragment;e=Pu.substitute(e,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,e=Pu.substitute(e,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result,n.Fragment=e}e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderTCoord=(e,n,r)=>{let o=e.Vertex;const a=e.Geometry;let i=e.Fragment;const s=t.renderable.getSlabThickness();o=Pu.substitute(o,"//VTK::TCoord::Dec",["uniform mat4 WCTCMatrix;","out vec3 fragTexCoord;"]).result,o=Pu.substitute(o,"//VTK::TCoord::Impl",["fragTexCoord = (WCTCMatrix * vertexWC).xyz;"]).result;const l=t.numberOfComponents,c=r.getProperty(t.currentValidInputs[0].inputIndex).getIndependentComponents();let u=["in vec3 fragTexCoord;",`uniform highp sampler3D volumeTexture[${t.scalarTextures.length}];`,"uniform mat4 WCTCMatrix;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;"];if(u.push("vec4 rawSampleTexture(vec3 pos) {"),t.multiTexturePerVolumeEnabled){u.push("vec4 rawSample;");for(let e=0;e<t.scalarTextures.length;++e)u.push(`rawSample[${e}] = texture(volumeTexture[${e}], pos)[0];`);u.push("return rawSample;","}")}else u.push("return texture(volumeTexture[0], pos);","}");if(c){for(let e=1;e<l;e++)u=u.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(l){case 1:u=u.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:u=u.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:u=u.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:Jp("Unsupported number of independent coordinates.")}}s>0&&(u=u.concat(["uniform vec3 spacing;","uniform float slabThickness;","uniform int slabType;","uniform int slabTrapezoid;","uniform vec3 vboScaling;"]),u=u.concat(["vec4 compositeValue(vec4 currVal, vec4 valToComp, int trapezoid)","{","  vec4 retVal = vec4(1.0);","  if (slabType == 0) // min","  {","    retVal = min(currVal, valToComp);","  }","  else if (slabType == 1) // max","  {","    retVal = max(currVal, valToComp);","  }","  else if (slabType == 3) // sum","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  else // mean","  {","    retVal = currVal + (trapezoid > 0 ? 0.5 * valToComp : valToComp); ","  }","  return retVal;","}"])),i=Pu.substitute(i,"//VTK::TCoord::Dec",u).result;let d=["if (any(greaterThan(fragTexCoord, vec3(1.0))) || any(lessThan(fragTexCoord, vec3(0.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}","vec4 tvalue = rawSampleTexture(fragTexCoord);"];if(s>0&&(d=d.concat(["// Get the first and last samples","int numSlices = 1;","float scaling = min(min(spacing.x, spacing.y), spacing.z) * 0.5;","vec3 normalxspacing = scaling * normalWCVSOutput;","float distTraveled = length(normalxspacing);","int trapezoid = 0;","while (distTraveled < slabThickness * 0.5)","{","  distTraveled += length(normalxspacing);","  float fnumSlices = float(numSlices);","  if (distTraveled > slabThickness * 0.5)","  {","    // Before stepping outside the slab, sample at the boundaries","    normalxspacing = normalWCVSOutput * slabThickness * 0.5 / fnumSlices;","    trapezoid = slabTrapezoid;","  }","  vec3 fragTCoordNeg = (WCTCMatrix * vec4(vertexWCVSOutput.xyz - fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = rawSampleTexture(fragTCoordNeg);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","  vec3 fragTCoordPos = (WCTCMatrix * vec4(vertexWCVSOutput.xyz + fnumSlices * normalxspacing * vboScaling, 1.0)).xyz;","  if (!any(greaterThan(fragTCoordNeg, vec3(1.0))) && !any(lessThan(fragTCoordNeg, vec3(0.0))))","  {","    vec4 newVal = rawSampleTexture(fragTCoordPos);","    tvalue = compositeValue(tvalue, newVal, trapezoid);","    numSlices += 1;","  }","}","// Finally, if slab type is *mean*, divide the sum by the numSlices","if (slabType == 2)","{","  tvalue = tvalue / float(numSlices);","}"])),c){const e=["r","g","b","a"];for(let t=0;t<l;++t)d=d.concat([`vec3 tcolor${t} = texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(l){case 1:d=d.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:d=d.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:d=d.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:Jp("Unsupported number of independent coordinates.")}}else switch(l){case 1:d=d.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:d=d.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:d=d.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=Pu.substitute(i,"//VTK::TCoord::Impl",d).result,e.Vertex=o,e.Fragment=i,e.Geometry=a},e.replaceShaderPositionVC=(n,r,o)=>{let a=n.Vertex;const i=n.Geometry;let s=n.Fragment;const l=t.renderable.getSlabThickness();let c=["attribute vec4 vertexWC;"];c=c.concat([`//${e.getMTime()}${t.resliceGeomUpdateString}`]),l>0&&(c=c.concat(["attribute vec3 normalWC;","varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),a=Pu.substitute(a,"//VTK::PositionVC::Dec",c).result;let u=["gl_Position = MCPCMatrix * vertexWC;"];l>0&&(u=u.concat(["normalWCVSOutput = normalWC;","vertexWCVSOutput = vertexWC;"])),a=Pu.substitute(a,"//VTK::PositionVC::Impl",u).result,a=Pu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;","uniform mat4 MCVCMatrix;"]).result;let d=[];l>0&&(d=d.concat(["varying vec3 normalWCVSOutput;","varying vec4 vertexWCVSOutput;"])),s=Pu.substitute(s,"//VTK::PositionVC::Dec",d).result,n.Vertex=a,n.Geometry=i,n.Fragment=s},e.updateResliceGeometry=()=>{let e="";const n=t.currentValidInputs[0].imageData,r=n?.getBounds();let o=!0,a=2;const i=t.renderable.getSlicePolyData(),s=t.renderable.getSlicePlane();if(i)e=e.concat(`PolyData${i.getMTime()}`);else if(s){e=e.concat(`Plane${s.getMTime()}`);const t=ie();n&&(e=e.concat(`Image${n.getMTime()}`),de(t,...n.getDirection()),ge(t,t));const r=[...s.getNormal()];On(r,r,t),[o,a]=function(e){La.normalize(e);const t=[0,0,0];for(let r=0;r<3;++r){(n=t)[0]=0,n[1]=0,n[2]=0,t[r]=1;const o=La.dot(e,t);if(o<-.999999||o>.999999)return[!0,r]}var n;return[!1,2]}(r)}else{const o=ti.newInstance();o.setNormal(0,0,1);let a=[0,1,0,1,0,1];n&&(a=r),o.setOrigin(a[0],a[2],.5*(a[5]+a[4])),t.renderable.setSlicePlane(o),e=e.concat(`Plane${s?.getMTime()}`),n&&(e=e.concat(`Image${n.getMTime()}`))}if(!t.resliceGeom||t.resliceGeomUpdateString!==e){if(i)t.resliceGeom||(t.resliceGeom=Uc.newInstance()),t.resliceGeom.getPoints().setData(i.getPoints().getData(),3),t.resliceGeom.getPolys().setData(i.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(i.getPointData().getNormals());else if(s)if(o){const e=new Float32Array(12),r=n.worldToIndex(s.getOrigin(),[0,0,0]),o=[(a+1)%3,(a+2)%3].sort(),i=n.getSpatialExtent();let l=0;for(let t=0;t<2;++t)for(let n=0;n<2;++n)e[l+a]=r[a],e[l+o[0]]=i[2*o[0]+n],e[l+o[1]]=i[2*o[1]+t],l+=3;t.transform.setMatrix(n.getIndexToWorld()),t.transform.transformPoints(e,e);const c=new Uint16Array(8);c[0]=3,c[1]=0,c[2]=1,c[3]=3,c[4]=3,c[5]=0,c[6]=3,c[7]=2;const u=s.getNormal();La.normalize(u);const d=new Float32Array(12);for(let e=0;e<4;++e)d[3*e]=u[0],d[3*e+1]=u[1],d[3*e+2]=u[2];t.resliceGeom||(t.resliceGeom=Uc.newInstance()),t.resliceGeom.getPoints().setData(e,3),t.resliceGeom.getPolys().setData(c,1);const p=Ts.newInstance({numberOfComponents:3,values:d,name:"Normals"});t.resliceGeom.getPointData().setNormals(p)}else{t.outlineFilter.setInputData(n),t.cutter.setInputConnection(t.outlineFilter.getOutputPort()),t.cutter.setCutFunction(s),t.lineToSurfaceFilter.setInputConnection(t.cutter.getOutputPort()),t.lineToSurfaceFilter.update(),t.resliceGeom||(t.resliceGeom=Uc.newInstance());const e=t.lineToSurfaceFilter.getOutputData();t.resliceGeom.getPoints().setData(e.getPoints().getData(),3),t.resliceGeom.getPolys().setData(e.getPolys().getData(),1),t.resliceGeom.getPointData().setNormals(e.getPointData().getNormals());const r=s.getNormal(),o=t.resliceGeom.getNumberOfPoints();La.normalize(r);const a=new Float32Array(3*o);for(let e=0;e<o;++e)a[3*e]=r[0],a[3*e+1]=r[1],a[3*e+2]=r[2];const i=Ts.newInstance({numberOfComponents:3,values:a,name:"Normals"});t.resliceGeom.getPointData().setNormals(i)}else Jp("Something went wrong.","A default slice plane should have been created in the beginning of","updateResliceGeometry.");t.resliceGeomUpdateString=e,t.resliceGeom?.modified()}},e.setScalarTextures=e=>{t.scalarTextures=[...e],t._externalOpenGLTexture=!0},e.delete=Vt((()=>{t._openGLRenderWindow&&a(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageResliceMapper");en("vtkImageResliceMapper",nf);var rf={SlicingMode:{NONE:-1,I:0,J:1,K:2,X:3,Y:4,Z:5}};const{vtkErrorMacro:of}=jt,{SlicingMode:af}=rf;function sf(e){const t=e.split("\n"),n=[];for(let e=0;e<t.length;++e){const r=t[e].trim();r.length>0&&n.push(r)}return n}const lf={VBOBuildTime:0,VBOBuildString:null,openGLTexture:null,tris:null,imagemat:null,imagematinv:null,colorTexture:null,pwfTexture:null,labelOutlineThicknessTexture:null,labelOutlineOpacityTexture:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0};const cf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,lf,n),Xt.extend(e,t,n),od(e,t,n),ad(e,t,n),t.tris=Bu.newInstance(),t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.projectionToWorld=g(new Float64Array(16)),t.idxToView=g(new Float64Array(16)),t.idxNormalMatrix=pe(new Float64Array(9)),t.modelToView=g(new Float64Array(16)),t.projectionToView=g(new Float64Array(16)),St(e,t,[]),t.VBOBuildTime={},vt(t.VBOBuildTime),function(e,t){function n(n){t.openGLTexture.releaseGraphicsResources(n),[t._colorTransferFunc,t._pwFunc,t._labelOutlineThicknessArray,t._labelOutlineOpacity].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow);const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),t.renderable.isA("vtkImageMapper")&&t.renderable.getSliceAtFocalPoint()&&t.renderable.setSliceFromCamera(o.getActiveCamera())}},e.translucentPass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.zBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.opaqueZBufferPass=t=>e.zBufferPass(t),e.opaquePass=t=>{t&&e.render()},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()==dl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.getShaderTemplate=(e,t,n)=>{e.Vertex=nd,e.Fragment=rd,e.Geometry=""},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;a=Pu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result,a=Pu.substitute(a,"//VTK::TCoord::Impl","tcoordVCVSOutput = tcoordMC;").result,a=Pu.substitute(a,"//VTK::TCoord::Dec","attribute vec2 tcoordMC; varying vec2 tcoordVCVSOutput;").result;const s=t.openGLTexture.getComponents(),l=o.getProperty().getIndependentComponents();let c=["varying vec2 tcoordVCVSOutput;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;","uniform sampler2D texture1;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;"];if(o.getProperty().getUseLabelOutline()&&(c=c.concat(["uniform sampler2D labelOutlineTexture1;","uniform sampler2D labelOutlineOpacityTexture1;"])),l){for(let e=1;e<s;e++)c=c.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(s){case 1:c=c.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:c=c.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:c=c.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:of("Unsupported number of independent coordinates.")}}if(i=Pu.substitute(i,"//VTK::TCoord::Dec",c).result,!0===o.getProperty().getUseLabelOutline()&&(i=Pu.substitute(i,"//VTK::LabelOutline::Dec",["uniform float vpWidth;","uniform float vpHeight;","uniform float vpOffsetX;","uniform float vpOffsetY;","uniform mat4 PCWCMatrix;","uniform mat4 vWCtoIDX;","uniform ivec3 imageDimensions;","uniform int sliceAxis;"]).result,i=Pu.substitute(i,"//VTK::ImageLabelOutlineOn","#define vtkImageLabelOutlineOn").result,i=Pu.substitute(i,"//VTK::LabelOutlineHelperFunction",["#ifdef vtkImageLabelOutlineOn","vec3 fragCoordToIndexSpace(vec4 fragCoord) {","  vec4 pcPos = vec4(","    (fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,","    (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,","    (fragCoord.z - 0.5) * 2.0,","    1.0);","","  vec4 worldCoord = PCWCMatrix * pcPos;","  vec4 vertex = (worldCoord/worldCoord.w);","","  vec3 index = (vWCtoIDX * vertex).xyz;","","  // half voxel fix for labelmapOutline","  return (index + vec3(0.5)) / vec3(imageDimensions);","}","vec2 getSliceCoords(vec3 coord, int axis) {","  if (axis == 0) return coord.yz;","  if (axis == 1) return coord.xz;","  if (axis == 2) return coord.xy;","}","#endif"]).result),l){const e=["r","g","b","a"];let t=["vec4 tvalue = texture2D(texture1, tcoordVCVSOutput);"];for(let n=0;n<s;n++)t=t.concat([`vec3 tcolor${n} = mix${n} * texture2D(colorTexture1, vec2(tvalue.${e[n]} * cscale${n} + cshift${n}, height${n})).rgb;`,`float compWeight${n} = mix${n} * texture2D(pwfTexture1, vec2(tvalue.${e[n]} * pwfscale${n} + pwfshift${n}, height${n})).r;`]);switch(s){case 1:t=t.concat(["gl_FragData[0] = vec4(tcolor0.rgb, opacity);"]);break;case 2:t=t.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:t=t.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:of("Unsupported number of independent coordinates.")}i=Pu.substitute(i,"//VTK::TCoord::Impl",t).result}else switch(s){case 1:i=Pu.substitute(i,"//VTK::TCoord::Impl",[...sf("\n                #ifdef vtkImageLabelOutlineOn\n                  vec3 centerPosIS = fragCoordToIndexSpace(gl_FragCoord);\n                  float centerValue = texture2D(texture1, getSliceCoords(centerPosIS, sliceAxis)).r;\n                  bool pixelOnBorder = false;\n                  vec3 tColor = texture2D(colorTexture1, vec2(centerValue * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(centerValue * pwfscale0 + pwfshift0, 0.5)).r;\n                  float opacityToUse = scalarOpacity * opacity;\n                  int segmentIndex = int(centerValue * 255.0);\n                  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n                  float textureValue = texture2D(labelOutlineTexture1, vec2(textureCoordinate, 0.5)).r;\n                  float outlineOpacity = texture2D(labelOutlineOpacityTexture1, vec2(textureCoordinate, 0.5)).r;\n                  int actualThickness = int(textureValue * 255.0);\n\n                  if (segmentIndex == 0){\n                    gl_FragData[0] = vec4(0.0, 0.0, 0.0, 0.0);\n                    return;\n                  }\n\n                  for (int i = -actualThickness; i <= actualThickness; i++) {\n                    for (int j = -actualThickness; j <= actualThickness; j++) {\n                      if (i == 0 || j == 0) {\n                        continue;\n                      }\n                      vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(i),\n                        gl_FragCoord.y + float(j),\n                        gl_FragCoord.z, gl_FragCoord.w);\n                      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n                      float value = texture2D(texture1, getSliceCoords(neighborPosIS, sliceAxis)).r;\n                      if (value != centerValue) {\n                        pixelOnBorder = true;\n                        break;\n                      }\n                    }\n                    if (pixelOnBorder == true) {\n                      break;\n                    }\n                  }\n                  if (pixelOnBorder == true) {\n                    gl_FragData[0] = vec4(tColor, outlineOpacity);\n                  }\n                  else {\n                    gl_FragData[0] = vec4(tColor, opacityToUse);\n                  }\n                #else\n                  float intensity = texture2D(texture1, tcoordVCVSOutput).r;\n                  vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;\n                  float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;\n                  gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);\n                #endif\n                ")]).result;break;case 2:i=Pu.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = texture2D(texture1, tcoordVCVSOutput);","float intensity = tcolor.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tcolor.g + pwfshift0);"]).result;break;case 3:i=Pu.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]).result;break;default:i=Pu.substitute(i,"//VTK::TCoord::Impl",["vec4 tcolor = cscale0*texture2D(texture1, tcoordVCVSOutput.st) + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"]).result}t.haveSeenDepthRequest&&(i=Pu.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=Pu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(tt("OpenGL has a limit of 6 clipping planes"),e=6),o=Pu.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=Pu.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=Pu.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=Pu.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.openGLTexture.getComponents(),a=r.getProperty().getIndependentComponents();let i=!1;return(!t.currentRenderPass&&t.lastRenderPassShaderReplacement||t.currentRenderPass&&t.currentRenderPass.getShaderReplacement()!==t.lastRenderPassShaderReplacement)&&(i=!0),!!(i||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||0===e.getProgram()?.getHandle()||e.getShaderSourceTime().getMTime()<t.renderable.getMTime()||e.getShaderSourceTime().getMTime()<t.currentInput.getMTime()||e.getShaderSourceTime().getMTime()<r.getProperty().getMTime()||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.updateShaders=(n,r,o)=>{if(t.lastBoundBO=n,e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{n.getCABO().getElementCount()&&(t.VBOBuildTime>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(n.getProgram().isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"vertexMC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||of("Error setting vertexMC in shader VAO.")),n.getProgram().isAttributeUsed("tcoordMC")&&n.getCABO().getTCoordOffset()&&(n.getVAO().addAttributeArray(n.getProgram(),n.getCABO(),"tcoordMC",n.getCABO().getTCoordOffset(),n.getCABO().getStride(),t.context.FLOAT,n.getCABO().getTCoordComponents(),t.context.FALSE)||of("Error setting tcoordMC in shader VAO.")),n.getAttributeUpdateTime().modified());const a=t.openGLTexture.getTextureUnit();n.getProgram().setUniformi("texture1",a);const i=t.openGLTexture.getComponents(),s=o.getProperty().getIndependentComponents();if(s)for(let e=0;e<i;e++)n.getProgram().setUniformf(`mix${e}`,o.getProperty().getComponentWeight(e));const l=t.openGLTexture.getShiftAndScale();for(let e=0;e<i;e++){let t=o.getProperty().getColorWindow(),r=o.getProperty().getColorLevel();const a=s?e:0,i=o.getProperty().getRGBTransferFunction(a);if(i&&o.getProperty().getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],r=.5*(e[1]+e[0])}const c=l.scale/t,u=(l.shift-r)/t+.5;n.getProgram().setUniformf(`cshift${e}`,u),n.getProgram().setUniformf(`cscale${e}`,c)}for(let e=0;e<i;e++){let t=1,r=0;const a=s?e:0,i=o.getProperty().getPiecewiseFunction(a);if(i){const e=i.getRange(),n=e[1]-e[0],o=.5*(e[0]+e[1]);t=l.scale/n,r=(l.shift-o)/n+.5}n.getProgram().setUniformf(`pwfshift${e}`,r),n.getProgram().setUniformf(`pwfscale${e}`,t)}if(t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),n.getProgram().isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);n.getProgram().setUniformf("coffset",t.offset),n.getProgram().isUniformUsed("cfactor")&&n.getProgram().setUniformf("cfactor",t.factor)}const c=t.colorTexture.getTextureUnit();n.getProgram().setUniformi("colorTexture1",c);const u=t.pwfTexture.getTextureUnit();if(n.getProgram().setUniformi("pwfTexture1",u),o.getProperty().getUseLabelOutline()){const e=t.labelOutlineThicknessTexture.getTextureUnit();n.getProgram().setUniformi("labelOutlineTexture1",e);const r=t.labelOutlineOpacityTexture.getTextureUnit();n.getProgram().setUniformi("labelOutlineOpacityTexture1",r)}if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(tt("OpenGL has a limit of 6 clipping planes"),e=6);const r=n.getCABO().getCoordShiftAndScaleEnabled()?n.getCABO().getInverseShiftAndScaleMatrix():null,a=r?d(t.imagematinv,o.getMatrix()):o.getMatrix();r&&(m(a,a),y(a,a,r),m(a,a)),m(t.imagemat,t.currentInput.getIndexToWorld()),y(t.imagematinv,a,t.imagemat);const i=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)i.push(e[t])}n.getProgram().setUniformi("numClipPlanes",e),n.getProgram().setUniform4fv("clipPlanes",i)}},e.setCameraShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=t.openGLImageSlice.getKeyMatrices(),s=t.currentInput,l=s.getIndexToWorld();y(t.imagemat,i.mcwc,l);const c=t.openGLCamera.getKeyMatrices(r);if(y(t.imagemat,c.wcpc,t.imagemat),n.getCABO().getCoordShiftAndScaleEnabled()){const e=n.getCABO().getInverseShiftAndScaleMatrix();y(t.imagemat,t.imagemat,e)}if(a.setUniformMatrix("MCPCMatrix",t.imagemat),!0===o.getProperty().getUseLabelOutline()){const n=s.getWorldToIndex(),o=s.getDimensions();let i=t.renderable.getClosestIJKAxis().ijkMode;i===af.NONE&&(i=af.K),a.setUniform3i("imageDimensions",o[0],o[1],o[2]),a.setUniformi("sliceAxis",i),a.setUniformMatrix("vWCtoIDX",n);const l=t.openGLCamera.getKeyMatrices(r);h(t.projectionToWorld,l.wcpc),t.openGLCamera.getKeyMatrices(r),a.setUniformMatrix("PCWCMatrix",t.projectionToWorld);const c=e.getRenderTargetSize();a.setUniformf("vpWidth",c[0]),a.setUniformf("vpHeight",c[1]);const u=e.getRenderTargetOffset();a.setUniformf("vpOffsetX",u[0]/c[0]),a.setUniformf("vpOffsetY",u[1]/c[1])}},e.setPropertyShaderParameters=(e,t,n)=>{const r=e.getProgram(),o=n.getProperty().getOpacity();r.setUniformf("opacity",o)},e.renderPieceStart=(n,r)=>{e.updateBufferObjects(n,r),t.lastBoundBO=null},e.renderPieceDraw=(n,r)=>{const o=t.context;t.openGLTexture.activate(),t.colorTexture.activate(),r.getProperty().getUseLabelOutline()&&(t.labelOutlineThicknessTexture.activate(),t.labelOutlineOpacityTexture.activate()),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.openGLTexture.deactivate(),t.colorTexture.deactivate(),r.getProperty().getUseLabelOutline()&&(t.labelOutlineThicknessTexture.deactivate(),t.labelOutlineOpacityTexture.deactivate()),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),t.currentInput=t.renderable.getCurrentImage(),e.invokeEvent({type:"EndEvent"}),t.currentInput?(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r)):of("No input!")},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty().getMTime()||t.VBOBuildTime.getMTime()<t.currentInput.getMTime()||!t.openGLTexture?.getHandle()||!t.colorTexture?.getHandle()||r.getProperty().getUseLabelOutline()&&(!t.labelOutlineThicknessTexture?.getHandle()||!t.labelOutlineOpacityTexture?.getHandle())||!t.pwfTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{const o=t.currentInput;if(!o)return;const a=o.getPointData()&&o.getPointData().getScalars();if(!a)return;const i=a.getDataType(),s=a.getNumberOfComponents(),l=r.getProperty(),c=l.getInterpolationType(),u=l.getIndependentComponents(),d=u?s:1,p=u?2*d:1,f=[];for(let e=0;e<d;++e)f.push(l.getRGBTransferFunction(e));const g=Xp(f,u,d),m=l.getRGBTransferFunction(),h=t._openGLRenderWindow.getGraphicsResourceForObject(m);if(h?.oglObject?.getHandle()&&h?.hash===g)t.colorTexture=h.oglObject;else{t.colorTexture=td.newInstance({resizable:!0}),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(n*p*3);if(c===Zp.NEAREST?(t.colorTexture.setMinificationFilter(Fu.NEAREST),t.colorTexture.setMagnificationFilter(Fu.NEAREST)):(t.colorTexture.setMinificationFilter(Fu.LINEAR),t.colorTexture.setMagnificationFilter(Fu.LINEAR)),m){const e=new Float32Array(3*n);for(let t=0;t<d;t++){const o=l.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),u)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:p,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.create2DFromRaw({width:n,height:1,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}m&&(t._openGLRenderWindow.setGraphicsResourceForObject(m,t.colorTexture,g),m!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(m,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=m)}const v=[];for(let e=0;e<d;++e)v.push(l.getPiecewiseFunction(e));const T=Xp(v,u,d),y=l.getPiecewiseFunction(),b=t._openGLRenderWindow.getGraphicsResourceForObject(y);if(b?.oglObject?.getHandle()&&b?.hash===T)t.pwfTexture=b.oglObject;else{let n=t.renderable.getOpacityTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=n*p,o=new Uint8ClampedArray(r);if(t.pwfTexture=td.newInstance({resizable:!0}),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),c===Zp.NEAREST?(t.pwfTexture.setMinificationFilter(Fu.NEAREST),t.pwfTexture.setMagnificationFilter(Fu.NEAREST)):(t.pwfTexture.setMinificationFilter(Fu.LINEAR),t.pwfTexture.setMagnificationFilter(Fu.LINEAR)),y){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<d;++t){const r=l.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),u)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:p,numComps:1,dataType:is.FLOAT,data:e})}else o.fill(255),t.pwfTexture.create2DFromRaw({width:n,height:1,numComps:1,dataType:is.UNSIGNED_CHAR,data:o});y&&(t._openGLRenderWindow.setGraphicsResourceForObject(y,t.pwfTexture,T),y!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(y,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=y)}r.getProperty().getUseLabelOutline()&&(e.updatelabelOutlineThicknessTexture(r),e.updateLabelOutlineOpacityTexture(r));const{ijkMode:x}=t.renderable.getClosestIJKAxis();let C=t.renderable.getSlice();x!==t.renderable.getSlicingMode()&&(C=t.renderable.getSliceAtPosition(C));const S=t.renderable.isA("vtkImageArrayMapper")?t.renderable.getSubSlice():Math.round(C),A=o.getExtent();let I;x===af.I&&(I=S-A[0]),x===af.J&&(I=S-A[2]),x!==af.K&&x!==af.NONE||(I=S-A[4]);const w=`${C}A${o.getMTime()}A${a.getMTime()}B${e.getMTime()}C${t.renderable.getSlicingMode()}D${r.getProperty().getInterpolationType()}`;if(t.VBOBuildString!==w){const e=o.getDimensions();t.openGLTexture||(t.openGLTexture=td.newInstance({resizable:!0})),t.openGLTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),c===Zp.NEAREST?(new Set([1,3,4]).has(s)&&i===is.UNSIGNED_CHAR&&!u?(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Fu.NEAREST)):t.openGLTexture.setMinificationFilter(Fu.NEAREST),t.openGLTexture.setMagnificationFilter(Fu.NEAREST)):(4!==s||i!==is.UNSIGNED_CHAR||u?t.openGLTexture.setMinificationFilter(Fu.LINEAR):(t.openGLTexture.setGenerateMipmap(!0),t.openGLTexture.setMinificationFilter(Fu.LINEAR_MIPMAP_LINEAR)),t.openGLTexture.setMagnificationFilter(Fu.LINEAR)),t.openGLTexture.setWrapS(Nu.CLAMP_TO_EDGE),t.openGLTexture.setWrapT(Nu.CLAMP_TO_EDGE);const n=e[0]*e[1]*s,r=new Float32Array(12),l=new Float32Array(8);for(let e=0;e<4;e++)l[2*e]=e%2?1:0,l[2*e+1]=e>1?1:0;const d=[af.X,af.Y,af.Z].includes(t.renderable.getSlicingMode())?C:S,p=o.getSpatialExtent(),f=a.getData();let g=null;if(x===af.I){g=new f.constructor(e[2]*e[1]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[1];r++){let o=(I+r*e[0]+n*e[0]*e[1])*s;t=(n*e[1]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[0]=e[1],e[1]=e[2],r[0]=d,r[1]=p[2],r[2]=p[4],r[3]=d,r[4]=p[3],r[5]=p[4],r[6]=d,r[7]=p[2],r[8]=p[5],r[9]=d,r[10]=p[3],r[11]=p[5]}else if(x===af.J){g=new f.constructor(e[2]*e[0]*s);let t=0;for(let n=0;n<e[2];n++)for(let r=0;r<e[0];r++){let o=(r+I*e[0]+n*e[0]*e[1])*s;t=(n*e[0]+r)*s;const a=o+s;for(;o<a;)g[t++]=f[o++]}e[1]=e[2],r[0]=p[0],r[1]=d,r[2]=p[4],r[3]=p[1],r[4]=d,r[5]=p[4],r[6]=p[0],r[7]=d,r[8]=p[5],r[9]=p[1],r[10]=d,r[11]=p[5]}else x===af.K||x===af.NONE?(g=f.subarray(I*n,(I+1)*n),r[0]=p[0],r[1]=p[2],r[2]=d,r[3]=p[1],r[4]=p[2],r[5]=d,r[6]=p[0],r[7]=p[3],r[8]=d,r[9]=p[1],r[10]=p[3],r[11]=d):of("Reformat slicing not yet supported.");const m=a.getRanges();t.openGLTexture.resetFormatAndType(),t.openGLTexture.create2DFilterableFromRaw({width:e[0],height:e[1],numComps:s,dataType:a.getDataType(),data:g,preferSizeOverAccuracy:!!t.renderable.getPreferSizeOverAccuracy?.(),ranges:m}),t.openGLTexture.activate(),t.openGLTexture.sendParameters(),t.openGLTexture.deactivate();const h=Ts.newInstance({numberOfComponents:3,values:r});h.setName("points");const v=Ts.newInstance({numberOfComponents:2,values:l});v.setName("tcoords");const T=new Uint16Array(8);T[0]=3,T[1]=0,T[2]=1,T[3]=3,T[4]=3,T[5]=0,T[6]=3,T[7]=2;const y=Ts.newInstance({numberOfComponents:1,values:T});t.tris.getCABO().createVBO(y,"polys",qi.SURFACE,{points:h,tcoords:v,cellOffset:0}),t.VBOBuildTime.modified(),t.VBOBuildString=w}},e.updateLabelOutlineOpacityTexture=n=>{let r=n.getProperty().getLabelOutlineOpacity();"number"==typeof r&&(r=t._cachedLabelOutlineOpacityObj?.[0]===r?t._cachedLabelOutlineOpacityObj:[r],t._cachedLabelOutlineOpacityObj=r);const o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineOpacityTexture=o.oglObject;else{let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const o=1,i=new Float32Array(n*o);for(let e=0;e<n;++e)i[e]=r[e]??r[0];t.labelOutlineOpacityTexture=td.newInstance({resizable:!1}),t.labelOutlineOpacityTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineOpacityTexture.resetFormatAndType(),t.labelOutlineOpacityTexture.setMinificationFilter(Fu.NEAREST),t.labelOutlineOpacityTexture.setMagnificationFilter(Fu.NEAREST),t.labelOutlineOpacityTexture.create2DFromRaw({width:n,height:o,numComps:1,dataType:is.FLOAT,data:i}),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineOpacityTexture,a),r!==t._labelOutlineOpacity&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineOpacity,e)),t._labelOutlineOpacity=r)}},e.updatelabelOutlineThicknessTexture=n=>{const r=n.getProperty().getLabelOutlineThicknessByReference(),o=t._openGLRenderWindow.getGraphicsResourceForObject(r),a=`${r.join("-")}`;if(o?.oglObject?.getHandle()&&o?.hash===a)t.labelOutlineThicknessTexture=o.oglObject;else{let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const o=1,i=new Uint8Array(n*o);for(let e=0;e<n;++e){const t=void 0!==r[e]?r[e]:r[0];i[e]=t}t.labelOutlineThicknessTexture=td.newInstance({resizable:!1}),t.labelOutlineThicknessTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.labelOutlineThicknessTexture.resetFormatAndType(),t.labelOutlineThicknessTexture.setMinificationFilter(Fu.NEAREST),t.labelOutlineThicknessTexture.setMagnificationFilter(Fu.NEAREST),t.labelOutlineThicknessTexture.create2DFromRaw({width:n,height:o,numComps:1,dataType:is.UNSIGNED_CHAR,data:i}),r&&(t._openGLRenderWindow.setGraphicsResourceForObject(r,t.labelOutlineThicknessTexture,a),r!==t._labelOutlineThicknessArray&&(t._openGLRenderWindow.registerGraphicsResourceUser(r,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._labelOutlineThicknessArray,e)),t._labelOutlineThicknessArray=r)}},e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.delete=Vt((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageMapper");en("vtkAbstractImageMapper",cf);const uf=0,df=1,pf=2,{vtkErrorMacro:ff}=Ht,gf={currentRenderPass:null,volumeTexture:null,colorTexture:null,pwfTexture:null,tris:null,lastHaveSeenDepthRequest:!1,haveSeenDepthRequest:!1,lastTextureComponents:0,lastIndependentComponents:0,imagemat:null,imagematinv:null};const mf=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,gf,n),Xt.extend(e,t,n),od(e,t,n),Ht.algo(e,t,2,0),t.tris=Bu.newInstance(),t.volumeTexture=null,t.colorTexture=null,t.pwfTexture=null,t.imagemat=g(new Float64Array(16)),t.imagematinv=g(new Float64Array(16)),t.VBOBuildTime={},Ht.obj(t.VBOBuildTime,{mtime:0}),function(e,t){function n(n){[t._scalars,t._colorTransferFunc,t._pwFunc].forEach((t=>n.unregisterGraphicsResourceUser(t,e)))}t.classHierarchy.push("vtkOpenGLImageCPRMapper"),e.buildPass=r=>{if(r){t.currentRenderPass=null,t.openGLImageSlice=e.getFirstAncestorOfType("vtkOpenGLImageSlice"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const r=t._openGLRenderWindow;t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow"),r&&!r.isDeleted()&&r!==t._openGLRenderWindow&&n(r),t.context=t._openGLRenderWindow.getContext(),t.openGLCamera=t._openGLRenderer.getViewNodeFor(t._openGLRenderer.getRenderable().getActiveCamera()),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow)}},e.opaquePass=(n,r)=>{n&&(t.currentRenderPass=r,e.render())},e.opaqueZBufferPass=n=>{n&&(t.haveSeenDepthRequest=!0,t.renderDepth=!0,e.render(),t.renderDepth=!1)},e.getCoincidentParameters=(e,n)=>t.renderable.getResolveCoincidentTopology()===dl.PolygonOffset?t.renderable.getCoincidentTopologyPolygonOffsetParameters():null,e.render=()=>{const n=t.openGLImageSlice.getRenderable(),r=t._openGLRenderer.getRenderable();e.renderPiece(r,n)},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update(),e.invokeEvent({type:"EndEvent"}),t.renderable.preRenderCheck()&&(t.currentImageDataInput=t.renderable.getInputData(0),t.currentCenterlineInput=t.renderable.getOrientedCenterline(),e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.renderPieceStart=(t,n)=>{e.updateBufferObjects(t,n)},e.renderPieceDraw=(n,r)=>{const o=t.context;t.volumeTexture.activate(),t.colorTexture.activate(),t.pwfTexture.activate(),t.tris.getCABO().getElementCount()&&(e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release()),t.volumeTexture.deactivate(),t.colorTexture.deactivate(),t.pwfTexture.deactivate()},e.renderPieceFinish=(e,t)=>{},e.updateBufferObjects=(n,r)=>{e.getNeedToRebuildBufferObjects(n,r)&&e.buildBufferObjects(n,r),r.getProperty().getInterpolationType()===Zp.NEAREST?(t.volumeTexture.setMinificationFilter(Fu.NEAREST),t.volumeTexture.setMagnificationFilter(Fu.NEAREST),t.colorTexture.setMinificationFilter(Fu.NEAREST),t.colorTexture.setMagnificationFilter(Fu.NEAREST),t.pwfTexture.setMinificationFilter(Fu.NEAREST),t.pwfTexture.setMagnificationFilter(Fu.NEAREST)):(t.volumeTexture.setMinificationFilter(Fu.LINEAR),t.volumeTexture.setMagnificationFilter(Fu.LINEAR),t.colorTexture.setMinificationFilter(Fu.LINEAR),t.colorTexture.setMagnificationFilter(Fu.LINEAR),t.pwfTexture.setMinificationFilter(Fu.LINEAR),t.pwfTexture.setMagnificationFilter(Fu.LINEAR))},e.getNeedToRebuildBufferObjects=(n,r)=>{const o=t.VBOBuildTime.getMTime();return o<e.getMTime()||o<t.renderable.getMTime()||o<r.getMTime()||o<t.currentImageDataInput.getMTime()||o<t.currentCenterlineInput.getMTime()||!t.volumeTexture?.getHandle()},e.buildBufferObjects=(n,r)=>{const o=t.currentImageDataInput,a=t.currentCenterlineInput,i=r.getProperty(),s=o?.getPointData()?.getScalars();if(!s)return;const l=t._openGLRenderWindow.getGraphicsResourceForObject(s),c=Yp(0,s),u=!l?.oglObject?.getHandle()||l?.hash!==c,d=i.getUpdatedExtents(),p=!!d.length;if(u){t.volumeTexture=td.newInstance(),t.volumeTexture.setOpenGLRenderWindow(t._openGLRenderWindow);const n=o.getDimensions();t.volumeTexture.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),t.volumeTexture.resetFormatAndType(),t.volumeTexture.create3DFilterableFromDataArray({width:n[0],height:n[1],depth:n[2],dataArray:s,preferSizeOverAccuracy:t.renderable.getPreferSizeOverAccuracy()}),t._openGLRenderWindow.setGraphicsResourceForObject(s,t.volumeTexture,c),s!==t._scalars&&(t._openGLRenderWindow.registerGraphicsResourceUser(s,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._scalars,e)),t._scalars=s}else t.volumeTexture=l.oglObject;if(p){i.setUpdatedExtents([]);const e=o.getDimensions();t.volumeTexture.create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:s,updatedExtents:d})}const f=s.getNumberOfComponents(),g=r.getProperty(),m=g.getIndependentComponents(),h=m?f:1,v=m?2*h:1,T=[];for(let e=0;e<h;++e)T.push(g.getRGBTransferFunction(e));const y=Xp(T,m,h),b=g.getRGBTransferFunction(),x=t._openGLRenderWindow.getGraphicsResourceForObject(b);if(x?.oglObject?.getHandle()&&x?.hash===y)t.colorTexture=x.oglObject;else{let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(n*v*3);if(t.colorTexture=td.newInstance(),t.colorTexture.setOpenGLRenderWindow(t._openGLRenderWindow),b){const e=new Float32Array(3*n);for(let t=0;t<h;t++){const o=g.getRGBTransferFunction(t),a=o.getRange();if(o.getTable(a[0],a[1],n,e,1),m)for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o],r[t*n*6+o+3*n]=255*e[o];else for(let o=0;o<3*n;o++)r[t*n*6+o]=255*e[o]}t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:v,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}else{for(let e=0;e<3*n;++e)r[e]=255*e/(3*(n-1)),r[e+1]=255*e/(3*(n-1)),r[e+2]=255*e/(3*(n-1));t.colorTexture.resetFormatAndType(),t.colorTexture.create2DFromRaw({width:n,height:1,numComps:3,dataType:is.UNSIGNED_CHAR,data:r})}b&&(t._openGLRenderWindow.setGraphicsResourceForObject(b,t.colorTexture,y),b!==t._colorTransferFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(b,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._colorTransferFunc,e)),t._colorTransferFunc=b)}const C=[];for(let e=0;e<h;++e)C.push(g.getPiecewiseFunction(e));const S=Xp(C,m,h),A=g.getPiecewiseFunction(),I=t._openGLRenderWindow.getGraphicsResourceForObject(A);if(I?.oglObject?.getHandle()&&I?.hash===S)t.pwfTexture=I.oglObject;else{let n=t.renderable.getOpacityTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=n*v,o=new Uint8ClampedArray(r);if(t.pwfTexture=td.newInstance(),t.pwfTexture.setOpenGLRenderWindow(t._openGLRenderWindow),A){const e=new Float32Array(r),o=new Float32Array(n);for(let t=0;t<h;++t){const r=g.getPiecewiseFunction(t);if(null===r)e.fill(1);else{const a=r.getRange();if(r.getTable(a[0],a[1],n,o,1),m)for(let r=0;r<n;r++)e[t*n*2+r]=o[r],e[t*n*2+r+n]=o[r];else for(let r=0;r<n;r++)e[t*n*2+r]=o[r]}}t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:v,numComps:1,dataType:is.FLOAT,data:e})}else o.fill(255),t.pwfTexture.resetFormatAndType(),t.pwfTexture.create2DFromRaw({width:n,height:1,numComps:1,dataType:is.UNSIGNED_CHAR,data:o});A&&(t._openGLRenderWindow.setGraphicsResourceForObject(A,t.pwfTexture,S),A!==t._pwFunc&&(t._openGLRenderWindow.registerGraphicsResourceUser(A,e),t._openGLRenderWindow.unregisterGraphicsResourceUser(t._pwFunc,e)),t._pwFunc=A)}if(t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.VBOBuildTime.getMTime()<a.getMTime()){const e=a.getNumberOfPoints(),n=e<=1?0:e-1,r=a.getDistancesToFirstPoint(),o=t.renderable.getHeight(),i=4*n,s=new Float32Array(3*i),l=t.renderable.getWidth();for(let e=0,t=0;e<n;++e)s.set([0,o-r[e],0],t),t+=3,s.set([l,o-r[e],0],t),t+=3,s.set([l,o-r[e+1],0],t),t+=3,s.set([0,o-r[e+1],0],t),t+=3;const c=Ts.newInstance({numberOfComponents:3,values:s});c.setName("points");const u=new Uint16Array(5*n);for(let e=0,t=0,r=0;e<n;++e)u.set([4,r+3,r+2,r+1,r],t),t+=5,r+=4;const d=Ts.newInstance({numberOfComponents:1,values:u}),p=a.getPoints(),f=new Float32Array(3*i),g=new Array(3),m=new Array(3);for(let e=0,t=0;e<n;++e)p.getPoint(e,g),p.getPoint(e+1,m),f.set(g,t),t+=3,f.set(g,t),t+=3,f.set(m,t),t+=3,f.set(m,t),t+=3;const h=Ts.newInstance({numberOfComponents:3,values:f,name:"centerlinePosition"}),v=new Float32Array(i);for(let e=0,t=0;e<n;++e)v.set([0,1,3,2],t),t+=4;const T=[h,Ts.newInstance({numberOfComponents:1,values:v,name:"quadIndex"})];if(!t.renderable.getUseUniformOrientation()){const e=t.renderable.getOrientedCenterline().getOrientations()??[],r=new Float32Array(4*i),o=new Float32Array(4*i);for(let t=0;t<n;++t){const n=e[t],a=e[t+1];for(let e=0;e<4;++e){const i=4*(e+4*t);r.set(n,i),o.set(a,i)}}const a=Ts.newInstance({numberOfComponents:4,values:r,name:"centerlineTopOrientation"}),s=Ts.newInstance({numberOfComponents:4,values:o,name:"centerlineBotOrientation"});T.push(a,s)}t.tris.getCABO().createVBO(d,"polys",qi.SURFACE,{points:c,customAttributes:T}),t.VBOBuildTime.modified()}},e.getNeedToRebuildShaders=(e,n,r)=>{const o=t.volumeTexture.getComponents(),a=r.getProperty().getIndependentComponents(),i=!!t.renderable.getCenterPoint(),s=t.renderable.getUseUniformOrientation(),l=t.renderable.isProjectionEnabled()&&t.renderable.getProjectionMode();return(0===e.getProgram()||t.lastUseCenterPoint!==i||t.lastUseUniformOrientation!==s||t.lastProjectionMode!==l||t.lastHaveSeenDepthRequest!==t.haveSeenDepthRequest||t.lastTextureComponents!==o||t.lastIndependentComponents!==a)&&(t.lastUseCenterPoint=i,t.lastUseUniformOrientation=s,t.lastProjectionMode=l,t.lastHaveSeenDepthRequest=t.haveSeenDepthRequest,t.lastTextureComponents=o,t.lastIndependentComponents=a,!0)},e.buildShaders=(t,n,r)=>{e.getShaderTemplate(t,n,r),e.replaceShaderValues(t,n,r)},e.replaceShaderValues=(n,r,o)=>{let a=n.Vertex,i=n.Fragment;const s=["vec3 applyQuaternionToVec(vec4 q, vec3 v) {","  float uvx = q.y * v.z - q.z * v.y;","  float uvy = q.z * v.x - q.x * v.z;","  float uvz = q.x * v.y - q.y * v.x;","  float uuvx = q.y * uvz - q.z * uvy;","  float uuvy = q.z * uvx - q.x * uvz;","  float uuvz = q.x * uvy - q.y * uvx;","  float w2 = q.w * 2.0;","  uvx *= w2;","  uvy *= w2;","  uvz *= w2;","  uuvx *= 2.0;","  uuvy *= 2.0;","  uuvz *= 2.0;","  return vec3(v.x + uvx + uuvx, v.y + uvy + uuvy, v.z + uvz + uuvz);","}"];a=Pu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 MCPCMatrix;"]).result,a=Pu.substitute(a,"//VTK::PositionVC::Impl",["  gl_Position = MCPCMatrix * vertexMC;"]).result;const l=["attribute vec3 centerlinePosition;","attribute float quadIndex;","uniform float width;","out vec2 quadOffsetVSOutput;","out vec3 centerlinePosVSOutput;"],c=t.renderable.isProjectionEnabled(),u=t.renderable.getUseUniformOrientation();u?(l.push("out vec3 samplingDirVSOutput;","uniform vec4 centerlineOrientation;","uniform vec3 tangentDirection;",...s),c&&l.push("out vec3 projectionDirVSOutput;","uniform vec3 bitangentDirection;")):l.push("out vec4 centerlineTopOrientationVSOutput;","out vec4 centerlineBotOrientationVSOutput;","attribute vec4 centerlineTopOrientation;","attribute vec4 centerlineBotOrientation;"),a=Pu.substitute(a,"//VTK::Color::Dec",l).result;const d=["quadOffsetVSOutput = vec2(width * (mod(quadIndex, 2.0) == 0.0 ? -0.5 : 0.5), quadIndex > 1.0 ? 0.0 : 1.0);","centerlinePosVSOutput = centerlinePosition;"];u?(d.push("samplingDirVSOutput = applyQuaternionToVec(centerlineOrientation, tangentDirection);"),c&&d.push("projectionDirVSOutput = applyQuaternionToVec(centerlineOrientation, bitangentDirection);")):d.push("centerlineTopOrientationVSOutput = centerlineTopOrientation;","centerlineBotOrientationVSOutput = centerlineBotOrientation;"),a=Pu.substitute(a,"//VTK::Color::Impl",d).result;const p=t.volumeTexture.getComponents(),f=o.getProperty().getIndependentComponents();let g=["uniform mat4 MCTCMatrix; // Model coordinates to texture coordinates","in vec2 quadOffsetVSOutput;","in vec3 centerlinePosVSOutput;","uniform highp sampler3D volumeTexture;","uniform sampler2D colorTexture1;","uniform sampler2D pwfTexture1;","uniform float opacity;","uniform vec4 backgroundColor;","uniform float cshift0;","uniform float cscale0;","uniform float pwfshift0;","uniform float pwfscale0;"];c&&g.push("uniform vec3 volumeSizeMC;","uniform int projectionSlabNumberOfSamples;","uniform float projectionConstantOffset;","uniform float projectionStepLength;"),u?(g.push("in vec3 samplingDirVSOutput;"),c&&g.push("in vec3 projectionDirVSOutput;")):(g.push("uniform vec3 tangentDirection;","in vec4 centerlineTopOrientationVSOutput;","in vec4 centerlineBotOrientationVSOutput;",...s),c&&g.push("uniform vec3 bitangentDirection;"));const m=t.renderable.getCenterPoint();if(m&&g.push("uniform vec3 globalCenterPoint;"),f){for(let e=1;e<p;e++)g=g.concat([`uniform float cshift${e};`,`uniform float cscale${e};`,`uniform float pwfshift${e};`,`uniform float pwfscale${e};`]);switch(p){case 1:g=g.concat(["uniform float mix0;","#define height0 0.5"]);break;case 2:g=g.concat(["uniform float mix0;","uniform float mix1;","#define height0 0.25","#define height1 0.75"]);break;case 3:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","#define height0 0.17","#define height1 0.5","#define height2 0.83"]);break;case 4:g=g.concat(["uniform float mix0;","uniform float mix1;","uniform float mix2;","uniform float mix3;","#define height0 0.125","#define height1 0.375","#define height2 0.625","#define height3 0.875"]);break;default:ff("Unsupported number of independent coordinates.")}}i=Pu.substitute(i,"//VTK::TCoord::Dec",g).result;let h=[];if(u?(h.push("vec3 samplingDirection = samplingDirVSOutput;"),c&&h.push("vec3 projectionDirection = projectionDirVSOutput;")):(h.push("vec4 q0 = centerlineBotOrientationVSOutput;","vec4 q1 = centerlineTopOrientationVSOutput;","float qCosAngle = dot(q0, q1);","vec4 interpolatedOrientation;","if (qCosAngle > 0.999 || qCosAngle < -0.999) {","  // Use LERP instead of SLERP when the two quaternions are close or opposite","  interpolatedOrientation = normalize(mix(q0, q1, quadOffsetVSOutput.y));","} else {","  float omega = acos(qCosAngle);","  interpolatedOrientation = normalize(sin((1.0 - quadOffsetVSOutput.y) * omega) * q0 + sin(quadOffsetVSOutput.y * omega) * q1);","}","vec3 samplingDirection = applyQuaternionToVec(interpolatedOrientation, tangentDirection);"),c&&h.push("vec3 projectionDirection = applyQuaternionToVec(interpolatedOrientation, bitangentDirection);")),m?h.push("float baseOffset = dot(samplingDirection, globalCenterPoint - centerlinePosVSOutput);","float horizontalOffset = quadOffsetVSOutput.x + baseOffset;"):h.push("float horizontalOffset = quadOffsetVSOutput.x;"),h.push("vec3 volumePosMC = centerlinePosVSOutput + horizontalOffset * samplingDirection;","vec3 volumePosTC = (MCTCMatrix * vec4(volumePosMC, 1.0)).xyz;","if (any(lessThan(volumePosTC, vec3(0.0))) || any(greaterThan(volumePosTC, vec3(1.0))))","{","  // set the background color and exit","  gl_FragData[0] = backgroundColor;","  return;","}"),c){const e=t.renderable.getProjectionMode();switch(e===df?h.push("const vec4 initialProjectionTextureValue = vec4(1.0);"):h.push("const vec4 initialProjectionTextureValue = vec4(0.0);"),h.push("vec3 projectionScaledDirection = projectionDirection / volumeSizeMC;","vec3 projectionStep = projectionStepLength * projectionScaledDirection;","vec3 projectionStartPosition = volumePosTC + projectionConstantOffset * projectionScaledDirection;","vec4 tvalue = initialProjectionTextureValue;","for (int projectionSampleIdx = 0; projectionSampleIdx < projectionSlabNumberOfSamples; ++projectionSampleIdx) {","  vec3 projectionSamplePosition = projectionStartPosition + float(projectionSampleIdx) * projectionStep;","  vec4 sampledTextureValue = texture(volumeTexture, projectionSamplePosition);"),e){case uf:h.push("  tvalue = max(tvalue, sampledTextureValue);");break;case df:h.push("  tvalue = min(tvalue, sampledTextureValue);");break;default:h.push("  tvalue = tvalue + sampledTextureValue;")}h.push("}"),e===pf&&h.push("tvalue = tvalue / float(projectionSlabNumberOfSamples);")}else h.push("vec4 tvalue = texture(volumeTexture, volumePosTC);");if(f){const e=["r","g","b","a"];for(let t=0;t<p;++t)h=h.concat([`vec3 tcolor${t} = mix${t} * texture2D(colorTexture1, vec2(tvalue.${e[t]} * cscale${t} + cshift${t}, height${t})).rgb;`,`float compWeight${t} = mix${t} * texture2D(pwfTexture1, vec2(tvalue.${e[t]} * pwfscale${t} + pwfshift${t}, height${t})).r;`]);switch(p){case 1:h=h.concat(["gl_FragData[0] = vec4(tcolor0.rgb, compWeight0 * opacity);"]);break;case 2:h=h.concat(["float weightSum = compWeight0 + compWeight1;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum))), opacity);"]);break;case 3:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum))), opacity);"]);break;case 4:h=h.concat(["float weightSum = compWeight0 + compWeight1 + compWeight2 + compWeight3;","gl_FragData[0] = vec4(vec3((tcolor0.rgb * (compWeight0 / weightSum)) + (tcolor1.rgb * (compWeight1 / weightSum)) + (tcolor2.rgb * (compWeight2 / weightSum)) + (tcolor3.rgb * (compWeight3 / weightSum))), opacity);"]);break;default:ff("Unsupported number of independent coordinates.")}}else switch(p){case 1:h=h.concat(["// Dependent components","float intensity = tvalue.r;","vec3 tcolor = texture2D(colorTexture1, vec2(intensity * cscale0 + cshift0, 0.5)).rgb;","float scalarOpacity = texture2D(pwfTexture1, vec2(intensity * pwfscale0 + pwfshift0, 0.5)).r;","gl_FragData[0] = vec4(tcolor, scalarOpacity * opacity);"]);break;case 2:h=h.concat(["float intensity = tvalue.r*cscale0 + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(intensity, 0.5)).rgb, pwfscale0*tvalue.g + pwfshift0);"]);break;case 3:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, opacity);"]);break;default:h=h.concat(["vec4 tcolor = cscale0*tvalue + cshift0;","gl_FragData[0] = vec4(texture2D(colorTexture1, vec2(tcolor.r,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.g,0.5)).r,","  texture2D(colorTexture1, vec2(tcolor.b,0.5)).r, tcolor.a);"])}i=Pu.substitute(i,"//VTK::TCoord::Impl",h).result,t.haveSeenDepthRequest&&(i=Pu.substitute(i,"//VTK::ZBuffer::Dec","uniform int depthRequest;").result,i=Pu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float iz = floor(gl_FragCoord.z*65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),n.Vertex=a,n.Fragment=i,e.replaceShaderClip(n,r,o),e.replaceShaderCoincidentOffset(n,r,o)},e.replaceShaderClip=(e,n,r)=>{let o=e.Vertex,a=e.Fragment;if(t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(Ht.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6),o=Pu.substitute(o,"//VTK::Clip::Dec",["uniform int numClipPlanes;","uniform vec4 clipPlanes[6];","varying float clipDistancesVSOutput[6];"]).result,o=Pu.substitute(o,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    clipDistancesVSOutput[planeNum] = dot(clipPlanes[planeNum], vertexMC);","    }"]).result,a=Pu.substitute(a,"//VTK::Clip::Dec",["uniform int numClipPlanes;","varying float clipDistancesVSOutput[6];"]).result,a=Pu.substitute(a,"//VTK::Clip::Impl",["for (int planeNum = 0; planeNum < 6; planeNum++)","    {","    if (planeNum >= numClipPlanes)","        {","        break;","        }","    if (clipDistancesVSOutput[planeNum] < 0.0) discard;","    }"]).result}e.Vertex=o,e.Fragment=a},e.getShaderTemplate=(e,t,n)=>{e.Vertex=nd,e.Fragment=rd,e.Geometry=""},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram(),i=n.getCABO();i.getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexMC")&&(n.getVAO().addAttributeArray(a,i,"vertexMC",i.getVertexOffset(),i.getStride(),t.context.FLOAT,3,t.context.FALSE)||ff("Error setting vertexMC in shader VAO.")),n.getCABO().getCustomData().forEach((e=>{e&&a.isAttributeUsed(e.name)&&!n.getVAO().addAttributeArray(a,i,e.name,e.offset,i.getStride(),t.context.FLOAT,e.components,t.context.FALSE)&&ff(`Error setting ${e.name} in shader VAO.`)})),n.getAttributeUpdateTime().modified());const s=t.volumeTexture.getTextureUnit();if(a.setUniformi("volumeTexture",s),a.setUniformf("width",t.renderable.getWidth()),n.getProgram().setUniform4fv("backgroundColor",t.renderable.getBackgroundColor()),a.isUniformUsed("tangentDirection")){const e=t.renderable.getTangentDirection();n.getProgram().setUniform3fArray("tangentDirection",e)}if(a.isUniformUsed("bitangentDirection")){const e=t.renderable.getBitangentDirection();n.getProgram().setUniform3fArray("bitangentDirection",e)}if(a.isUniformUsed("centerlineOrientation")){const e=t.renderable.getUniformOrientation();n.getProgram().setUniform4fv("centerlineOrientation",e)}if(a.isUniformUsed("globalCenterPoint")){const e=t.renderable.getCenterPoint();a.setUniform3fArray("globalCenterPoint",e)}if(t.renderable.isProjectionEnabled()){const e=t.currentImageDataInput,n=e.getSpacing(),r=e.getDimensions(),o=t.renderable.getProjectionSlabThickness(),i=t.renderable.getProjectionSlabNumberOfSamples(),s=En([],n,r);a.setUniform3fArray("volumeSizeMC",s),a.setUniformi("projectionSlabNumberOfSamples",i);const l=-.5*o;a.setUniformf("projectionConstantOffset",l);const c=o/(i-1);a.setUniformf("projectionStepLength",c)}const l=t.currentImageDataInput,c=l.getWorldToIndex(),u=O(new Float32Array(16),Cn([],l.getDimensions())),p=oe(u,u,c);if(a.setUniformMatrix("MCTCMatrix",p),t.haveSeenDepthRequest&&n.getProgram().setUniformi("depthRequest",t.renderDepth?1:0),t.renderable.getNumberOfClippingPlanes()){let e=t.renderable.getNumberOfClippingPlanes();e>6&&(Ht.vtkErrorMacro("OpenGL has a limit of 6 clipping planes"),e=6);const n=i.getCoordShiftAndScaleEnabled()?i.getInverseShiftAndScaleMatrix():null,r=n?d(t.imagematinv,o.getMatrix()):o.getMatrix();n&&(m(r,r),y(r,r,n),m(r,r)),m(t.imagemat,t.currentImageDataInput.getIndexToWorld()),y(t.imagematinv,r,t.imagemat);const s=[];for(let n=0;n<e;n++){const e=[];t.renderable.getClippingPlaneInDataCoords(t.imagematinv,n,e);for(let t=0;t<4;t++)s.push(e[t])}a.setUniformi("numClipPlanes",e),a.setUniform4fv("clipPlanes",s)}if(a.isUniformUsed("coffset")){const t=e.getCoincidentParameters(r,o);a.setUniformf("coffset",t.offset),a.isUniformUsed("cfactor")&&a.setUniformf("cfactor",t.factor)}},e.setCameraShaderParameters=(e,n,r)=>{const o=t.openGLImageSlice.getKeyMatrices().mcwc,a=t.openGLCamera.getKeyMatrices(n).wcpc;if(y(t.imagemat,a,o),e.getCABO().getCoordShiftAndScaleEnabled()){const n=e.getCABO().getInverseShiftAndScaleMatrix();y(t.imagemat,t.imagemat,n)}e.getProgram().setUniformMatrix("MCPCMatrix",t.imagemat)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=r.getProperty(),i=a.getOpacity();o.setUniformf("opacity",i);const s=t.volumeTexture.getComponents(),l=a.getIndependentComponents();if(l)for(let e=0;e<s;++e)o.setUniformf(`mix${e}`,a.getComponentWeight(e));const c=t.volumeTexture.getVolumeInfo();for(let e=0;e<s;e++){let t=a.getColorWindow(),n=a.getColorLevel();const r=l?e:0,i=a.getRGBTransferFunction(r);if(i&&a.getUseLookupTableScalarRange()){const e=i.getRange();t=e[1]-e[0],n=.5*(e[1]+e[0])}const s=c.scale[e]/t,u=(c.offset[e]-n)/t+.5;o.setUniformf(`cshift${e}`,u),o.setUniformf(`cscale${e}`,s)}const u=t.colorTexture.getTextureUnit();o.setUniformi("colorTexture1",u);for(let e=0;e<s;e++){let t=1,n=0;const r=l?e:0,i=a.getPiecewiseFunction(r);if(i){const r=i.getRange(),o=r[1]-r[0],a=.5*(r[0]+r[1]);t=c.scale[e]/o,n=(c.offset[e]-a)/o+.5}o.setUniformf(`pwfshift${e}`,n),o.setUniformf(`pwfscale${e}`,t)}const d=t.pwfTexture.getTextureUnit();o.setUniformi("pwfTexture1",d)},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o)},e.delete=Ht.chain((()=>{t._openGLRenderWindow&&n(t._openGLRenderWindow)}),e.delete)}(e,t)}),"vtkOpenGLImageCPRMapper");en("vtkImageCPRMapper",mf);const hf={context:null,keyMatrixTime:null,keyMatrices:null};const vf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hf,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.keyMatrices={mcwc:g(new Float64Array(16))},St(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLImageSlice"),e.buildPass=n=>{if(t.renderable&&t.renderable.getVisibility()&&n){if(!t.renderable)return;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes()}},e.traverseZBufferPass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseOpaqueZBufferPass=t=>e.traverseOpaquePass(t),e.traverseOpaquePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&t.renderable.getIsOpaque()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.traverseTranslucentPass=n=>{!t.renderable||!t.renderable.getNestedVisibility()||t.renderable.getIsOpaque()||t._openGLRenderer.getSelector()&&!t.renderable.getNestedPickable()||(e.apply(n,!0),t.children.forEach((e=>{e.traverse(n)})),e.apply(n,!1))},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;t.renderable.getIsOpaque()?n.incrementOpaqueActorCount():n.incrementTranslucentActorCount()}},e.zBufferPass=(t,n)=>e.opaquePass(t,n),e.opaqueZBufferPass=(t,n)=>e.opaquePass(t,n),e.opaquePass=(e,n)=>{e&&t.context.depthMask(!0)},e.translucentPass=(e,n)=>{t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(d(t.keyMatrices.mcwc,t.renderable.getMatrix()),m(t.keyMatrices.mcwc,t.keyMatrices.mcwc),t.keyMatrixTime.modified()),t.keyMatrices)}(e,t)}),"vtkOpenGLImageSlice");en("vtkImageSlice",vf);const Tf={};const yf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tf,n),Xt.extend(e,t,n),t.keyMatrixTime={},vt(t.keyMatrixTime,{mtime:0}),t.normalMatrix=new Float64Array(9),t.MCWCMatrix=new Float64Array(16),St(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLVolume"),e.buildPass=n=>{t.renderable&&t.renderable.getVisibility()&&n&&(t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t.context=t._openGLRenderWindow.getContext(),e.prepareNodes(),e.addMissingNode(t.renderable.getMapper()),e.removeUnusedNodes())},e.queryPass=(e,n)=>{if(e){if(!t.renderable||!t.renderable.getVisibility())return;n.incrementVolumeCount()}},e.traverseVolumePass=n=>{t.renderable&&t.renderable.getNestedVisibility()&&(!t._openGLRenderer.getSelector()||t.renderable.getNestedPickable())&&(e.apply(n,!0),t.children[0].traverse(n),e.apply(n,!1))},e.volumePass=e=>{t.renderable&&t.renderable.getVisibility()&&t.context.depthMask(!e)},e.getKeyMatrices=()=>(t.renderable.getMTime()>t.keyMatrixTime.getMTime()&&(t.renderable.computeMatrix(),d(t.MCWCMatrix,t.renderable.getMatrix()),m(t.MCWCMatrix,t.MCWCMatrix),t.renderable.getIsIdentity()?pe(t.normalMatrix):(se(t.normalMatrix,t.MCWCMatrix),ge(t.normalMatrix,t.normalMatrix),fe(t.normalMatrix,t.normalMatrix)),t.keyMatrixTime.modified()),{mcwc:t.MCWCMatrix,normalMatrix:t.normalMatrix})}(e,t)}),"vtkOpenGLVolume");en("vtkVolume",yf);const bf={NEAREST:0,LINEAR:1,FAST_LINEAR:2},xf={FRACTIONAL:0,PROPORTIONAL:1},Cf={DEFAULT:0,ADDITIVE:1,COLORIZE:2,CUSTOM:3};var Sf={InterpolationType:bf,OpacityMode:xf,ColorMixPreset:Cf,FilterMode:{OFF:0,NORMALIZED:1,RAW:2}};const Af={COMPOSITE_BLEND:0,MAXIMUM_INTENSITY_BLEND:1,MINIMUM_INTENSITY_BLEND:2,AVERAGE_INTENSITY_BLEND:3,ADDITIVE_INTENSITY_BLEND:4,RADON_TRANSFORM_BLEND:5,LABELMAP_EDGE_PROJECTION_BLEND:6};var If={BlendMode:Af};const{vtkWarningMacro:wf,vtkErrorMacro:Of}=jt,Pf={idxToView:g(new Float64Array(16)),vecISToVCMatrix:pe(new Float64Array(9)),modelToView:g(new Float64Array(16)),projectionToView:g(new Float64Array(16)),projectionToWorld:g(new Float64Array(16))};const Rf={context:null,VBOBuildTime:null,scalarTextures:[],_scalarTexturesCore:[],opacityTexture:null,_opacityTextureCore:null,colorTexture:null,_colorTextureCore:null,labelOutlineThicknessTexture:null,_labelOutlineThicknessTextureCore:null,jitterTexture:null,tris:null,framebuffer:null,copyShader:null,copyVAO:null,lastXYF:1,targetXYF:1,zBufferTexture:null,lastZBufferTexture:null,fullViewportTime:1,idxToView:null,vecISToVCMatrix:null,modelToView:null,projectionToView:null,avgWindowArea:0,avgFrameTime:0};const Mf=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Rf,n),Xt.extend(e,t,n),ad(e,t,n),t.VBOBuildTime={},vt(t.VBOBuildTime,{mtime:0}),t.tris=Bu.newInstance(),t.jitterTexture=td.newInstance(),t.jitterTexture.setWrapS(Nu.REPEAT),t.jitterTexture.setWrapT(Nu.REPEAT),t.framebuffer=qd.newInstance(),St(e,t,["context"]),function(e,t){function n(e){return e.getUseLabelOutline()||t.renderable.getBlendMode()===Af.LABELMAP_EDGE_PROJECTION_BLEND}t.classHierarchy.push("vtkOpenGLVolumeMapper");const r=new Map;function o(t,n,o){n!==o&&(function(t,n){if(!n)return;const o=(r.get(n)??0)-1;o<=0?(t.unregisterGraphicsResourceUser(n,e),r.delete(n)):r.set(n,o)}(t,n),function(t,n){if(!n)return;const o=r.get(n)??0,a=o+1;r.set(n,a),o<=0&&t.registerGraphicsResourceUser(n,e)}(t,o))}function a(t){[...r.keys()].forEach((n=>t.unregisterGraphicsResourceUser(n,e)))}e.buildPass=()=>{t.zBufferTexture=null},e.zBufferPass=(e,n)=>{if(e){const e=n.getZBufferTexture();e!==t.zBufferTexture&&(t.zBufferTexture=e)}},e.opaqueZBufferPass=(t,n)=>e.zBufferPass(t,n),e.volumePass=(n,r)=>{if(n){const n=t._openGLRenderWindow;t._openGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),n&&!n.isDeleted()&&n!==t._openGLRenderWindow&&a(n),t.context=t._openGLRenderWindow.getContext(),t.tris.setOpenGLRenderWindow(t._openGLRenderWindow),t.jitterTexture.setOpenGLRenderWindow(t._openGLRenderWindow),t.framebuffer.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLVolume=e.getFirstAncestorOfType("vtkOpenGLVolume");const r=t.openGLVolume.getRenderable();t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer");const o=t._openGLRenderer.getRenderable();t.openGLCamera=t._openGLRenderer.getViewNodeFor(o.getActiveCamera()),e.renderPiece(o,r)}},e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkPolyDataVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\n\nvarying vec3 vertexVCVSOutput;\nuniform mat4 PCVCMatrix;\n\nuniform float dcxmin;\nuniform float dcxmax;\nuniform float dcymin;\nuniform float dcymax;\n\nvoid main()\n{\n  // dcsmall is the device coords reduced to the\n  // x y area covered by the volume\n  vec4 dcsmall = vec4(\n    dcxmin + 0.5 * (vertexDC.x + 1.0) * (dcxmax - dcxmin),\n    dcymin + 0.5 * (vertexDC.y + 1.0) * (dcymax - dcymin),\n    vertexDC.z,\n    vertexDC.w);\n  vec4 vcpos = PCVCMatrix * dcsmall;\n  vertexVCVSOutput = vcpos.xyz/vcpos.w;\n  gl_Position = dcsmall;\n}\n",e.Fragment="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkVolumeFS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// Template for the volume mappers fragment shader\n\nconst float infinity = 3.402823466e38;\n\n// the output of this shader\n//VTK::Output::Dec\n\nin vec3 vertexVCVSOutput;\n\n// From Sources\\Rendering\\Core\\VolumeProperty\\Constants.js\n#define COMPOSITE_BLEND 0\n#define MAXIMUM_INTENSITY_BLEND 1\n#define MINIMUM_INTENSITY_BLEND 2\n#define AVERAGE_INTENSITY_BLEND 3\n#define ADDITIVE_INTENSITY_BLEND 4\n#define RADON_TRANSFORM_BLEND 5\n#define LABELMAP_EDGE_PROJECTION_BLEND 6\n\n#define vtkNumberOfLights //VTK::NumberOfLights\n#define vtkMaxLaoKernelSize //VTK::MaxLaoKernelSize\n#define vtkNumberOfComponents //VTK::NumberOfComponents\n#define vtkBlendMode //VTK::BlendMode\n#define vtkMaximumNumberOfSamples //VTK::MaximumNumberOfSamples\n\n//VTK::EnabledColorFunctions\n\n//VTK::EnabledLightings\n\n//VTK::EnabledMultiTexturePerVolume\n\n//VTK::EnabledGradientOpacity\n\n//VTK::EnabledIndependentComponents\n\n//VTK::vtkProportionalComponents\n\n//VTK::vtkForceNearestComponents\n\nuniform int twoSidedLighting;\n\n#if vtkMaxLaoKernelSize > 0\n  vec2 kernelSample[vtkMaxLaoKernelSize];\n#endif\n\n// Textures\n#ifdef EnabledMultiTexturePerVolume\n  #define vtkNumberOfVolumeTextures vtkNumberOfComponents\n#else\n  #define vtkNumberOfVolumeTextures 1\n#endif\nuniform highp sampler3D volumeTexture[vtkNumberOfVolumeTextures];\nuniform sampler2D colorTexture;\nuniform sampler2D opacityTexture;\nuniform sampler2D jtexture;\nuniform sampler2D labelOutlineThicknessTexture;\n\nstruct Volume {\n  // ---- Volume geometry settings ----\n\n  vec3 originVC;          // in VC\n  vec3 spacing;           // in VC per IC\n  vec3 inverseSpacing;    // 1/spacing\n  ivec3 dimensions;       // in IC\n  vec3 inverseDimensions; // 1/vec3(dimensions)\n  mat3 vecISToVCMatrix;   // convert from IS to VC without translation\n  mat3 vecVCToISMatrix;   // convert from VC to IS without translation\n  mat4 PCWCMatrix;\n  mat4 worldToIndex;\n  float diagonalLength; // in VC, this is: length(size)\n\n  // ---- Texture settings ----\n\n  // Texture shift and scale\n  vec4 colorTextureScale;\n  vec4 colorTextureShift;\n  vec4 opacityTextureScale;\n  vec4 opacityTextureShift;\n\n  // The heights defined below are the locations for the up to four components\n  // of the transfer functions. The transfer functions have a height of (2 *\n  // numberOfComponents) pixels so the values are computed to hit the middle of\n  // the two rows for that component\n  vec4 transferFunctionsSampleHeight;\n\n  // ---- Mode specific settings ----\n\n  // Independent component default preset settings per component\n  vec4 independentComponentMix;\n\n  // Additive / average blending mode settings\n  vec4 ipScalarRangeMin;\n  vec4 ipScalarRangeMax;\n\n  // ---- Rendering settings ----\n\n  // Lighting\n  float ambient;\n  float diffuse;\n  float specular;\n  float specularPower;\n  int computeNormalFromOpacity;\n\n  // Gradient opacity\n  vec4 gradientOpacityScale;\n  vec4 gradientOpacityShift;\n  vec4 gradientOpacityMin;\n  vec4 gradientOpacityMax;\n\n  // Volume shadow\n  float volumetricScatteringBlending;\n  float globalIlluminationReach;\n  float anisotropy;\n  float anisotropySquared;\n\n  // LAO\n  int kernelSize;\n  int kernelRadius;\n\n  // Label outline\n  float outlineOpacity;\n};\nuniform Volume volume;\n\nstruct Light {\n  vec3 color;\n  vec3 positionVC;\n  vec3 directionVC; // normalized\n  vec3 halfAngleVC;\n  vec3 attenuation;\n  float exponent;\n  float coneAngle;\n  int isPositional;\n};\n#if vtkNumberOfLights > 0\n  uniform Light lights[vtkNumberOfLights];\n#endif\n\nuniform float vpWidth;\nuniform float vpHeight;\nuniform float vpOffsetX;\nuniform float vpOffsetY;\n\n// Bitmasks for label outline\nconst int MAX_SEGMENT_INDEX = 256; // Define as per expected maximum\n#define MAX_SEGMENTS 256\n#define UINT_SIZE 32\n// We add UINT_SIZE - 1, as we want the ceil of the division instead of the\n// floor\n#define BITMASK_SIZE ((MAX_SEGMENTS + UINT_SIZE - 1) / UINT_SIZE)\nuint labelOutlineBitmasks[BITMASK_SIZE];\n\n// Set the corresponding bit in the bitmask\nvoid setLabelOutlineBit(int segmentIndex) {\n  int arrayIndex = segmentIndex / UINT_SIZE;\n  int bitIndex = segmentIndex % UINT_SIZE;\n  labelOutlineBitmasks[arrayIndex] |= 1u << bitIndex;\n}\n\n// Check if a bit is set in the bitmask\nbool isLabelOutlineBitSet(int segmentIndex) {\n  int arrayIndex = segmentIndex / UINT_SIZE;\n  int bitIndex = segmentIndex % UINT_SIZE;\n  return ((labelOutlineBitmasks[arrayIndex] & (1u << bitIndex)) != 0u);\n}\n\n// if you want to see the raw tiled\n// data in webgl1 uncomment the following line\n// #define debugtile\n\n// camera values\nuniform float camThick;\nuniform float camNear;\nuniform float camFar;\nuniform int cameraParallel;\n\n//VTK::ClipPlane::Dec\n\n// A random number between 0 and 1 that only depends on the fragment\n// It uses the jtexture, so this random seed repeats by blocks of 32 fragments\n// in screen space\nfloat fragmentSeed;\n\n// sample texture is global\nuniform float sampleDistance;\nuniform float volumeShadowSampleDistance;\n\n// declaration for intermixed geometry\n//VTK::ZBuffer::Dec\n\n//=======================================================================\n// global and custom variables (a temporary section before photorealistics\n// rendering module is complete)\nvec3 rayDirVC;\n\n#define INV4PI 0.0796\n#define EPSILON 0.001\n#define PI 3.1415\n#define PI2 9.8696\n\nvec4 rawSampleTexture(vec3 pos) {\n  #ifdef EnabledMultiTexturePerVolume\n    vec4 rawSample;\n    rawSample[0] = texture(volumeTexture[0], pos)[0];\n  #if vtkNumberOfComponents > 1\n    rawSample[1] = texture(volumeTexture[1], pos)[0];\n  #endif\n  #if vtkNumberOfComponents > 2\n    rawSample[2] = texture(volumeTexture[2], pos)[0];\n  #endif\n  #if vtkNumberOfComponents > 3\n    rawSample[3] = texture(volumeTexture[3], pos)[0];\n  #endif\n    return rawSample;\n  #else\n    return texture(volumeTexture[0], pos);\n  #endif\n}\n\nvec4 rawFetchTexture(ivec3 pos) {\n  #ifdef EnabledMultiTexturePerVolume\n    vec4 rawSample;\n    #if vtkNumberOfComponents > 0\n      rawSample[0] = texelFetch(volumeTexture[0], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 1\n      rawSample[1] = texelFetch(volumeTexture[1], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 2\n      rawSample[2] = texelFetch(volumeTexture[2], pos, 0)[0];\n    #endif\n    #if vtkNumberOfComponents > 3\n      rawSample[3] = texelFetch(volumeTexture[3], pos, 0)[0];\n    #endif\n    return rawSample;\n  #else\n    return texelFetch(volumeTexture[0], pos, 0);\n  #endif\n}\n\nvec4 getTextureValue(vec3 pos) {\n  vec4 tmp = rawSampleTexture(pos);\n\n  // Force nearest\n  #if defined(vtkComponent0ForceNearest) || \\\n      defined(vtkComponent1ForceNearest) || \\\n      defined(vtkComponent2ForceNearest) || \\\n      defined(vtkComponent3ForceNearest)\n    vec3 nearestPos = (floor(pos * vec3(volume.dimensions)) + 0.5) *\n                      volume.inverseDimensions;\n    vec4 nearestValue = rawSampleTexture(nearestPos);\n    #ifdef vtkComponent0ForceNearest\n      tmp[0] = nearestValue[0];\n    #endif\n    #ifdef vtkComponent1ForceNearest\n      tmp[1] = nearestValue[1];\n    #endif\n    #ifdef vtkComponent2ForceNearest\n      tmp[2] = nearestValue[2];\n    #endif\n    #ifdef vtkComponent3ForceNearest\n      tmp[3] = nearestValue[3];\n    #endif\n  #endif\n\n  // Set alpha when using dependent components\n  #ifndef EnabledIndependentComponents\n    #if vtkNumberOfComponents == 1\n      tmp.a = tmp.r;\n    #endif\n    #if vtkNumberOfComponents == 2\n      tmp.a = tmp.g;\n    #endif\n    #if vtkNumberOfComponents == 3\n      tmp.a = length(tmp.rgb);\n    #endif\n  #endif\n\n  return tmp;\n}\n\n// `height` is usually `volume.transferFunctionsSampleHeight[component]`\n// when using independent component and `0.5` otherwise. Don't move the if\n// statement in these function, as the callers usually already knows if it is\n// using independent component or not\nfloat getOpacityFromTexture(float scalar, int component, float height) {\n  float scaledScalar = scalar * volume.opacityTextureScale[component] +\n                       volume.opacityTextureShift[component];\n  return texture2D(opacityTexture, vec2(scaledScalar, height)).r;\n}\nvec3 getColorFromTexture(float scalar, int component, float height) {\n  float scaledScalar = scalar * volume.colorTextureScale[component] +\n                       volume.colorTextureShift[component];\n  return texture2D(colorTexture, vec2(scaledScalar, height)).rgb;\n}\n\n//=======================================================================\n// transformation between VC and IS space\n\n// convert vector position from idx to vc\nvec3 posIStoVC(vec3 posIS) {\n  return volume.vecISToVCMatrix * posIS + volume.originVC;\n}\n\n// convert vector position from vc to idx\nvec3 posVCtoIS(vec3 posVC) {\n  return volume.vecVCToISMatrix * (posVC - volume.originVC);\n}\n\n// Rotate vector to view coordinate\nvec3 vecISToVC(vec3 dirIS) {\n  return volume.vecISToVCMatrix * dirIS;\n}\n\n// Rotate vector to idx coordinate\nvec3 vecVCToIS(vec3 dirVC) {\n  return volume.vecVCToISMatrix * dirVC;\n}\n\n//=======================================================================\n// Given a normal compute the gradient opacity factors\nfloat computeGradientOpacityFactor(float normalMag, int component) {\n  float goscale = volume.gradientOpacityScale[component];\n  float goshift = volume.gradientOpacityShift[component];\n  float gomin = volume.gradientOpacityMin[component];\n  float gomax = volume.gradientOpacityMax[component];\n  return clamp(normalMag * goscale + goshift, gomin, gomax);\n}\n\n#ifdef vtkClippingPlanesOn\n  bool isPointClipped(vec3 posVC) {\n    for (int i = 0; i < clip_numPlanes; ++i) {\n      if (dot(vec3(vClipPlaneOrigins[i] - posVC), vClipPlaneNormals[i]) > 0.0) {\n        return true;\n      }\n    }\n    return false;\n  }\n#endif\n\n//=======================================================================\n// compute the normal and gradient magnitude for a position, uses forward\n// difference\n\n// The output normal is in VC\nvec4 computeDensityNormal(vec3 opacityUCoords[2], float opacityTextureHeight,\n                          float gradientOpacity, int component) {\n  // Pass the scalars through the opacity functions\n  vec4 opacityG;\n  opacityG.x += getOpacityFromTexture(opacityUCoords[0].x, component,\n                                      opacityTextureHeight);\n  opacityG.y += getOpacityFromTexture(opacityUCoords[0].y, component,\n                                      opacityTextureHeight);\n  opacityG.z += getOpacityFromTexture(opacityUCoords[0].z, component,\n                                      opacityTextureHeight);\n  opacityG.x -= getOpacityFromTexture(opacityUCoords[1].x, component,\n                                      opacityTextureHeight);\n  opacityG.y -= getOpacityFromTexture(opacityUCoords[1].y, component,\n                                      opacityTextureHeight);\n  opacityG.z -= getOpacityFromTexture(opacityUCoords[1].z, component,\n                                      opacityTextureHeight);\n\n  // Divide by spacing and convert to VC\n  opacityG.xyz *= gradientOpacity * volume.inverseSpacing;\n  opacityG.w = length(opacityG.xyz);\n  if (opacityG.w == 0.0) {\n    return vec4(0.0);\n  }\n\n  // Normalize\n  opacityG.xyz = normalize(vecISToVC(opacityG.xyz));\n\n  return opacityG;\n}\n\n// The output normal is in VC\nvec4 computeNormalForDensity(vec3 posIS, out vec3 scalarInterp[2],\n                             const int opacityComponent) {\n  vec3 offsetedPosIS;\n  for (int axis = 0; axis < 3; ++axis) {\n    // Positive direction\n    offsetedPosIS = posIS;\n    offsetedPosIS[axis] += volume.inverseDimensions[axis];\n    scalarInterp[0][axis] =\n        getTextureValue(offsetedPosIS)[opacityComponent];\n    #ifdef vtkClippingPlanesOn\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\n        scalarInterp[0][axis] = 0.0;\n      }\n    #endif\n\n    // Negative direction\n    offsetedPosIS = posIS;\n    offsetedPosIS[axis] -= volume.inverseDimensions[axis];\n    scalarInterp[1][axis] =\n        getTextureValue(offsetedPosIS)[opacityComponent];\n    #ifdef vtkClippingPlanesOn\n      if (isPointClipped(posIStoVC(offsetedPosIS))) {\n        scalarInterp[1][axis] = 0.0;\n      }\n    #endif\n  }\n\n  vec4 result;\n  result.xyz = (scalarInterp[0] - scalarInterp[1]) * volume.inverseSpacing;\n  result.w = length(result.xyz);\n  if (result.w == 0.0) {\n    return vec4(0.0);\n  }\n  result.xyz = normalize(vecISToVC(result.xyz));\n  return result;\n}\n\nvec4 fragCoordToPCPos(vec4 fragCoord) {\n  return vec4((fragCoord.x / vpWidth - vpOffsetX - 0.5) * 2.0,\n              (fragCoord.y / vpHeight - vpOffsetY - 0.5) * 2.0,\n              (fragCoord.z - 0.5) * 2.0, 1.0);\n}\n\nvec4 pcPosToWorldCoord(vec4 pcPos) {\n  return volume.PCWCMatrix * pcPos;\n}\n\nvec3 fragCoordToIndexSpace(vec4 fragCoord) {\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\n  vec4 vertex = (worldCoord / worldCoord.w);\n\n  vec3 index = (volume.worldToIndex * vertex).xyz;\n\n  // half voxel fix for labelmapOutline\n  return (index + vec3(0.5)) * volume.inverseDimensions;\n}\n\nvec3 fragCoordToWorld(vec4 fragCoord) {\n  vec4 pcPos = fragCoordToPCPos(fragCoord);\n  vec4 worldCoord = pcPosToWorldCoord(pcPos);\n  return worldCoord.xyz;\n}\n\n//=======================================================================\n// Compute the normals and gradient magnitudes for a position for independent\n// components The output normals are in VC\nmat4 computeMat4Normal(vec3 posIS, vec4 tValue) {\n  vec3 xvec = vec3(volume.inverseDimensions.x, 0.0, 0.0);\n  vec3 yvec = vec3(0.0, volume.inverseDimensions.y, 0.0);\n  vec3 zvec = vec3(0.0, 0.0, volume.inverseDimensions.z);\n\n  vec4 distX = getTextureValue(posIS + xvec) - getTextureValue(posIS - xvec);\n  vec4 distY = getTextureValue(posIS + yvec) - getTextureValue(posIS - yvec);\n  vec4 distZ = getTextureValue(posIS + zvec) - getTextureValue(posIS - zvec);\n\n  // divide by spacing\n  distX *= 0.5 * volume.inverseSpacing.x;\n  distY *= 0.5 * volume.inverseSpacing.y;\n  distZ *= 0.5 * volume.inverseSpacing.z;\n\n  mat4 result;\n\n  // optionally compute the 1st component\n  #if vtkNumberOfComponents > 0 && !defined(vtkComponent0Proportional)\n    {\n      const int component = 0;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 2nd component\n  #if vtkNumberOfComponents > 1 && !defined(vtkComponent1Proportional)\n    {\n      const int component = 1;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 3rd component\n  #if vtkNumberOfComponents > 2 && !defined(vtkComponent2Proportional)\n    {\n      const int component = 2;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  // optionally compute the 4th component\n  #if vtkNumberOfComponents > 3 && !defined(vtkComponent3Proportional)\n    {\n      const int component = 3;\n      vec3 normal = vec3(distX[component], distY[component], distZ[component]);\n      float normalLength = length(normal);\n      if (normalLength > 0.0) {\n        normal = normalize(vecISToVC(normal));\n      }\n      result[component] = vec4(normal, normalLength);\n    }\n  #endif\n\n  return result;\n}\n\n//=======================================================================\n// global shadow - secondary ray\n\n// henyey greenstein phase function\nfloat phaseFunction(float cos_angle) {\n  // divide by 2.0 instead of 4pi to increase intensity\n  float anisotropy = volume.anisotropy;\n  if (abs(anisotropy) <= EPSILON) {\n    // isotropic scatter returns 0.5 instead of 1/4pi to increase intensity\n    return 0.5;\n  }\n  float anisotropy2 = volume.anisotropySquared;\n  return ((1.0 - anisotropy2) /\n          pow(1.0 + anisotropy2 - 2.0 * anisotropy * cos_angle, 1.5)) /\n         2.0;\n}\n\n// Compute the two intersection distances of the ray with the volume in VC\n// The entry point is `rayOriginVC + distanceMin * rayDirVC` and the exit point\n// is `rayOriginVC + distanceMax * rayDirVC` If distanceMin < distanceMax, the\n// volume is not intersected The ray origin is inside the box when distanceMin <\n// 0.0 < distanceMax\nvec2 rayIntersectVolumeDistances(vec3 rayOriginVC, vec3 rayDirVC) {\n  // Compute origin and direction in IS\n  vec3 rayOriginIS = posVCtoIS(rayOriginVC);\n  vec3 rayDirIS = vecVCToIS(rayDirVC);\n  // Don't check for infinity as the min/max combination afterward will always\n  // find an intersection before infinity\n  vec3 invDir = 1.0 / rayDirIS;\n\n  // We have: bound = origin + t * dir\n  // So: t = (1/dir) * (bound - origin)\n  vec3 distancesTo0 = invDir * (vec3(0.0) - rayOriginIS);\n  vec3 distancesTo1 = invDir * (vec3(1.0) - rayOriginIS);\n  // Min and max distances to plane intersection per plane\n  vec3 dMinPerAxis = min(distancesTo0, distancesTo1);\n  vec3 dMaxPerAxis = max(distancesTo0, distancesTo1);\n  // Overall first and last intersection\n  float distanceMin = max(dMinPerAxis.x, max(dMinPerAxis.y, dMinPerAxis.z));\n  float distanceMax = min(dMaxPerAxis.x, min(dMaxPerAxis.y, dMaxPerAxis.z));\n  return vec2(distanceMin, distanceMax);\n}\n\n//=======================================================================\n// local ambient occlusion\n#if vtkMaxLaoKernelSize > 0\n\n  // Return a random point on the unit sphere\n  vec3 sampleDirectionUniform(int rayIndex) {\n    // Each ray of each fragment should be different, two sources of randomness\n    // are used. Only depends on ray index\n    vec2 rayRandomness = kernelSample[rayIndex];\n    // Only depends on fragment\n    float fragmentRandomness = fragmentSeed;\n    // Merge both source of randomness in a single uniform random variable using\n    // the formula (x+y < 1 ? x+y : x+y-1). The simpler formula (x+y)/2 doesn't\n    // result in a uniform distribution\n    vec2 mergedRandom = rayRandomness + vec2(fragmentRandomness);\n    mergedRandom -= vec2(greaterThanEqual(mergedRandom, vec2(1.0)));\n\n    // Insipred by:\n    // https://karthikkaranth.me/blog/generating-random-points-in-a-sphere/#better-choice-of-spherical-coordinates\n    float u = mergedRandom[0];\n    float v = mergedRandom[1];\n    float theta = u * 2.0 * PI;\n    float phi = acos(2.0 * v - 1.0);\n    float sinTheta = sin(theta);\n    float cosTheta = cos(theta);\n    float sinPhi = sin(phi);\n    float cosPhi = cos(phi);\n    return vec3(sinPhi * cosTheta, sinPhi * sinTheta, cosPhi);\n  }\n\n  float computeLAO(vec3 posVC, vec4 normalVC, float originalOpacity) {\n    // apply LAO only at selected locations, otherwise return full brightness\n    if (normalVC.w <= 0.0 || originalOpacity <= 0.05) {\n      return 1.0;\n    }\n\n    #ifdef EnabledGradientOpacity\n      float gradientOpacityFactor = computeGradientOpacityFactor(normalVC.w, 0);\n    #endif\n\n    float visibilitySum = 0.0;\n    float weightSum = 0.0;\n    for (int i = 0; i < volume.kernelSize; i++) {\n      // Only sample on an hemisphere around the normalVC.xyz axis, so\n      // normalDotRay should be negative\n      vec3 rayDirectionVC = sampleDirectionUniform(i);\n      float normalDotRay = dot(normalVC.xyz, rayDirectionVC);\n      if (normalDotRay > 0.0) {\n        // Flip rayDirectionVC when it is in the wrong hemisphere\n        rayDirectionVC = -rayDirectionVC;\n        normalDotRay = -normalDotRay;\n      }\n\n      vec3 currPosIS = posVCtoIS(posVC);\n      float visibility = 1.0;\n      vec3 randomDirStepIS = vecVCToIS(rayDirectionVC * sampleDistance);\n      for (int j = 0; j < volume.kernelRadius; j++) {\n        currPosIS += randomDirStepIS;\n        // If out of the volume, we are done\n        if (any(lessThan(currPosIS, vec3(0.0))) ||\n            any(greaterThan(currPosIS, vec3(1.0)))) {\n          break;\n        }\n        float opacity = getOpacityFromTexture(getTextureValue(currPosIS).r, 0, 0.5);\n        #ifdef EnabledGradientOpacity\n          opacity *= gradientOpacityFactor;\n        #endif\n        visibility *= 1.0 - opacity;\n        // If visibility is less than EPSILON, consider it to be 0\n        if (visibility < EPSILON) {\n          visibility = 0.0;\n          break;\n        }\n      }\n      float rayWeight = -normalDotRay;\n      visibilitySum += visibility * rayWeight;\n      weightSum += rayWeight;\n    }\n\n    // If no sample, LAO factor is one\n    if (weightSum == 0.0) {\n      return 1.0;\n    }\n\n    // LAO factor is the average visibility:\n    // - visibility low => ambient low\n    // - visibility high => ambient high\n    float lao = visibilitySum / weightSum;\n\n    // Reduce variance by clamping\n    return clamp(lao, 0.3, 1.0);\n  }\n#endif\n\n//=======================================================================\n// Volume shadows\n#if vtkNumberOfLights > 0\n\n  // Non-memoised version\n  float computeVolumeShadowWithoutCache(vec3 posVC, vec3 lightDirNormVC) {\n    // modify sample distance with a random number between 1.5 and 3.0\n    float rayStepLength =\n        volumeShadowSampleDistance * mix(1.5, 3.0, fragmentSeed);\n\n    // in case the first sample near surface has a very tiled light ray, we need\n    // to offset start position\n    vec3 initialPosVC = posVC + rayStepLength * lightDirNormVC;\n\n    #ifdef vtkClippingPlanesOn\n      float clippingPlanesMaxDistance = infinity;\n      for (int i = 0; i < clip_numPlanes; ++i) {\n        // Find distance of intersection with the plane\n        // Points are clipped when:\n        // dot(planeOrigin - (rayOrigin + distance * rayDirection), planeNormal) > 0\n        // This is equivalent to:\n        // dot(planeOrigin - rayOrigin, planeNormal) - distance * dot(rayDirection,\n        // planeNormal) > 0.0\n        // We precompute the dot products, so we clip ray points when:\n        // dotOrigin - distance * dotDirection > 0.0\n        float dotOrigin =\n            dot(vClipPlaneOrigins[i] - initialPosVC, vClipPlaneNormals[i]);\n        if (dotOrigin > 0.0) {\n          // The initialPosVC is clipped by this plane\n          return 1.0;\n        }\n        float dotDirection = dot(lightDirNormVC, vClipPlaneNormals[i]);\n        if (dotDirection < 0.0) {\n          // We only hit the plane if dotDirection is negative, as (distance is\n          // positive)\n          float intersectionDistance =\n              dotOrigin / dotDirection; // negative divided by negative => positive\n          clippingPlanesMaxDistance =\n              min(clippingPlanesMaxDistance, intersectionDistance);\n        }\n      }\n    #endif\n\n    vec2 intersectionDistances =\n        rayIntersectVolumeDistances(initialPosVC, lightDirNormVC);\n\n    if (intersectionDistances[1] <= intersectionDistances[0] ||\n        intersectionDistances[1] <= 0.0) {\n      // Volume not hit or behind the ray\n      return 1.0;\n    }\n\n    // When globalIlluminationReach is 0, no sample at all\n    // When globalIlluminationReach is 1, the ray will go through the whole\n    // volume\n    float maxTravelDistance = mix(0.0, volume.diagonalLength,\n                                  volume.globalIlluminationReach);\n    float startDistance = max(intersectionDistances[0], 0.0);\n    float endDistance = min(intersectionDistances[1], startDistance + maxTravelDistance);\n    #ifdef vtkClippingPlanesOn\n      endDistance = min(endDistance, clippingPlanesMaxDistance);\n    #endif\n    if (endDistance - startDistance < 0.0) {\n      return 1.0;\n    }\n\n    // These two variables are used to compute posIS, without having to call\n    // VCtoIS at each step\n    vec3 initialPosIS = posVCtoIS(initialPosVC);\n    // The light dir is scaled and rotated, but not translated, as it is a\n    // vector (w = 0)\n    vec3 scaledLightDirIS = vecVCToIS(lightDirNormVC);\n\n    float shadow = 1.0;\n    for (float currentDistance = startDistance; currentDistance <= endDistance;\n          currentDistance += rayStepLength) {\n      vec3 posIS = initialPosIS + currentDistance * scaledLightDirIS;\n      vec4 scalar = getTextureValue(posIS);\n      float opacity = getOpacityFromTexture(scalar.r, 0, 0.5);\n      #if defined(EnabledGradientOpacity) && !defined(EnabledIndependentComponents)\n        vec3 scalarInterp[2];\n        vec4 normal = computeNormalForDensity(posIS, scalarInterp, 3);\n        float opacityFactor = computeGradientOpacityFactor(normal.w, 0);\n        opacity *= opacityFactor;\n      #endif\n      shadow *= 1.0 - opacity;\n\n      // Early termination if shadow coeff is near 0.0\n      if (shadow < EPSILON) {\n        return 0.0;\n      }\n    }\n    return shadow;\n  }\n\n  // Some cache for volume shadows\n  struct {\n    vec3 posVC;\n    float shadow;\n  } cachedShadows[vtkNumberOfLights];\n\n  // Memoised version\n  float computeVolumeShadow(vec3 posVC, vec3 lightDirNormVC, int lightIdx) {\n    if (posVC == cachedShadows[lightIdx].posVC) {\n      return cachedShadows[lightIdx].shadow;\n    }\n    float shadow = computeVolumeShadowWithoutCache(posVC, lightDirNormVC);\n    cachedShadows[lightIdx].posVC = posVC;\n    cachedShadows[lightIdx].shadow = shadow;\n    return shadow;\n  }\n\n#endif\n\n//=======================================================================\n// surface light contribution\n#if vtkNumberOfLights > 0\n  vec3 applyLighting(vec3 tColor, vec4 normalVC) {\n    vec3 diffuse = vec3(0.0, 0.0, 0.0);\n    vec3 specular = vec3(0.0, 0.0, 0.0);\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\n      float df = dot(normalVC.xyz, lights[lightIdx].directionVC);\n      if (df > 0.0) {\n        diffuse += df * lights[lightIdx].color;\n        float sf = dot(normalVC.xyz, -lights[lightIdx].halfAngleVC);\n        if (sf > 0.0) {\n          specular += pow(sf, volume.specularPower) * lights[lightIdx].color;\n        }\n      }\n    }\n    return tColor * (diffuse * volume.diffuse + volume.ambient) +\n          specular * volume.specular;\n  }\n\n  vec3 applySurfaceShadowLighting(vec3 tColor, float alpha, vec3 posVC,\n                                  vec4 normalVC) {\n    // everything in VC\n    vec3 diffuse = vec3(0.0);\n    vec3 specular = vec3(0.0);\n    for (int ligthIdx = 0; ligthIdx < vtkNumberOfLights; ligthIdx++) {\n      vec3 vertLightDirection;\n      float attenuation;\n      if (lights[ligthIdx].isPositional == 1) {\n        vertLightDirection = posVC - lights[ligthIdx].positionVC;\n        float lightDistance = length(vertLightDirection);\n        // Normalize with precomputed length\n        vertLightDirection = vertLightDirection / lightDistance;\n        // Base attenuation\n        vec3 attenuationPolynom = lights[ligthIdx].attenuation;\n        attenuation =\n            1.0 / (attenuationPolynom[0] +\n                  lightDistance * (attenuationPolynom[1] +\n                                    lightDistance * attenuationPolynom[2]));\n        // Cone attenuation\n        float coneDot = dot(vertLightDirection, lights[ligthIdx].directionVC);\n        // Per OpenGL standard cone angle is 90 or less for a spot light\n        if (lights[ligthIdx].coneAngle <= 90.0) {\n          if (coneDot >= cos(radians(lights[ligthIdx].coneAngle))) {\n            // Inside the cone\n            attenuation *= pow(coneDot, lights[ligthIdx].exponent);\n          } else {\n            // Outside the cone\n            attenuation = 0.0;\n          }\n        }\n      } else {\n        vertLightDirection = lights[ligthIdx].directionVC;\n        attenuation = 1.0;\n      }\n\n      float ndotL = dot(normalVC.xyz, vertLightDirection);\n      if (ndotL < 0.0 && twoSidedLighting == 1) {\n        ndotL = -ndotL;\n      }\n      if (ndotL > 0.0) {\n        // Diffuse\n        diffuse += ndotL * attenuation * lights[ligthIdx].color;\n        // Specular\n        float vdotR =\n            dot(-rayDirVC, normalize(vertLightDirection - 2.0 * ndotL * normalVC.xyz));\n        if (vdotR > 0.0) {\n          specular += pow(vdotR, volume.specularPower) * attenuation *\n                      lights[ligthIdx].color;\n        }\n      }\n    }\n    #if vtkMaxLaoKernelSize > 0\n      float laoFactor = computeLAO(posVC, normalVC, alpha);\n    #else\n      const float laoFactor = 1.0;\n    #endif\n    return tColor * (diffuse * volume.diffuse +\n                    volume.ambient * laoFactor) +\n          specular * volume.specular;\n  }\n\n  vec3 applyVolumeShadowLighting(vec3 tColor, vec3 posVC) {\n    // Here we have no effect of cones and no attenuation\n    vec3 diffuse = vec3(0.0);\n    for (int lightIdx = 0; lightIdx < vtkNumberOfLights; lightIdx++) {\n      vec3 lightDirVC = lights[lightIdx].isPositional == 1\n                            ? normalize(lights[lightIdx].positionVC - posVC)\n                            : -lights[lightIdx].directionVC;\n      float shadowCoeff = computeVolumeShadow(posVC, lightDirVC, lightIdx);\n      float phaseAttenuation = phaseFunction(dot(rayDirVC, lightDirVC));\n      diffuse += phaseAttenuation * shadowCoeff * lights[lightIdx].color;\n    }\n    return tColor * (diffuse * volume.diffuse + volume.ambient);\n  }\n#endif\n\n// LAO of surface shadows and volume shadows only work with dependent components\nvec3 applyAllLightning(vec3 tColor, float alpha, vec3 posVC,\n                       vec4 surfaceNormalVC) {\n  #if vtkNumberOfLights > 0\n    // 0 <= volCoeff < EPSILON => only surface shadows\n    // EPSILON <= volCoeff < 1 - EPSILON => mix of surface and volume shadows\n    // 1 - EPSILON <= volCoeff => only volume shadows\n    float volCoeff = volume.volumetricScatteringBlending *\n                    (1.0 - alpha / 2.0) *\n                    (1.0 - atan(surfaceNormalVC.w) * INV4PI);\n\n    // Compute surface lighting if needed\n    vec3 surfaceShadedColor = tColor;\n    #ifdef EnableSurfaceLighting\n      if (volCoeff < 1.0 - EPSILON) {\n        surfaceShadedColor =\n            applySurfaceShadowLighting(tColor, alpha, posVC, surfaceNormalVC);\n      }\n    #endif\n\n    // Compute volume lighting if needed\n    vec3 volumeShadedColor = tColor;\n    #ifdef EnableVolumeLighting\n      if (volCoeff >= EPSILON) {\n        volumeShadedColor = applyVolumeShadowLighting(tColor, posVC);\n      }\n    #endif\n\n    // Return the right mix\n    if (volCoeff < EPSILON) {\n      // Surface shadows\n      return surfaceShadedColor;\n    }\n    if (volCoeff >= 1.0 - EPSILON) {\n      // Volume shadows\n      return volumeShadedColor;\n    }\n    // Mix of surface and volume shadows\n    return mix(surfaceShadedColor, volumeShadedColor, volCoeff);\n  #endif\n  return tColor;\n}\n\nvec4 getColorForLabelOutline() {\n  vec3 centerPosIS =\n      fragCoordToIndexSpace(gl_FragCoord); // pos in texture space\n  vec4 centerValue = getTextureValue(centerPosIS);\n  bool pixelOnBorder = false;\n  vec4 tColor = vec4(getColorFromTexture(centerValue.r, 0, 0.5),\n                     getOpacityFromTexture(centerValue.r, 0, 0.5));\n\n  int segmentIndex = int(centerValue.r * 255.0);\n\n  // Use texture sampling for outlineThickness\n  float textureCoordinate = float(segmentIndex - 1) / 1024.0;\n  float textureValue =\n      texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\n  int actualThickness = int(textureValue * 255.0);\n\n  // If it is the background (segment index 0), we should quickly bail out.\n  // Previously, this was determined by tColor.a, which was incorrect as it\n  // prevented the outline from appearing when the fill is 0.\n  if (segmentIndex == 0) {\n    return vec4(0, 0, 0, 0);\n  }\n\n  // Only perform outline check on fragments rendering voxels that aren't\n  // invisible. Saves a bunch of needless checks on the background.\n  // TODO define epsilon when building shader?\n  for (int i = -actualThickness; i <= actualThickness; i++) {\n    for (int j = -actualThickness; j <= actualThickness; j++) {\n      if (i == 0 || j == 0) {\n        continue;\n      }\n\n      vec4 neighborPixelCoord =\n          vec4(gl_FragCoord.x + float(i), gl_FragCoord.y + float(j),\n               gl_FragCoord.z, gl_FragCoord.w);\n\n      vec3 neighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n      vec4 value = getTextureValue(neighborPosIS);\n\n      // If any of my neighbours are not the same value as I\n      // am, this means I am on the border of the segment.\n      // We can break the loops\n      if (any(notEqual(value, centerValue))) {\n        pixelOnBorder = true;\n        break;\n      }\n    }\n\n    if (pixelOnBorder == true) {\n      break;\n    }\n  }\n\n  // If I am on the border, I am displayed at full opacity\n  if (pixelOnBorder == true) {\n    tColor.a = volume.outlineOpacity;\n  }\n\n  return tColor;\n}\n\nvec4 getColorForAdditivePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\n  // compute normals\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\n  vec4 normalLights[2];\n  normalLights[0] = normalMat[0];\n  normalLights[1] = normalMat[1];\n  #if vtkNumberOfLights > 0\n    if (volume.computeNormalFromOpacity == 1) {\n      for (int component = 0; component < 2; ++component) {\n        vec3 scalarInterp[2];\n        float height = volume.transferFunctionsSampleHeight[component];\n        computeNormalForDensity(posIS, scalarInterp, component);\n        normalLights[component] =\n            computeDensityNormal(scalarInterp, height, 1.0, component);\n      }\n    }\n  #endif\n\n  // compute opacities\n  float opacities[2];\n  opacities[0] = getOpacityFromTexture(\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\n  opacities[1] = getOpacityFromTexture(\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\n  #ifdef EnabledGradientOpacity\n    for (int component = 0; component < 2; ++component) {\n      opacities[component] *=\n          computeGradientOpacityFactor(normalMat[component].a, component);\n    }\n  #endif\n  float opacitySum = opacities[0] + opacities[1];\n  if (opacitySum <= 0.0) {\n    return vec4(0.0);\n  }\n\n  // mix the colors and opacities\n  vec3 colors[2];\n  for (int component = 0; component < 2; ++component) {\n    float sampleHeight = volume.transferFunctionsSampleHeight[component];\n    vec3 color = getColorFromTexture(tValue[component], component, sampleHeight);\n    color = applyAllLightning(color, opacities[component], posVC,\n                              normalLights[component]);\n    colors[component] = color;\n  }\n  vec3 mixedColor =\n      (opacities[0] * colors[0] + opacities[1] * colors[1]) / opacitySum;\n  return vec4(mixedColor, min(1.0, opacitySum));\n}\n\nvec4 getColorForColorizePreset(vec4 tValue, vec3 posVC, vec3 posIS) {\n  // compute normals\n  mat4 normalMat = computeMat4Normal(posIS, tValue);\n  vec4 normalLight = normalMat[0];\n  #if vtkNumberOfLights > 0\n    if (volume.computeNormalFromOpacity == 1) {\n      vec3 scalarInterp[2];\n      float height = volume.transferFunctionsSampleHeight[0];\n      computeNormalForDensity(posIS, scalarInterp, 0);\n      normalLight = computeDensityNormal(scalarInterp, height, 1.0, 0);\n    }\n  #endif\n\n  // compute opacities\n  float opacity = getOpacityFromTexture(\n      tValue[0], 0, volume.transferFunctionsSampleHeight[0]);\n  #ifdef EnabledGradientOpacity\n    opacity *= computeGradientOpacityFactor(normalMat[0].a, 0);\n  #endif\n\n  // colorizing component\n  vec3 colorizingColor = getColorFromTexture(\n      tValue[0], 1, volume.transferFunctionsSampleHeight[1]);\n  float colorizingOpacity = getOpacityFromTexture(\n      tValue[1], 1, volume.transferFunctionsSampleHeight[1]);\n\n  // mix the colors and opacities\n  vec3 color =\n      getColorFromTexture(tValue[0], 0,\n                          volume.transferFunctionsSampleHeight[0]) *\n      mix(vec3(1.0), colorizingColor, colorizingOpacity);\n  color = applyAllLightning(color, opacity, posVC, normalLight);\n  return vec4(color, opacity);\n}\n\nvec4 getColorForDefaultIndependentPreset(vec4 tValue, vec3 posIS) {\n\n  // compute the normal vectors as needed\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\n    mat4 normalMat = computeMat4Normal(posIS, tValue);\n  #endif\n\n  // process color and opacity for each component\n  // initial value of alpha is determined by wether the first component is\n  // proportional or not\n  #if defined(vtkComponent0Proportional)\n    // when it is proportional, it starts at 1 (neutral for multiplications)\n    float alpha = 1.0;\n  #else\n    // when it is not proportional, it starts at 0 (neutral for additions)\n    float alpha = 0.0;\n  #endif\n\n  vec3 mixedColor = vec3(0.0);\n  #if vtkNumberOfComponents > 0\n    {\n      const int component = 0;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent0Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 1\n    {\n      const int component = 1;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent1Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 2\n    {\n      const int component = 2;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent2Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n  #if vtkNumberOfComponents > 3\n    {\n      const int component = 3;\n      vec3 color = getColorFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      float opacity = getOpacityFromTexture(\n          tValue[component], component,\n          volume.transferFunctionsSampleHeight[component]);\n      #if !defined(vtkComponent3Proportional)\n        float alphaContribution = volume.independentComponentMix[component] * opacity;\n        #ifdef EnabledGradientOpacity\n          alphaContribution *= computeGradientOpacityFactor(normalMat[component].a, component);\n        #endif\n        alpha += alphaContribution;\n        #if vtkNumberOfLights > 0\n          color = applyLighting(color, normalMat[component]);\n        #endif\n      #else\n        color *= opacity;\n        alpha *= mix(opacity, 1.0,\n                    (1.0 - volume.independentComponentMix[component]));\n      #endif\n      mixedColor += volume.independentComponentMix[component] * color;\n    }\n  #endif\n\n  return vec4(mixedColor, alpha);\n}\n\nvec4 getColorForDependentComponents(vec4 tValue, vec3 posVC, vec3 posIS) {\n  #if defined(EnabledGradientOpacity) || vtkNumberOfLights > 0\n    // use component 3 of the opacity texture as getTextureValue() sets alpha to\n    // the opacity value\n    vec3 scalarInterp[2];\n    vec4 normal0 = computeNormalForDensity(posIS, scalarInterp, 3);\n    float gradientOpacity = computeGradientOpacityFactor(normal0.a, 0);\n  #endif\n\n  // get color and opacity\n  #if vtkNumberOfComponents == 1\n    vec3 tColor = getColorFromTexture(tValue.r, 0, 0.5);\n    float alpha = getOpacityFromTexture(tValue.r, 0, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 2\n    vec3 tColor = vec3(tValue.r * volume.colorTextureScale[0] +\n                  volume.colorTextureShift[0]);\n    float alpha = getOpacityFromTexture(tValue.a, 1, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 3\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\n              volume.colorTextureShift.rgb;\n      float alpha = getOpacityFromTexture(tValue.a, 0, 0.5);\n  #endif\n  #if vtkNumberOfComponents == 4\n      vec3 tColor = tValue.rgb * volume.colorTextureScale.rgb +\n              volume.colorTextureShift.rgb;\n      float alpha = getOpacityFromTexture(tValue.a, 3, 0.5);\n  #endif\n\n  // Apply gradient opacity\n  #if defined(EnabledGradientOpacity)\n    alpha *= gradientOpacity;\n  #endif\n\n  #if vtkNumberOfComponents == 1\n    if (alpha < EPSILON) {\n      return vec4(0.0);\n    }\n  #endif\n\n  // lighting\n  #if vtkNumberOfLights > 0\n    vec4 normalLight;\n    if (volume.computeNormalFromOpacity == 1) {\n      if (normal0[3] != 0.0) {\n        normalLight =\n            computeDensityNormal(scalarInterp, 0.5, gradientOpacity, 0);\n        if (normalLight[3] == 0.0) {\n          normalLight = normal0;\n        }\n      }\n    } else {\n      normalLight = normal0;\n    }\n    tColor = applyAllLightning(tColor, alpha, posVC, normalLight);\n  #endif\n\n  return vec4(tColor, alpha);\n}\n\nvec4 getColorForValue(vec4 tValue, vec3 posVC, vec3 posIS) {\n  #ifdef EnableColorForValueFunctionId0\n    return getColorForDependentComponents(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId1\n    return getColorForAdditivePreset(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId2\n    return getColorForColorizePreset(tValue, posVC, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId3\n    /*\n      * Mix the color information from all the independent components to get a\n      * single rgba output. See other shader functions like\n      * `getColorForAdditivePreset` to learn how to create a custom color mix.\n      * The custom color mix should return a value, but if it doesn't, it will\n      * fallback on the default shading\n      */\n    //VTK::CustomColorMix\n  #endif\n\n  #if defined(EnableColorForValueFunctionId4) || defined(EnableColorForValueFunctionId3)\n    return getColorForDefaultIndependentPreset(tValue, posIS);\n  #endif\n\n  #ifdef EnableColorForValueFunctionId5\n    return getColorForLabelOutline();\n  #endif\n}\n\nbool valueWithinScalarRange(vec4 val) {\n  #if vtkNumberOfComponents > 1 && !defined(EnabledIndependentComponents)\n    return false;\n  #endif\n  vec4 rangeMin = volume.ipScalarRangeMin;\n  vec4 rangeMax = volume.ipScalarRangeMax;\n  for (int component = 0; component < vtkNumberOfComponents; ++component) {\n    if (val[component] < rangeMin[component] ||\n        rangeMax[component] < val[component]) {\n      return false;\n    }\n  }\n  return true;\n}\n\n#if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\n  bool checkOnEdgeForNeighbor(int xFragmentOffset, int yFragmentOffset,\n                              int segmentIndex, vec3 stepIS) {\n    vec3 volumeDimensions = vec3(volume.dimensions);\n    vec4 neighborPixelCoord = vec4(gl_FragCoord.x + float(xFragmentOffset),\n                                  gl_FragCoord.y + float(yFragmentOffset),\n                                  gl_FragCoord.z, gl_FragCoord.w);\n    vec3 originalNeighborPosIS = fragCoordToIndexSpace(neighborPixelCoord);\n\n    vec3 neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\n      vec4 texValue = rawFetchTexture(texCoord);\n      if (int(texValue.g) == segmentIndex) {\n        // not on edge\n        return false;\n      }\n      neighborPosIS += stepIS;\n    }\n\n    neighborPosIS = originalNeighborPosIS;\n    for (int k = 0; k < vtkMaximumNumberOfSamples / 2; ++k) {\n      ivec3 texCoord = ivec3(neighborPosIS * volumeDimensions);\n      vec4 texValue = rawFetchTexture(texCoord);\n      if (int(texValue.g) == segmentIndex) {\n        // not on edge\n        return false;\n      }\n      neighborPosIS -= stepIS;\n    }\n\n    // onedge\n    float sampleHeight = volume.transferFunctionsSampleHeight[1];\n    vec3 tColorSegment =\n        getColorFromTexture(float(segmentIndex), 1, sampleHeight);\n    float pwfValueSegment =\n        getOpacityFromTexture(float(segmentIndex), 1, sampleHeight);\n    gl_FragData[0] = vec4(tColorSegment, pwfValueSegment);\n    return true;\n  }\n#endif\n\nvec4 getColorAtPos(vec3 posVC) {\n  vec3 posIS = posVCtoIS(posVC);\n  vec4 texValue = getTextureValue(posIS);\n  return getColorForValue(texValue, posVC, posIS);\n}\n\n//=======================================================================\n// Apply the specified blend mode operation along the ray's path.\n//\nvoid applyBlend(vec3 rayOriginVC, vec3 rayDirVC, float minDistance,\n                float maxDistance) {\n  // start slightly inside and apply some jitter\n  vec3 stepVC = rayDirVC * sampleDistance;\n  float raySteps = (maxDistance - minDistance) / sampleDistance;\n\n  // Avoid 0.0 jitter\n  float jitter = 0.01 + 0.99 * fragmentSeed;\n\n  #if vtkBlendMode == COMPOSITE_BLEND\n    // now map through opacity and color\n    vec3 firstPosVC = rayOriginVC + minDistance * rayDirVC;\n    vec4 firstColor = getColorAtPos(firstPosVC);\n\n    // handle very thin volumes\n    if (raySteps <= 1.0) {\n      firstColor.a = 1.0 - pow(1.0 - firstColor.a, raySteps);\n      gl_FragData[0] = firstColor;\n      return;\n    }\n\n    // first color only counts for `jitter` factor of the step\n    firstColor.a = 1.0 - pow(1.0 - firstColor.a, jitter);\n    vec4 color = vec4(firstColor.rgb * firstColor.a, firstColor.a);\n    vec3 posVC = firstPosVC + jitter * stepVC;\n    float stepsTraveled = jitter;\n\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n      vec4 tColor = getColorAtPos(posVC);\n\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * (1.0 - color.a);\n      stepsTraveled++;\n      posVC += stepVC;\n      if (color.a > 0.99) {\n        color.a = 1.0;\n        break;\n      }\n    }\n\n    if (color.a < 0.99 && (raySteps - stepsTraveled) > 0.0) {\n      vec3 endPosVC = rayOriginVC + maxDistance * rayDirVC;\n      vec4 tColor = getColorAtPos(endPosVC);\n      tColor.a = 1.0 - pow(1.0 - tColor.a, raySteps - stepsTraveled);\n\n      float mix = (1.0 - color.a);\n      color = color + vec4(tColor.rgb * tColor.a, tColor.a) * mix;\n    }\n\n    gl_FragData[0] = vec4(color.rgb / color.a, color.a);\n  #endif\n\n  #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND ||                                 \\\n      vtkBlendMode == MINIMUM_INTENSITY_BLEND\n    // Find maximum/minimum intensity along the ray.\n\n    // Define the operation we will use (min or max)\n    #if vtkBlendMode == MAXIMUM_INTENSITY_BLEND\n      #define OP max\n    #else\n      #define OP min\n    #endif\n\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    // Find a value to initialize the selected variables\n    vec4 selectedValue;\n    vec3 selectedPosVC;\n    vec3 selectedPosIS;\n    {\n      vec3 posIS = posVCtoIS(posVC);\n      selectedValue = getTextureValue(posIS);\n      selectedPosVC = posVC;\n      selectedPosIS = posIS;\n    }\n\n    // If the clipping range is shorter than the sample distance\n    // we can skip the sampling loop along the ray.\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\n      return;\n    }\n\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      // Get selected values\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 previousSelectedValue = selectedValue;\n      vec4 currentValue = getTextureValue(posIS);\n      selectedValue = OP(selectedValue, currentValue);\n      if (previousSelectedValue != selectedValue) {\n        selectedPosVC = posVC;\n        selectedPosIS = posIS;\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posVC += stepVC;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posVC = rayOriginVC + maxDistance * rayDirVC;\n    {\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 previousSelectedValue = selectedValue;\n      vec4 currentValue = getTextureValue(posIS);\n      selectedValue = OP(selectedValue, currentValue);\n      if (previousSelectedValue != selectedValue) {\n        selectedPosVC = posVC;\n        selectedPosIS = posIS;\n      }\n    }\n\n    gl_FragData[0] = getColorForValue(selectedValue, selectedPosVC, selectedPosIS);\n  #endif\n\n  #if vtkBlendMode == ADDITIVE_INTENSITY_BLEND ||                                \\\n      vtkBlendMode == AVERAGE_INTENSITY_BLEND\n    vec4 sum = vec4(0.);\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n      float totalWeight = 0.0;\n    #endif\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    vec3 posIS = posVCtoIS(posVC);\n    vec4 value = getTextureValue(posIS);\n\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(value * raySteps, posVC, posIS);\n      return;\n    }\n\n    if (valueWithinScalarRange(value)) {\n      sum += value * jitter;\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n        totalWeight += jitter;\n      #endif\n    }\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      posIS = posVCtoIS(posVC);\n      value = getTextureValue(posIS);\n      // One can control the scalar range by setting the AverageIPScalarRange to\n      // disregard scalar values, not in the range of interest, from the average\n      // computation. Notes:\n      // - We are comparing all values in the texture to see if any of them\n      //   are outside of the scalar range. In the future we might want to allow\n      //   scalar ranges for each component.\n      if (valueWithinScalarRange(value)) {\n        sum += value;\n        #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n          totalWeight++;\n        #endif\n      }\n\n      stepsTraveled++;\n      posVC += stepVC;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posVC = rayOriginVC + maxDistance * rayDirVC;\n    posIS = posVCtoIS(posVC);\n    value = getTextureValue(posIS);\n    if (valueWithinScalarRange(value)) {\n      sum += value;\n      #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n        totalWeight += raySteps - stepsTraveled;\n      #endif\n    }\n\n    #if vtkBlendMode == AVERAGE_INTENSITY_BLEND\n      sum /= vec4(totalWeight, totalWeight, totalWeight, 1.0);\n    #endif\n\n    gl_FragData[0] = getColorForValue(sum, posVC, posIS);\n  #endif\n\n  #if vtkBlendMode == RADON_TRANSFORM_BLEND\n    float normalizedRayIntensity = 1.0;\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n\n    // handle very thin volumes\n    if (raySteps <= 1.0) {\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 tValue = getTextureValue(posIS);\n      normalizedRayIntensity -= raySteps * sampleDistance *\n                                getOpacityFromTexture(tValue.r, 0, 0.5);\n      gl_FragData[0] =\n          vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\n      return;\n    }\n\n    posVC += jitter * stepVC;\n    stepsTraveled += jitter;\n\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      vec3 posIS = posVCtoIS(posVC);\n      vec4 value = getTextureValue(posIS);\n      // Convert scalar value to normalizedRayIntensity coefficient and\n      // accumulate normalizedRayIntensity\n      normalizedRayIntensity -=\n          sampleDistance * getOpacityFromTexture(value.r, 0, 0.5);\n\n      posVC += stepVC;\n      stepsTraveled++;\n    }\n\n    // map normalizedRayIntensity to color\n    gl_FragData[0] =\n        vec4(getColorFromTexture(normalizedRayIntensity, 0, 0.5), 1.0);\n  #endif\n\n  #if vtkBlendMode == LABELMAP_EDGE_PROJECTION_BLEND\n    // Only works with a single volume\n    vec3 posVC = rayOriginVC + minDistance * rayDirVC;\n    float stepsTraveled = 0.0;\n    vec3 posIS = posVCtoIS(posVC);\n    vec4 tValue = getTextureValue(posIS);\n    if (raySteps <= 1.0) {\n      gl_FragData[0] = getColorForValue(tValue, posVC, posIS);\n      return;\n    }\n\n    vec3 stepIS = vecVCToIS(stepVC);\n    vec4 value = tValue;\n    posIS += jitter * stepIS;\n    stepsTraveled += jitter;\n    vec3 maxPosIS = posIS; // Store the position of the max value\n    int segmentIndex = int(value.g);\n    bool originalPosHasSeenNonZero = false;\n\n    if (segmentIndex != 0) {\n      // Tried using the segment index in an boolean array but reading\n      // from the array by dynamic indexing was horrondously slow\n      // so use bit masking instead and assign 1 to the bit corresponding to the\n      // segment index and later check if the bit is set via bit operations\n      setLabelOutlineBit(segmentIndex);\n    }\n\n    // Sample along the ray until vtkMaximumNumberOfSamples,\n    // ending slightly inside the total distance\n    for (int i = 0; i < vtkMaximumNumberOfSamples; ++i) {\n      // If we have reached the last step, break\n      if (stepsTraveled + 1.0 >= raySteps) {\n        break;\n      }\n\n      // compute the scalar\n      tValue = getTextureValue(posIS);\n      segmentIndex = int(tValue.g);\n\n      if (segmentIndex != 0) {\n        originalPosHasSeenNonZero = true;\n        setLabelOutlineBit(segmentIndex);\n      }\n\n      if (tValue.r > value.r) {\n        value = tValue;   // Update the max value\n        maxPosIS = posIS; // Update the position where max occurred\n      }\n\n      // Otherwise, continue along the ray\n      stepsTraveled++;\n      posIS += stepIS;\n    }\n\n    // Perform the last step along the ray using the\n    // residual distance\n    posIS = posVCtoIS(rayOriginVC + maxDistance * rayDirVC);\n    tValue = getTextureValue(posIS);\n\n    if (tValue.r > value.r) {\n      value = tValue;   // Update the max value\n      maxPosIS = posIS; // Update the position where max occurred\n    }\n\n    // If we have not seen any non-zero segments, we can return early\n    // and grab color from the actual center value first component (image)\n    if (!originalPosHasSeenNonZero) {\n      vec3 maxPosVC = posIStoVC(maxPosIS);\n      gl_FragData[0] = getColorForValue(value, maxPosVC, maxPosIS);\n      return;\n    }\n\n    vec3 neighborRayStepsIS = stepIS;\n    float neighborRaySteps = raySteps;\n    bool shouldLookInAllNeighbors = false;\n\n    vec3 volumeSpacings = volume.spacing;\n    float minVoxelSpacing =\n        min(volumeSpacings[0], min(volumeSpacings[1], volumeSpacings[2]));\n    vec4 base =\n        vec4(gl_FragCoord.x, gl_FragCoord.y, gl_FragCoord.z, gl_FragCoord.w);\n\n    vec4 baseXPlus = vec4(gl_FragCoord.x + 1.0, gl_FragCoord.y, gl_FragCoord.z,\n                          gl_FragCoord.w);\n    vec4 baseYPlus = vec4(gl_FragCoord.x, gl_FragCoord.y + 1.0, gl_FragCoord.z,\n                          gl_FragCoord.w);\n\n    vec3 baseWorld = fragCoordToWorld(base);\n    vec3 baseXPlusWorld = fragCoordToWorld(baseXPlus);\n    vec3 baseYPlusWorld = fragCoordToWorld(baseYPlus);\n\n    float XPlusDiff = length(baseXPlusWorld - baseWorld);\n    float YPlusDiff = length(baseYPlusWorld - baseWorld);\n\n    float minFragSpacingWorld = min(XPlusDiff, YPlusDiff);\n\n    for (int s = 1; s < MAX_SEGMENT_INDEX; s++) {\n      // bail out quickly if the segment index has not\n      // been seen by the center segment\n      if (!isLabelOutlineBitSet(s)) {\n        continue;\n      }\n\n      // Use texture sampling for outlineThickness so that we can have\n      // per segment thickness\n      float textureCoordinate = float(s - 1) / 1024.0;\n      float textureValue =\n          texture2D(labelOutlineThicknessTexture, vec2(textureCoordinate, 0.5)).r;\n\n      int actualThickness = int(textureValue * 255.0);\n\n      // check the extreme points in the neighborhood since there is a better\n      // chance of finding the edge there, so that we can bail out\n      // faster if we find the edge\n      bool onEdge = checkOnEdgeForNeighbor(-actualThickness, -actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(actualThickness, actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(actualThickness, -actualThickness, s,\n                                          stepIS) ||\n                    checkOnEdgeForNeighbor(-actualThickness, +actualThickness, s,\n                                          stepIS);\n\n      if (onEdge) {\n        return;\n      }\n\n      // since the next step is computationally expensive, we need to perform\n      // some optimizations to avoid it if possible. One of the optimizations\n      // is to check the whether the minimum of the voxel spacing is greater than\n      // the 2 * the thickness of the outline segment. If that is the case\n      // then we can safely skip the next step since we can be sure that the\n      // the previous 4 checks on the extreme points would caught the entirety\n      // of the all the fragments inside. i.e., this happens when we zoom out,\n      if (minVoxelSpacing >\n          (2.0 * float(actualThickness) - 1.0) * minFragSpacingWorld) {\n        continue;\n      }\n\n      // Loop through the rest, skipping the processed extremes and the center\n      for (int i = -actualThickness; i <= actualThickness; i++) {\n        for (int j = -actualThickness; j <= actualThickness; j++) {\n          if (i == 0 && j == 0)\n            continue; // Skip the center\n          if (abs(i) == actualThickness && abs(j) == actualThickness)\n            continue; // Skip corners\n          if (checkOnEdgeForNeighbor(i, j, s, stepIS)) {\n            return;\n          }\n        }\n      }\n    }\n\n    float sampleHeight = volume.transferFunctionsSampleHeight[0];\n    vec3 tColor0 = getColorFromTexture(value.r, 0, sampleHeight);\n    float pwfValue0 = getOpacityFromTexture(value.r, 0, sampleHeight);\n    gl_FragData[0] = vec4(tColor0, pwfValue0);\n  #endif\n}\n\n//=======================================================================\n// given a\n// - ray direction (rayDir)\n// - starting point (vertexVCVSOutput)\n// - bounding planes of the volume\n// - optionally depth buffer values\n// - far clipping plane\n// compute the start/end distances of the ray we need to cast\nvec2 computeRayDistances(vec3 rayOriginVC, vec3 rayDirVC) {\n  vec2 dists = rayIntersectVolumeDistances(rayOriginVC, rayDirVC);\n\n  //VTK::ClipPlane::Impl\n\n  // do not go behind front clipping plane\n  dists.x = max(0.0, dists.x);\n\n  // do not go PAST far clipping plane\n  float farDist = -camThick / rayDirVC.z;\n  dists.y = min(farDist, dists.y);\n\n  // Do not go past the zbuffer value if set\n  // This is used for intermixing opaque geometry\n  //VTK::ZBuffer::Impl\n\n  return dists;\n}\n\nfloat getFragmentSeed() {\n  // This first noise has a diagonal pattern\n  float firstNoise =\n      fract(sin(dot(gl_FragCoord.xy, vec2(12.9898, 78.233))) * 43758.5453);\n  // This second noise is made out of blocks of CPU generated noise\n  float secondNoise = texture2D(jtexture, gl_FragCoord.xy / 32.0).r;\n  // Combine the two sources of noise in a way that the distribution is uniform\n  // in [0,1[\n  float noiseSum = firstNoise + secondNoise;\n  return noiseSum < 1.0 ? noiseSum : noiseSum - 1.0;\n}\n\nvoid main() {\n  fragmentSeed = getFragmentSeed();\n\n  if (cameraParallel == 1) {\n    // Camera is parallel, so the rayDir is just the direction of the camera.\n    rayDirVC = vec3(0.0, 0.0, -1.0);\n  } else {\n    // camera is at 0,0,0 so rayDir for perspective is just the vc coord\n    rayDirVC = normalize(vertexVCVSOutput);\n  }\n\n  vec3 rayOriginVC = vertexVCVSOutput;\n  vec2 rayStartEndDistancesVC = computeRayDistances(rayOriginVC, rayDirVC);\n  if (rayStartEndDistancesVC[1] <= rayStartEndDistancesVC[0] ||\n      rayStartEndDistancesVC[1] <= 0.0) {\n    // Volume not hit or behind the ray\n    discard;\n  }\n\n  // Perform the blending operation along the ray\n  applyBlend(rayOriginVC, rayDirVC, rayStartEndDistancesVC[0], rayStartEndDistancesVC[1]);\n}\n",e.Geometry=""},e.replaceShaderValues=(e,n,r)=>{let o=e.Fragment;o=Pu.substitute(o,"//VTK::EnabledColorFunctions",`#define EnableColorForValueFunctionId${t.previousState.colorForValueFunctionId}`).result;const a=[];t.previousState.surfaceLightingEnabled&&a.push("Surface"),t.previousState.volumeLightingEnabled&&a.push("Volume"),o=Pu.substitute(o,"//VTK::EnabledLightings",a.map((e=>`#define Enable${e}Lighting`))).result,t.previousState.multiTexturePerVolumeEnabled&&(o=Pu.substitute(o,"//VTK::EnabledMultiTexturePerVolume","#define EnabledMultiTexturePerVolume").result),t.previousState.useIndependentComponents&&(o=Pu.substitute(o,"//VTK::EnabledIndependentComponents","#define EnabledIndependentComponents").result),t.previousState.gradientOpacityEnabled&&(o=Pu.substitute(o,"//VTK::EnabledGradientOpacity","#define EnabledGradientOpacity").result),o=Pu.substitute(o,"//VTK::vtkProportionalComponents",t.previousState.proportionalComponents.map((e=>`#define vtkComponent${e}Proportional`)).join("\n")).result,o=Pu.substitute(o,"//VTK::vtkForceNearestComponents",t.previousState.forceNearestComponents.map((e=>`#define vtkComponent${e}ForceNearest`)).join("\n")).result,t.previousState.hasZBufferTexture&&(o=Pu.substitute(o,"//VTK::ZBuffer::Dec",["uniform sampler2D zBufferTexture;","uniform float vpZWidth;","uniform float vpZHeight;"]).result,o=Pu.substitute(o,"//VTK::ZBuffer::Impl",["vec4 depthVec = texture2D(zBufferTexture, vec2(gl_FragCoord.x / vpZWidth, gl_FragCoord.y/vpZHeight));","float zdepth = (depthVec.r*256.0 + depthVec.g)/257.0;","zdepth = zdepth * 2.0 - 1.0;","if (cameraParallel == 0) {","zdepth = -2.0 * camFar * camNear / (zdepth*(camFar-camNear)-(camFar+camNear)) - camNear;}","else {","zdepth = (zdepth + 1.0) * 0.5 * (camFar - camNear);}\n","zdepth = -zdepth/rayDirVC.z;","dists.y = min(zdepth,dists.y);"]).result),o=Pu.substitute(o,"//VTK::BlendMode",`${t.previousState.blendMode}`).result,o=Pu.substitute(o,"//VTK::NumberOfLights",`${t.previousState.numberOfLights}`).result,o=Pu.substitute(o,"//VTK::MaxLaoKernelSize",`${t.previousState.maxLaoKernelSize}`).result,o=Pu.substitute(o,"//VTK::NumberOfComponents",`${t.previousState.numberOfComponents}`).result,o=Pu.substitute(o,"//VTK::MaximumNumberOfSamples",`${t.previousState.maximumNumberOfSamples}`).result,e.Fragment=o;const i=t.previousState.numberOfClippingPlanes;i>0&&(o=Pu.substitute(o,"//VTK::ClipPlane::Dec",["uniform vec3 vClipPlaneNormals[6];","uniform float vClipPlaneDistances[6];","uniform vec3 vClipPlaneOrigins[6];","uniform int clip_numPlanes;","//VTK::ClipPlane::Dec","#define vtkClippingPlanesOn"],!1).result,o=Pu.substitute(o,"//VTK::ClipPlane::Impl",[`for(int i = 0; i < ${i}; i++) {`,"  float rayDirRatio = dot(rayDirVC, vClipPlaneNormals[i]);","  float equationResult = dot(vertexVCVSOutput, vClipPlaneNormals[i]) + vClipPlaneDistances[i];","  if (rayDirRatio == 0.0)","  {","    if (equationResult < 0.0) dists.x = dists.y;","    continue;","  }","  float result = -1.0 * equationResult / rayDirRatio;","  if (rayDirRatio < 0.0) dists.y = min(dists.y, result);","  else dists.x = max(dists.x, result);","}","//VTK::ClipPlane::Impl"],!1).result),e.Fragment=o},e.getNeedToRebuildShaders=(r,o,a)=>{const i=!!t.zBufferTexture,s=t.currentValidInputs.length,l=t.numberOfLights,c=t.numberOfComponents,u=t.useIndependentComponents,d=a.getProperties(),p=t.currentValidInputs[0],f=d[p.inputIndex],g=s>1,m=p.imageData.getBounds(),h=Fi.getDiagonalLength(m),v=Math.ceil(h/e.getCurrentSampleDistance(o));v>t.renderable.getMaximumSamplesPerRay()&&wf(`The number of steps required ${v} is larger than the specified maximum number of steps ${t.renderable.getMaximumSamplesPerRay()}.\nPlease either change the volumeMapper sampleDistance or its maximum number of samples.`);const T=u?c:1;let y=!1;for(let e=0;e<T;++e)if(f.getUseGradientOpacity(e)){y=!0;break}let b=0;const x=f.getLAOKernelSize();x>b&&f.getLocalAmbientOcclusion()&&f.getAmbient()>0&&(b=x);const C=t.renderable.getClippingPlanes().length,S=t.renderable.getViewSpecificProperties().OpenGL?.ShaderReplacements,A=t.currentRenderPass?.getShaderReplacement(),I=t.renderable.getBlendMode(),w=(()=>{if(I!==Af.LABELMAP_EDGE_PROJECTION_BLEND&&n(f))return 5;if(u)switch(f.getColorMixPreset()){case Cf.ADDITIVE:return 1;case Cf.COLORIZE:return 2;case Cf.CUSTOM:return 3;default:return 4}return 0})(),O=f.getVolumetricScatteringBlending()<1,P=f.getVolumetricScatteringBlending()>0;let R=!1;for(let e=0;e<c;++e)if(f.getForceNearestInterpolation(e)){R=!0;break}const M=[],E=[];for(let e=0;e<c;e++)f.getOpacityMode(e)===xf.PROPORTIONAL&&M.push(e),f.getForceNearestInterpolation(e)&&E.push(e);const V={numberOfComponents:c,useIndependentComponents:u,proportionalComponents:M,forceNearestComponents:E,blendMode:I,numberOfLights:l,numberOfValidInputs:s,maximumNumberOfSamples:v,hasZBufferTexture:i,maxLaoKernelSize:b,numberOfClippingPlanes:C,mapperShaderReplacements:S,renderPassShaderReplacements:A,colorForValueFunctionId:w,surfaceLightingEnabled:O,volumeLightingEnabled:P,forceNearestInterpolationEnabled:R,multiTexturePerVolumeEnabled:g,gradientOpacityEnabled:y};return!(0!==r.getProgram()?.getHandle()&&t.previousState&&Ge()(t.previousState,V)||(t.previousState=V,0))},e.updateShaders=(n,r,o)=>{if(e.getNeedToRebuildShaders(n,r,o)){const a={Vertex:null,Fragment:null,Geometry:null};e.buildShaders(a,r,o);const i=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(a.Vertex,a.Fragment,a.Geometry);i!==n.getProgram()&&(n.setProgram(i),n.getVAO().releaseGraphicsResources()),n.getShaderSourceTime().modified()}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(n.getProgram());n.getVAO().bind(),e.setMapperShaderParameters(n,r,o),e.setCameraShaderParameters(n,r,o),e.setPropertyShaderParameters(n,r,o),e.getClippingPlaneShaderParameters(n,r,o)},e.setMapperShaderParameters=(n,r,o)=>{const a=n.getProgram();n.getCABO().getElementCount()&&(t.VBOBuildTime.getMTime()>n.getAttributeUpdateTime().getMTime()||n.getShaderSourceTime().getMTime()>n.getAttributeUpdateTime().getMTime())&&(a.isAttributeUsed("vertexDC")&&(n.getVAO().addAttributeArray(a,n.getCABO(),"vertexDC",n.getCABO().getVertexOffset(),n.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Of("Error setting vertexDC in shader VAO.")),n.getAttributeUpdateTime().modified());const i=e.getCurrentSampleDistance(r);a.setUniformf("sampleDistance",i);const s=i*t.renderable.getVolumeShadowSamplingDistFactor();a.setUniformf("volumeShadowSampleDistance",s),t.scalarTextures.forEach(((e,t)=>{a.setUniformi(`volumeTexture[${t}]`,e.getTextureUnit())}));const l=o.getProperties()[t.currentValidInputs[0].inputIndex].getIpScalarRange(),c=new Float32Array(4),u=new Float32Array(4),d=(e,t,n)=>{t?.dataComputedScale?.length&&(c[e]=l[0]*t.dataComputedScale[n]+t.dataComputedOffset[n],u[e]=l[1]*t.dataComputedScale[n]+t.dataComputedOffset[n],c[e]=(c[e]-t.offset[n])/t.scale[n],u[e]=(u[e]-t.offset[n])/t.scale[n])};if(t.previousState.multiTexturePerVolumeEnabled)t.scalarTextures.forEach(((e,t)=>{const n=e.getVolumeInfo();d(t,n,0)}));else{const e=t.scalarTextures[0].getVolumeInfo();for(let t=0;t<4;++t)d(t,e,t)}const p="volume";if(a.setUniform4f(`${p}.ipScalarRangeMin`,c[0],c[1],c[2],c[3]),a.setUniform4f(`${p}.ipScalarRangeMax`,u[0],u[1],u[2],u[3]),null!==t.zBufferTexture){a.setUniformi("zBufferTexture",t.zBufferTexture.getTextureUnit());const e=t._useSmallViewport?[t._smallViewportWidth,t._smallViewportHeight]:t._openGLRenderWindow.getFramebufferSize();a.setUniformf("vpZWidth",e[0]),a.setUniformf("vpZHeight",e[1])}},e.setCameraShaderParameters=(r,o,a)=>{const{idxToView:i,vecISToVCMatrix:s,modelToView:l,projectionToView:c,projectionToWorld:u}=Pf,d=t.openGLCamera.getKeyMatrices(o),p=t.openGLVolume.getKeyMatrices();y(l,d.wcvc,p.mcwc);const f=r.getProgram(),g=t.openGLCamera.getRenderable(),m=g.getParallelProjection(),v=g.getClippingRange();f.setUniformf("camThick",v[1]-v[0]),f.setUniformf("camNear",v[0]),f.setUniformf("camFar",v[1]),f.setUniformi("cameraParallel",m);const T=t.currentValidInputs[0],b=T.imageData.getBounds(),x=Fi.getCorners(b,[]).map((e=>(wn(e,e,l),m||xn(e,e,-v[0]/(e[2]*mn(e))),wn(e,e,d.vcpc),e))),C=Fi.addPoints([...Fi.INIT_BOUNDS],x);f.setUniformf("dcxmin",C[0]),f.setUniformf("dcxmax",C[1]),f.setUniformf("dcymin",C[2]),f.setUniformf("dcymax",C[3]);const S=e.getRenderTargetSize();f.setUniformf("vpWidth",S[0]),f.setUniformf("vpHeight",S[1]);const A=e.getRenderTargetOffset();f.setUniformf("vpOffsetX",A[0]/S[0]),f.setUniformf("vpOffsetY",A[1]/S[1]),h(c,d.vcpc),f.setUniformMatrix("PCVCMatrix",c),f.setUniformi("twoSidedLighting",o.getTwoSidedLighting());const I=new Array(2*t.previousState.maxLaoKernelSize);for(let e=0;e<t.previousState.maxLaoKernelSize;e++)I[2*e]=Math.random(),I[2*e+1]=Math.random();if(f.setUniform2fv("kernelSample",I),t.numberOfLights>0){let e=0;o.getLights().forEach((t=>{if(t.getSwitch()>0){const n=`lights[${e}]`,r=xn([],t.getColor(),t.getIntensity());f.setUniform3fv(`${n}.color`,r);const o=t.getTransformedPosition();wn(o,o,l),f.setUniform3fv(`${n}.positionVC`,o);const a=[...t.getDirection()];On(a,a,d.normalMatrix),Sn(a,a),f.setUniform3fv(`${n}.directionVC`,a);const i=[-.5*a[0],-.5*a[1],-.5*(a[2]-1)];f.setUniform3fv(`${n}.halfAngleVC`,i);const s=t.getAttenuationValues();f.setUniform3fv(`${n}.attenuation`,s);const c=t.getExponent();f.setUniformf(`${n}.exponent`,c);const u=t.getConeAngle();f.setUniformf(`${n}.coneAngle`,u);const p=t.getPositional();f.setUniformi(`${n}.isPositional`,p),e++}}))}const w="volume",O=a.getProperties()[T.inputIndex],P=T.imageData,R=P.getSpatialExtent(),M=P.getSpacing(),E=P.getDimensions(),V=P.getIndexToWorld(),D=P.getWorldToIndex(),L=P.getDirectionByReference();y(i,l,V),f.setUniform3fv(`${w}.spacing`,M);const B=Cn([],M);f.setUniform3fv(`${w}.inverseSpacing`,B),f.setUniform3iv(`${w}.dimensions`,E),f.setUniform3fv(`${w}.inverseDimensions`,Cn([],E)),f.setUniformMatrix(`${w}.worldToIndex`,D),s.fill(0);const N=bn(new Float64Array(3),E,M);s[0]=N[0],s[4]=N[1],s[8]=N[2],ve(s,L,s),ve(s,p.normalMatrix,s),ve(s,d.normalMatrix,s),f.setUniformMatrix3x3(`${w}.vecISToVCMatrix`,s),f.setUniformMatrix3x3(`${w}.vecVCToISMatrix`,ge(new Float32Array(9),s));const F=hn(R[0],R[2],R[4]),_=wn(new Float64Array(3),F,i);f.setUniform3fv(`${w}.originVC`,_);const G=mn(N);if(f.setUniformf(`${w}.diagonalLength`,G),n(O)){const e=g.getDistance();g.setClippingRange(e,e+.1),h(u,t.openGLCamera.getKeyMatrices(o).wcpc),g.setClippingRange(v[0],v[1]),t.openGLCamera.getKeyMatrices(o),f.setUniformMatrix(`${w}.PCWCMatrix`,u)}if(O.getVolumetricScatteringBlending()>0&&(f.setUniformf(`${w}.globalIlluminationReach`,O.getGlobalIlluminationReach()),f.setUniformf(`${w}.volumetricScatteringBlending`,O.getVolumetricScatteringBlending()),f.setUniformf(`${w}.anisotropy`,O.getAnisotropy()),f.setUniformf(`${w}.anisotropySquared`,O.getAnisotropy()**2)),O.getLocalAmbientOcclusion()&&O.getAmbient()>0){const e=O.getLAOKernelSize();f.setUniformi(`${w}.kernelSize`,e);const t=O.getLAOKernelRadius();f.setUniformi(`${w}.kernelRadius`,t)}else f.setUniformi(`${w}.kernelSize`,0)},e.setPropertyShaderParameters=(e,n,r)=>{const o=e.getProgram();o.setUniformi("jtexture",t.jitterTexture.getTextureUnit());const a=r.getProperties();o.setUniformi("labelOutlineThicknessTexture",t.labelOutlineThicknessTexture.getTextureUnit()),o.setUniformi("opacityTexture",t.opacityTexture.getTextureUnit()),o.setUniformi("colorTexture",t.colorTexture.getTextureUnit());const i="volume",s=a[t.currentValidInputs[0].inputIndex],l=t.previousState.numberOfComponents,c=t.previousState.useIndependentComponents;if(c){const e=new Float32Array(4);for(let t=0;t<l;t++)e[t]=s.getComponentWeight(t);o.setUniform4fv(`${i}.independentComponentMix`,e);const t=new Float32Array(4),n=1/l;for(let e=0;e<l;++e)t[e]=(e+.5)*n;o.setUniform4fv(`${i}.transferFunctionsSampleHeight`,t)}const u=t.colorForValueFunctionId;o.setUniformi(`${i}.colorForValueFunctionId`,u);const d=s.getComputeNormalFromOpacity();o.setUniformi(`${i}.computeNormalFromOpacity`,d);const p=new Float32Array(4),f=new Float32Array(4),g=new Float32Array(4),m=new Float32Array(4);for(let e=0;e<l;e++){const n=t.previousState.multiTexturePerVolumeEnabled,r=n?e:0,o=n?0:e,a=t.scalarTextures[r].getVolumeInfo(),i=c?e:0,l=a.scale[o],u=s.getRGBTransferFunction(i).getRange();p[e]=l/(u[1]-u[0]),f[e]=(a.offset[o]-u[0])/(u[1]-u[0]);const d=s.getScalarOpacity(i).getRange();g[e]=l/(d[1]-d[0]),m[e]=(a.offset[o]-d[0])/(d[1]-d[0])}if(o.setUniform4fv(`${i}.colorTextureScale`,p),o.setUniform4fv(`${i}.colorTextureShift`,f),o.setUniform4fv(`${i}.opacityTextureScale`,g),o.setUniform4fv(`${i}.opacityTextureShift`,m),t.previousState.gradientOpacityEnabled){const e=new Array(4),n=new Array(4),r=new Array(4),a=new Array(4);if(c)for(let o=0;o<l;++o){const i=t.previousState.multiTexturePerVolumeEnabled,l=i?o:0,c=i?0:o,u=t.scalarTextures[l].getVolumeInfo().scale[c];if(s.getUseGradientOpacity(o)){const t=[s.getGradientOpacityMinimumOpacity(o),s.getGradientOpacityMaximumOpacity(o)],i=[s.getGradientOpacityMinimumValue(o),s.getGradientOpacityMaximumValue(o)];r[o]=t[0],a[o]=t[1],e[o]=u*(t[1]-t[0])/(i[1]-i[0]),n[o]=-i[0]*(t[1]-t[0])/(i[1]-i[0])+t[0]}else r[o]=1,a[o]=1,e[o]=0,n[o]=1}else{const o=l-1,i=t.previousState.multiTexturePerVolumeEnabled,c=i?o:0,u=i?0:o,d=t.scalarTextures[c].getVolumeInfo().scale[u],p=[s.getGradientOpacityMinimumOpacity(0),s.getGradientOpacityMaximumOpacity(0)],f=[s.getGradientOpacityMinimumValue(0),s.getGradientOpacityMaximumValue(0)];r[0]=p[0],a[0]=p[1],e[0]=d*(p[1]-p[0])/(f[1]-f[0]),n[0]=-f[0]*(p[1]-p[0])/(f[1]-f[0])+p[0]}o.setUniform4f(`${i}.gradientOpacityScale`,e),o.setUniform4f(`${i}.gradientOpacityShift`,n),o.setUniform4f(`${i}.gradientOpacityMin`,r),o.setUniform4f(`${i}.gradientOpacityMax`,a)}const h=s.getLabelOutlineOpacity();if(o.setUniformf(`${i}.outlineOpacity`,h),t.numberOfLights>0){o.setUniformf(`${i}.ambient`,s.getAmbient()),o.setUniformf(`${i}.diffuse`,s.getDiffuse()),o.setUniformf(`${i}.specular`,s.getSpecular());const e=s.getSpecularPower();o.setUniformf(`${i}.specularPower`,0===e?1:e)}},e.getClippingPlaneShaderParameters=(e,n,r)=>{if(t.renderable.getClippingPlanes().length>0){const r=t.openGLCamera.getKeyMatrices(n),o=[],a=[],i=[],s=t.renderable.getClippingPlanes(),l=s.length;for(let e=0;e<l;++e){const t=s[e].getNormal(),n=s[e].getOrigin();On(t,t,r.normalMatrix),wn(n,n,r.wcvc);const l=-1*An(n,t);o.push(t[0]),o.push(t[1]),o.push(t[2]),a.push(l),i.push(n[0]),i.push(n[1]),i.push(n[2])}const c=e.getProgram();c.setUniform3fv("vClipPlaneNormals",o),c.setUniformfv("vClipPlaneDistances",a),c.setUniform3fv("vClipPlaneOrigins",i),c.setUniformi("clip_numPlanes",l)}},e.delete=Vt((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),(()=>{t._openGLRenderWindow&&a(t._openGLRenderWindow)}),e.delete),e.getRenderTargetSize=()=>{if(t._useSmallViewport)return[t._smallViewportWidth,t._smallViewportHeight];const{usize:e,vsize:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getRenderTargetOffset=()=>{const{lowerLeftU:e,lowerLeftV:n}=t._openGLRenderer.getTiledSizeAndOrigin();return[e,n]},e.getCurrentSampleDistance=e=>{const n=e.getVTKWindow().getInteractor(),r=t.renderable.getSampleDistance();return n.isAnimating()?r*t.renderable.getInteractionSampleDistanceFactor():r},e.renderPieceStart=(n,r)=>{const o=n.getVTKWindow().getInteractor();if(t._lastScale||(t._lastScale=t.renderable.getInitialInteractionScale()),t._useSmallViewport=!1,o.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._animationRateSubscription||(t._animationRateSubscription=o.onAnimationFrameRateUpdate((()=>{if(t.renderable.getAutoAdjustSampleDistances()){const e=o.getRecentAnimationFrameRate(),n=o.getDesiredUpdateRate()/e;(n>1.15||n<.85)&&(t._lastScale*=n),t._lastScale>400&&(t._lastScale=400),t._lastScale<1.5&&(t._lastScale=1.5)}else t._lastScale=t.renderable.getImageSampleDistance()*t.renderable.getImageSampleDistance()}))),t._useSmallViewport){const e=t._openGLRenderWindow.getFramebufferSize(),n=1/Math.sqrt(t._lastScale);if(t._smallViewportWidth=Math.ceil(n*e[0]),t._smallViewportHeight=Math.ceil(n*e[1]),t._smallViewportHeight>e[1]&&(t._smallViewportHeight=e[1]),t._smallViewportWidth>e[0]&&(t._smallViewportWidth=e[0]),t.framebuffer.saveCurrentBindingsAndBuffers(),null===t.framebuffer.getGLFramebuffer())t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer();else{const n=t.framebuffer.getSize();n&&n[0]===e[0]&&n[1]===e[1]||(t.framebuffer.create(e[0],e[1]),t.framebuffer.populateFramebuffer())}t.framebuffer.bind();const r=t.context;r.clearColor(0,0,0,0),r.colorMask(!0,!0,!0,!0),r.clear(r.COLOR_BUFFER_BIT),r.viewport(0,0,t._smallViewportWidth,t._smallViewportHeight),t.fvp=[t._smallViewportWidth/e[0],t._smallViewportHeight/e[1]]}t.context.disable(t.context.DEPTH_TEST),e.updateBufferObjects(n,r);const a=r.getProperties();t.currentValidInputs.forEach((e=>{let{inputIndex:n}=e;const r=a[n].getInterpolationType(),o=t.scalarTextures[n];r===bf.NEAREST?(o.setMinificationFilter(Fu.NEAREST),o.setMagnificationFilter(Fu.NEAREST)):(o.setMinificationFilter(Fu.LINEAR),o.setMagnificationFilter(Fu.LINEAR))})),null!==t.zBufferTexture&&t.zBufferTexture.activate()},e.renderPieceDraw=(n,r)=>{const o=t.context,a=[...t.scalarTextures,t.colorTexture,t.opacityTexture,t.labelOutlineThicknessTexture,t.jitterTexture];a.forEach((e=>e.activate())),e.updateShaders(t.tris,n,r),o.drawArrays(o.TRIANGLES,0,t.tris.getCABO().getElementCount()),t.tris.getVAO().release(),a.forEach((e=>e.deactivate()))},e.renderPieceFinish=(e,n)=>{if(null!==t.zBufferTexture&&t.zBufferTexture.deactivate(),t._useSmallViewport){if(t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader){t.copyShader=t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","uniform vec2 tfactor;","varying vec2 tcoord;","void main() { tcoord = vec2(vertexDC.x*0.5 + 0.5, vertexDC.y*0.5 + 0.5) * tfactor; gl_Position = vertexDC; }"].join("\n"),["//VTK::System::Dec","//VTK::Output::Dec","uniform sampler2D texture1;","varying vec2 tcoord;","void main() { gl_FragData[0] = texture2D(texture1,tcoord); }"].join("\n"),"");const e=t.copyShader;t.copyVAO=Eu.newInstance(),t.copyVAO.setOpenGLRenderWindow(t._openGLRenderWindow),t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(e,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE)||Of("Error setting vertexDC in copy shader VAO.")}else t._openGLRenderWindow.getShaderCache().readyShaderProgram(t.copyShader);const e=t._openGLRenderWindow.getFramebufferSize();t.context.viewport(0,0,e[0],e[1]);const n=t.framebuffer.getColorTexture();n.activate(),t.copyShader.setUniformi("texture",n.getTextureUnit()),t.copyShader.setUniform2f("tfactor",t.fvp[0],t.fvp[1]);const r=t.context;r.blendFuncSeparate(r.ONE,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA),t.context.drawArrays(t.context.TRIANGLES,0,t.tris.getCABO().getElementCount()),n.deactivate(),r.blendFuncSeparate(r.SRC_ALPHA,r.ONE_MINUS_SRC_ALPHA,r.ONE,r.ONE_MINUS_SRC_ALPHA)}},e.renderPiece=(n,r)=>{e.invokeEvent({type:"StartEvent"}),t.renderable.update();const o=t.renderable.getNumberOfInputPorts();t.currentValidInputs=[];for(let e=0;e<o;++e){const n=t.renderable.getInputData(e);n&&!n.isDeleted()&&t.currentValidInputs.push({imageData:n,inputIndex:e})}let a=0;if(t.currentValidInputs.length>0){const e=r.getProperties(),o=t.currentValidInputs[0],i=o.imageData.getPointData().getScalars(),s=e[o.inputIndex];s.getShade()&&t.renderable.getBlendMode()===Af.COMPOSITE_BLEND&&n.getLights().forEach((e=>{e.getSwitch()>0&&a++}));const l=t.currentValidInputs.length,c=l>1;t.numberOfComponents=c?l:i.getNumberOfComponents(),t.useIndependentComponents=function(e,t){const n=e.getIndependentComponents(),r=e.getColorMixPreset();return n&&t>=2||!!r}(s,t.numberOfComponents)}a!==t.numberOfLights&&(t.numberOfLights=a,e.modified()),e.invokeEvent({type:"EndEvent"}),0!==t.currentValidInputs.length&&(e.renderPieceStart(n,r),e.renderPieceDraw(n,r),e.renderPieceFinish(n,r))},e.updateBufferObjects=(t,n)=>{e.getNeedToRebuildBufferObjects(t,n)&&e.buildBufferObjects(t,n)},e.getNeedToRebuildBufferObjects=(n,r)=>t.VBOBuildTime.getMTime()<e.getMTime()||t.VBOBuildTime.getMTime()<r.getMTime()||t.VBOBuildTime.getMTime()<r.getProperty(t.currentValidInputs[0].inputIndex)?.getMTime()||t.VBOBuildTime.getMTime()<t.renderable.getMTime()||t.currentValidInputs.some((e=>{let{imageData:n}=e;return t.VBOBuildTime.getMTime()<n.getMTime()}))||t.scalarTextures.length!==t.currentValidInputs.length||!t.scalarTextures.every((e=>!!e?.getHandle()))||!t.colorTexture?.getHandle()||!t.opacityTexture?.getHandle()||!t.labelOutlineThicknessTexture?.getHandle()||!t.jitterTexture?.getHandle(),e.buildBufferObjects=(n,r)=>{if(!t.jitterTexture.getHandle()){const e=new Float32Array(1024);for(let t=0;t<1024;++t)e[t]=Math.random();t.jitterTexture.setMinificationFilter(Fu.NEAREST),t.jitterTexture.setMagnificationFilter(Fu.NEAREST),t.jitterTexture.create2DFromRaw({width:32,height:32,numComps:1,dataType:is.FLOAT,data:e})}const a=r.getProperties(),i=t.currentValidInputs[0],s=a[i.inputIndex],l=t.numberOfComponents,c=t.useIndependentComponents,u=c?l:1,d=[];for(let e=0;e<u;++e)d.push(s.getScalarOpacity(e));const p=Xp(d,c,u),f=s.getScalarOpacity(),g=t._openGLRenderWindow.getGraphicsResourceForObject(f);if(g?.oglObject?.getHandle()&&g.hash===p)t.opacityTexture=g.oglObject;else{const r=td.newInstance();r.setOpenGLRenderWindow(t._openGLRenderWindow);let o=t.renderable.getOpacityTextureWidth();o<=0&&(o=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const a=2*o*u,i=new Float32Array(a),l=new Float32Array(o);for(let t=0;t<u;++t){const r=s.getScalarOpacity(t),a=e.getCurrentSampleDistance(n)/s.getScalarOpacityUnitDistance(t),c=r.getRange();r.getTable(c[0],c[1],o,l,1);for(let e=0;e<o;++e)i[t*o*2+e]=1-(1-l[e])**a,i[t*o*2+e+o]=i[t*o*2+e]}if(r.resetFormatAndType(),r.setMinificationFilter(Fu.LINEAR),r.setMagnificationFilter(Fu.LINEAR),t._openGLRenderWindow.getWebgl2()||t.context.getExtension("OES_texture_float")&&t.context.getExtension("OES_texture_float_linear"))r.create2DFromRaw({width:o,height:2*u,numComps:1,dataType:is.FLOAT,data:i});else{const e=new Uint8ClampedArray(a);for(let t=0;t<a;++t)e[t]=255*i[t];r.create2DFromRaw({width:o,height:2*u,numComps:1,dataType:is.UNSIGNED_CHAR,data:e})}f&&t._openGLRenderWindow.setGraphicsResourceForObject(f,r,p),t.opacityTexture=r}o(t._openGLRenderWindow,t._opacityTextureCore,f),t._opacityTextureCore=f;const m=[];for(let e=0;e<u;++e)m.push(s.getRGBTransferFunction(e));const h=Xp(m,c,u),v=s.getRGBTransferFunction(),T=t._openGLRenderWindow.getGraphicsResourceForObject(v);if(T?.oglObject?.getHandle()&&T?.hash===h)t.colorTexture=T.oglObject;else{const e=td.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getColorTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=new Uint8ClampedArray(2*n*u*3),o=new Float32Array(3*n);for(let e=0;e<u;++e){const t=s.getRGBTransferFunction(e),a=t.getRange();t.getTable(a[0],a[1],n,o,1);for(let t=0;t<3*n;++t)r[e*n*6+t]=255*o[t],r[e*n*6+t+3*n]=255*o[t]}e.resetFormatAndType(),e.setMinificationFilter(Fu.LINEAR),e.setMagnificationFilter(Fu.LINEAR),e.create2DFromRaw({width:n,height:2*u,numComps:3,dataType:is.UNSIGNED_CHAR,data:r}),t._openGLRenderWindow.setGraphicsResourceForObject(v,e,h),t.colorTexture=e}o(t._openGLRenderWindow,t._colorTextureCore,v),t._colorTextureCore=v,t.currentValidInputs.forEach(((e,n)=>{let{imageData:r,inputIndex:i}=e;const s=a[i],l=r.getPointData().getScalars(),c=t._openGLRenderWindow.getGraphicsResourceForObject(l),u=Yp(0,l),d=!c?.oglObject?.getHandle()||c?.hash!==u,p=s.getUpdatedExtents(),f=!!p.length;if(d&&!f){const e=td.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);const o=r.getDimensions();e.setOglNorm16Ext(t.context.getExtension("EXT_texture_norm16")),e.resetFormatAndType(),e.create3DFilterableFromDataArray({width:o[0],height:o[1],depth:o[2],dataArray:l,preferSizeOverAccuracy:s.getPreferSizeOverAccuracy()}),t._openGLRenderWindow.setGraphicsResourceForObject(l,e,u),t.scalarTextures[n]=e}else t.scalarTextures[n]=c.oglObject;if(f){s.setUpdatedExtents([]);const e=r.getDimensions();t.scalarTextures[n].create3DFilterableFromDataArray({width:e[0],height:e[1],depth:e[2],dataArray:l,updatedExtents:p})}o(t._openGLRenderWindow,t._scalarTexturesCore[n],l),t._scalarTexturesCore[n]=l}));const y=s.getLabelOutlineThickness(),b=t._openGLRenderWindow.getGraphicsResourceForObject(y),x=y.join("-");if(b?.oglObject?.getHandle()&&b?.hash===x)t.labelOutlineThicknessTexture=b.oglObject;else{const e=td.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow);let n=t.renderable.getLabelOutlineTextureWidth();n<=0&&(n=t.context.getParameter(t.context.MAX_TEXTURE_SIZE));const r=1,o=new Uint8Array(n*r);for(let e=0;e<n;++e){const t=void 0!==y[e]?y[e]:y[0];o[e]=t}e.resetFormatAndType(),e.setMinificationFilter(Fu.NEAREST),e.setMagnificationFilter(Fu.NEAREST),e.create2DFromRaw({width:n,height:r,numComps:1,dataType:is.UNSIGNED_CHAR,data:o}),y&&t._openGLRenderWindow.setGraphicsResourceForObject(y,e,x),t.labelOutlineThicknessTexture=e}if(o(t._openGLRenderWindow,t._labelOutlineThicknessTextureCore,y),t._labelOutlineThicknessTextureCore=y,!t.tris.getCABO().getElementCount()){const e=new Float32Array(12);for(let t=0;t<4;t++)e[3*t]=t%2*2-1,e[3*t+1]=t>1?1:-1,e[3*t+2]=-1;const n=new Uint16Array(8);n[0]=3,n[1]=0,n[2]=1,n[3]=3,n[4]=3,n[5]=0,n[6]=3,n[7]=2;const r=Ts.newInstance({numberOfComponents:3,values:e});r.setName("points");const o=Ts.newInstance({numberOfComponents:1,values:n});t.tris.getCABO().createVBO(o,"polys",qi.SURFACE,{points:r,cellOffset:0})}t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLVolumeMapper");en("vtkVolumeMapper",Mf);const{vtkDebugMacro:Ef}=jt,Vf={};const Df=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Vf,n),Xt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLPixelSpaceCallbackMapper"),e.opaquePass=(n,r)=>{t._openGLRenderer=e.getFirstAncestorOfType("vtkOpenGLRenderer"),t._openGLRenderWindow=t._openGLRenderer.getLastAncestorOfType("vtkOpenGLRenderWindow");const o=t._openGLRenderer.getAspectRatio(),a=t._openGLRenderer?t._openGLRenderer.getRenderable().getActiveCamera():null,i=t._openGLRenderer.getTiledSizeAndOrigin();let s=null;if(t.renderable.getUseZValues()){const e=r.getZBufferTexture(),n=Math.floor(e.getWidth()),o=Math.floor(e.getHeight()),a=t._openGLRenderWindow.getContext();e.bind();const i=r.getFramebuffer();i?i.saveCurrentBindingsAndBuffers():Ef("No framebuffer to save/restore");const l=a.createFramebuffer();a.bindFramebuffer(a.FRAMEBUFFER,l),a.framebufferTexture2D(a.FRAMEBUFFER,a.COLOR_ATTACHMENT0,a.TEXTURE_2D,e.getHandle(),0),a.checkFramebufferStatus(a.FRAMEBUFFER)===a.FRAMEBUFFER_COMPLETE&&(s=new Uint8Array(n*o*4),a.viewport(0,0,n,o),a.readPixels(0,0,n,o,a.RGBA,a.UNSIGNED_BYTE,s)),i&&i.restorePreviousBindingsAndBuffers(),a.deleteFramebuffer(l)}t.renderable.invokeCallback(t.renderable.getInputData(),a,o,i,s)},e.queryPass=(e,n)=>{e&&t.renderable.getUseZValues()&&n.requestDepth()}}(e,t)}),"vtkOpenGLPixelSpaceCallbackMapper");en("vtkPixelSpaceCallbackMapper",Df);var Lf="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtktextureObjectVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n\nattribute vec4 vertexDC;\nattribute vec2 tcoordDC;\nvarying vec2 tcoordVC;\n\nvoid main()\n{\n  tcoordVC = tcoordDC;\n  gl_Position = vertexDC;\n}\n";const{Representation:Bf}=ts;function Nf(e,t,n,r){let[o,a]=t;const i=e.getContext(),s=td.newInstance({autoParameters:!1,wrapS:r,wrapT:r,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:i.FLOAT,baseLevel:0,maxLevel:0});return s.setOpenGLRenderWindow(e),s.setInternalFormat(i.RGBA32F),s.create2DFromRaw({width:o,height:a,numComps:4,dataType:"Float32Array",data:null}),s.activate(),s.sendParameters(),s.deactivate(),s}function Ff(e,t){return Nf(e,t,td.Filter.NEAREST,td.Wrap.CLAMP_TO_EDGE)}const _f={vectorTexture:null,maskVectorTexture:null,noiseTexture:null,doEEPass:!1,doVTPass:!1,readIndex:0,quad:null,lastProgramHash:null,framebuffer:null,size:null,pingTextures:[],pongTextures:[],textures:[]};function Gf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_f,n),Ht.obj(e,t),Ht.get(e,t,["readIndex"]),Ht.setGet(e,t,["doEEPass","doVTPass","_openGLRenderWindow","vectorTexture","maskVectorTexture","noiseTexture","framebuffer","size"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkLICPingPongBufferManager"),t._openGLRenderWindow?(t.quad=function(e){const t=Bu.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ts.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ts.newInstance({numberOfComponents:1,values:o}),s=Ts.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",Bf.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow),t.context=t._openGLRenderWindow.getContext(),t.licTexture0=Ff(t._openGLRenderWindow,t.size),t.seedTexture0=Ff(t._openGLRenderWindow,t.size),t.licTexture1=Ff(t._openGLRenderWindow,t.size),t.seedTexture1=Ff(t._openGLRenderWindow,t.size),t.eeTexture=t.doEEPass?Nf(t._openGLRenderWindow,t.size,td.Filter.NEAREST,td.Wrap.CLAMP_TO_EDGE):null,t.imageVectorTexture=t.doVTPass?(n=t._openGLRenderWindow,r=t.size,Nf(n,r,td.Filter.LINEAR,td.Wrap.CLAMP_TO_EDGE)):null,t.pingTextures[0]=t.licTexture0,t.pingTextures[1]=t.seedTexture0,t.pongTextures[0]=t.licTexture1,t.pongTextures[1]=t.seedTexture1,t.textures[0]=t.pingTextures,t.textures[1]=t.pongTextures,e.swap=()=>{t.readIndex=1-t.readIndex},e.renderQuad=(e,n)=>{const r=t.quad,o=t.context;let a=t.quadVAO;a||(a=Eu.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.quadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.getLastLICBuffer=()=>0===t.readIndex?t.licTexture0:t.licTexture1,e.getLastSeedBuffer=()=>0===t.readIndex?t.seedTexture0:t.seedTexture1,e.getLICBuffer=()=>1-t.readIndex==0?t.licTexture0:t.licTexture1,e.getSeedBuffer=()=>1-t.readIndex==0?t.seedTexture0:t.seedTexture1,e.getLICTextureUnit=()=>{const e=t.textures[t.readIndex][0];return e.activate(),e.getTextureUnit()},e.getSeedTextureUnit=()=>{const e=t.textures[t.readIndex][1];return e.activate(),e.getTextureUnit()},e.getNoiseTextureUnit=function(){return 0===(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0)?(t.noiseTexture.activate(),t.noiseTexture.getTextureUnit()):(t.eeTexture.activate(),t.eeTexture.getTextureUnit())},e.getVectorTextureUnit=()=>(t.vectorTexture.activate(),t.vectorTexture.getTextureUnit()),e.getImageVectorTextureUnit=()=>t.imageVectorTexture?(t.imageVectorTexture.activate(),t.imageVectorTexture.getTextureUnit()):e.getVectorTextureUnit(),e.getMaskVectorTextureUnit=()=>t.maskVectorTexture?(t.maskVectorTexture.activate(),t.maskVectorTexture.getTextureUnit()):e.getImageVectorTextureUnit(),e.clearBuffers=function(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),n.setColorBuffer(t.licTexture0,0),n.setColorBuffer(t.seedTexture0,1),n.setColorBuffer(t.licTexture1,2),n.setColorBuffer(t.seedTexture1,3);const o=[r.COLOR_ATTACHMENT0,r.COLOR_ATTACHMENT1,r.COLOR_ATTACHMENT2,r.COLOR_ATTACHMENT3];e&&(n.removeColorBuffer(4),n.setColorBuffer(t.eeTexture,4),o.push(r.COLOR_ATTACHMENT4)),r.drawBuffers(o),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeColorBuffer(3),e&&n.removeColorBuffer(4),r.drawBuffers([r.NONE])},e.clearBuffer=e=>{const n=t.framebuffer,r=t.context;n.removeColorBuffer(0),n.setColorBuffer(e,0),r.drawBuffers([r.COLOR_ATTACHMENT0]),r.clearColor(0,1,0,0),r.disable(r.SCISSOR_TEST),r.disable(r.BLEND),r.clear(r.COLOR_BUFFER_BIT),n.removeColorBuffer(e,0),r.drawBuffers([r.NONE])},e.activateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.activate():t.vectorTexture.activate(),t.maskVectorTexture&&t.maskVectorTexture.activate()},e.deactivateVectorTextures=()=>{t.imageVectorTexture?t.imageVectorTexture.deactivate():t.vectorTexture.deactivate(),t.maskVectorTexture&&t.maskVectorTexture.deactivate()},e.activateNoiseTexture=function(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 0:t.noiseTexture.activate();break;case 1:t.eeTexture.activate();break;default:console.error("Wrong LIC pass number")}},e.deactivateNoiseTexture=function(){switch(arguments.length>0&&void 0!==arguments[0]?arguments[0]:0){case 0:t.noiseTexture.deactivate();break;case 1:t.eeTexture.deactivate();break;default:console.error("Wrong LIC pass number")}},e.attachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.textures[1-t.readIndex],r=t.framebuffer,o=t.context;e[0].activate(),e[1].activate(),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(n[0],0),r.setColorBuffer(n[1],1),o.drawBuffers([o.COLOR_ATTACHMENT0,o.COLOR_ATTACHMENT1])},e.detachLICBuffers=()=>{const e=t.textures[t.readIndex],n=t.context,r=t.framebuffer;e[0].deactivate(),e[1].deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE])},e.attachImageVectorBuffer=()=>{const e=t.framebuffer,n=t.context;t.vectorTexture.activate(),e.removeColorBuffer(0),e.setColorBuffer(t.imageVectorTexture,0),n.drawBuffers([n.COLOR_ATTACHMENT0])},e.detachImageVectorBuffer=()=>{const e=t.context,n=t.framebuffer;t.vectorTexture.deactivate(),n.removeColorBuffer(0),e.drawBuffers([e.NONE])},e.attachEEBuffer=()=>{t.textures[t.readIndex][0].activate(),t.framebuffer.removeColorBuffer(0),t.framebuffer.setColorBuffer(t.eeTexture,0);const e=t.context;e.drawBuffers([e.COLOR_ATTACHMENT0])},e.detachEEBuffer=()=>{const e=t.context;t.framebuffer.removeColorBuffer(0),e.drawBuffers([e.NONE]),t.textures[t.readIndex][0].deactivate()},e.detachBuffers=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),e.drawBuffers([e.NONE]);const r=t.textures[t.readIndex],o=t.textures[1-t.readIndex];r[0]&&r[0].deactivate(),r[1]&&r[1].deactivate(),o[0]&&o[0].deactivate(),o[1]&&o[1].deactivate(),t.eeTexture&&t.eeTexture.deactivate(),t.noiseTexture&&t.noiseTexture.deactivate()},e.getWriteIndex=()=>1-t.readIndex,e.detachBuffers()):console.error("Pass renderwindow to ping pong manager");var n,r}(e,t)}var kf={newInstance:Ht.newInstance(Gf,"vtkLICPingPongBufferManager"),extend:Gf};const Uf=0,zf=1,Wf=2,Hf=3,jf=1,Kf={shadersNeedBuild:!0,stepSize:1,numberOfSteps:10,enhancedLIC:!0,enhanceContrast:!1,lowContrastEnhancementFactor:0,highContrastEnhancementFactor:0,antiAlias:0,componentIds:[0,1],normalizeVectors:!0,maskThreshold:0,transformVectors:!0,bufs:null,isComposite:!0};function $f(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kf,n),Ht.obj(e,t),Ht.setGet(e,t,["context","_openGLRenderWindow","nuberOfSteps","stepSize","normalizeVectors","maskThreshold","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","componentIds","isComposite"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){function n(e,t){e.setUniformi("texLIC",t.getLICTextureUnit()),e.setUniformi("texSeedPts",t.getSeedTextureUnit())}function r(e,t,n){e.attachLICBuffers(),e.renderQuad(t,n),e.detachLICBuffers(),e.swap()}t.classHierarchy.push("vtkLineIntegralConvolution2D"),e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Lf,e,""),e.dumpTextureValues=function(e,n){let[r,o]=n,a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow,s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:4;const l=qd.newInstance(),c=a;let u=null;return l.setOpenGLRenderWindow(i),l.saveCurrentBindingsAndBuffers(),l.create(r,o),l.populateFramebuffer(),l.setColorBuffer(e),u=new Float32Array(r*o*s),c.readPixels(0,0,r,o,4===s?c.RGBA:c.RGB,c.FLOAT,u),l.restorePreviousBindingsAndBuffers(),u},e.getTextureMinMax=function(n,r){let o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:t.context,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:t._openGLRenderWindow;const i=e.dumpTextureValues(n,r,o,a,4);let s=Number.MAX_VALUE,l=Number.MIN_VALUE;for(let e=0;e<i.length;e+=4)if(0===i[e+1]){const t=i[e];t<s&&(s=t),t>l&&(l=t)}return{min:s,max:l}},e.getComponentSelectionProgram=e=>{const t="xyzw";return`.${t[e[0]]}${t[e[1]]}`},e.buildShaders=()=>{t.LIC0ShaderProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LIC0.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n/**\nThis shader initializes the convolution for the LIC computation.\n*/\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texMaskVectors;\nuniform sampler2D texNoise;\nuniform sampler2D texLIC;\n\nuniform int   uStepNo;         // in step 0 initialize lic and seeds, else just seeds\nuniform int   uPassNo;         // in pass 1 hpf of pass 0 is convolved.\nuniform float uMaskThreshold;  // if |V| < uMaskThreshold render transparent\nuniform vec2  uNoiseBoundsPt1; // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the *whole* domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value. this\n// depends on the pass number.\nvec2 getNoiseTC(vec2 vectc)\n{\n  // in pass 1 : convert from vector tc to noise tc\n  // in pass 2 : use vector tc\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(vectc);\n    }\n  else\n    {\n    return vectc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the\n// need to convert to noise texture coordinates.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\nvoid main(void)\n{\n  vec2 vectc = tcoordVC.st;\n\n  // lic => (convolution, mask, 0, step count)\n  if (uStepNo == 0)\n    {\n    float maskCriteria = length(texture2D(texMaskVectors, vectc).xyz);\n    float maskFlag;\n    if (maskCriteria <= uMaskThreshold)\n      {\n      maskFlag = 1.0;\n      }\n    else\n      {\n      maskFlag = 0.0;\n      }\n    float noise = getNoise(vectc);\n    LICOutput = vec4(noise, maskFlag, 0.0, 1.0);\n    }\n  else\n    {\n    LICOutput = texture2D(texLIC, vectc);\n    }\n\n  // initial seed\n  SeedOutput = vec4(vectc, 0.0, 1.0);\n}\n");const n=Pu.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_VT.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// move vector field to normalized image space\n// pre-processing for vtkLineIntegralConvolution2D\n\n// the output of this shader\n//VTK::Output::Dec\n\n// Fragment shader used by the gaussian blur filter render pass.\n\nuniform sampler2D texVectors; // input texture\nuniform vec2      uTexSize;   // size of texture\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  //VTK::LICComponentSelection::Impl\n  V = V/uTexSize;\n  gl_FragData[0] = vec4(V, 0.0, 1.0);\n}\n","//VTK::LICComponentSelection::Impl",`vec2 V = texture2D(texVectors, tcoordVC.st)${e.getComponentSelectionProgram(t.componentIds)};`).result;t.VTProgram=e.buildAShader(n);const r=Pu.substitute("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs1.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D  texVectors;\nuniform sampler2D  texNoise;\nuniform sampler2D  texLIC;\nuniform sampler2D  texSeedPts;\n\nuniform int   uPassNo;          // in pass 1 hpf of pass 0 is convolved.\nuniform float uStepSize;        // step size in parametric space\n\nuniform vec2  uNoiseBoundsPt1;  // tc of upper right pt of noise texture\n\nin vec2 tcoordVC;\n\n//VTK::LICVectorLookup::Impl\n\n// We need to do this manually since CLAMP_TO_BORDER and and borderColor\n// are very poorly supported in webgl\nvec2 clampToBorder(vec2 uv){\n  if(uv.x < 0.0 || uv.x > 1.0 || uv.y < 0.0 || uv.y > 1.0)\n  {\n    return vec2(0.0, 0.0);\n  }\n  return getVector(uv);\n}\n\n// convert from vector coordinate space to noise coordinate space.\n// the noise texture is tiled across the whole domain\nvec2 VectorTCToNoiseTC(vec2 vectc)\n{\n  return vectc/uNoiseBoundsPt1;\n}\n\n// get the texture coordidnate to lookup noise value.\n// in pass 1 repeatedly tile the noise texture across\n// the computational domain.\nvec2 getNoiseTC(vec2 tc)\n{\n  if (uPassNo == 0)\n    {\n    return VectorTCToNoiseTC(tc);\n    }\n  else\n    {\n    return tc;\n    }\n}\n\n// look up noise value at the given location. The location\n// is supplied in vector texture coordinates, hence the need\n// to convert to either noise or lic texture coordinates in\n// pass 1 and 2 respectively.\nfloat getNoise(vec2 vectc)\n{\n  return texture2D(texNoise, getNoiseTC(vectc)).r;\n}\n\n// fourth-order Runge-Kutta streamline integration\n// no bounds checks are made, therefore it's essential\n// to have the entire texture initialized to 0\n// and set clamp to border and have border color 0\n// an integer is set if the step was taken, keeping\n// an accurate step count is necessary to prevent\n// boundary artifacts. Don't count the step if\n// all vector lookups are identically 0. This is\n// a proxy for \"stepped outside valid domain\"\nvec2 rk4(vec2 pt0, float dt, out bool count)\n{\n  count=true;\n  float dtHalf = dt * 0.5;\n  vec2 pt1;\n\n  vec2 v0 = clampToBorder(pt0);\n  pt1 = pt0 + v0 * dtHalf;\n\n  vec2 v1 = clampToBorder(pt1);\n  pt1 = pt0 + v1 * dtHalf;\n\n  vec2 v2 = clampToBorder(pt1);\n  pt1 = pt0 + v2 * dt;\n\n  vec2 v3 = clampToBorder(pt1);\n  vec2 vSum = v0 + v1 + v1 + v2 + v2 + v3;\n\n  if (vSum == vec2(0.0, 0.0))\n    {\n      count = false;\n    }\n\n  pt1 = pt0 + (vSum) * (dt * (1.0/6.0));\n\n return pt1;\n}\n\nvoid main(void)\n{\n  vec2 lictc = tcoordVC.st;\n  vec4 lic = texture2D(texLIC, lictc);\n  vec2 pt0 = texture2D(texSeedPts, lictc).st;\n\n  bool count;\n  vec2 pt1 = rk4(pt0, uStepSize, count);\n\n  if (count)\n    {\n    // accumulate lic step\n    // (lic, mask, 0, step count)\n    float noise = getNoise(pt1);\n    LICOutput = vec4(lic.r + noise, lic.g, 0.0, lic.a + 1.0);\n    SeedOutput = vec4(pt1, 0.0, 1.0);\n    }\n  else\n    {\n    // keep existing values\n    LICOutput = lic;\n    SeedOutput = vec4(pt0, 0.0, 1.0);\n    }\n}\n","//VTK::LICVectorLookup::Impl",function(){return arguments.length>0&&void 0!==arguments[0]&&!arguments[0]?"\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      return texture2D( texVectors, vectc ).xy;\n\n      }\n\n    ":"\n    vec2 getVector( vec2 vectc )\n\n      {\n\n      vec2 V = texture2D( texVectors, vectc ).xy;\n\n      // normalize if |V| not 0\n\n      float lenV = length( V );\n\n      if ( lenV > 1.0e-8 )\n\n        {\n\n        return V/lenV;\n\n        }\n\n      else\n\n        {\n\n        return vec2( 0.0, 0.0 );\n\n        }\n\n      }\n\n    "}(t.normalizeVectors),!0).result;t.LICIShaderProgram=e.buildAShader(r),t.LICNShaderProgram=e.buildAShader(" //VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_LICN.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n/**\nThis shader finalizes the convolution for the LIC computation\napplying the normalization. eg. if box kernel is used the this\nis the number of steps taken.\n*/\n\nuniform sampler2D texLIC;\n\nin vec2 tcoordVC;\n\nvoid main(void)\n{\n  vec4 conv = texture2D(texLIC, tcoordVC.st);\n  conv.r = conv.r/conv.a;\n  // lic => (convolution, mask, 0, 1)\n  LICOutput = vec4(conv.rg , 0.0, 1.0);\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.CEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// gray scale contrast enhance stage implemented via histogram stretching\n// if the min and max are tweaked it can generate out-of-range values\n// these will be clamped in 0 to 1\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\n\nuniform sampler2D texLIC;  // most recent lic pass\nuniform float uMin;        // min gray scale color value\nuniform float uMaxMinDiff; // max-min\n\nin vec2 tcoordVC;\n\nvoid main( void )\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g!=0.0)\n    {\n    LICOutput = lic;\n    }\n  else\n    {\n    float CElic = clamp((lic.r - uMin)/uMaxMinDiff, 0.0, 1.0);\n    LICOutput = vec4(CElic, lic.gb, 1.0);\n    }\n    SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.EEProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// high-pass filter stage employed by vtkLineIntegralConvolution2D\n// between LIC pass 1 and LIC pass 2. filtered LIC pass 1, becomes\n// noise for pass2.\n\n// the output of this shader\nlayout(location = 0) out vec4 EEOutput;\n\nuniform sampler2D texLIC; // most recent lic pass\nuniform float     uDx;    // fragment size\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n// kernel for simple laplace edge enhancement.\n// p=Laplace(p)+p\nfloat K[9] = float[9](\n  -1.0, -1.0, -1.0,\n  -1.0,  9.0, -1.0,\n  -1.0, -1.0, -1.0\n  );\n\n// determine if the fragment was masked\nbool Masked(float val) { return val != 0.0; }\n\nvoid main(void)\n{\n  // tex coord neighbor offsets\n  vec2 fragDx[9] = vec2[9](\n    vec2(-uDx, uDy), vec2(0.0, uDy), vec2(uDx, uDy),\n    vec2(-uDx, 0.0), vec2(0.0, 0.0), vec2(uDx, 0.0),\n    vec2(-uDx,-uDy), vec2(0.0,-uDy), vec2(uDx,-uDy)\n    );\n\n  vec2 lictc = tcoordVC.st;\n\n  // compute the convolution but don't use convovled values if\n  // any masked fragments on the stencil. Fragments outside\n  // the valid domain are masked during initialization, and\n  // texture wrap parameters are clamp to border with border\n  // color that contains masked flag\n  float conv = 0.0;\n  bool dontUse = false;\n  for (int i=0; i<9; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    vec4 lic = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic.g);\n    conv = conv + K[i] * lic.r;\n    }\n\n  if (dontUse)\n    {\n    EEOutput = vec4(texture2D(texLIC, lictc).rg, 0.0, 1.0);\n    }\n  else\n    {\n    conv = clamp(conv, 0.0, 1.0);\n    EEOutput = vec4(conv,texture2D(texLIC, lictc).g, 0.0, 1.0);\n    }\n\n}\n"),t.AAHProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAH.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// horizontal pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDx;    // fragment size\n\nin vec2 tcoordVC;\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDx[3] = vec2[3](vec2(-uDx,0.0), vec2(0.0,0.0), vec2(uDx,0.0));\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDx[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n"),t.AAVProgram=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkLineIntegralConvolution2D_AAV.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// Anti-alias stage in vtkLineIntegralConvolution2D\n// vertical pass of a Gaussian convolution\n\n// the output of this shader\nlayout(location = 0) out vec4 LICOutput;\nlayout(location = 1) out vec4 SeedOutput;\n\nuniform sampler2D texLIC; // input texture\nuniform float     uDy;    // fragment size\n\nin vec2 tcoordVC;\n\n\n// factored 3x3 Gaussian kernel\n// K^T*K = G\nfloat K[3] = float[3](0.141421356, 0.707106781, 0.141421356);\n\n// determine if the fragment was masked\nbool Masked(float val){ return val != 0.0; }\n\nvoid main(void)\n{\n// neighbor offsets\nvec2 fragDy[3] = vec2[3](vec2(0.0,-uDy), vec2(0.0,0.0), vec2(0.0,uDy));\n\n\n  vec2 lictc = tcoordVC.st;\n  vec4 lic[3];\n  bool dontUse = false;\n  float conv = 0.0;\n  for (int i=0; i<3; ++i)\n    {\n    vec2 tc = lictc + fragDy[i];\n    lic[i] = texture2D(texLIC, tc);\n    dontUse = dontUse || Masked(lic[i].g);\n    conv = conv + K[i] * lic[i].r;\n    }\n  // output is (conv, mask, skip, 1)\n  if (dontUse)\n    {\n    LICOutput = vec4(lic[1].rg, 1.0, 1.0);\n    }\n  else\n    {\n    LICOutput = vec4(conv, lic[1].gb, 1.0);\n    }\n  SeedOutput = vec4(0.0, 0.0, 0.0, 0.0);\n}\n")},e.executeLIC=(o,a,i,s,l,c)=>{if(t._openGLRenderWindow=l,t.context=l.getContext(),Object.assign(t,c),o[0]<=0||o[1]<=0)return null;const u=[1/o[0],1/o[1]];let d=t.stepSize*Math.sqrt(u[0]*u[0]+u[1]*u[1]);d<=0&&(d=1e-10);const p=t.context;let f=t.framebuffer;const g=f?.getSize();f&&g&&o[0]===g&&o[1]===g||(f=qd.newInstance(),f.setOpenGLRenderWindow(t._openGLRenderWindow),f.saveCurrentBindingsAndBuffers(),f.create(...o),f.populateFramebuffer(),f.restorePreviousBindingsAndBuffers(),t.framebuffer=f),f.saveCurrentBindingsAndBuffers(),f.bind(),p.viewport(0,0,...o),p.scissor(0,0,...o),t.shadersNeedBuild&&(e.buildShaders(),t.shadersNeedBuild=!1),t.bufs?(t.bufs.setVectorTexture(a),t.bufs.setMaskVectorTexture(i),t.bufs.setNoiseTexture(s)):t.bufs=kf.newInstance({openGLRenderWindow:l,doEEPass:t.enhancedLIC,doVTPass:t.transformVectors,vectorTexture:a,maskVectorTexture:i,noiseTexture:s,framebuffer:f,size:o});const m=[(s.getWidth()+1)/o[0],(s.getHeight()+1)/o[1]],h=1/o[0],v=1/o[1],T=t._openGLRenderWindow.getShaderCache();if(t.transformVectors){const e=t.VTProgram;T.readyShaderProgram(e),t.bufs.attachImageVectorBuffer(),e.setUniform2f("uTexSize",...o),e.setUniformi("texVectors",t.bufs.getVectorTextureUnit()),p.clearColor(0,0,0,0),p.clear(p.COLOR_BUFFER_BIT),t.bufs.renderQuad(o,e),t.bufs.detachImageVectorBuffer()}t.bufs.clearBuffers(t.enhancedLIC),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(0);const{LIC0ShaderProgram:y}=t;T.readyShaderProgram(y),y.setUniformi("uStepNo",0),y.setUniformi("uPassNo",0),y.setUniformf("uMaskThreshold",t.maskThreshold),y.setUniform2f("uNoiseBoundsPt1",...m),y.setUniformi("texMaskVectors",t.bufs.getMaskVectorTextureUnit()),y.setUniformi("texLIC",t.bufs.getLICTextureUnit()),y.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0)),r(t.bufs,o,y);const{LICIShaderProgram:b}=t;T.readyShaderProgram(b),b.setUniformi("uPassNo",0),b.setUniformf("uStepSize",-d),b.setUniform2f("uNoiseBoundsPt1",...m),b.setUniformi("texVectors",t.bufs.getImageVectorTextureUnit()),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(0));for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);T.readyShaderProgram(y),y.setUniformi("uStepNo",1),n(y,t.bufs),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<t.numberOfSteps;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(0),t.bufs.deactivateVectorTextures();const{LICNShaderProgram:x}=t;if(T.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),r(t.bufs,o,x),t.enhancedLIC){t.enhanceContrast!==zf&&t.enhanceContrast!==Hf||e.contrastEnhance(!1,o),t.bufs.attachEEBuffer();const{EEProgram:a}=t;T.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDx",h),a.setUniformf("uDy",v),t.bufs.renderQuad(o,a),t.bufs.detachEEBuffer(),t.bufs.detachBuffers(),t.bufs.clearBuffers(!1),t.bufs.activateVectorTextures(),t.bufs.activateNoiseTexture(1),T.readyShaderProgram(y),y.setUniformi("uStepNo",0),y.setUniformi("uPassNo",1),n(y,t.bufs),y.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1)),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformi("uPassNo",1),b.setUniformf("uStepSize",-d),b.setUniformi("texNoise",t.bufs.getNoiseTextureUnit(1));const i=t.numberOfSteps/2;for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);T.readyShaderProgram(y),y.setUniformi("uStepNo",1),n(y,t.bufs),r(t.bufs,o,y),T.readyShaderProgram(b),b.setUniformf("uStepSize",d);for(let e=0;e<i;++e)n(b,t.bufs),r(t.bufs,o,b);t.bufs.deactivateNoiseTexture(1),t.bufs.deactivateVectorTextures(),T.readyShaderProgram(x),x.setUniformi("texLIC",t.bufs.getLICTextureUnit()),x.setUniformi("texSeedPts",t.bufs.getSeedTextureUnit()),r(t.bufs,o,x)}if(t.antiAlias){const e=t.AAHProgram;T.readyShaderProgram(e),e.setUniformi("texLIC",t.bufs.getLICTextureUnit()),e.setUniformf("uDx",h);const a=t.AAVProgram;T.readyShaderProgram(a),a.setUniformi("texLIC",t.bufs.getLICTextureUnit()),a.setUniformf("uDy",v);for(let i=0;i<t.antiAlias;++i)T.readyShaderProgram(e),n(e,t.bufs),r(t.bufs,o,e),T.readyShaderProgram(a),n(a,t.bufs),r(t.bufs,o,a)}return t.enhanceContrast!==zf&&t.enhanceContrast!==Hf||e.contrastEnhance(!0,o),t.bufs.detachBuffers(),f.restorePreviousBindingsAndBuffers(),t.bufs.getLastLICBuffer()},e.contrastEnhance=(n,o)=>{const a=t._openGLRenderWindow.getShaderCache();let{min:i,max:s}=e.getTextureMinMax(t.bufs.getLastLICBuffer(),o,t.context,t._openGLRenderWindow);(s<=i||s>1||i<0)&&(console.error("Invalid color range: ",i,s),i=0,s=1);let l=s-i;n&&(i+=l*t.lowLICContrastEnhancementFactor,s-=l*t.highLICContrastEnhancementFactor,l=s-i);const{CEProgram:c}=t;a.readyShaderProgram(c),c.setUniformi("texLIC",t.bufs.getLICTextureUnit()),c.setUniformf("uMin",i),c.setUniformf("uMaxMinDiff",l),r(t.bufs,o,c)}}(e,t)}var qf={newInstance:Ht.newInstance($f,"vtkLineIntegralConvolution2D"),extend:$f};const Xf={enableLIC:!1,nuberOfSteps:40,stepSize:.25,transformVectors:!0,normalizeVectors:!0,maskOnSurface:!1,maskThreshold:0,maskColor:[0,0,0],maskIntensity:0,enhancedLIC:!0,enhanceContrast:Uf,lowLICContrastEnhancementFactor:0,highLICContrastEnhancementFactor:0,lowColorContrastEnhancementFactor:0,highColorContrastEnhancementFactor:0,antiAlias:0,colorMode:0,LICIntensity:1,mapModeBias:0,noiseTextureSize:200,noiseTextureType:jf,noiseGrainSize:8,noiseImpulseProbability:.1,noiseImpulseBackgroundValue:0,noiseGeneratorSeed:0,minNoiseValue:0,maxNoiseValue:1,numberOfNoiseLevels:2,shadersNeedBuilding:!0,reallocateTextures:!0,rebuildNoiseTexture:!1,viewPortScale:1};function Yf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xf,n),Ht.obj(e,t),Ht.setGet(e,t,["enableLIC","numberOfSteps","stepSize","normalizeVectors","transformVectors","maskOnSurface","maskThreshold","maskColor","maskIntensity","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor","antiAlias","colorMode","LICIntensity","mapModeBias","noiseTextureSize","noiseTextureType","noiseGrainSize","minNoiseValue","maxNoiseValue","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","noiseGeneratorSeed","viewPortScale","rebuildNoiseTexture"]),function(e,t){t.classHierarchy.push("vtkSurfaceLICInterface")}(0,t)}var Zf={newInstance:Ht.newInstance(Yf,"vtkSurfaceLICInterface"),extend:Yf};const{Representation:Qf}=ts;const Jf={context:null,shadersNeedBuilding:!0,reallocateTextures:!0,size:null,licInterface:null};function eg(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jf,n),Zf.extend(e,t,n),Ht.obj(e,t),Ht.setGet(e,t,["context","_openGLRenderWindow","reallocateTextures","licInterface","size"]),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICInterface"),e.renderQuad=(e,n)=>{const r=t.licQuad,o=t.context;let a=t.licQuadVAO;a||(a=Eu.newInstance(),a.setOpenGLRenderWindow(t._openGLRenderWindow),t.licQuadVAO=a),t.previousProgramHash!==n.getMd5Hash()&&(a.shaderProgramChanged(),r.getCABO().bind(),a.addAttributeArray(n,r.getCABO(),"vertexDC",r.getCABO().getVertexOffset(),r.getCABO().getStride(),t.context.FLOAT,3,t.context.FALSE),a.addAttributeArray(n,r.getCABO(),"tcoordDC",r.getCABO().getTCoordOffset(),r.getCABO().getStride(),t.context.FLOAT,2,t.context.FALSE),t.previousProgramHash=n.getMd5Hash()),o.drawArrays(o.TRIANGLES,0,r.getCABO().getElementCount()),a.release()},e.generateNoiseTexture=e=>{if(!t.noiseTexture||t.licInterface.getRebuildNoiseTexture()){t.licInterface.setRebuildNoiseTexture(!1),t.noiseTexture&&t.noiseTexture.releaseGraphicsResources(),io()(t.noiseGeneratorSeed,{global:!0});let n=[];const{noiseTextureType:r,noiseGrainSize:o,numberOfNoiseLevels:a,noiseImpulseProbability:i,noiseImpulseBackgroundValue:s,minNoiseValue:l,maxNoiseValue:c}=t.licInterface.get("noiseTextureType","noiseGrainSize","numberOfNoiseLevels","noiseImpulseProbability","noiseImpulseBackgroundValue","minNoiseValue","maxNoiseValue");n=r===jf?function(e,t,n,r,o,a){const i=Math.max(0,Math.min(1,n)),s=Float32Array.from({length:e*e},(()=>{let e=0;if(1===i||Math.random()>1-i)for(let t=0;t<2048;++t)e+=Math.random();return e}));let l=0,c=2049;s.forEach((e=>{c=1===i?e<c?e:c:e<c&&e>0?e:c,l=e>l?e:l}));let u=l-c;0===u&&(c=0,u=0===l?1:l);const d=t-1,p=0!==d?1/d:0,f=a-o;return s.map((e=>{const n=e<c?e:(e-c)/u,i=Math.floor(n*t);return e>=c?1===t?a:o+(i>d?d:i)*p*f:r}))}(Math.floor(e/o),a,i,s,l,c):function(e,t,n,r){let[o,a]=e;const i=r-n;return Float32Array.from({length:o*a},(()=>{let e=Math.random();return e=Math.floor(e*t)/t,e=e*i+n,e>1?1:e<0?0:e}))}([Math.ceil(e/o),Math.ceil(e/o)],a,l,c);const u=1/o,d=Float32Array.from({length:e*e*4},((t,r)=>{const a=r/4;if(r%4==0){const t=Math.floor(a%e*u),r=Math.floor(a/e*u);return n[r*(e/o)+t]}return r%4==1||r%4==3?1:0})),p=td.newInstance({wrapS:td.Wrap.REPEAT,wrapT:td.Wrap.REPEAT,minificationFilter:td.Filter.NEAREST,magnificationFilter:td.Filter.NEAREST,generateMipMap:!1,openGLDataType:t.context.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});p.setOpenGLRenderWindow(t._openGLRenderWindow),p.create2DFromRaw({width:e,height:e,numComps:4,dataType:"Float32Array",data:d}),p.activate(),p.sendParameters(),p.deactivate(),t.noiseTexture=p}},e.buildAShader=e=>t._openGLRenderWindow.getShaderCache().readyShaderProgramArray(Lf,e,""),e.allocateTextures=()=>{const n=td.Filter.NEAREST,r=td.Filter.LINEAR,o=t._openGLRenderWindow;t.geometryImage||(t.geometryImage=e.allocateTexture(o,n)),t.vectorImage||(t.vectorImage=e.allocateTexture(o,r)),t.maskVectorImage||(t.maskVectorImage=e.allocateTexture(o,r)),t.LICImage||(t.LICImage=e.allocateTexture(o,n)),t.RGBColorImage||(t.RGBColorImage=e.allocateTexture(o,n)),t.HSLColorImage||(t.HSLColorImage=e.allocateTexture(o,n)),t.depthTexture||(t.depthTexture=e.allocateDepthTexture(o))},e.allocateTexture=(e,n)=>{const r=t.context,o=td.newInstance({wrapS:td.Wrap.CLAMP_TO_EDGE,wrapT:td.Wrap.CLAMP_TO_EDGE,minificationFilter:n,magnificationFilter:n,generateMipmap:!1,openGLDataType:r.FLOAT,baseLevel:0,maxLevel:0,autoParameters:!1});return o.setOpenGLRenderWindow(e),o.setInternalFormat(r.RGBA32F),o.create2DFromRaw({width:t.size[0],height:t.size[1],numComps:4,dataType:"Float32Array",data:null}),o.activate(),o.sendParameters(),o.deactivate(),o},e.allocateDepthTexture=e=>{const n=t.context,r=td.newInstance({generateMipmap:!1,openGLDataType:n.FLOAT,autoParameters:!1});return r.setOpenGLRenderWindow(e),r.createDepthFromRaw({width:t.size[0],height:t.size[1],dataType:"Float32Array",data:null}),r.activate(),r.sendParameters(),r.deactivate(),r},e.createFBO=()=>{if(!t.framebuffer){t.licHelper=null;const e=qd.newInstance();e.setOpenGLRenderWindow(t._openGLRenderWindow),e.saveCurrentBindingsAndBuffers(),e.create(...t.size),e.populateFramebuffer(),t.framebuffer=e,e.restorePreviousBindingsAndBuffers()}},e.completedGeometry=()=>{const e=t.context,n=t.framebuffer;n.removeColorBuffer(0),n.removeColorBuffer(1),n.removeColorBuffer(2),n.removeDepthBuffer(),e.drawBuffers([e.NONE]),n.restorePreviousBindingsAndBuffers()},e.buildAllShaders=()=>{t.shadersNeedBuilding&&(t.licColorPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_fs2.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader combines surface geometry, LIC, and  scalar colors.\n\n// the output of this shader\nlayout(location = 0) out vec4 RGBOutput;\nlayout(location = 1) out vec4 HSLOutput;\n\nuniform sampler2D texVectors;       // vectors, depth\nuniform sampler2D texGeomColors;    // scalar colors + lighting\nuniform sampler2D texLIC;           // image lic\nuniform int       uScalarColorMode; // select between blend, and map shader\nuniform float     uLICIntensity;    // blend shader: blending factor for lic'd colors\nuniform float     uMapBias;         // map shader: adjust the brightness of the result\nuniform float     uMaskIntensity;   // blending factor for mask color\nuniform vec3      uMaskColor;       // color for the masked out fragments\n\nin vec2 tcoordVC;\n\n/**\nConvert from RGB color space into HSL colorspace.\n*/\nvec3 RGBToHSL(vec3 RGB)\n{\n  vec3 HSL = vec3(0.0, 0.0, 0.0);\n\n  float RGBMin = min(min(RGB.r, RGB.g), RGB.b);\n  float RGBMax = max(max(RGB.r, RGB.g), RGB.b);\n  float RGBMaxMinDiff = RGBMax - RGBMin;\n\n  HSL.z = (RGBMax + RGBMin) / 2.0;\n\n  if (RGBMaxMinDiff == 0.0)\n    {\n    // Gray scale\n    HSL.x = 0.0;\n    HSL.y = 0.0;\n    }\n  else\n    {\n    // Color\n    if (HSL.z < 0.5)\n      HSL.y = RGBMaxMinDiff / (RGBMax + RGBMin);\n    else\n      HSL.y = RGBMaxMinDiff / (2.0 - RGBMax - RGBMin);\n\n    float dR\n      = (((RGBMax - RGB.r) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dG\n      = (((RGBMax - RGB.g) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n    float dB\n      = (((RGBMax - RGB.b) / 6.0) + (RGBMaxMinDiff / 2.0)) / RGBMaxMinDiff;\n\n    if (RGB.r == RGBMax)\n      HSL.x = dB - dG;\n    else\n    if (RGB.g == RGBMax)\n      HSL.x = (1.0 / 3.0) + dR - dB;\n    else\n    if (RGB.b == RGBMax)\n      HSL.x = (2.0 / 3.0) + dG - dR;\n\n    if (HSL.x < 0.0)\n      HSL.x += 1.0;\n\n    if (HSL.x > 1.0)\n      HSL.x -= 1.0;\n    }\n\n  return HSL;\n}\n\n/**\nHelper for HSL to RGB conversion.\n*/\nfloat Util(float v1, float v2, float vH)\n{\n  if (vH < 0.0)\n    vH += 1.0;\n\n  if (vH > 1.0)\n     vH -= 1.0;\n\n  if ((6.0 * vH) < 1.0)\n    return (v1 + (v2 - v1) * 6.0 * vH);\n\n  if ((2.0 * vH) < 1.0)\n    return (v2);\n\n  if ((3.0 * vH) < 2.0)\n    return (v1 + (v2 - v1) * ((2.0 / 3.0) - vH) * 6.0);\n\n  return v1;\n}\n\n/**\nConvert from HSL space into RGB space.\n*/\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  if (HSL.y == 0.0)\n    {\n    // Gray\n    RGB.r = HSL.z;\n    RGB.g = HSL.z;\n    RGB.b = HSL.z;\n    }\n  else\n    {\n    // Chromatic\n    float v2;\n    if (HSL.z < 0.5)\n      v2 = HSL.z * (1.0 + HSL.y);\n    else\n      v2 = (HSL.z + HSL.y) - (HSL.y * HSL.z);\n\n    float v1 = 2.0 * HSL.z - v2;\n\n    RGB.r = Util(v1, v2, HSL.x + (1.0 / 3.0));\n    RGB.g = Util(v1, v2, HSL.x);\n    RGB.b = Util(v1, v2, HSL.x - (1.0 / 3.0));\n    }\n\n  return RGB.rgb;\n}\n\nvoid main()\n{\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n\n  // depth is used to determine which fragment belong to us\n  // and we can change\n  float depth = texture2D(texVectors, tcoordVC.st).a;\n\n  vec3 fragColorRGB;\n  float valid;\n  if (depth > 1.0e-3)\n    {\n    // we own it\n    // shade LIC'ed geometry, or apply mask\n    if (lic.g!=0.0)\n      {\n      // it's masked\n      // apply fragment mask\n      fragColorRGB = uMaskIntensity * uMaskColor + (1.0 - uMaskIntensity) * geomColor.rgb;\n      valid = 0.0;\n      }\n    else\n      {\n      if (uScalarColorMode==0)\n        {\n        // blend with scalars\n        fragColorRGB = lic.rrr * uLICIntensity + geomColor.rgb * (1.0 - uLICIntensity);\n        }\n      else\n        {\n        // multiply with scalars\n        fragColorRGB = geomColor.rgb * clamp((uMapBias + lic.r), 0.0, 1.0);\n        }\n      if (lic.b != 0.0)\n        {\n        // didn't have the required guard pixels\n        // don't consider it in min max estimation\n        // for histpgram stretching\n        valid = 0.0;\n        }\n      else\n        {\n        // ok to use in min/max estimates for histogram\n        // stretching\n        valid = 1.0;\n        }\n      }\n    }\n  else\n    {\n    // we don't own it\n    // pass through scalars\n    fragColorRGB = geomColor.rgb;\n    valid = 0.0;\n    }\n\n  // if no further stages this texture is\n  // copied to the screen\n  RGBOutput = vec4(fragColorRGB, geomColor.a);\n\n  // if further stages, move to hsl space for contrast\n  // enhancement. encoding validity saves moving a texture to the cpu\n  vec3 fragColorHSL = RGBToHSL(fragColorRGB);\n  HSLOutput = vec4(fragColorHSL, valid);\n}\n"),t.licCopyPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_DCpy.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// This shader copies fragments and depths to the output buffer\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texDepth;     // z values from vertex shader\nuniform sampler2D texRGBColors; // final rgb LIC colors\n\nin vec2 tcoordVC;\n\nvoid main()\n{\n  gl_FragDepth = texture2D(texDepth, tcoordVC).x;\n  gl_FragData[0] = texture2D(texRGBColors, tcoordVC);\n\n  // since we render a screen aligned quad\n  // we're going to be writing fragments\n  // not touched by the original geometry\n  // it's critical not to modify those\n  // fragments.\n  if (gl_FragDepth == 1.0)\n    {\n    discard;\n    }\n}\n"),t.enhanceContrastPass=e.buildAShader("//VTK::System::Dec\n\n//=========================================================================\n//\n//  Program:   Visualization Toolkit\n//  Module:    vtkSurfaceLICMapper_CE.glsl\n//\n//  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n//  All rights reserved.\n//  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n//\n//     This software is distributed WITHOUT ANY WARRANTY; without even\n//     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n//     PURPOSE.  See the above copyright notice for more information.\n//\n//=========================================================================\n\n// color contrast enhance stage implemented via histogram stretching\n// on lightness channel. if the min and max are tweaked it can generate\n// out-of-range values these will be clamped in 0 to 1\n\n// the output of this shader\n//VTK::Output::Dec\n\nuniform sampler2D texGeomColors; // scalars + lighting\nuniform sampler2D texLIC;        // image lic, mask\nuniform sampler2D texHSLColors;  // hsla colors\n\nuniform float     uLMin;         // min lightness over all fragments\nuniform float     uLMaxMinDiff;  // max - min lightness over all fragments\n\nin vec2 tcoordVC;\n\nvec3 HSLToRGB(vec3 HSL)\n{\n  vec3 RGB;\n  float v;\n  float h = HSL.x;\n  float sl = HSL.y;\n  float l = HSL.z;\n\n  v = (l <= 0.5) ? (l * (1.0 + sl)) : (l + sl - l * sl);\n  if (v <= 0.0) {\n    RGB = vec3(0.0,0.0,0.0);\n  } else {\n    float m;\n    int sextant;\n    float fract, vsf, mid1, mid2;\n\n    m = l + l - v;\n    h *= 6.0;\n    sextant = int(h);\n    fract = h - float(sextant);\n\n    vsf = (v - m) * fract;\n    mid1 = m + vsf;\n    mid2 = v - vsf;\n    switch (sextant) {\n      case 0: RGB.r = v; RGB.g = mid1; RGB.b = m; break;\n      case 1: RGB.r = mid2; RGB.g = v; RGB.b = m; break;\n      case 2: RGB.r = m; RGB.g = v; RGB.b = mid1; break;\n      case 3: RGB.r = m; RGB.g = mid2; RGB.b = v; break;\n      case 4: RGB.r = mid1; RGB.g = m; RGB.b = v; break;\n      case 5: RGB.r = v; RGB.g = m; RGB.b = mid2; break;\n    }\n  }\n  return RGB;\n}\n\nvoid main()\n{\n  // lookup hsl color , mask\n  vec4 fragColor = texture2D(texHSLColors, tcoordVC.st);\n\n  // don't modify masked fragments (masked => lic.g==1)\n  vec4 lic = texture2D(texLIC, tcoordVC.st);\n  if (lic.g==0.0)\n    {\n    // normalize lightness channel\n    fragColor.z = clamp((fragColor.z - uLMin)/uLMaxMinDiff, 0.0, 1.0);\n    }\n\n  // back into rgb space\n  fragColor.rgb = HSLToRGB(fragColor.xyz);\n\n  // add alpha\n  vec4 geomColor = texture2D(texGeomColors, tcoordVC.st);\n  fragColor.a = geomColor.a;\n\n  gl_FragData[0] = fragColor;\n}\n"),t.shadersNeedBuilding=!1)},e.initializeResources=()=>{e.createFBO(),e.generateNoiseTexture(t.licInterface.getNoiseTextureSize()),e.allocateTextures(),e.buildAllShaders(),t.licQuad||(t.licQuad=function(e){const t=Bu.newInstance();t.setOpenGLRenderWindow(e);const n=new Float32Array(12);for(let e=0;e<4;e++)n[3*e]=e%2*2-1,n[3*e+1]=e>1?1:-1,n[3*e+2]=0;const r=new Float32Array([0,0,1,0,0,1,1,1]),o=new Uint16Array(8);o[0]=3,o[1]=0,o[2]=1,o[3]=3,o[4]=3,o[5]=0,o[6]=3,o[7]=2;const a=Ts.newInstance({numberOfComponents:3,values:n});a.setName("points");const i=Ts.newInstance({numberOfComponents:1,values:o}),s=Ts.newInstance({numberOfComponents:2,values:r});return t.getCABO().createVBO(i,"polys",Qf.SURFACE,{points:a,cellOffset:0,tcoords:s}),t}(t._openGLRenderWindow)),t.licHelper||(t.licHelper=qf.newInstance())},e.prepareForGeometry=()=>{const e=t.framebuffer;e.saveCurrentBindingsAndBuffers(),e.bind(),t.geometryImage.activate(),t.vectorImage.activate(),t.maskVectorImage.activate(),e.removeColorBuffer(0),e.removeColorBuffer(2),e.removeColorBuffer(3),e.setColorBuffer(t.geometryImage,0),e.setColorBuffer(t.vectorImage,2),e.setColorBuffer(t.maskVectorImage,3),e.setDepthBuffer(t.depthTexture);const n=t.context;n.drawBuffers([n.COLOR_ATTACHMENT0,n.NONE,n.COLOR_ATTACHMENT2,n.COLOR_ATTACHMENT3]),n.viewport(0,0,...t.size),n.scissor(0,0,...t.size),n.disable(n.BLEND),n.disable(n.DEPTH_TEST),n.disable(n.SCISSOR_TEST),n.clearColor(0,0,0,0),n.clear(n.DEPTH_BUFFER_BIT|n.COLOR_BUFFER_BIT)},e.copyToScreen=n=>{t.RGBColorImage.activate(),t.depthTexture.activate(),t.licCopyPass||e.initializeResources();const r=t.licCopyPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(r);const o=t.context;o.viewport(0,0,...n),o.scissor(0,0,...n),o.disable(o.BLEND),o.enable(o.DEPTH_TEST),o.disable(o.SCISSOR_TEST),r.setUniformi("texDepth",t.depthTexture.getTextureUnit()),r.setUniformi("texRGBColors",t.RGBColorImage.getTextureUnit()),e.renderQuad(n,r),t.RGBColorImage.deactivate(),t.depthTexture.deactivate()},e.combineColorsAndLIC=()=>{const n=t.context,r=t.framebuffer;r.saveCurrentBindingsAndBuffers(),r.bind(),r.create(...t.size),r.removeColorBuffer(0),r.removeColorBuffer(1),r.setColorBuffer(t.RGBColorImage,0),r.setColorBuffer(t.HSLColorImage,1),n.drawBuffers([n.COLOR_ATTACHMENT0,n.COLOR_ATTACHMENT1]),n.disable(n.DEPTH_TEST),n.clearColor(0,0,0,0),n.clear(n.COLOR_BUFFER_BIT),t.vectorImage.activate(),t.geometryImage.activate(),t.LICImage.activate(),t.licColorPass||e.initializeResources();const o=t.licColorPass;t._openGLRenderWindow.getShaderCache().readyShaderProgram(o),o.setUniformi("texVectors",t.vectorImage.getTextureUnit()),o.setUniformi("texGeomColors",t.geometryImage.getTextureUnit());const{colorMode:a,LICIntensity:i,mapModeBias:s,maskIntensity:l,maskColor:c,enhanceContrast:u,lowColorContrastEnhancementFactor:d,highColorContrastEnhancementFactor:p}=t.licInterface.get("colorMode","LICIntensity","mapModeBias","maskIntensity","maskColor","enhanceContrast","lowColorContrastEnhancementFactor","highColorContrastEnhancementFactor");if(o.setUniformi("texLIC",t.LICImage.getTextureUnit()),o.setUniformi("uScalarColorMode",a),o.setUniformf("uLICIntensity",i),o.setUniformf("uMapBias",s),o.setUniformf("uMaskIntensity",l),o.setUniform3f("uMaskColor",...c),e.renderQuad(t.size,o),t.vectorImage.deactivate(),t.geometryImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),r.removeColorBuffer(1),n.drawBuffers([n.NONE]),u===Wf||u===Hf){let o=0,a=1,i=a-o;o+=i*d,a-=i*p,i=a-o,r.setColorBuffer(t.RGBColorImage),n.drawBuffers([n.COLOR_ATTACHMENT0]),t.geometryImage.activate(),t.HSLColorImage.activate(),t.LICImage.activate(),t.enhanceContrastPass||e.initializeResources();const{enhanceContrastPass:s}=t;t._openGLRenderWindow.getShaderCache().readyShaderProgram(s),s.setUniformi("texGeomColors",t.geometryImage.getTextureUnit()),s.setUniformi("texHSLColors",t.HSLColorImage.getTextureUnit()),s.setUniformi("texLIC",t.LICImage.getTextureUnit()),s.setUniformf("uLMin",o),s.setUniformf("uLMaxMinDiff",i),e.renderQuad(t.size,s),t.geometryImage.deactivate(),t.HSLColorImage.deactivate(),t.LICImage.deactivate(),r.removeColorBuffer(0),n.drawBuffers([n.NONE])}r.restorePreviousBindingsAndBuffers()},e.applyLIC=()=>{const e=t.licInterface.get("stepSize","numberOfSteps","enhancedLIC","enhanceContrast","lowLICContrastEnhancementFactor","highLICContrastEnhancementFactor","antiAlias","normalizeVectors","maskThreshold","transformVectors"),n=t.licHelper.executeLIC(t.size,t.vectorImage,t.maskVectorImage,t.noiseTexture,t._openGLRenderWindow,e);if(!n)return console.error("Failed to compute image LIC"),void(t.LICImage=null);t.LICImage=n},e.setSize=n=>{Array.isArray(n)&&2===n.length&&(t.size&&t.size[0]===n[0]&&t.size[1]===n[1]||(t.size=n,e.releaseGraphicsResources()))},e.releaseGraphicsResources=()=>{t.geometryImage&&(t.geometryImage.releaseGraphicsResources(),t.geometryImage=null),t.vectorImage&&(t.vectorImage.releaseGraphicsResources(),t.vectorImage=null),t.maskVectorImage&&(t.maskVectorImage.releaseGraphicsResources(),t.maskVectorImage=null),t.LICImage&&(t.LICImage.releaseGraphicsResources(),t.LICImage=null),t.RGBColorImage&&(t.RGBColorImage.releaseGraphicsResources(),t.RGBColorImage=null),t.HSLColorImage&&(t.HSLColorImage.releaseGraphicsResources(),t.HSLColorImage=null),t.depthTexture&&(t.depthTexture.releaseGraphicsResources(),t.depthTexture=null),t.framebuffer&&(t.framebuffer.releaseGraphicsResources(),t.framebuffer=null)}}(e,t)}var tg={newInstance:Ht.newInstance(eg,"vtkSurfaceLICInterface"),extend:eg};const{vtkErrorMacro:ng}=jt,rg={canDrawLIC:!1,rebuildLICShaders:!1,rebuildLICBuffers:!1,openGLLicInterface:null};const og=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rg,n),bd.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLSurfaceLICMapper");const n={...e};e.getNeedToRebuildShaders=(e,r,o)=>t.rebuildLICShaders||n.getNeedToRebuildShaders(e,r,o),e.replaceShaderValues=(e,r,o)=>{const a=t.lastBoundBO.getReferenceByName("lastLightComplexity");let i=e.Vertex,s=e.Fragment;const l=t.renderable.getInputArrayToProcess(0);if(l&&t.canDrawLIC){s=Pu.substitute(s,"//VTK::Output::Dec",["//VTK::Output::Dec","layout(location = 2) out vec4 vectorTexture;","layout(location = 3) out vec4 maskVectorTexture;"]).result;const n=`${l.getName()}MC`;0===a&&t.lastBoundBO.set({lastLightComplexity:1},!0),i=Pu.substitute(i,"//VTK::TCoord::Dec",[`attribute vec3 ${n};`,"out vec3 licOutput;","//VTK::TCoord::Dec"]).result,i=Pu.substitute(i,"//VTK::TCoord::Impl",[`licOutput = ${n};`,"//VTK::TCoord::Impl"]).result,s=Pu.substitute(s,"//VTK::TCoord::Dec",["uniform int uMaskOnSurface;","uniform mat3 normalMatrix;","in vec3 licOutput;","//VTK::TCoord::Dec"]).result,s=Pu.substitute(s,"//VTK::TCoord::Impl",["// projected vectors","  vec3 tcoordLIC = normalMatrix * licOutput;","  vec3 normN = normalize(normalVCVSOutput);","  float k = dot(tcoordLIC, normN);","  vec3 projected = (tcoordLIC - k*normN);","  vectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","// vectors for fragment masking","  if (uMaskOnSurface == 0)","    {","    maskVectorTexture = vec4(licOutput, 1.0);","    }","  else","    {","    maskVectorTexture = vec4(projected.x, projected.y, 0.0 , 1.0);","    }","//VTK::TCoord::Impl"],!1).result,e.Vertex=i}t.rebuildLICShaders=!1,e.Fragment=s,n.replaceShaderValues(e,r,o),a>0&&t.lastBoundBO.set({lastLightComplexity:a},!0)},e.setMapperShaderParameters=(e,r,o)=>{n.setMapperShaderParameters(e,r,o),t.canDrawLIC&&e.getProgram().setUniformi("uMaskOnSurface",t.maskOnSurface)},e.getNeedToRebuildBufferObjects=(e,r)=>t.rebuildLICBuffers||n.getNeedToRebuildBufferObjects(e,r),e.buildBufferObjects=(e,r)=>{if(t.canDrawLIC){const e=t.renderable.getInputArrayToProcess(0);e&&e.getNumberOfComponents()>1&&t.renderable.setCustomShaderAttributes([e.getName()])}t.rebuildLICBuffers=!1,n.buildBufferObjects(e,r)},e.pushState=e=>{t.stateCache={[e.BLEND]:e.isEnabled(e.BLEND),[e.DEPTH_TEST]:e.isEnabled(e.DEPTH_TEST),[e.SCISSOR_TEST]:e.isEnabled(e.SCISSOR_TEST),[e.CULL_FACE]:e.isEnabled(e.CULL_FACE)}},e.popState=e=>{const n=n=>t.stateCache[n]?e.enable(n):e.disable(n);n(e.BLEND),n(e.DEPTH_TEST),n(e.SCISSOR_TEST),n(e.CULL_FACE)},e.renderPiece=(r,o)=>{let a=!0;t._openGLRenderWindow.getWebgl2()||(ng("SurfaceLICMapper Requires WebGL 2"),a=!1),t.context.getExtension("EXT_color_buffer_float")&&t.context.getExtension("OES_texture_float_linear")||(ng("SurfaceLICMapper requires the EXT_color_buffer_float and OES_texture_float_linear WebGL2 extensions."),a=!1),t.currentInput=t.renderable.getInputData(),t.currentInput||(ng("No input"),a=!1);let i=t.renderable.getLicInterface();i||(i=Zf.newInstance(),t.renderable.setLicInterface(i)),t.openGLLicInterface||(t.openGLLicInterface=tg.newInstance()),i!==t.openGLLicInterface.getLicInterface()&&t.openGLLicInterface.setLicInterface(i);const s=t.renderable.getInputArrayToProcess(0);if(i.getEnableLIC()&&(!s||s.getNumberOfComponents()<2)&&(ng("No vector input array"),a=!1),i.getEnableLIC()||(a=!1),t.canDrawLIC!==a&&(t.rebuildLICShaders=!0,t.rebuildLICBuffers=!0),t.canDrawLIC=a,!a||!i.getEnableLIC())return void n.renderPiece(r,o);const l=t.context,c=o.getProperty().getBackfaceCulling(),u=o.getProperty().getFrontfaceCulling();c||u?u?(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.FRONT)):(t._openGLRenderWindow.enableCullFace(),l.cullFace(l.BACK)):t._openGLRenderWindow.disableCullFace();const d=t._openGLRenderWindow.getSize(),p=d.map((e=>Math.round(e*i.getViewPortScale())));t.openGLLicInterface.setSize(p),t.openGLLicInterface.setOpenGLRenderWindow(t._openGLRenderWindow),t.openGLLicInterface.setContext(t.context),e.pushState(t.context),t.openGLLicInterface.initializeResources(),t.openGLLicInterface.prepareForGeometry(),e.popState(t.context),n.renderPieceStart(r,o),n.renderPieceDraw(r,o),n.renderPieceFinish(r,o),e.pushState(t.context),t.VBOBuildTime.modified(),t.openGLLicInterface.completedGeometry(),t.context.disable(t.context.CULL_FACE),t.openGLLicInterface.applyLIC(),t.openGLLicInterface.combineColorsAndLIC(),t.openGLLicInterface.copyToScreen(d),e.popState(t.context)}}(e,t),St(e,t,["openGLLicInterface"])}),"vtkOpenGLSurfaceLICMapper");en("vtkSurfaceLICMapper",og);const{vtkErrorMacro:ag}=jt,ig={};const sg=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ig,n),bd.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLSphereMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkSphereMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Spheres\n\nattribute vec4 vertexMC;\nattribute vec2 offsetMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying vec3 centerVCVSOutput;\n\nuniform int cameraParallel;\nuniform float scaleFactor;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  // compute the projected vertex position\n  vec2 scaledOffsetMC = scaleFactor * offsetMC;\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = length(scaledOffsetMC)*0.5;\n\n  // make the triangle face the camera\n  if (cameraParallel == 0)\n    {\n    vec3 dir = normalize(-vertexVCVSOutput.xyz);\n    vec3 base2 = normalize(cross(dir,vec3(1.0,0.0,0.0)));\n    vec3 base1 = cross(base2,dir);\n    vertexVCVSOutput.xyz = vertexVCVSOutput.xyz + scaledOffsetMC.x*base1 + scaledOffsetMC.y*base2;\n    }\n  else\n    {\n    // add in the offset\n    vertexVCVSOutput.xy = vertexVCVSOutput.xy + scaledOffsetMC;\n    }\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=rd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=Pu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=Pu.substitute(i,"//VTK::PositionVC::Dec",["varying vec4 vertexVCVSOutput;"]).result,i=Pu.substitute(i,"//VTK::PositionVC::Impl",["vec4 vertexVC = vertexVCVSOutput;\n"]).result,i=Pu.substitute(i,"//VTK::Normal::Dec",["uniform float invertedDepth;\n","uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=Pu.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float b = 2.0*dot(EyePos,EyeDir);\n","  float c = dot(EyePos,EyePos) - 1.0;\n","  float d = b*b - 4.0*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t = (-b - invertedDepth*sqrt(d))*0.5;\n","    normalVCVSOutput = invertedDepth*normalize(EyePos + t*EyeDir);\n","    vertexVC.xyz = normalVCVSOutput*radiusVCVSOutput + centerVCVSOutput;\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=Pu.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=Pu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{if(e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"offsetMC",12,e.getCABO().getStride(),t.context.FLOAT,2,!1)||ag("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isUniformUsed("invertedDepth")&&e.getProgram().setUniformf("invertedDepth",t.invert?-1:1),e.getProgram().isUniformUsed("scaleFactor")){const n=t.currentInput.getPointData();null!=t.renderable.getScaleArray()&&n.hasArray(t.renderable.getScaleArray())?e.getProgram().setUniformf("scaleFactor",t.renderable.getScaleFactor()):e.getProgram().setUniformf("scaleFactor",1)}n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc);const s=new Float64Array(16);if(o.isUniformUsed("MCVCMatrix"))if(r.getIsIdentity())d(s,i.wcvc),e.getCABO().getCoordShiftAndScaleEnabled()&&y(s,s,e.getCABO().getInverseShiftAndScaleMatrix()),o.setUniformMatrix("MCVCMatrix",s);else{const n=t.openGLActor.getKeyMatrices();y(s,i.wcvc,n.mcwc),e.getCABO().getCoordShiftAndScaleEnabled()&&y(s,s,e.getCABO().getInverseShiftAndScaleMatrix()),o.setUniformMatrix("MCVCMatrix",s)}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(u=i.getArray(t.renderable.getScaleArray()).getData());let d=null,p=0,f=null;o?(p=o.getNumberOfComponents(),a.setColorOffset(0),a.setColorBOStride(4),d=o.getData(),f=new Uint8Array(3*l*4),a.getColorBO()||a.setColorBO(mu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow)):a.getColorBO()&&a.setColorBO(null),a.setColorComponents(p);const g=new Float32Array(5*l*3);a.setStride(20);const m=Math.cos(yo(30));let h=0,v=0;const{useShiftAndScale:T,coordShift:y,coordScale:b}=hu(s);T&&a.setCoordShiftAndScale(y,b);let x=0,C=0;for(let e=0;e<l;++e){let n=t.renderable.getRadius();u&&(n=u[e]),h=3*e;const r=(c[h++]-y[0])*b[0],o=(c[h++]-y[1])*b[1],a=(c[h++]-y[2])*b[2];g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=-2*n*m,g[x++]=-n,d&&(v=e*p,f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3]),g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=2*n*m,g[x++]=-n,d&&(f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3]),g[x++]=r,g[x++]=o,g[x++]=a,g[x++]=0,g[x++]=2*n,d&&(f[C++]=d[v],f[C++]=d[v+1],f[C++]=d[v+2],f[C++]=d[v+3])}a.setElementCount(x/5),a.upload(g,uu.ARRAY_BUFFER),o&&a.getColorBO().upload(f,uu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLSphereMapper");en("vtkSphereMapper",sg);const{vtkErrorMacro:lg}=jt,cg={};const ug=Et((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,cg,n),bd.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkOpenGLStickMapper");const n={...e};e.getShaderTemplate=(e,t,n)=>{e.Vertex="//VTK::System::Dec\n\n/*=========================================================================\n\n  Program:   Visualization Toolkit\n  Module:    vtkStickMapperVS.glsl\n\n  Copyright (c) Ken Martin, Will Schroeder, Bill Lorensen\n  All rights reserved.\n  See Copyright.txt or http://www.kitware.com/Copyright.htm for details.\n\n     This software is distributed WITHOUT ANY WARRANTY; without even\n     the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR\n     PURPOSE.  See the above copyright notice for more information.\n\n=========================================================================*/\n// this shader implements imposters in OpenGL for Sticks\n\nattribute vec4 vertexMC;\nattribute vec3 orientMC;\nattribute vec4 offsetMC;\nattribute float radiusMC;\n\n// optional normal declaration\n//VTK::Normal::Dec\n\n//VTK::Picking::Dec\n\n// Texture coordinates\n//VTK::TCoord::Dec\n\nuniform mat3 normalMatrix; // transform model coordinate directions to view coordinates\n\n// material property values\n//VTK::Color::Dec\n\n// clipping plane vars\n//VTK::Clip::Dec\n\n// camera and actor matrix values\n//VTK::Camera::Dec\n\nvarying vec4 vertexVCVSOutput;\nvarying float radiusVCVSOutput;\nvarying float lengthVCVSOutput;\nvarying vec3 centerVCVSOutput;\nvarying vec3 orientVCVSOutput;\n\nuniform int cameraParallel;\n\nvoid main()\n{\n  //VTK::Picking::Impl\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Clip::Impl\n\n  vertexVCVSOutput = MCVCMatrix * vertexMC;\n  centerVCVSOutput = vertexVCVSOutput.xyz;\n  radiusVCVSOutput = radiusMC;\n  lengthVCVSOutput = length(orientMC);\n  orientVCVSOutput = normalMatrix * normalize(orientMC);\n\n  // make sure it is pointing out of the screen\n  if (orientVCVSOutput.z < 0.0)\n    {\n    orientVCVSOutput = -orientVCVSOutput;\n    }\n\n  // make the basis\n  vec3 xbase;\n  vec3 ybase;\n  vec3 dir = vec3(0.0,0.0,1.0);\n  if (cameraParallel == 0)\n    {\n    dir = normalize(-vertexVCVSOutput.xyz);\n    }\n  if (abs(dot(dir,orientVCVSOutput)) == 1.0)\n    {\n    xbase = normalize(cross(vec3(0.0,1.0,0.0),orientVCVSOutput));\n    ybase = cross(xbase,orientVCVSOutput);\n    }\n  else\n    {\n    xbase = normalize(cross(orientVCVSOutput,dir));\n    ybase = cross(orientVCVSOutput,xbase);\n    }\n\n  vec3 offsets = offsetMC.xyz*2.0-1.0;\n  vertexVCVSOutput.xyz = vertexVCVSOutput.xyz +\n    radiusVCVSOutput*offsets.x*xbase +\n    radiusVCVSOutput*offsets.y*ybase +\n    0.5*lengthVCVSOutput*offsets.z*orientVCVSOutput;\n\n  gl_Position = VCPCMatrix * vertexVCVSOutput;\n}\n",e.Fragment=rd,e.Geometry=""},e.replaceShaderValues=(e,r,o)=>{let a=e.Vertex,i=e.Fragment;a=Pu.substitute(a,"//VTK::Camera::Dec",["uniform mat4 VCPCMatrix;\n","uniform mat4 MCVCMatrix;"]).result,i=Pu.substitute(i,"//VTK::PositionVC::Dec","varying vec4 vertexVCVSOutput;").result,i=Pu.substitute(i,"//VTK::PositionVC::Impl","  vec4 vertexVC = vertexVCVSOutput;\n").result,i=Pu.substitute(i,"//VTK::Normal::Dec",["uniform int cameraParallel;\n","varying float radiusVCVSOutput;\n","varying vec3 orientVCVSOutput;\n","varying float lengthVCVSOutput;\n","varying vec3 centerVCVSOutput;\n","uniform mat4 VCPCMatrix;\n"]).result;let s="";t.context.getExtension("EXT_frag_depth")&&(s="  gl_FragDepthEXT = (pos.z / pos.w + 1.0) / 2.0;\n"),t._openGLRenderWindow.getWebgl2()&&(s="gl_FragDepth = (pos.z / pos.w + 1.0) / 2.0;\n"),i=Pu.substitute(i,"//VTK::Depth::Impl",["  vec3 EyePos;\n","  vec3 EyeDir;\n","  if (cameraParallel != 0) {\n","    EyePos = vec3(vertexVC.x, vertexVC.y, vertexVC.z + 3.0*radiusVCVSOutput);\n","    EyeDir = vec3(0.0,0.0,-1.0); }\n","  else {\n","    EyeDir = vertexVC.xyz;\n","    EyePos = vec3(0.0,0.0,0.0);\n","    float lengthED = length(EyeDir);\n","    EyeDir = normalize(EyeDir);\n","    if (lengthED > radiusVCVSOutput*3.0) {\n","      EyePos = vertexVC.xyz - EyeDir*3.0*radiusVCVSOutput; }\n","    }\n","  EyePos = EyePos - centerVCVSOutput;\n","  vec3 base1;\n","  if (abs(orientVCVSOutput.z) < 0.99) {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,0.0,1.0))); }\n","  else {\n","    base1 = normalize(cross(orientVCVSOutput,vec3(0.0,1.0,0.0))); }\n","  vec3 base2 = cross(orientVCVSOutput,base1);\n","  EyePos = vec3(dot(EyePos,base1),dot(EyePos,base2),dot(EyePos,orientVCVSOutput));\n","  EyeDir = vec3(dot(EyeDir,base1),dot(EyeDir,base2),dot(EyeDir,orientVCVSOutput));\n","  EyePos = EyePos/radiusVCVSOutput;\n","  float a = EyeDir.x*EyeDir.x + EyeDir.y*EyeDir.y;\n","  float b = 2.0*(EyePos.x*EyeDir.x + EyePos.y*EyeDir.y);\n","  float c = EyePos.x*EyePos.x + EyePos.y*EyePos.y - 1.0;\n","  float d = b*b - 4.0*a*c;\n","  vec3 normalVCVSOutput = vec3(0.0,0.0,1.0);\n","  if (d < 0.0) { discard; }\n","  else {\n","    float t =  (-b - sqrt(d))/(2.0*a);\n","    float tz = EyePos.z + t*EyeDir.z;\n","    vec3 iPoint = EyePos + t*EyeDir;\n","    if (abs(iPoint.z)*radiusVCVSOutput > lengthVCVSOutput*0.5) {\n","      float t2 = (-b + sqrt(d))/(2.0*a);\n","      float tz2 = EyePos.z + t2*EyeDir.z;\n","      if (tz2*radiusVCVSOutput > lengthVCVSOutput*0.5 || tz*radiusVCVSOutput < -0.5*lengthVCVSOutput) { discard; }\n","      else {\n","        normalVCVSOutput = orientVCVSOutput;\n","        float t3 = (lengthVCVSOutput*0.5/radiusVCVSOutput - EyePos.z)/EyeDir.z;\n","        iPoint = EyePos + t3*EyeDir;\n","        vertexVC.xyz = radiusVCVSOutput*(iPoint.x*base1 + iPoint.y*base2 + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","        }\n","      }\n","    else {\n","      normalVCVSOutput = iPoint.x*base1 + iPoint.y*base2;\n","      vertexVC.xyz = radiusVCVSOutput*(normalVCVSOutput + iPoint.z*orientVCVSOutput) + centerVCVSOutput;\n","      }\n","    }\n","  vec4 pos = VCPCMatrix * vertexVC;\n",s]).result,i=Pu.substitute(i,"//VTK::Normal::Impl","").result,t.haveSeenDepthRequest&&(i=Pu.substitute(i,"//VTK::ZBuffer::Impl",["if (depthRequest == 1) {","float computedZ = (pos.z / pos.w + 1.0) / 2.0;","float iz = floor(computedZ * 65535.0 + 0.1);","float rf = floor(iz/256.0)/255.0;","float gf = mod(iz,256.0)/255.0;","gl_FragData[0] = vec4(rf, gf, 0.0, 1.0); }"]).result),e.Vertex=a,e.Fragment=i,n.replaceShaderValues(e,r,o)},e.setMapperShaderParameters=(e,r,o)=>{e.getCABO().getElementCount()&&(t.VBOBuildTime>e.getAttributeUpdateTime().getMTime()||e.getShaderSourceTime().getMTime()>e.getAttributeUpdateTime().getMTime())&&(e.getProgram().isAttributeUsed("orientMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"orientMC",12,e.getCABO().getStride(),t.context.FLOAT,3,!1)||lg("Error setting 'orientMC' in shader VAO.")),e.getProgram().isAttributeUsed("offsetMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO().getColorBO(),"offsetMC",0,e.getCABO().getColorBOStride(),t.context.UNSIGNED_BYTE,3,!0)||lg("Error setting 'offsetMC' in shader VAO.")),e.getProgram().isAttributeUsed("radiusMC")&&(e.getVAO().addAttributeArray(e.getProgram(),e.getCABO(),"radiusMC",24,e.getCABO().getStride(),t.context.FLOAT,1,!1)||lg("Error setting 'radiusMC' in shader VAO."))),n.setMapperShaderParameters(e,r,o)},e.setCameraShaderParameters=(e,n,r)=>{const o=e.getProgram(),a=n.getActiveCamera(),i=t.openGLCamera.getKeyMatrices(n);if(o.isUniformUsed("VCPCMatrix")&&o.setUniformMatrix("VCPCMatrix",i.vcpc),r.getIsIdentity())o.isUniformUsed("MCVCMatrix")&&o.setUniformMatrix("MCVCMatrix",i.wcvc),o.isUniformUsed("normalMatrix")&&o.setUniformMatrix3x3("normalMatrix",i.normalMatrix);else{const e=t.openGLActor.getKeyMatrices();if(o.isUniformUsed("MCVCMatrix")){const t=new Float64Array(16);y(t,i.wcvc,e.mcwc),o.setUniformMatrix("MCVCMatrix",t)}if(o.isUniformUsed("normalMatrix")){const t=new Float64Array(9);ve(t,i.normalMatrix,e.normalMatrix),o.setUniformMatrix3x3("normalMatrix",t)}}o.isUniformUsed("cameraParallel")&&e.getProgram().setUniformi("cameraParallel",a.getParallelProjection())},e.getOpenGLMode=(e,n)=>t.context.TRIANGLES,e.buildBufferObjects=(e,n)=>{const r=t.currentInput;if(null===r)return;t.renderable.mapScalars(r,1);const o=t.renderable.getColorMapColors(),a=t.primitives[t.primTypes.Tris].getCABO(),i=r.getPointData(),s=r.getPoints(),l=s.getNumberOfPoints(),c=s.getData();let u=3;u+=4;let d=null,p=0;a.setColorBOStride(4),a.getColorBO()||a.setColorBO(mu.newInstance()),a.getColorBO().setOpenGLRenderWindow(t._openGLRenderWindow),o&&(p=o.getNumberOfComponents(),a.setColorOffset(4),d=o.getData(),a.setColorBOStride(8)),a.setColorComponents(p),a.setStride(28);const f=new Float32Array(7*l*12),g=new Uint8Array(12*l*(d?8:4));let m=null,h=null;null!=t.renderable.getScaleArray()&&i.hasArray(t.renderable.getScaleArray())&&(m=i.getArray(t.renderable.getScaleArray()).getData()),null!=t.renderable.getOrientationArray()&&i.hasArray(t.renderable.getOrientationArray())?h=i.getArray(t.renderable.getOrientationArray()).getData():lg(["Error setting orientationArray.\n","You have to specify the stick orientation"]);const v=[0,1,3,0,3,2,2,3,5,2,5,4];let T=0,y=0,b=0,x=0;for(let e=0;e<l;++e){let n=t.renderable.getLength(),r=t.renderable.getRadius();m&&(n=m[2*e],r=m[2*e+1]);for(let t=0;t<v.length;++t)T=3*e,f[b++]=c[T++],f[b++]=c[T++],f[b++]=c[T++],T=3*e,f[b++]=h[T++]*n,f[b++]=h[T++]*n,f[b++]=h[T++]*n,f[b++]=r,g[x++]=v[t]%2*255,g[x++]=v[t]>=4?255:0,g[x++]=v[t]>=2?255:0,g[x++]=255,y=e*p,d&&(g[x++]=d[y],g[x++]=d[y+1],g[x++]=d[y+2],g[x++]=d[y+3])}a.setElementCount(b/7),a.upload(f,uu.ARRAY_BUFFER),a.getColorBO().upload(g,uu.ARRAY_BUFFER),t.VBOBuildTime.modified()}}(e,t)}),"vtkOpenGLStickMapper");en("vtkStickMapper",ug);const dg=[];dg["-".charCodeAt(0)]=62,dg["_".charCodeAt(0)]=63;const pg="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";for(let e=0;e<64;e++)dg[pg.charCodeAt(e)]=e;function fg(e){return void 0!==dg[e.charCodeAt(0)]}function gg(e,t,n,r){const{start:o,count:a}=t,i=a%4,s=Math.floor(a/4);let l=o,c=null,u=n;for(let t=0;t<s;t++){for(;!fg(e[l]);)l++;for(c=dg[e.charCodeAt(l++)]<<18;!fg(e[l]);)l++;for(c|=dg[e.charCodeAt(l++)]<<12;!fg(e[l]);)l++;for(c|=dg[e.charCodeAt(l++)]<<6;!fg(e[l]);)l++;c|=dg[e.charCodeAt(l++)],r[u++]=c>>16&255,r[u++]=c>>8&255,r[u++]=255&c}switch(i){case 3:for(;!fg(e[l]);)l++;for(c=dg[e.charCodeAt(l++)]<<10;!fg(e[l]);)l++;for(c|=dg[e.charCodeAt(l++)]<<4;!fg(e[l]);)l++;c|=dg[e.charCodeAt(l++)]>>2,r[u++]=c>>8&255,r[u++]=255&c;break;case 2:for(;!fg(e[l]);)l++;for(c=dg[e.charCodeAt(l++)]<<2;!fg(e[l]);)l++;c|=dg[e.charCodeAt(l++)]>>4,r[u++]=255&c;break;case 1:throw new Error("BASE64: remain 1 should not happen")}return u}function mg(e,t,n){const r=(e<<16)+(t<<8)+n;return pg[r>>18]+pg[r>>12&63]+pg[r>>6&63]+pg[63&r]}function hg(e){const t=new Uint8Array(e),n=e.byteLength%3,r=e.byteLength-n,o=Array(r/3);for(let e=0;e<o.length;e++){const n=3*e;o[e]=mg(t[n],t[n+1],t[n+2])}if(n>0){const e=mg(t[r],t[r+1]||0,t[r+2]||0);1===n?o.push(`${e.substr(0,2)}==`):2===n&&o.push(`${e.substr(0,3)}=`)}return o.join("")}var vg={toArrayBuffer:function(e){const t=function(e){const t=e.length,n=[];let r=null;for(let o=0;o<t;o++)fg(e[o])?(r||(r={start:o,count:0}),r.count++,r.end=o):"="===e[o]&&r&&(n.push(r),r=null);return r&&n.push(r),n}(e),n=t[t.length-1].end+1,r=(4-n%4)%4,o=new ArrayBuffer(3*(n+r)/4-r),a=new Uint8Array(o);let i=0;for(let n=0;n<t.length;n++)i+=gg(e,t[n],i,a),i+=(4-t[n].count%4)%4;return o},fromArrayBuffer:hg};const Tg={};function yg(e,t){Tg[e]=t}var bg={get:function(){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Tg[arguments.length>0&&void 0!==arguments[0]?arguments[0]:"http"](e)},has:function(e){return!!Tg[e]},registerType:yg},xg=Uint8Array,Cg=Uint16Array,Sg=Uint32Array,Ag=new xg([0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0]),Ig=new xg([0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0]),wg=new xg([16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15]),Og=function(e,t){for(var n=new Cg(31),r=0;r<31;++r)n[r]=t+=1<<e[r-1];var o=new Sg(n[30]);for(r=1;r<30;++r)for(var a=n[r];a<n[r+1];++a)o[a]=a-n[r]<<5|r;return[n,o]},Pg=Og(Ag,2),Rg=Pg[0],Mg=Pg[1];Rg[28]=258,Mg[258]=28;for(var Eg=Og(Ig,0),Vg=Eg[0],Dg=(Eg[1],new Cg(32768)),Lg=0;Lg<32768;++Lg){var Bg=(43690&Lg)>>>1|(21845&Lg)<<1;Bg=(61680&(Bg=(52428&Bg)>>>2|(13107&Bg)<<2))>>>4|(3855&Bg)<<4,Dg[Lg]=((65280&Bg)>>>8|(255&Bg)<<8)>>>1}var Ng=function(e,t,n){for(var r=e.length,o=0,a=new Cg(t);o<r;++o)e[o]&&++a[e[o]-1];var i,s=new Cg(t);for(o=0;o<t;++o)s[o]=s[o-1]+a[o-1]<<1;if(n){i=new Cg(1<<t);var l=15-t;for(o=0;o<r;++o)if(e[o])for(var c=o<<4|e[o],u=t-e[o],d=s[e[o]-1]++<<u,p=d|(1<<u)-1;d<=p;++d)i[Dg[d]>>>l]=c}else for(i=new Cg(r),o=0;o<r;++o)e[o]&&(i[o]=Dg[s[e[o]-1]++]>>>15-e[o]);return i},Fg=new xg(288);for(Lg=0;Lg<144;++Lg)Fg[Lg]=8;for(Lg=144;Lg<256;++Lg)Fg[Lg]=9;for(Lg=256;Lg<280;++Lg)Fg[Lg]=7;for(Lg=280;Lg<288;++Lg)Fg[Lg]=8;var _g=new xg(32);for(Lg=0;Lg<32;++Lg)_g[Lg]=5;var Gg=Ng(Fg,9,1),kg=Ng(_g,5,1),Ug=function(e){for(var t=e[0],n=1;n<e.length;++n)e[n]>t&&(t=e[n]);return t},zg=function(e,t,n){var r=t/8|0;return(e[r]|e[r+1]<<8)>>(7&t)&n},Wg=function(e,t){var n=t/8|0;return(e[n]|e[n+1]<<8|e[n+2]<<16)>>(7&t)},Hg=function(e,t,n){(null==t||t<0)&&(t=0),(null==n||n>e.length)&&(n=e.length);var r=new(2==e.BYTES_PER_ELEMENT?Cg:4==e.BYTES_PER_ELEMENT?Sg:xg)(n-t);return r.set(e.subarray(t,n)),r},jg=["unexpected EOF","invalid block type","invalid length/literal","invalid distance","stream finished","no stream handler",,"no callback","invalid UTF-8 data","extra field too long","date not in range 1980-2099","filename too long","stream finishing","invalid zip data"],Kg=function(e,t,n){var r=new Error(t||jg[e]);if(r.code=e,Error.captureStackTrace&&Error.captureStackTrace(r,Kg),!n)throw r;return r},$g=function(e,t,n){var r=e.length;if(!r||n&&n.f&&!n.l)return t||new xg(0);var o=!t||n,a=!n||n.i;n||(n={}),t||(t=new xg(3*r));var i,s=function(e){var n=t.length;if(e>n){var r=new xg(Math.max(2*n,e));r.set(t),t=r}},l=n.f||0,c=n.p||0,u=n.b||0,d=n.l,p=n.d,f=n.m,g=n.n,m=8*r;do{if(!d){l=zg(e,c,1);var h=zg(e,c+1,3);if(c+=3,!h){var v=e[(i=c,(P=4+((i+7)/8|0))-4)]|e[P-3]<<8,T=P+v;if(T>r){a&&Kg(0);break}o&&s(u+v),t.set(e.subarray(P,T),u),n.b=u+=v,n.p=c=8*T,n.f=l;continue}if(1==h)d=Gg,p=kg,f=9,g=5;else if(2==h){var y=zg(e,c,31)+257,b=zg(e,c+10,15)+4,x=y+zg(e,c+5,31)+1;c+=14;for(var C=new xg(x),S=new xg(19),A=0;A<b;++A)S[wg[A]]=zg(e,c+3*A,7);c+=3*b;var I=Ug(S),w=(1<<I)-1,O=Ng(S,I,1);for(A=0;A<x;){var P,R=O[zg(e,c,w)];if(c+=15&R,(P=R>>>4)<16)C[A++]=P;else{var M=0,E=0;for(16==P?(E=3+zg(e,c,3),c+=2,M=C[A-1]):17==P?(E=3+zg(e,c,7),c+=3):18==P&&(E=11+zg(e,c,127),c+=7);E--;)C[A++]=M}}var V=C.subarray(0,y),D=C.subarray(y);f=Ug(V),g=Ug(D),d=Ng(V,f,1),p=Ng(D,g,1)}else Kg(1);if(c>m){a&&Kg(0);break}}o&&s(u+131072);for(var L=(1<<f)-1,B=(1<<g)-1,N=c;;N=c){var F=(M=d[Wg(e,c)&L])>>>4;if((c+=15&M)>m){a&&Kg(0);break}if(M||Kg(2),F<256)t[u++]=F;else{if(256==F){N=c,d=null;break}var _=F-254;if(F>264){var G=Ag[A=F-257];_=zg(e,c,(1<<G)-1)+Rg[A],c+=G}var k=p[Wg(e,c)&B],U=k>>>4;if(k||Kg(3),c+=15&k,D=Vg[U],U>3&&(G=Ig[U],D+=Wg(e,c)&(1<<G)-1,c+=G),c>m){a&&Kg(0);break}o&&s(u+131072);for(var z=u+_;u<z;u+=4)t[u]=t[u-D],t[u+1]=t[u+1-D],t[u+2]=t[u+2-D],t[u+3]=t[u+3-D];u=z}}n.l=d,n.p=N,n.b=u,n.f=l,d&&(l=1,n.m=f,n.d=p,n.n=g)}while(!l);return u==t.length?t:Hg(t,0,u)},qg=new xg(0),Xg=function(e,t){return e[t]|e[t+1]<<8},Yg=function(e,t){return(e[t]|e[t+1]<<8|e[t+2]<<16|e[t+3]<<24)>>>0},Zg=function(e,t){return Yg(e,t)+4294967296*Yg(e,t+4)};function Qg(e,t){return $g(e,t)}function Jg(e,t){return $g(e.subarray(function(e){31==e[0]&&139==e[1]&&8==e[2]||Kg(6,"invalid gzip data");var t=e[3],n=10;4&t&&(n+=e[10]|2+(e[11]<<8));for(var r=(t>>3&1)+(t>>4&1);r>0;r-=!e[n++]);return n+(2&t)}(e),-8),t||new xg((r=(n=e).length,(n[r-4]|n[r-3]<<8|n[r-2]<<16|n[r-1]<<24)>>>0)));var n,r}function em(e,t){return $g(((8!=(15&(n=e)[0])||n[0]>>>4>7||(n[0]<<8|n[1])%31)&&Kg(6,"invalid zlib data"),32&n[1]&&Kg(6,"invalid zlib data: preset dictionaries not supported"),e.subarray(2,-4)),t);var n}function tm(e,t){return 31==e[0]&&139==e[1]&&8==e[2]?Jg(e,t):8!=(15&e[0])||e[0]>>4>7||(e[0]<<8|e[1])%31?Qg(e,t):em(e,t)}var nm="undefined"!=typeof TextEncoder&&new TextEncoder,rm="undefined"!=typeof TextDecoder&&new TextDecoder;try{rm.decode(qg,{stream:!0})}catch(e){}function om(e,t){if(t){for(var n="",r=0;r<e.length;r+=16384)n+=String.fromCharCode.apply(null,e.subarray(r,r+16384));return n}if(rm)return rm.decode(e);var o=function(e){for(var t="",n=0;;){var r=e[n++],o=(r>127)+(r>223)+(r>239);if(n+o>e.length)return[t,Hg(e,n-1)];o?3==o?(r=((15&r)<<18|(63&e[n++])<<12|(63&e[n++])<<6|63&e[n++])-65536,t+=String.fromCharCode(55296|r>>10,56320|1023&r)):t+=1&o?String.fromCharCode((31&r)<<6|63&e[n++]):String.fromCharCode((15&r)<<12|(63&e[n++])<<6|63&e[n++]):t+=String.fromCharCode(r)}}(e),a=o[0];return o[1].length&&Kg(8),a}var am=function(e,t){return t+30+Xg(e,t+26)+Xg(e,t+28)},im=function(e,t,n){var r=Xg(e,t+28),o=om(e.subarray(t+46,t+46+r),!(2048&Xg(e,t+8))),a=t+46+r,i=Yg(e,t+20),s=n&&4294967295==i?sm(e,a):[i,Yg(e,t+24),Yg(e,t+42)],l=s[0],c=s[1],u=s[2];return[Xg(e,t+10),l,c,o,a+Xg(e,t+30)+Xg(e,t+32),u]},sm=function(e,t){for(;1!=Xg(e,t);t+=4+Xg(e,t+2));return[Zg(e,t+12),Zg(e,t+4),Zg(e,t+20)]};function lm(e,t){for(var n={},r=e.length-22;101010256!=Yg(e,r);--r)(!r||e.length-r>65558)&&Kg(13);var o=Xg(e,r+8);if(!o)return{};var a=Yg(e,r+16),i=4294967295==a;i&&(r=Yg(e,r-12),101075792!=Yg(e,r)&&Kg(13),o=Yg(e,r+32),a=Yg(e,r+48));for(var s=t&&t.filter,l=0;l<o;++l){var c=im(e,a,i),u=c[0],d=c[1],p=c[2],f=c[3],g=c[4],m=c[5],h=am(e,m);a=g,s&&!s({name:f,size:d,originalSize:p,compression:u})||(u?8==u?n[f]=Qg(e.subarray(h,h+d),new xg(p)):Kg(14,"unknown compression type "+u):n[f]=Hg(e,h,h+d))}return n}function cm(){const e=new ArrayBuffer(4),t=new Uint8Array(e),n=new Uint32Array(e);return t[0]=161,t[1]=178,t[2]=195,t[3]=212,3569595041===n[0]?"LittleEndian":2712847316===n[0]?"BigEndian":null}"function"==typeof queueMicrotask?queueMicrotask:"function"==typeof setTimeout&&setTimeout;var um=cm(),dm=function(e,t){if(t<2)return;const n=new Int8Array(e),r=n.length,o=[];for(let e=0;e<r;e+=t){for(let r=0;r<t;r++)o.push(n[e+r]);for(let r=0;r<t;r++)n[e+r]=o.pop()}};const{vtkErrorMacro:pm,vtkDebugMacro:fm}=Ht;let gm=0;function mm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const r=new XMLHttpRequest;return r.open(e,t,!0),n.headers&&Object.entries(n.headers).forEach((e=>{let[t,n]=e;return r.setRequestHeader(t,n)})),n.progressCallback&&r.addEventListener("progress",n.progressCallback),r}const hm={fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return n.ref&&!n.ref.pending?new Promise(((o,a)=>{let i=null;i=n.ref.url?n.ref.url:[t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/");const s=mm("GET",i,r);s.onreadystatechange=t=>{1===s.readyState&&(n.ref.pending=!0,1==++gm&&e?.invokeBusy&&e.invokeBusy(!0)),4===s.readyState&&(n.ref.pending=!1,200===s.status||0===s.status?(n.buffer=s.response,r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=om(tm(new Uint8Array(n.buffer))):n.buffer=tm(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(um!==n.ref.encode&&um&&(fm(`Swap bytes of ${n.name}`),dm(n.buffer,as[n.dataType])),n.values=Ht.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&pm(`Error in FetchArray: ${n.name}, does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`),delete n.ref,0==--gm&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)):a({xhr:s,e:t}))},s.responseType=r.compression||"string"!==n.dataType?"arraybuffer":"text",s.send()})):Promise.resolve(n)},fetchJSON:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((r,o)=>{const a=mm("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++gm&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--gm&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(JSON.parse(om(tm(new Uint8Array(a.response))))):r(JSON.parse(a.responseText)):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchText:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return n&&n.compression&&"gz"!==n.compression&&(pm("Supported algorithms are: [gz]"),pm(`Unkown compression algorithm: ${n.compression}`)),new Promise(((r,o)=>{const a=mm("GET",t,n);a.onreadystatechange=t=>{1===a.readyState&&1==++gm&&e?.invokeBusy&&e.invokeBusy(!0),4===a.readyState&&(0==--gm&&e?.invokeBusy&&e.invokeBusy(!1),200===a.status||0===a.status?n.compression?r(om(tm(new Uint8Array(a.response)))):r(a.responseText):o({xhr:a,e:t}))},a.responseType=n.compression?"arraybuffer":"text",a.send()}))},fetchBinary:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return t&&t.compression&&"gz"!==t.compression&&(pm("Supported algorithms are: [gz]"),pm(`Unkown compression algorithm: ${t.compression}`)),new Promise(((n,r)=>{const o=mm("GET",e,t);o.onreadystatechange=e=>{4===o.readyState&&(200===o.status||0===o.status?t.compression?n(tm(new Uint8Array(o.response)).buffer):n(o.response):r({xhr:o,e:e}))},o.responseType="arraybuffer",o.send()}))},fetchImage:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return new Promise(((e,r)=>{const o=new Image;n.crossOrigin&&(o.crossOrigin=n.crossOrigin),o.onload=()=>e(o),o.onerror=r,o.src=t}))}};yg("http",(e=>hm));const{vtkDebugMacro:vm}=Ht,Tm={position:[0,0,1],focalPoint:[0,0,0],viewUp:[0,1,0],directionOfProjection:[0,0,-1],parallelProjection:!1,useHorizontalViewAngle:!1,viewAngle:30,parallelScale:1,clippingRange:[.01,1000.01],windowCenter:[0,0],viewPlaneNormal:[0,0,1],useOffAxisProjection:!1,screenBottomLeft:[-.5,-.5,-.5],screenBottomRight:[.5,-.5,-.5],screenTopRight:[.5,.5,-.5],freezeFocalPoint:!1,projectionMatrix:null,viewMatrix:null,cameraLightTransform:c(),physicalTranslation:[0,0,0],physicalScale:1,physicalViewUp:[0,1,0],physicalViewNorth:[0,0,-1]};function ym(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Tm,n),Ht.obj(e,t),Ht.get(e,t,["distance"]),Ht.setGet(e,t,["parallelProjection","useHorizontalViewAngle","viewAngle","parallelScale","useOffAxisProjection","freezeFocalPoint","physicalScale"]),Ht.getArray(e,t,["directionOfProjection","viewPlaneNormal","position","focalPoint"]),Ht.setGetArray(e,t,["clippingRange","windowCenter"],2),Ht.setGetArray(e,t,["viewUp","screenBottomLeft","screenBottomRight","screenTopRight","physicalTranslation","physicalViewUp","physicalViewNorth"],3),function(e,t){t.classHierarchy.push("vtkCamera");const n=new Float64Array(3),r=new Float64Array([0,0,-1]),o=new Float64Array([0,1,0]),a=g(new Float64Array(16)),i=g(new Float64Array(16)),s=new Float64Array(3),l=new Float64Array(3),c=new Float64Array(3),u=g(new Float64Array(16)),p=g(new Float64Array(16)),f=new Float64Array(3),v=new Float64Array(3);function T(){t.viewPlaneNormal[0]=-t.directionOfProjection[0],t.viewPlaneNormal[1]=-t.directionOfProjection[1],t.viewPlaneNormal[2]=-t.directionOfProjection[2]}e.orthogonalizeViewUp=()=>{const n=e.getViewMatrix();t.viewUp[0]=n[4],t.viewUp[1]=n[5],t.viewUp[2]=n[6],e.modified()},e.setPosition=(n,r,o)=>{n===t.position[0]&&r===t.position[1]&&o===t.position[2]||(t.position[0]=n,t.position[1]=r,t.position[2]=o,e.computeDistance(),e.modified())},e.setFocalPoint=(n,r,o)=>{n===t.focalPoint[0]&&r===t.focalPoint[1]&&o===t.focalPoint[2]||(t.focalPoint[0]=n,t.focalPoint[1]=r,t.focalPoint[2]=o,e.computeDistance(),e.modified())},e.setDistance=n=>{if(t.distance===n)return;t.distance=n,t.distance<1e-20&&(t.distance=1e-20,vm("Distance is set to minimum."));const r=t.directionOfProjection;t.focalPoint[0]=t.position[0]+r[0]*t.distance,t.focalPoint[1]=t.position[1]+r[1]*t.distance,t.focalPoint[2]=t.position[2]+r[2]*t.distance,e.modified()},e.computeDistance=()=>{const e=t.focalPoint[0]-t.position[0],n=t.focalPoint[1]-t.position[1],r=t.focalPoint[2]-t.position[2];if(t.distance=Math.sqrt(e*e+n*n+r*r),t.distance<1e-20){t.distance=1e-20,vm("Distance is set to minimum.");const e=t.directionOfProjection;t.focalPoint[0]=t.position[0]+e[0]*t.distance,t.focalPoint[1]=t.position[1]+e[1]*t.distance,t.focalPoint[2]=t.position[2]+e[2]*t.distance}t.directionOfProjection[0]=e/t.distance,t.directionOfProjection[1]=n/t.distance,t.directionOfProjection[2]=r/t.distance,T()},e.dolly=n=>{if(n<=0)return;const r=t.distance/n;e.setPosition(t.focalPoint[0]-r*t.directionOfProjection[0],t.focalPoint[1]-r*t.directionOfProjection[1],t.focalPoint[2]-r*t.directionOfProjection[2])},e.roll=n=>{const r=t.position,o=t.focalPoint,a=t.viewUp,i=new Float64Array([a[0],a[1],a[2],0]);g(u);const s=new Float64Array([o[0]-r[0],o[1]-r[1],o[2]-r[2]]);C(u,u,yo(n),s),Ba(i,i,u),t.viewUp[0]=i[0],t.viewUp[1]=i[1],t.viewUp[2]=i[2],e.modified()},e.azimuth=n=>{const r=t.focalPoint;g(p),b(p,p,r),C(p,p,yo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),wn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.yaw=n=>{const r=t.position;g(p),b(p,p,r),C(p,p,yo(n),t.viewUp),b(p,p,[-r[0],-r[1],-r[2]]),wn(v,t.focalPoint,p),e.setFocalPoint(v[0],v[1],v[2])},e.elevation=n=>{const r=t.focalPoint,o=e.getViewMatrix(),a=[-o[0],-o[1],-o[2]];g(p),b(p,p,r),C(p,p,yo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),wn(f,t.position,p),e.setPosition(f[0],f[1],f[2])},e.pitch=n=>{const r=t.position,o=e.getViewMatrix(),a=[o[0],o[1],o[2]];g(p),b(p,p,r),C(p,p,yo(n),a),b(p,p,[-r[0],-r[1],-r[2]]),wn(v,t.focalPoint,p),e.setFocalPoint(...v)},e.zoom=n=>{n<=0||(t.parallelProjection?t.parallelScale/=n:t.viewAngle/=n,e.modified())},e.translate=(n,r,o)=>{const a=[n,r,o];Eo(t.position,a,t.position),Eo(t.focalPoint,a,t.focalPoint),e.computeDistance(),e.modified()},e.applyTransform=n=>{const r=[...t.viewUp,1],o=[],a=[],i=[];r[0]+=t.position[0],r[1]+=t.position[1],r[2]+=t.position[2],Ba(o,[...t.position,1],n),Ba(a,[...t.focalPoint,1],n),Ba(i,r,n),i[0]-=o[0],i[1]-=o[1],i[2]-=o[2],e.setPosition(...o.slice(0,3)),e.setFocalPoint(...a.slice(0,3)),e.setViewUp(...i.slice(0,3))},e.getThickness=()=>t.clippingRange[1]-t.clippingRange[0],e.setThickness=n=>{let r=n;r<1e-20&&(r=1e-20,vm("Thickness is set to minimum.")),e.setClippingRange(t.clippingRange[0],t.clippingRange[0]+r)},e.setThicknessFromFocalPoint=n=>{let r=n;r<1e-20&&(r=1e-20,vm("Thickness is set to minimum.")),e.setClippingRange(t.distance-r/2,t.distance+r/2)},e.setRoll=e=>{},e.getRoll=()=>{},e.setObliqueAngles=(e,t)=>{},e.getOrientation=()=>{},e.getOrientationWXYZ=()=>{},e.getFrustumPlanes=e=>{},e.getCameraLightTransformMatrix=e=>(d(e,t.cameraLightTransform),e),e.computeCameraLightTransform=()=>{d(a,e.getViewMatrix()),h(a,a),O(i,[t.distance,t.distance,t.distance]),y(a,a,i),g(t.cameraLightTransform),b(t.cameraLightTransform,a,[0,0,-1])},e.deepCopy=e=>{},e.physicalOrientationToWorldDirection=e=>{const t=Ga(e[0],e[1],e[2],e[3]),n=Na(),r=Ga(0,0,1,0);var o,a;return a=t,(o=n)[0]=-a[0],o[1]=-a[1],o[2]=-a[2],o[3]=a[3],_a(r,t,r),_a(r,r,n),[r[0],r[1],r[2]]},e.getPhysicalToWorldMatrix=t=>{e.getWorldToPhysicalMatrix(t),h(t,t)},e.getWorldToPhysicalMatrix=e=>{g(e);const n=[3];Fo(t.physicalViewNorth,t.physicalViewUp,n),e[0]=n[0],e[1]=n[1],e[2]=n[2],e[4]=t.physicalViewUp[0],e[5]=t.physicalViewUp[1],e[6]=t.physicalViewUp[2],e[8]=-t.physicalViewNorth[0],e[9]=-t.physicalViewNorth[1],e[10]=-t.physicalViewNorth[2],m(e,e),vn(s,1/t.physicalScale,1/t.physicalScale,1/t.physicalScale),x(e,e,s),b(e,e,t.physicalTranslation)},e.computeViewParametersFromViewMatrix=i=>{h(a,i),wn(s,n,a),e.computeDistance();const u=t.distance;e.setPosition(s[0],s[1],s[2]),wn(l,r,a),yn(l,l,s),Sn(l,l),e.setDirectionOfProjection(l[0],l[1],l[2]),wn(c,o,a),yn(c,c,s),Sn(c,c),e.setViewUp(c[0],c[1],c[2]),e.setDistance(u)},e.computeViewParametersFromPhysicalMatrix=t=>{e.getWorldToPhysicalMatrix(a),y(a,t,a),e.computeViewParametersFromViewMatrix(a)},e.setViewMatrix=n=>{t.viewMatrix=n,t.viewMatrix&&(d(a,t.viewMatrix),e.computeViewParametersFromViewMatrix(a),m(t.viewMatrix,t.viewMatrix))},e.getViewMatrix=()=>{if(t.viewMatrix)return t.viewMatrix;q(a,t.position,t.focalPoint,t.viewUp),m(a,a);const e=new Float64Array(16);return d(e,a),e},e.setProjectionMatrix=e=>{t.projectionMatrix=e},e.getProjectionMatrix=(e,n,r)=>{const o=new Float64Array(16);if(g(o),t.projectionMatrix){const e=1/t.physicalScale;return vn(s,e,e,e),d(o,t.projectionMatrix),x(o,o,s),m(o,o),o}g(a);const i=t.clippingRange[1]-t.clippingRange[0],l=[t.clippingRange[0]+(n+1)*i/2,t.clippingRange[0]+(r+1)*i/2];if(t.parallelProjection){const n=t.parallelScale*e,r=t.parallelScale,o=(t.windowCenter[0]-1)*n,i=(t.windowCenter[0]+1)*n,s=(t.windowCenter[1]-1)*r,c=(t.windowCenter[1]+1)*r;K(a,o,i,s,c,l[0],l[1]),m(a,a)}else{if(t.useOffAxisProjection)throw new Error("Off-Axis projection is not supported at this time");{const n=Math.tan(yo(t.viewAngle)/2);let r,o;!0===t.useHorizontalViewAngle?(r=t.clippingRange[0]*n,o=t.clippingRange[0]*n/e):(r=t.clippingRange[0]*n*e,o=t.clippingRange[0]*n);const i=(t.windowCenter[0]-1)*r,s=(t.windowCenter[0]+1)*r,c=(t.windowCenter[1]-1)*o,u=(t.windowCenter[1]+1)*o,d=l[0],p=l[1];a[0]=2*d/(s-i),a[5]=2*d/(u-c),a[2]=(i+s)/(s-i),a[6]=(c+u)/(u-c),a[10]=-(d+p)/(p-d),a[14]=-1,a[11]=-2*d*p/(p-d),a[15]=0}}return d(o,a),o},e.getCompositeProjectionMatrix=(t,n,r)=>{const o=e.getViewMatrix(),a=e.getProjectionMatrix(t,n,r);return y(a,o,a),a},e.setDirectionOfProjection=(e,n,r)=>{if(t.directionOfProjection[0]===e&&t.directionOfProjection[1]===n&&t.directionOfProjection[2]===r)return;t.directionOfProjection[0]=e,t.directionOfProjection[1]=n,t.directionOfProjection[2]=r;const o=t.directionOfProjection;t.focalPoint[0]=t.position[0]+o[0]*t.distance,t.focalPoint[1]=t.position[1]+o[1]*t.distance,t.focalPoint[2]=t.position[2]+o[2]*t.distance,T()},e.setDeviceAngles=(n,r,o,a)=>{const i=[3];Fo(t.physicalViewNorth,t.physicalViewUp,i);const s=g(new Float64Array(16));C(s,s,yo(n),t.physicalViewUp),C(s,s,yo(r),i),C(s,s,yo(o),t.physicalViewNorth),C(s,s,yo(-a),t.physicalViewUp);const l=new Float64Array([-t.physicalViewUp[0],-t.physicalViewUp[1],-t.physicalViewUp[2]]),c=new Float64Array(t.physicalViewNorth);wn(l,l,s),wn(c,c,s),e.setDirectionOfProjection(l[0],l[1],l[2]),e.setViewUp(c[0],c[1],c[2]),e.modified()},e.setOrientationWXYZ=(t,n,r,o)=>{const a=g(new Float64Array(16));if(0!==t&&(0!==n||0!==r||0!==o)){const e=yo(t),i=Na();Fa(i,[n,r,o],e),G(a,i)}const i=new Float64Array(3);wn(i,[0,0,-1],a);const s=new Float64Array(3);wn(s,[0,1,0],a),e.setDirectionOfProjection(...i),e.setViewUp(...s),e.modified()},e.computeClippingRange=e=>{let n=null,r=null;n=t.viewPlaneNormal,r=t.position;const o=-n[0],a=-n[1],i=-n[2],s=-(o*r[0]+a*r[1]+i*r[2]),l=[o*e[0]+a*e[2]+i*e[4]+s,1e-18];for(let t=0;t<2;t++)for(let n=0;n<2;n++)for(let r=0;r<2;r++){const c=o*e[r]+a*e[2+n]+i*e[4+t]+s;l[0]=c<l[0]?c:l[0],l[1]=c>l[1]?c:l[1]}return l}}(e,t)}var bm={newInstance:Ht.newInstance(ym,"vtkCamera"),extend:ym};const xm={switch:!0,intensity:1,color:[1,1,1],position:[0,0,1],focalPoint:[0,0,0],positional:!1,exponent:1,coneAngle:30,coneFalloff:5,attenuationValues:[1,0,0],transformMatrix:null,lightType:"SceneLight",shadowAttenuation:1,direction:[0,0,0],directionMTime:0};function Cm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xm,n),Ht.obj(e,t),Ht.setGet(e,t,["intensity","switch","positional","exponent","coneAngle","coneFalloff","transformMatrix","lightType","shadowAttenuation","attenuationValues"]),Ht.setGetArray(e,t,["color","position","focalPoint","attenuationValues"],3),function(e,t){t.classHierarchy.push("vtkLight");const n=new Float64Array(3);e.getTransformedPosition=()=>(t.transformMatrix?wn(n,t.position,t.transformMatrix):vn(n,t.position[0],t.position[1],t.position[2]),n),e.getTransformedFocalPoint=()=>(t.transformMatrix?wn(n,t.focalPoint,t.transformMatrix):vn(n,t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),n),e.getDirection=()=>(t.directionMTime<t.mtime&&(Mn(t.direction,t.focalPoint,t.position),Go(t.direction),t.directionMTime=t.mtime),t.direction),e.setDirection=e=>{const n=new Float64Array(3);Mn(n,t.position,e),t.focalPoint=n},e.setDirectionAngle=(t,n)=>{const r=yo(t),o=yo(n);e.setPosition(Math.cos(r)*Math.sin(o),Math.sin(r),Math.cos(r)*Math.cos(o)),e.setFocalPoint(0,0,0),e.setPositional(0)},e.setLightTypeToHeadLight=()=>{e.setLightType("HeadLight")},e.setLightTypeToCameraLight=()=>{e.setLightType("CameraLight")},e.setLightTypeToSceneLight=()=>{e.setTransformMatrix(null),e.setLightType("SceneLight")},e.lightTypeIsHeadLight=()=>"HeadLight"===t.lightType,e.lightTypeIsSceneLight=()=>"SceneLight"===t.lightType,e.lightTypeIsCameraLight=()=>"CameraLight"===t.lightType}(e,t)}var Sm={newInstance:Ht.newInstance(Cm,"vtkLight"),extend:Cm,LIGHT_TYPES:["HeadLight","CameraLight","SceneLight"]};const{vtkErrorMacro:Am}=Ht;const Im={background:[0,0,0],background2:[.2,.2,.2],gradientBackground:!1,viewport:[0,0,1,1],aspect:[1,1],pixelAspect:[1,1],props:[],actors2D:[]};function wm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Im,n),Ht.obj(e,t),Ht.event(e,t,"event"),Ht.setGetArray(e,t,["viewport"],4),Ht.setGetArray(e,t,["background","background2"],3),function(e,t){function n(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];t.push(e);const r=e.getNestedProps();if(r&&r.length)for(let e=0;e<r.length;e++)n(r[e],t);return t}t.classHierarchy.push("vtkViewport"),e.getViewProps=()=>t.props,e.hasViewProp=e=>t.props.includes(e),e.addViewProp=n=>{n&&!e.hasViewProp(n)&&t.props.push(n)},e.removeViewProp=e=>{const n=t.props.filter((t=>t!==e));t.props.length!==n.length&&(t.props=n)},e.removeAllViewProps=()=>{t.props=[]},e.getViewPropsWithNestedProps=()=>{let r=[];const o=e.getActors2D();o.sort(((e,t)=>e.getLayerNumber()-t.getLayerNumber()));const a=t.props.filter((e=>!o.includes(e)));for(let e=0;e<a.length;e++)n(a[e],r);return r=r.concat(o),r},e.addActor2D=e.addViewProp,e.removeActor2D=t=>{e.removeViewProp(t)},e.getActors2D=()=>(t.actors2D=[],t.props.forEach((e=>{t.actors2D=t.actors2D.concat(e.getActors2D())})),t.actors2D),e.displayToView=()=>Am("call displayToView on your view instead"),e.viewToDisplay=()=>Am("callviewtodisplay on your view instead"),e.getSize=()=>Am("call getSize on your View instead"),e.normalizedDisplayToProjection=(t,n,r)=>{const o=e.normalizedDisplayToNormalizedViewport(t,n,r);return e.normalizedViewportToProjection(o[0],o[1],o[2])},e.normalizedDisplayToNormalizedViewport=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[(e-t.viewport[0])/o[0],(n-t.viewport[1])/o[1],r]},e.normalizedViewportToProjection=(e,t,n)=>[2*e-1,2*t-1,2*n-1],e.projectionToNormalizedDisplay=(t,n,r)=>{const o=e.projectionToNormalizedViewport(t,n,r);return e.normalizedViewportToNormalizedDisplay(o[0],o[1],o[2])},e.normalizedViewportToNormalizedDisplay=(e,n,r)=>{const o=[t.viewport[2]-t.viewport[0],t.viewport[3]-t.viewport[1]];return[e*o[0]+t.viewport[0],n*o[1]+t.viewport[1],r]},e.projectionToNormalizedViewport=(e,t,n)=>[.5*(e+1),.5*(t+1),.5*(n+1)],e.PickPropFrom=()=>Am("vtkViewport::PickPropFrom - NOT IMPLEMENTED")}(e,t)}var Om={newInstance:Ht.newInstance(wm,"vtkViewport"),extend:wm};const{vtkDebugMacro:Pm,vtkErrorMacro:Rm,vtkWarningMacro:Mm}=jt;function Em(e){return()=>Rm(`vtkRenderer::${e} - NOT IMPLEMENTED`)}const Vm={pickedProp:null,activeCamera:null,allBounds:[],ambient:[1,1,1],allocatedRenderTime:100,timeFactor:1,automaticLightCreation:!0,twoSidedLighting:!0,lastRenderTimeInSeconds:-1,renderWindow:null,lights:[],actors:[],volumes:[],lightFollowCamera:!0,numberOfPropsRendered:0,propArray:null,pathArray:null,layer:0,preserveColorBuffer:!1,preserveDepthBuffer:!1,computeVisiblePropBounds:Ra(),interactive:!0,nearClippingPlaneTolerance:0,clippingRangeExpansion:.05,erase:!0,draw:!0,useShadows:!1,useDepthPeeling:!1,occlusionRatio:0,maximumNumberOfPeels:4,selector:null,delegate:null,texturedBackground:!1,backgroundTexture:null,environmentTexture:null,environmentTextureDiffuseStrength:1,environmentTextureSpecularStrength:1,useEnvironmentTextureAsBackground:!1,pass:0};function Dm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};for(Object.assign(t,Vm,n),Om.extend(e,t,n),t.background||(t.background=[0,0,0,1]);t.background.length<3;)t.background.push(0);3===t.background.length&&t.background.push(1),yt(e,t,["_renderWindow","allocatedRenderTime","timeFactor","lastRenderTimeInSeconds","numberOfPropsRendered","lastRenderingUsedDepthPeeling","selector"]),St(e,t,["twoSidedLighting","lightFollowCamera","automaticLightCreation","erase","draw","nearClippingPlaneTolerance","clippingRangeExpansion","backingStore","interactive","layer","preserveColorBuffer","preserveDepthBuffer","useDepthPeeling","occlusionRatio","maximumNumberOfPeels","delegate","backgroundTexture","texturedBackground","environmentTexture","environmentTextureDiffuseStrength","environmentTextureSpecularStrength","useEnvironmentTextureAsBackground","useShadows","pass"]),At(e,t,["actors","volumes","lights"]),wt(e,t,["background"],4,1),Ot(0,t,["renderWindow"]),function(e,t){t.classHierarchy.push("vtkRenderer");const n={type:"ComputeVisiblePropBoundsEvent",renderer:e},r={type:"ResetCameraClippingRangeEvent",renderer:e},o={type:"ResetCameraEvent",renderer:e};e.updateCamera=()=>(t.activeCamera||(Pm("No cameras are on, creating one."),e.getActiveCameraAndResetIfCreated()),t.activeCamera.render(e),!0),e.updateLightsGeometryToFollowCamera=()=>{const n=e.getActiveCameraAndResetIfCreated();t.lights.forEach((e=>{e.lightTypeIsSceneLight()||(e.lightTypeIsHeadLight()?(e.setPositionFrom(n.getPositionByReference()),e.setFocalPointFrom(n.getFocalPointByReference()),e.modified(n.getMTime())):e.lightTypeIsCameraLight()?e.setTransformMatrix(n.getCameraLightTransformMatrix(c())):Rm("light has unknown light type",e.get()))}))},e.updateLightGeometry=()=>!t.lightFollowCamera||e.updateLightsGeometryToFollowCamera(),e.allocateTime=Em("allocateTime"),e.updateGeometry=Em("updateGeometry"),e.getVTKWindow=()=>t._renderWindow,e.setLayer=n=>{Pm(e.getClassName(),e,"setting Layer to ",n),t.layer!==n&&(t.layer=n,e.modified()),e.setPreserveColorBuffer(!!n)},e.setActiveCamera=n=>t.activeCamera!==n&&(t.activeCamera=n,e.modified(),e.invokeEvent({type:"ActiveCameraEvent",camera:n}),!0),e.makeCamera=()=>{const t=bm.newInstance();return e.invokeEvent({type:"CreateCameraEvent",camera:t}),t},e.getActiveCamera=()=>(t.activeCamera||(t.activeCamera=e.makeCamera()),t.activeCamera),e.getActiveCameraAndResetIfCreated=()=>(t.activeCamera||(e.getActiveCamera(),e.resetCamera()),t.activeCamera),e.getActors=()=>(t.actors=[],t.props.forEach((e=>{t.actors=t.actors.concat(e.getActors())})),t.actors),e.addActor=e.addViewProp,e.removeActor=n=>{t.actors=t.actors.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllActors=()=>{e.getActors().forEach((t=>{e.removeViewProp(t)})),t.actors=[],e.modified()},e.getVolumes=()=>(t.volumes=[],t.props.forEach((e=>{t.volumes=t.volumes.concat(e.getVolumes())})),t.volumes),e.addVolume=e.addViewProp,e.removeVolume=n=>{t.volumes=t.volumes.filter((e=>e!==n)),e.removeViewProp(n),e.modified()},e.removeAllVolumes=()=>{e.getVolumes().forEach((t=>{e.removeViewProp(t)})),t.volumes=[],e.modified()},e.hasLight=e=>t.lights.includes(e),e.addLight=n=>{n&&!e.hasLight(n)&&(t.lights.push(n),e.modified())},e.removeLight=n=>{t.lights=t.lights.filter((e=>e!==n)),e.modified()},e.removeAllLights=()=>{t.lights=[],e.modified()},e.setLightCollection=n=>{t.lights=n,e.modified()},e.makeLight=Sm.newInstance,e.createLight=()=>{t.automaticLightCreation&&(t._createdLight&&(e.removeLight(t._createdLight),t._createdLight.delete(),t._createdLight=null),t._createdLight=e.makeLight(),e.addLight(t._createdLight),t._createdLight.setLightTypeToHeadLight(),t._createdLight.setPosition(e.getActiveCamera().getPosition()),t._createdLight.setFocalPoint(e.getActiveCamera().getFocalPoint()))},e.normalizedDisplayToWorld=(t,n,r,o)=>{let a=e.normalizedDisplayToProjection(t,n,r);return a=e.projectionToView(a[0],a[1],a[2],o),e.viewToWorld(a[0],a[1],a[2])},e.worldToNormalizedDisplay=(t,n,r,o)=>{let a=e.worldToView(t,n,r);return a=e.viewToProjection(a[0],a[1],a[2],o),e.projectionToNormalizedDisplay(a[0],a[1],a[2])},e.viewToWorld=(e,n,r)=>{if(null===t.activeCamera)return Rm("ViewToWorld: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();h(o,o),m(o,o);const a=new Float64Array([e,n,r]);return wn(a,a,o),a},e.projectionToView=(e,n,r,o)=>{if(null===t.activeCamera)return Rm("ProjectionToView: no active camera, cannot compute projection to view, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);h(a,a),m(a,a);const i=new Float64Array([e,n,r]);return wn(i,i,a),i},e.worldToView=(e,n,r)=>{if(null===t.activeCamera)return Rm("WorldToView: no active camera, cannot compute view to world, returning 0,0,0"),[0,0,0];const o=t.activeCamera.getViewMatrix();m(o,o);const a=new Float64Array([e,n,r]);return wn(a,a,o),a},e.viewToProjection=(e,n,r,o)=>{if(null===t.activeCamera)return Rm("ViewToProjection: no active camera, cannot compute view to projection, returning 0,0,0"),[0,0,0];const a=t.activeCamera.getProjectionMatrix(o,-1,1);m(a,a);const i=new Float64Array([e,n,r]);return wn(i,i,a),i},e.computeVisiblePropBounds=()=>{t.allBounds[0]=Fi.INIT_BOUNDS[0],t.allBounds[1]=Fi.INIT_BOUNDS[1],t.allBounds[2]=Fi.INIT_BOUNDS[2],t.allBounds[3]=Fi.INIT_BOUNDS[3],t.allBounds[4]=Fi.INIT_BOUNDS[4],t.allBounds[5]=Fi.INIT_BOUNDS[5];let r=!0;e.invokeEvent(n);for(let e=0;e<t.props.length;++e){const n=t.props[e];if(n.getVisibility()&&n.getUseBounds()){const e=n.getBounds();e&&ba(e)&&(r=!1,e[0]<t.allBounds[0]&&(t.allBounds[0]=e[0]),e[1]>t.allBounds[1]&&(t.allBounds[1]=e[1]),e[2]<t.allBounds[2]&&(t.allBounds[2]=e[2]),e[3]>t.allBounds[3]&&(t.allBounds[3]=e[3]),e[4]<t.allBounds[4]&&(t.allBounds[4]=e[4]),e[5]>t.allBounds[5]&&(t.allBounds[5]=e[5]))}}return r&&(ya(t.allBounds),Pm("Can't compute bounds, no 3D props are visible")),t.allBounds},e.resetCamera=function(){const n=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null)||e.computeVisiblePropBounds(),r=[0,0,0];if(!ba(n))return Pm("Cannot reset camera!"),!1;let a=null;if(!e.getActiveCamera())return Rm("Trying to reset non-existent camera"),!1;a=t.activeCamera.getViewPlaneNormal(),t.activeCamera.setViewAngle(30),r[0]=(n[0]+n[1])/2,r[1]=(n[2]+n[3])/2,r[2]=(n[4]+n[5])/2;let i=n[1]-n[0],s=n[3]-n[2],l=n[5]-n[4];i*=i,s*=s,l*=l;let c=i+s+l;c=0===c?1:c,c=.5*Math.sqrt(c);const u=yo(t.activeCamera.getViewAngle()),d=c,p=c/Math.sin(.5*u),f=t.activeCamera.getViewUp();return Math.abs(No(f,a))>.999&&(Mm("Resetting view-up since view plane normal is parallel"),t.activeCamera.setViewUp(-f[2],f[0],f[1])),t.activeCamera.setFocalPoint(r[0],r[1],r[2]),t.activeCamera.setPosition(r[0]+p*a[0],r[1]+p*a[1],r[2]+p*a[2]),e.resetCameraClippingRange(n),t.activeCamera.setParallelScale(d),t.activeCamera.setPhysicalScale(c),t.activeCamera.setPhysicalTranslation(-r[0],-r[1],-r[2]),e.invokeEvent(o),!0},e.resetCameraClippingRange=function(){const n=(arguments.length>0&&void 0!==arguments[0]?arguments[0]:null)||e.computeVisiblePropBounds();if(!ba(n))return Pm("Cannot reset camera clipping range!"),!1;if(e.getActiveCameraAndResetIfCreated(),!t.activeCamera)return Rm("Trying to reset clipping range of non-existent camera"),!1;const o=t.activeCamera.computeClippingRange(n);let a=0;if(t.activeCamera.getParallelProjection())a=.2*t.activeCamera.getParallelScale();else{const e=yo(t.activeCamera.getViewAngle());a=.2*Math.tan(e/2)*o[1]}return o[1]-o[0]<a&&(a=a-o[1]+o[0],o[1]+=a/2,o[0]-=a/2),o[0]<0&&(o[0]=0),o[0]=.99*o[0]-(o[1]-o[0])*t.clippingRangeExpansion,o[1]=1.01*o[1]+(o[1]-o[0])*t.clippingRangeExpansion,o[0]=o[0]>=o[1]?.01*o[1]:o[0],t.nearClippingPlaneTolerance||(t.nearClippingPlaneTolerance=.01),o[0]<t.nearClippingPlaneTolerance*o[1]&&(o[0]=t.nearClippingPlaneTolerance*o[1]),t.activeCamera.setClippingRange(o[0],o[1]),e.invokeEvent(r),!1},e.setRenderWindow=e=>{e!==t._renderWindow&&(t._vtkWindow=e,t._renderWindow=e)},e.visibleActorCount=()=>t.props.filter((e=>e.getVisibility())).length,e.visibleVolumeCount=e.visibleActorCount,e.getMTime=()=>{let e=t.mtime;const n=t.activeCamera?t.activeCamera.getMTime():0;n>e&&(e=n);const r=t._createdLight?t._createdLight.getMTime():0;return r>e&&(e=r),e},e.getTransparent=()=>!!t.preserveColorBuffer,e.isActiveCameraCreated=()=>!!t.activeCamera}(e,t)}var Lm={newInstance:Et(Dm,"vtkRenderer"),extend:Dm};const Bm=Object.create(null);function Nm(e,t){Bm[e]=t}function Fm(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Bm[e]&&Bm[e](t)}const _m={defaultViewAPI:"WebGL",renderers:[],views:[],interactor:null,neverRendered:!0,numberOfLayers:1,childRenderWindows:[]};function Gm(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,_m,n),Ht.obj(e,t),Ht.setGet(e,t,["interactor","numberOfLayers","_views","defaultViewAPI"]),Ht.get(e,t,["neverRendered"]),Ht.getArray(e,t,["renderers","childRenderWindows"]),Ht.moveToProtected(e,t,["views"]),Ht.event(e,t,"completion"),function(e,t){t.classHierarchy.push("vtkRenderWindow"),e.addRenderer=n=>{e.hasRenderer(n)||(n.setRenderWindow(e),t.renderers.push(n),e.modified())},e.removeRenderer=n=>{t.renderers=t.renderers.filter((e=>e!==n)),e.modified()},e.hasRenderer=e=>-1!==t.renderers.indexOf(e),e.newAPISpecificView=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Fm(e||t.defaultViewAPI,n)},e.addView=n=>{e.hasView(n)||(n.setRenderable(e),t._views.push(n),e.modified())},e.removeView=n=>{t._views=t._views.filter((e=>e!==n)),e.modified()},e.hasView=e=>-1!==t._views.indexOf(e),e.preRender=()=>{t.renderers.forEach((e=>{e.isActiveCameraCreated()||e.resetCamera()}))},e.render=()=>{e.preRender(),t.interactor?t.interactor.render():t._views.forEach((e=>e.traverseAllPasses()))},e.getStatistics=()=>{const e={propCount:0,invisiblePropCount:0,gpuMemoryMB:0};return t._views.forEach((t=>{t.getGraphicsMemoryInfo&&(e.gpuMemoryMB+=t.getGraphicsMemoryInfo()/1e6)})),t.renderers.forEach((n=>{const r=n.getViewProps(),o=t._views[0].getViewNodeFor(n);r.forEach((t=>{if(t.getVisibility()){e.propCount+=1;const n=t.getMapper&&t.getMapper();if(n&&n.getPrimitiveCount){const t=o.getViewNodeFor(n);if(t){t.getAllocatedGPUMemoryInBytes&&(e.gpuMemoryMB+=t.getAllocatedGPUMemoryInBytes()/1e6);const r=n.getPrimitiveCount();Object.keys(r).forEach((t=>{e[t]||(e[t]=0),e[t]+=r[t]}))}}}else e.invisiblePropCount+=1}))})),e.str=Object.keys(e).map((t=>`${t}: ${e[t]}`)).join("\n"),e},e.captureImages=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Ht.setImmediate(e.render),t._views.map((e=>e.captureNextImage?e.captureNextImage(n,r):void 0)).filter((e=>!!e))},e.addRenderWindow=n=>!t.childRenderWindows.includes(n)&&(t.childRenderWindows.push(n),e.modified(),!0),e.removeRenderWindow=n=>{const r=t.childRenderWindows.findIndex((e=>e===n));return!(r<0||(t.childRenderWindows.splice(r,1),e.modified(),0))}}(e,t)}var km={newInstance:Ht.newInstance(Gm,"vtkRenderWindow"),extend:Gm,registerViewConstructor:Nm,listViewAPIs:function(){return Object.keys(Bm)},newAPISpecificView:Fm};const Um={Unknown:0,LeftController:1,RightController:2},zm={Unknown:0,Trigger:1,TrackPad:2,Grip:3,Thumbstick:4,A:5,B:6,ApplicationMenu:7};var Wm={Device:Um,Input:zm,Axis:{Unknown:0,TouchpadX:1,TouchpadY:2,ThumbstickX:3,ThumbstickY:4},MouseButton:{LeftButton:1,MiddleButton:2,RightButton:3}};const{Device:Hm,Input:jm}=Wm,{vtkWarningMacro:Km,vtkErrorMacro:$m,normalizeWheel:qm,vtkOnceErrorMacro:Xm}=Ht,Ym={ctrlKey:!1,altKey:!1,shiftKey:!1},Zm={"xr-standard":[jm.Trigger,jm.Grip,jm.TrackPad,jm.Thumbstick,jm.A,jm.B]},Qm=["StartAnimation","Animation","EndAnimation","PointerEnter","PointerLeave","MouseEnter","MouseLeave","StartMouseMove","MouseMove","EndMouseMove","LeftButtonPress","LeftButtonRelease","MiddleButtonPress","MiddleButtonRelease","RightButtonPress","RightButtonRelease","KeyPress","KeyDown","KeyUp","StartMouseWheel","MouseWheel","EndMouseWheel","StartPinch","Pinch","EndPinch","StartPan","Pan","EndPan","StartRotate","Rotate","EndRotate","Button3D","Move3D","StartPointerLock","EndPointerLock","StartInteraction","Interaction","EndInteraction","AnimationFrameRateUpdate"];function Jm(e){e.cancelable&&e.preventDefault()}function eh(e){const t=Object.create(null);return e.forEach((e=>{let{pointerId:n,position:r}=e;t[n]=r})),t}const th={renderWindow:null,interactorStyle:null,picker:null,pickingManager:null,initialized:!1,enabled:!1,enableRender:!0,currentRenderer:null,lightFollowCamera:!0,desiredUpdateRate:30,stillUpdateRate:2,container:null,recognizeGestures:!0,currentGesture:"Start",animationRequest:null,lastFrameTime:.1,recentAnimationFrameRate:10,wheelTimeoutID:0,moveTimeoutID:0,lastGamepadValues:{},preventDefaultOnPointerDown:!1,preventDefaultOnPointerUp:!1,mouseScrollDebounceByPass:!1};function nh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,th,n),Ht.obj(e,t),t._animationExtendedEnd=0,Ht.event(e,t,"RenderEvent"),Qm.forEach((n=>Ht.event(e,t,n))),Ht.get(e,t,["initialized","interactorStyle","lastFrameTime","recentAnimationFrameRate","_view"]),Ht.setGet(e,t,["container","lightFollowCamera","enabled","enableRender","recognizeGestures","desiredUpdateRate","stillUpdateRate","picker","preventDefaultOnPointerDown","preventDefaultOnPointerUp","mouseScrollDebounceByPass"]),Ht.moveToProtected(e,t,["view"]),function(e,t){t.classHierarchy.push("vtkRenderWindowInteractor");const n={...e},r=new Set,o=new Map;let a=1;function i(n,r){t._forcedRenderer||(t.currentRenderer=e.findPokedRenderer(n,r))}e.start=()=>{(t.initialized||(e.initialize(),t.initialized))&&e.startEventLoop()},e.setRenderWindow=e=>{$m("you want to call setView(view) instead of setRenderWindow on a vtk.js interactor")},e.setInteractorStyle=n=>{t.interactorStyle!==n&&(null!=t.interactorStyle&&t.interactorStyle.setInteractor(null),t.interactorStyle=n,null!=t.interactorStyle&&t.interactorStyle.getInteractor()!==e&&t.interactorStyle.setInteractor(e))},e.initialize=()=>{t.initialized=!0,e.enable(),e.render()},e.enable=()=>e.setEnabled(!0),e.disable=()=>e.setEnabled(!1),e.startEventLoop=()=>Km("empty event loop"),e.getCurrentRenderer=()=>(t.currentRenderer||i(0,0),t.currentRenderer);const s=t._getScreenEventPositionFor||function(e){const n=t._view.getCanvas(),r=n.getBoundingClientRect(),a=n.width/r.width,s=n.height/r.height,l={x:a*(e.clientX-r.left),y:s*(r.height-e.clientY+r.top),z:0,movementX:a*e.movementX,movementY:s*e.movementY};return(o.size<=1||!t.currentRenderer)&&i(l.x,l.y),l};function l(e){return{controlKey:e.ctrlKey,altKey:e.altKey,shiftKey:e.shiftKey}}function c(e){const t=l(e);return{key:e.key,keyCode:e.charCode,...t}}function u(e){return e.pointerType||""}const d=()=>{if(null===t.container)return;const{container:n}=t;n.addEventListener("contextmenu",Jm),n.addEventListener("wheel",e.handleWheel),n.addEventListener("DOMMouseScroll",e.handleWheel),n.addEventListener("pointerenter",e.handlePointerEnter),n.addEventListener("pointerleave",e.handlePointerLeave),n.addEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.addEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.addEventListener("pointerup",e.handlePointerUp),n.addEventListener("pointercancel",e.handlePointerCancel),n.addEventListener("keypress",e.handleKeyPress),n.addEventListener("keydown",e.handleKeyDown),document.addEventListener("keyup",e.handleKeyUp),document.addEventListener("pointerlockchange",e.handlePointerLockChange),n.tabIndex=0,n.style.touchAction="none",n.style.userSelect="none",n.style.webkitTapHighlightColor="rgba(0,0,0,0)"};e.bindEvents=e=>{null!==e&&n.setContainer(e)&&d()};const p=()=>{clearTimeout(t.moveTimeoutID),clearTimeout(t.wheelTimeoutID),t.moveTimeoutID=0,t.wheelTimeoutID=0,a=1;const{container:n}=t;n&&(n.removeEventListener("contextmenu",Jm),n.removeEventListener("wheel",e.handleWheel),n.removeEventListener("DOMMouseScroll",e.handleWheel),n.removeEventListener("pointerenter",e.handlePointerEnter),n.removeEventListener("pointerleave",e.handlePointerLeave),n.removeEventListener("pointermove",e.handlePointerMove,{passive:!1}),n.removeEventListener("pointerdown",e.handlePointerDown,{passive:!1}),n.removeEventListener("pointerup",e.handlePointerUp),n.removeEventListener("pointercancel",e.handlePointerCancel),n.removeEventListener("keypress",e.handleKeyPress),n.removeEventListener("keydown",e.handleKeyDown)),document.removeEventListener("keyup",e.handleKeyUp),document.removeEventListener("pointerlockchange",e.handlePointerLockChange),o.clear()};function f(){t._view&&t.enabled&&t.enableRender&&(t.inRender=!0,t._view.traverseAllPasses(),t.inRender=!1),e.invokeRenderEvent()}e.unbindEvents=()=>{p(),n.setContainer(null)},e.handleKeyPress=t=>{const n=c(t);e.keyPressEvent(n)},e.handleKeyDown=t=>{const n=c(t);e.keyDownEvent(n)},e.handleKeyUp=t=>{const n=c(t);e.keyUpEvent(n)},e.handlePointerEnter=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerEnterEvent(n),"mouse"===n.deviceType&&e.mouseEnterEvent(n)},e.handlePointerLeave=t=>{const n={...l(t),position:s(t),deviceType:u(t)};e.pointerLeaveEvent(n),"mouse"===n.deviceType&&e.mouseLeaveEvent(n)},e.handlePointerDown=n=>{if(!(n.button>2||e.isPointerLocked()))switch(t.preventDefaultOnPointerDown&&Jm(n),n.target.hasPointerCapture(n.pointerId)&&n.target.releasePointerCapture(n.pointerId),t.container.setPointerCapture(n.pointerId),o.has(n.pointerId)&&Km("[RenderWindowInteractor] duplicate pointerId detected"),o.set(n.pointerId,{pointerId:n.pointerId,position:s(n)}),n.pointerType){case"pen":case"touch":e.handleTouchStart(n);break;default:e.handleMouseDown(n)}},e.handlePointerUp=n=>{if(o.has(n.pointerId))switch(t.preventDefaultOnPointerUp&&Jm(n),o.delete(n.pointerId),t.container.releasePointerCapture(n.pointerId),n.pointerType){case"pen":case"touch":e.handleTouchEnd(n);break;default:e.handleMouseUp(n)}},e.handlePointerCancel=t=>{if(o.has(t.pointerId))switch(o.delete(t.pointerId),t.pointerType){case"pen":case"touch":e.handleTouchEnd(t);break;default:e.handleMouseUp(t)}},e.handlePointerMove=t=>{switch(o.has(t.pointerId)&&(o.get(t.pointerId).position=s(t)),t.pointerType){case"pen":case"touch":e.handleTouchMove(t);break;default:e.handleMouseMove(t)}},e.handleMouseDown=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonPressEvent(n);break;case 1:e.middleButtonPressEvent(n);break;case 2:e.rightButtonPressEvent(n);break;default:$m(`Unknown mouse button pressed: ${t.button}`)}},e.requestPointerLock=()=>{t.container&&t.container.requestPointerLock()},e.exitPointerLock=()=>document.exitPointerLock?.(),e.isPointerLocked=()=>!!t.container&&document.pointerLockElement===t.container,e.handlePointerLockChange=()=>{e.isPointerLocked()?e.startPointerLockEvent():e.endPointerLockEvent()},e.requestAnimation=n=>{void 0!==n?r.has(n)?Km("requester is already registered for animating"):(r.add(n),t.animationRequest||1!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())):$m("undefined requester, can not start animating")},e.extendAnimation=n=>{const o=Date.now()+n;t._animationExtendedEnd=Math.max(t._animationExtendedEnd,o),t.animationRequest||0!==r.size||t.xrAnimation||(t._animationStartTime=Date.now(),t._animationFrameCount=0,t.animationRequest=requestAnimationFrame(e.handleAnimation),e.startAnimationEvent())},e.isAnimating=()=>t.xrAnimation||null!==t.animationRequest,e.cancelAnimation=function(n){let o=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(r.has(n))r.delete(n),t.animationRequest&&0===r.size&&Date.now()>t._animationExtendedEnd&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render());else if(!o){const e=n&&n.getClassName?n.getClassName():n;Km(`${e} did not request an animation`)}},e.switchToXRAnimation=()=>{t.animationRequest&&(cancelAnimationFrame(t.animationRequest),t.animationRequest=null),t.xrAnimation=!0},e.returnFromXRAnimation=()=>{t.xrAnimation=!1,0!==r.size&&(t.recentAnimationFrameRate=10,t.animationRequest=requestAnimationFrame(e.handleAnimation))},e.updateXRGamepads=(n,r,o)=>{n.inputSources.forEach((n=>{const a=null==n.gripSpace?null:r.getPose(n.gripSpace,o),i=null==n.gripSpace?null:r.getPose(n.targetRaySpace,o),s=n.gamepad,l=n.handedness;if(s){s.index in t.lastGamepadValues||(t.lastGamepadValues[s.index]={left:{buttons:{}},right:{buttons:{}},none:{buttons:{}}});for(let r=0;r<s.buttons.length;++r)r in t.lastGamepadValues[s.index][l].buttons||(t.lastGamepadValues[s.index][l].buttons[r]=!1),t.lastGamepadValues[s.index][l].buttons[r]!==s.buttons[r].pressed&&null!=a&&(e.button3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,pressed:s.buttons[r].pressed,device:"left"===n.handedness?Hm.LeftController:Hm.RightController,input:Zm[s.mapping]&&Zm[s.mapping][r]?Zm[s.mapping][r]:jm.Trigger}),t.lastGamepadValues[s.index][l].buttons[r]=s.buttons[r].pressed),t.lastGamepadValues[s.index][l].buttons[r]&&null!=a&&e.move3DEvent({gamepad:s,position:a.transform.position,orientation:a.transform.orientation,targetPosition:i.transform.position,targetOrientation:i.transform.orientation,device:"left"===n.handedness?Hm.LeftController:Hm.RightController})}}))},e.handleMouseMove=n=>{const r={...l(n),position:s(n),deviceType:u(n)};0===t.moveTimeoutID?e.startMouseMoveEvent(r):(e.mouseMoveEvent(r),clearTimeout(t.moveTimeoutID)),t.moveTimeoutID=setTimeout((()=>{e.endMouseMoveEvent(),t.moveTimeoutID=0}),200)},e.handleAnimation=()=>{const n=Date.now();t._animationFrameCount++,n-t._animationStartTime>1e3&&t._animationFrameCount>1&&(t.recentAnimationFrameRate=1e3*(t._animationFrameCount-1)/(n-t._animationStartTime),t.lastFrameTime=1/t.recentAnimationFrameRate,e.animationFrameRateUpdateEvent(),t._animationStartTime=n,t._animationFrameCount=1),e.animationEvent(),f(),r.size>0||Date.now()<t._animationExtendedEnd?t.animationRequest=requestAnimationFrame(e.handleAnimation):(cancelAnimationFrame(t.animationRequest),t.animationRequest=null,e.endAnimationEvent(),e.render())},e.handleWheel=n=>{Jm(n);const r={...qm(n),...l(n),position:s(n),deviceType:u(n)};0===t.wheelTimeoutID&&(a=Math.abs(r.spinY)>=.3?Math.abs(r.spinY):1),r.spinY/=a,0===t.wheelTimeoutID?(e.startMouseWheelEvent(r),e.mouseWheelEvent(r)):(e.mouseWheelEvent(r),clearTimeout(t.wheelTimeoutID)),t.mouseScrollDebounceByPass?(e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0):t.wheelTimeoutID=setTimeout((()=>{e.extendAnimation(600),e.endMouseWheelEvent(),t.wheelTimeoutID=0}),200)},e.handleMouseUp=t=>{const n={...l(t),position:s(t),deviceType:u(t)};switch(t.button){case 0:e.leftButtonReleaseEvent(n);break;case 1:e.middleButtonReleaseEvent(n);break;case 2:e.rightButtonReleaseEvent(n);break;default:$m(`Unknown mouse button released: ${t.button}`)}},e.handleTouchStart=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=eh(o);if(2===r.length){const t={...l(Ym),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}e.recognizeGesture("TouchStart",t)}else if(1===r.length){const t={...l(Ym),position:s(n),deviceType:u(n)};e.leftButtonPressEvent(t)}},e.handleTouchMove=n=>{const r=[...o.values()];if(t.recognizeGestures&&r.length>1){const t=eh(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Ym),position:r[0].position,deviceType:u(n)};e.mouseMoveEvent(t)}},e.handleTouchEnd=n=>{const r=[...o.values()];if(t.recognizeGestures)if(0===r.length){const t={...l(Ym),position:s(n),deviceType:u(n)};e.leftButtonReleaseEvent(t)}else if(1===r.length){const t=eh(o);e.recognizeGesture("TouchEnd",t);const a={...l(Ym),position:r[0].position,deviceType:u(n)};e.leftButtonPressEvent(a)}else{const t=eh(o);e.recognizeGesture("TouchMove",t)}else if(1===r.length){const t={...l(Ym),position:r[0].position,deviceType:u(n)};e.leftButtonReleaseEvent(t)}},e.setView=n=>{t._view!==n&&(t._view=n,t._view.getRenderable().setInteractor(e),e.modified())},e.getFirstRenderer=()=>t._view?.getRenderable()?.getRenderersByReference()?.[0],e.findPokedRenderer=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;if(!t._view)return null;const r=t._view?.getRenderable()?.getRenderers();if(!r||0===r.length)return null;r.sort(((e,t)=>e.getLayer()-t.getLayer()));let o=null,a=null,i=null,s=r.length;for(;s--;){const l=r[s];if(t._view.isInViewport(e,n,l)&&l.getInteractive()){i=l;break}null===o&&l.getInteractive()&&(o=l),null===a&&t._view.isInViewport(e,n,l)&&(a=l)}return null===i&&(i=o),null===i&&(i=a),null==i&&(i=r[0]),i},e.render=()=>{e.isAnimating()||t.inRender||f()},Qm.forEach((n=>{const r=n.charAt(0).toLowerCase()+n.slice(1);e[`${r}Event`]=r=>{if(!t.enabled)return;if(!e.getCurrentRenderer())return void Xm("\n          Can not forward events without a current renderer on the interactor.\n        ");const o={type:n,pokedRenderer:t.currentRenderer,firstRenderer:e.getFirstRenderer(),...r};e[`invoke${n}`](o)}})),e.recognizeGesture=(n,r)=>{if(Object.keys(r).length>2)return;if(t.startingEventPositions||(t.startingEventPositions={}),"TouchStart"===n)return Object.keys(r).forEach((e=>{t.startingEventPositions[e]=r[e]})),void(t.currentGesture="Start");if("TouchEnd"===n)return"Pinch"===t.currentGesture&&(e.render(),e.endPinchEvent()),"Rotate"===t.currentGesture&&(e.render(),e.endRotateEvent()),"Pan"===t.currentGesture&&(e.render(),e.endPanEvent()),t.currentGesture="Start",void(t.startingEventPositions={});let o=0;const a=[],i=[];Object.keys(r).forEach((e=>{a[o]=r[e],i[o]=t.startingEventPositions[e],o++}));const s=Math.sqrt((i[0].x-i[1].x)*(i[0].x-i[1].x)+(i[0].y-i[1].y)*(i[0].y-i[1].y)),l=Math.sqrt((a[0].x-a[1].x)*(a[0].x-a[1].x)+(a[0].y-a[1].y)*(a[0].y-a[1].y));let c=bo(Math.atan2(i[1].y-i[0].y,i[1].x-i[0].x)),u=bo(Math.atan2(a[1].y-a[0].y,a[1].x-a[0].x)),d=u-c;u=u+180>=360?u-180:u+180,c=c+180>=360?c-180:c+180,Math.abs(u-c)<Math.abs(d)&&(d=u-c);const p=[];if(p[0]=(a[0].x-i[0].x+a[1].x-i[1].x)/2,p[1]=(a[0].y-i[0].y+a[1].y-i[1].y)/2,"TouchMove"===n)if("Start"===t.currentGesture){let n=.01*Math.sqrt(t.container.clientWidth*t.container.clientWidth+t.container.clientHeight*t.container.clientHeight);n<15&&(n=15);const o=Math.abs(l-s),a=3.1415926*l*Math.abs(d)/360,i=Math.sqrt(p[0]*p[0]+p[1]*p[1]);if(o>n&&o>a&&o>i){t.currentGesture="Pinch";const n={scale:1,touches:r};e.startPinchEvent(n)}else if(a>n&&a>i){t.currentGesture="Rotate";const n={rotation:0,touches:r};e.startRotateEvent(n)}else if(i>n){t.currentGesture="Pan";const n={translation:[0,0],touches:r};e.startPanEvent(n)}}else{if("Rotate"===t.currentGesture){const t={rotation:d,touches:r};e.rotateEvent(t)}if("Pinch"===t.currentGesture){const t={scale:l/s,touches:r};e.pinchEvent(t)}if("Pan"===t.currentGesture){const t={translation:p,touches:r};e.panEvent(t)}}},e.handleVisibilityChange=()=>{t._animationStartTime=Date.now(),t._animationFrameCount=0},e.setCurrentRenderer=e=>{t._forcedRenderer=!!e,t.currentRenderer=e},e.setContainer=e=>{p();const t=n.setContainer(e??null);return t&&d(),t},e.delete=()=>{for(;r.size;)e.cancelAnimation(r.values().next().value);void 0!==document.hidden&&document.removeEventListener("visibilitychange",e.handleVisibilityChange),t.container&&e.setContainer(null),n.delete()},void 0!==document.hidden&&document.addEventListener("visibilitychange",e.handleVisibilityChange,!1)}(e,t)}var rh={newInstance:Ht.newInstance(nh,"vtkRenderWindowInteractor"),extend:nh,handledEvents:Qm,...Wm};const{vtkErrorMacro:oh,VOID:ah}=Ht,ih={enabled:!0,priority:0,processEvents:!0,subscribedEvents:[]};function sh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ih,n),Ht.obj(e,t),Ht.event(e,t,"InteractionEvent"),Ht.event(e,t,"StartInteractionEvent"),Ht.event(e,t,"EndInteractionEvent"),Ht.get(e,t,["_interactor","enabled"]),Ht.setGet(e,t,["priority","processEvents"]),Ht.moveToProtected(e,t,["interactor"]),function(e,t){t.classHierarchy.push("vtkInteractorObserver");const n={...e};function r(){for(;t.subscribedEvents.length;)t.subscribedEvents.pop().unsubscribe()}function o(){rh.handledEvents.forEach((n=>{e[`handle${n}`]&&t.subscribedEvents.push(t._interactor[`on${n}`]((r=>t.processEvents?e[`handle${n}`](r):ah),t.priority))}))}e.setInteractor=n=>{n!==t._interactor&&(r(),t._interactor=n,n&&t.enabled&&o(),e.modified())},e.setEnabled=n=>{n!==t.enabled&&(r(),n&&(t._interactor?o():oh("\n          The interactor must be set before subscribing to events\n        ")),t.enabled=n,e.modified())},e.computeDisplayToWorld=(e,n,r,o)=>e?t._interactor.getView().displayToWorld(n,r,o,e):null,e.computeWorldToDisplay=(e,n,r,o)=>e?t._interactor.getView().worldToDisplay(n,r,o,e):null,e.setPriority=e=>{n.setPriority(e)&&t._interactor&&(r(),o())}}(e,t)}var lh={newInstance:Ht.newInstance(sh,"vtkInteractorObserver"),extend:sh,computeWorldToDisplay:function(e,t,n,r){return e.getRenderWindow().getViews()[0].worldToDisplay(t,n,r,e)},computeDisplayToWorld:function(e,t,n,r){return e.getRenderWindow().getViews()[0].displayToWorld(t,n,r,e)}},ch={States:{IS_START:0,IS_NONE:0,IS_ROTATE:1,IS_PAN:2,IS_SPIN:3,IS_DOLLY:4,IS_CAMERA_POSE:11,IS_WINDOW_LEVEL:1024,IS_SLICE:1025}};const{States:uh}=ch,dh={Rotate:uh.IS_ROTATE,Pan:uh.IS_PAN,Spin:uh.IS_SPIN,Dolly:uh.IS_DOLLY,CameraPose:uh.IS_CAMERA_POSE,WindowLevel:uh.IS_WINDOW_LEVEL,Slice:uh.IS_SLICE},ph={state:uh.IS_NONE,handleObservers:1,autoAdjustCameraClippingRange:1};function fh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ph,n),lh.extend(e,t,n),Ht.setGet(e,t,["focusedRenderer"]),function(e,t){t.classHierarchy.push("vtkInteractorStyle"),Object.keys(dh).forEach((n=>{Ht.event(e,t,`Start${n}Event`),e[`start${n}`]=()=>{t.state===uh.IS_NONE&&(t.state=dh[n],t._interactor.requestAnimation(e),e.invokeStartInteractionEvent({type:"StartInteractionEvent"}),e[`invokeStart${n}Event`]({type:`Start${n}Event`}))},Ht.event(e,t,`End${n}Event`),e[`end${n}`]=()=>{t.state===dh[n]&&(t.state=uh.IS_NONE,t._interactor.cancelAnimation(e),e.invokeEndInteractionEvent({type:"EndInteractionEvent"}),e[`invokeEnd${n}Event`]({type:`End${n}Event`}),t._interactor.render())}})),t.getRenderer=e=>t.focusedRenderer||e.pokedRenderer,e.handleKeyPress=e=>{const n=t._interactor;let r=null;switch(e.key){case"r":case"R":t.getRenderer(e).resetCamera(),n.render();break;case"w":case"W":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToWireframe&&t.setRepresentationToWireframe()})),n.render();break;case"s":case"S":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToSurface&&t.setRepresentationToSurface()})),n.render();break;case"v":case"V":r=t.getRenderer(e).getActors(),r.forEach((e=>{const t=e.getProperty();t.setRepresentationToPoints&&t.setRepresentationToPoints()})),n.render()}}}(e,t)}var gh={newInstance:Ht.newInstance(fh,"vtkInteractorStyle"),extend:fh,...ch};const{States:mh}=ch,hh={motionFactor:10,zoomFactor:10};function vh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hh,n),gh.extend(e,t,n),Ht.setGet(e,t,["motionFactor","zoomFactor"]),function(e,t){t.classHierarchy.push("vtkInteractorStyleTrackballCamera"),e.handleMouseMove=n=>{const r=n.position,o=t.getRenderer(n);switch(t.state){case mh.IS_ROTATE:e.handleMouseRotate(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case mh.IS_PAN:e.handleMousePan(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case mh.IS_DOLLY:e.handleMouseDolly(o,r),e.invokeInteractionEvent({type:"InteractionEvent"});break;case mh.IS_SPIN:e.handleMouseSpin(o,r),e.invokeInteractionEvent({type:"InteractionEvent"})}t.previousPosition=r},e.handleButton3D=n=>{!n||!n.pressed||n.device!==Um.RightController||n.input!==zm.Trigger&&n.input!==zm.TrackPad?!n||n.pressed||n.device!==Um.RightController||n.input!==zm.Trigger&&n.input!==zm.TrackPad||t.state!==mh.IS_CAMERA_POSE||e.endCameraPose():e.startCameraPose()},e.handleMove3D=n=>{t.state===mh.IS_CAMERA_POSE&&e.updateCameraPose(n)},e.updateCameraPose=e=>{const n=t.getRenderer(e).getActiveCamera(),r=n.getPhysicalTranslation(),o=.025*n.getPhysicalScale(),a=n.physicalOrientationToWorldDirection([e.orientation.x,e.orientation.y,e.orientation.z,e.orientation.w]);n.setPhysicalTranslation(r[0]+a[0]*o,r[1]+a[1]*o,r[2]+a[2]*o)},e.handleLeftButtonPress=n=>{const r=n.position;t.previousPosition=r,n.shiftKey?n.controlKey||n.altKey?e.startDolly():e.startPan():n.controlKey||n.altKey?e.startSpin():e.startRotate()},e.handleLeftButtonRelease=()=>{switch(t.state){case mh.IS_DOLLY:e.endDolly();break;case mh.IS_PAN:e.endPan();break;case mh.IS_SPIN:e.endSpin();break;case mh.IS_ROTATE:e.endRotate()}},e.handleStartMouseWheel=()=>{e.startDolly()},e.handleEndMouseWheel=()=>{e.endDolly()},e.handleStartPinch=n=>{t.previousScale=n.scale,e.startDolly()},e.handleEndPinch=()=>{e.endDolly()},e.handleStartRotate=n=>{t.previousRotation=n.rotation,e.startRotate()},e.handleEndRotate=()=>{e.endRotate()},e.handleStartPan=n=>{t.previousTranslation=n.translation,e.startPan()},e.handleEndPan=()=>{e.endPan()},e.handlePinch=n=>{e.dollyByFactor(t.getRenderer(n),n.scale/t.previousScale),t.previousScale=n.scale},e.handlePan=n=>{const r=t.getRenderer(n).getActiveCamera();let o=r.getFocalPoint();o=e.computeWorldToDisplay(t.getRenderer(n),o[0],o[1],o[2]);const a=o[2],i=n.translation,s=t.previousTranslation,l=e.computeDisplayToWorld(t.getRenderer(n),o[0]+i[0]-s[0],o[1]+i[1]-s[1],a),c=e.computeDisplayToWorld(t.getRenderer(n),o[0],o[1],a),u=[];u[0]=c[0]-l[0],u[1]=c[1]-l[1],u[2]=c[2]-l[2],o=r.getFocalPoint();const d=r.getPosition();r.setFocalPoint(u[0]+o[0],u[1]+o[1],u[2]+o[2]),r.setPosition(u[0]+d[0],u[1]+d[1],u[2]+d[2]),t._interactor.getLightFollowCamera()&&t.getRenderer(n).updateLightsGeometryToFollowCamera(),r.orthogonalizeViewUp(),t.previousTranslation=n.translation},e.handleRotate=e=>{const n=t.getRenderer(e).getActiveCamera();n.roll(e.rotation-t.previousRotation),n.orthogonalizeViewUp(),t.previousRotation=e.rotation},e.handleMouseRotate=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=n.x-t.previousPosition.x,a=n.y-t.previousPosition.y,i=r.getView().getViewportSize(e);let s=-.1,l=-.1;i[0]&&i[1]&&(s=-20/i[1],l=-20/i[0]);const c=o*l*t.motionFactor,u=a*s*t.motionFactor,d=e.getActiveCamera();Number.isNaN(c)||Number.isNaN(u)||(d.azimuth(c),d.elevation(u),d.orthogonalizeViewUp()),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange(),r.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()},e.handleMouseSpin=(e,n)=>{if(!t.previousPosition)return;const r=t._interactor,o=e.getActiveCamera(),a=r.getView().getViewportCenter(e),i=bo(Math.atan2(t.previousPosition.y-a[1],t.previousPosition.x-a[0])),s=bo(Math.atan2(n.y-a[1],n.x-a[0]))-i;Number.isNaN(s)||(o.roll(s),o.orthogonalizeViewUp())},e.handleMousePan=(n,r)=>{if(!t.previousPosition)return;const o=n.getActiveCamera();let a=o.getFocalPoint();a=e.computeWorldToDisplay(n,a[0],a[1],a[2]);const i=a[2],s=e.computeDisplayToWorld(n,r.x,r.y,i),l=e.computeDisplayToWorld(n,t.previousPosition.x,t.previousPosition.y,i),c=[];c[0]=l[0]-s[0],c[1]=l[1]-s[1],c[2]=l[2]-s[2],a=o.getFocalPoint();const u=o.getPosition();o.setFocalPoint(c[0]+a[0],c[1]+a[1],c[2]+a[2]),o.setPosition(c[0]+u[0],c[1]+u[1],c[2]+u[2]),t._interactor.getLightFollowCamera()&&n.updateLightsGeometryToFollowCamera()},e.handleMouseDolly=(n,r)=>{if(!t.previousPosition)return;const o=r.y-t.previousPosition.y,a=t._interactor.getView().getViewportCenter(n),i=t.motionFactor*o/a[1];e.dollyByFactor(n,1.1**i)},e.handleMouseWheel=n=>{const r=1-n.spinY/t.zoomFactor;e.dollyByFactor(t.getRenderer(n),r)},e.dollyByFactor=(e,n)=>{if(Number.isNaN(n))return;const r=e.getActiveCamera();r.getParallelProjection()?r.setParallelScale(r.getParallelScale()/n):(r.dolly(n),t.autoAdjustCameraClippingRange&&e.resetCameraClippingRange()),t._interactor.getLightFollowCamera()&&e.updateLightsGeometryToFollowCamera()}}(e,t)}var Th={newInstance:Ht.newInstance(vh,"vtkInteractorStyleTrackballCamera"),extend:vh};function yh(e){return e}function bh(e){return null===e||"null"===e?null:"true"===e||"false"!==e&&(void 0!==e&&"undefined"!==e?"["===e[0]&&"]"===e[e.length-1]?e.substring(1,e.length-1).split(",").map((e=>bh(e.trim()))):""===e||Number.isNaN(Number(e))?e:Number(e):void 0)}var xh=function(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:window.location.search;const n={},r=e?bh:yh;return new URLSearchParams(t).forEach(((e,t)=>{t&&(n[t]=!e||r(e))})),n};const Ch={delegates:[],currentOperation:null,preDelegateOperations:[],postDelegateOperations:[],currentParent:null};function Sh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ch,n),Ht.obj(e,t),Ht.get(e,t,["currentOperation"]),Ht.setGet(e,t,["delegates","_currentParent","preDelegateOperations","postDelegateOperations"]),Ht.moveToProtected(e,t,["currentParent"]),function(e,t){t.classHierarchy.push("vtkRenderPass"),e.getOperation=()=>t.currentOperation,e.setCurrentOperation=e=>{t.currentOperation=e,t.currentTraverseOperation=`traverse${Ht.capitalize(t.currentOperation)}`},e.getTraverseOperation=()=>t.currentTraverseOperation,e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;t.deleted||(t._currentParent=r,t.preDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})),t.delegates.forEach((t=>{t.traverse(n,e)})),t.postDelegateOperations.forEach((t=>{e.setCurrentOperation(t),n.traverse(e)})))}}(e,t)}var Ah={newInstance:Ht.newInstance(Sh,"vtkRenderPass"),extend:Sh};const{Representation:Ih}=ts,{vtkErrorMacro:wh}=Ht;function Oh(e){const t=Pu.substitute(e.Fragment,"//VTK::RenderPassFragmentShader::Impl","\n      float weight = gl_FragData[0].a * pow(max(1.1 - gl_FragCoord.z, 0.0), 2.0);\n      gl_FragData[0] = vec4(gl_FragData[0].rgb*weight, gl_FragData[0].a);\n      gl_FragData[1].r = weight;\n    ",!1);e.Fragment=t.result}const Ph={framebuffer:null,copyShader:null,tris:null};function Rh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ph,n),Ah.extend(e,t,n),t.VBOBuildTime={},Ht.obj(t.VBOBuildTime,{mtime:0}),t.tris=Bu.newInstance(),Ht.get(e,t,["framebuffer"]),function(e,t){t.classHierarchy.push("vtkOpenGLOrderIndependentTranslucentPass"),e.createVertexBuffer=()=>{const e=new Float32Array([-1,-1,-1,1,-1,-1,-1,1,-1,1,1,-1]),n=new Float32Array([0,0,1,0,0,1,1,1]),r=new Uint16Array([4,0,1,3,2]),o=Ts.newInstance({numberOfComponents:3,values:e});o.setName("points");const a=Ts.newInstance({numberOfComponents:2,values:n});a.setName("tcoords");const i=Ts.newInstance({numberOfComponents:1,values:r});t.tris.getCABO().createVBO(i,"polys",Ih.SURFACE,{points:o,tcoords:a,cellOffset:0}),t.VBOBuildTime.modified()},e.createFramebuffer=e=>{const n=e.getSize(),r=e.getContext();t.framebuffer=qd.newInstance(),t.framebuffer.setOpenGLRenderWindow(e),t.framebuffer.create(...n),t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind(),t.translucentRGBATexture=td.newInstance(),t.translucentRGBATexture.setInternalFormat(r.RGBA16F),t.translucentRGBATexture.setFormat(r.RGBA),t.translucentRGBATexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRGBATexture.setOpenGLRenderWindow(e),t.translucentRGBATexture.create2DFromRaw({width:n[0],height:n[1],numComps:4,dataType:"Float32Array",data:null}),t.translucentRTexture=td.newInstance(),t.translucentRTexture.setInternalFormat(r.R16F),t.translucentRTexture.setFormat(r.RED),t.translucentRTexture.setOpenGLDataType(r.HALF_FLOAT),t.translucentRTexture.setOpenGLRenderWindow(e),t.translucentRTexture.create2DFromRaw({width:n[0],height:n[1],numComps:1,dataType:"Float32Array",data:null}),t.translucentZTexture=td.newInstance(),t.translucentZTexture.setOpenGLRenderWindow(e),t.translucentZTexture.createDepthFromRaw({width:n[0],height:n[1],dataType:"Float32Array",data:null}),t.framebuffer.setColorBuffer(t.translucentRGBATexture,0),t.framebuffer.setColorBuffer(t.translucentRTexture,1),t.framebuffer.setDepthBuffer(t.translucentZTexture)},e.createCopyShader=e=>{t.copyShader=e.getShaderCache().readyShaderProgramArray(["//VTK::System::Dec","attribute vec4 vertexDC;","attribute vec2 tcoordTC;","varying vec2 tcoord;","void main() { tcoord = tcoordTC; gl_Position = vertexDC; }"].join("\n"),"//VTK::System::Dec\n\nin vec2 tcoord;\n\nuniform sampler2D translucentRTexture;\nuniform sampler2D translucentRGBATexture;\n\n// the output of this shader\n//VTK::Output::Dec\n\nvoid main()\n{\n  vec4 t1Color = texture(translucentRGBATexture, tcoord);\n  float t2Color = texture(translucentRTexture, tcoord).r;\n  gl_FragData[0] = vec4(t1Color.rgb/max(t2Color,0.01), 1.0 - t1Color.a);\n}\n","")},e.createVBO=n=>{const r=n.getContext();t.tris.setOpenGLRenderWindow(n),e.createVertexBuffer();const o=t.copyShader;t.tris.getCABO().bind(),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"vertexDC",t.tris.getCABO().getVertexOffset(),t.tris.getCABO().getStride(),r.FLOAT,3,r.FALSE)||wh("Error setting vertexDC in copy shader VAO."),t.copyVAO.addAttributeArray(o,t.tris.getCABO(),"tcoordTC",t.tris.getCABO().getTCoordOffset(),t.tris.getCABO().getStride(),r.FLOAT,2,r.FALSE)||wh("Error setting vertexDC in copy shader VAO.")},e.traverse=(n,r,o)=>{if(t.deleted)return;const a=n.getSize(),i=n.getContext();if(t._supported=!1,r.getSelector()||!i||!n.getWebgl2()||!i.getExtension("EXT_color_buffer_half_float")&&!i.getExtension("EXT_color_buffer_float"))return e.setCurrentOperation("translucentPass"),void r.traverse(e);if(t._supported=!0,null===t.framebuffer)e.createFramebuffer(n);else{const r=t.framebuffer.getSize();null===r||r[0]!==a[0]||r[1]!==a[1]?(t.framebuffer.releaseGraphicsResources(),t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRTexture.releaseGraphicsResources(n),t.translucentZTexture.releaseGraphicsResources(n),e.createFramebuffer(n)):(t.framebuffer.saveCurrentBindingsAndBuffers(),t.framebuffer.bind())}i.drawBuffers([i.COLOR_ATTACHMENT0]),i.clearBufferfv(i.COLOR,0,[0,0,0,0]),i.clearBufferfv(i.DEPTH,0,[1]),i.colorMask(!1,!1,!1,!1),o.getOpaqueActorCount()>0&&(o.setCurrentOperation("opaqueZBufferPass"),r.traverse(o)),i.colorMask(!0,!0,!0,!0),i.drawBuffers([i.COLOR_ATTACHMENT0,i.COLOR_ATTACHMENT1]),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),i.clearBufferfv(i.COLOR,0,[0,0,0,1]),i.clearBufferfv(i.COLOR,1,[0,0,0,0]),i.enable(i.DEPTH_TEST),i.enable(i.BLEND),i.blendFuncSeparate(i.ONE,i.ONE,i.ZERO,i.ONE_MINUS_SRC_ALPHA),e.setCurrentOperation("translucentPass"),r.traverse(e),i.drawBuffers([i.NONE]),t.framebuffer.restorePreviousBindingsAndBuffers(),null===t.copyShader?e.createCopyShader(n):n.getShaderCache().readyShaderProgram(t.copyShader),t.copyVAO||(t.copyVAO=Eu.newInstance(),t.copyVAO.setOpenGLRenderWindow(n)),t.copyVAO.bind(),t.VBOBuildTime.getMTime()<e.getMTime()&&e.createVBO(n),i.blendFuncSeparate(i.SRC_ALPHA,i.ONE_MINUS_SRC_ALPHA,i.ONE,i.ONE_MINUS_SRC_ALPHA),i.depthMask(!1),i.depthFunc(i.ALWAYS),i.viewport(0,0,a[0],a[1]),i.scissor(0,0,a[0],a[1]),t.translucentRGBATexture.activate(),t.copyShader.setUniformi("translucentRGBATexture",t.translucentRGBATexture.getTextureUnit()),t.translucentRTexture.activate(),t.copyShader.setUniformi("translucentRTexture",t.translucentRTexture.getTextureUnit()),i.drawArrays(i.TRIANGLES,0,t.tris.getCABO().getElementCount()),i.depthMask(!0),i.depthFunc(i.LEQUAL),t.translucentRGBATexture.deactivate(),t.translucentRTexture.deactivate();const s=r.getTiledSizeAndOrigin();i.scissor(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize),i.viewport(s.lowerLeftU,s.lowerLeftV,s.usize,s.vsize)},e.getShaderReplacement=()=>t._supported?Oh:null,e.releaseGraphicsResources=n=>{t.framebuffer&&(t.framebuffer.releaseGraphicsResources(n),t.framebuffer=null),t.translucentRGBATexture&&(t.translucentRGBATexture.releaseGraphicsResources(n),t.translucentRGBATexture=null),t.translucentRTexture&&(t.translucentRTexture.releaseGraphicsResources(n),t.translucentRTexture=null),t.translucentZTexture&&(t.translucentZTexture.releaseGraphicsResources(n),t.translucentZTexture=null),t.copyVAO&&(t.copyVAO.releaseGraphicsResources(n),t.copyVAO=null),t.copyShader&&(t.copyShader.releaseGraphicsResources(n),t.copyShader=null),t.tris&&(t.tris.releaseGraphicsResources(n),t.tris=null),e.modified()}}(e,t)}var Mh={newInstance:Ht.newInstance(Rh,"vtkOpenGLOrderIndependentTranslucentPass"),extend:Rh};const Eh={opaqueActorCount:0,translucentActorCount:0,volumeCount:0,overlayActorCount:0,framebuffer:null,depthRequested:!1};function Vh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Eh,n),Ah.extend(e,t,n),Ht.get(e,t,["framebuffer","opaqueActorCount","translucentActorCount","volumeCount"]),function(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getRenderable().getNumberOfLayers(),a=n.getRenderable().getRenderersByReference();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getViewNodeFor(i);if(i.getDraw()&&i.getLayer()===r){if(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumeCount=0,t.overlayActorCount=0,e.setCurrentOperation("queryPass"),s.traverse(e),(t.opaqueActorCount>0||t.translucentActorCount>0)&&t.volumeCount>0||t.depthRequested){const r=n.getFramebufferSize();null===t.framebuffer&&(t.framebuffer=qd.newInstance()),t.framebuffer.setOpenGLRenderWindow(n),t.framebuffer.saveCurrentBindingsAndBuffers();const o=t.framebuffer.getSize();null!==o&&o[0]===r[0]&&o[1]===r[1]||(t.framebuffer.create(r[0],r[1]),t.framebuffer.populateFramebuffer()),t.framebuffer.bind(),e.setCurrentOperation("zBufferPass"),s.traverse(e),t.framebuffer.restorePreviousBindingsAndBuffers(),t.depthRequested=!1}e.setCurrentOperation("cameraPass"),s.traverse(e),t.opaqueActorCount>0&&(e.setCurrentOperation("opaquePass"),s.traverse(e)),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=Mh.newInstance()),t.translucentPass.traverse(n,s,e)),t.volumeCount>0&&(e.setCurrentOperation("volumePass"),s.traverse(e)),t.overlayActorCount>0&&(e.setCurrentOperation("overlayPass"),s.traverse(e))}}},e.getZBufferTexture=()=>t.framebuffer?t.framebuffer.getColorTexture():null,e.requestDepth=()=>{t.depthRequested=!0},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.incrementVolumeCount=()=>t.volumeCount++,e.incrementOverlayActorCount=()=>t.overlayActorCount++}(e,t)}var Dh={newInstance:Ht.newInstance(Vh,"vtkForwardPass"),extend:Vh},Lh=n(292),Bh=n.n(Lh);const Nh=["lastShaderProgramBound","context","_openGLRenderWindow"],Fh={lastShaderProgramBound:null,shaderPrograms:null,context:null};function _h(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fh,n),t.shaderPrograms={},Ht.obj(e,t),Ht.setGet(e,t,Nh),Ht.moveToProtected(e,t,["openGLRenderWindow"]),function(e,t){t.classHierarchy.push("vtkShaderCache"),e.replaceShaderValues=(e,n,r)=>{let o=n;r.length>0&&(o=Pu.substitute(o,"VSOut","GSOut").result);const a=t._openGLRenderWindow.getWebgl2();let i="\n",s="#version 100\n";a?s="#version 300 es\n#define attribute in\n#define textureCube texture\n#define texture2D texture\n#define textureCubeLod textureLod\n#define texture2DLod textureLod\n":(t.context.getExtension("OES_standard_derivatives"),t.context.getExtension("EXT_frag_depth")&&(i="#extension GL_EXT_frag_depth : enable\n"),t.context.getExtension("EXT_shader_texture_lod")&&(i+="#extension GL_EXT_shader_texture_lod : enable\n#define textureCubeLod textureCubeLodEXT\n#define texture2DLod texture2DLodEXT")),o=Pu.substitute(o,"//VTK::System::Dec",[`${s}\n`,a?"":"#extension GL_OES_standard_derivatives : enable\n",i,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;let l=Pu.substitute(e,"//VTK::System::Dec",[`${s}\n`,"#ifdef GL_FRAGMENT_PRECISION_HIGH","precision highp float;","precision highp int;","#else","precision mediump float;","precision mediump int;","#endif"]).result;if(a){l=Pu.substitute(l,"varying","out").result,o=Pu.substitute(o,"varying","in").result;let e="",t=0;for(;o.includes(`gl_FragData[${t}]`);)o=Pu.substitute(o,`gl_FragData\\[${t}\\]`,`fragOutput${t}`).result,e+=`layout(location = ${t}) out vec4 fragOutput${t};\n`,t++;o=Pu.substitute(o,"//VTK::Output::Dec",e).result}return{VSSource:l,FSSource:o,GSSource:Pu.substitute(r,"//VTK::System::Dec",s).result}},e.readyShaderProgramArray=(t,n,r)=>{const o=e.replaceShaderValues(t,n,r),a=e.getShaderProgram(o.VSSource,o.FSSource,o.GSSource);return e.readyShaderProgram(a)},e.readyShaderProgram=t=>t&&(t.getCompiled()||t.compileShader())&&e.bindShaderProgram(t)?t:null,e.getShaderProgram=(e,n,r)=>{const o=`${e}${n}${r}`,a=Bh().hash(o);if(!(a in t.shaderPrograms)){const o=Pu.newInstance();return o.setContext(t.context),o.getVertexShader().setSource(e),o.getFragmentShader().setSource(n),r&&o.getGeometryShader().setSource(r),o.setMd5Hash(a),t.shaderPrograms[a]=o,o}return t.shaderPrograms[a]},e.releaseGraphicsResources=n=>{e.releaseCurrentShaderProgram(),Object.keys(t.shaderPrograms).map((e=>t.shaderPrograms[e])).forEach((e=>e.cleanup())),t.shaderPrograms={}},e.releaseCurrentShaderProgram=()=>{t.lastShaderProgramBound&&(t.lastShaderProgramBound.cleanup(),t.lastShaderProgramBound=null)},e.bindShaderProgram=e=>(t.lastShaderProgramBound===e||(t.lastShaderProgramBound&&t.lastShaderProgramBound.release(),e.bind(),t.lastShaderProgramBound=e),1)}(e,t)}var Gh={newInstance:Ht.newInstance(_h,"vtkShaderCache"),extend:_h};const{vtkErrorMacro:kh}=Ht,Uh={context:null,numberOfTextureUnits:0,textureUnits:0};function zh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Uh,n),Ht.obj(e,t),t.textureUnits=[],Ht.get(e,t,["numberOfTextureUnits"]),Ht.setGet(e,t,["context"]),function(e,t){t.classHierarchy.push("vtkOpenGLTextureUnitManager"),e.deleteTable=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)!0===t.textureUnits[e]&&kh("some texture units  were not properly released");t.textureUnits=[],t.numberOfTextureUnits=0},e.setContext=n=>{if(t.context!==n){if(0!==t.context&&e.deleteTable(),t.context=n,t.context){t.numberOfTextureUnits=n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS);for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}e.modified()}},e.allocate=()=>{for(let n=0;n<t.numberOfTextureUnits;n++)if(!e.isAllocated(n))return t.textureUnits[n]=!0,n;return-1},e.allocateUnit=n=>e.isAllocated(n)?-1:(t.textureUnits[n]=!0,n),e.isAllocated=e=>t.textureUnits[e],e.free=e=>{t.textureUnits[e]=!1},e.freeAll=()=>{for(let e=0;e<t.numberOfTextureUnits;++e)t.textureUnits[e]=!1}}(e,t)}var Wh={newInstance:Ht.newInstance(zh,"vtkOpenGLTextureUnitManager"),extend:zh};const Hh={size:void 0,selector:void 0};function jh(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Hh,n),t.size||(t.size=[300,300]),Ht.getArray(e,t,["size"],2),Ht.get(e,t,["selector"]),Xt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkRenderWindowViewNode"),e.getViewNodeFactory=()=>null,e.getAspectRatio=()=>t.size[0]/t.size[1],e.getAspectRatioForRenderer=e=>{const n=e.getViewportByReference();return t.size[0]*(n[2]-n[0])/((n[3]-n[1])*t.size[1])},e.isInViewport=(t,n,r)=>{const o=r.getViewportByReference(),a=e.getFramebufferSize();return o[0]*a[0]<=t&&o[2]*a[0]>=t&&o[1]*a[1]<=n&&o[3]*a[1]>=n},e.getViewportSize=t=>{const n=t.getViewportByReference(),r=e.getFramebufferSize();return[(n[2]-n[0])*r[0],(n[3]-n[1])*r[1]]},e.getViewportCenter=t=>{const n=e.getViewportSize(t);return[.5*n[0],.5*n[1]]},e.displayToNormalizedDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t/o[0],n/o[1],r]},e.normalizedDisplayToDisplay=(t,n,r)=>{const o=e.getFramebufferSize();return[t*o[0],n*o[1],r]},e.worldToView=(e,t,n,r)=>r.worldToView(e,t,n),e.viewToWorld=(e,t,n,r)=>r.viewToWorld(e,t,n),e.worldToDisplay=(t,n,r,o)=>{const a=o.worldToView(t,n,r),i=e.getViewportSize(o),s=o.viewToProjection(a[0],a[1],a[2],i[0]/i[1]),l=o.projectionToNormalizedDisplay(s[0],s[1],s[2]);return e.normalizedDisplayToDisplay(l[0],l[1],l[2])},e.displayToWorld=(t,n,r,o)=>{const a=e.displayToNormalizedDisplay(t,n,r),i=o.normalizedDisplayToProjection(a[0],a[1],a[2]),s=e.getViewportSize(o),l=o.projectionToView(i[0],i[1],i[2],s[0]/s[1]);return o.viewToWorld(l[0],l[1],l[2])},e.normalizedDisplayToViewport=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=e.normalizedDisplayToDisplay(t,n,r);return[i[0]-a[0]-.5,i[1]-a[1]-.5,r]},e.viewportToNormalizedViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return a&&0!==a[0]&&0!==a[1]?[t/(a[0]-1),n/(a[1]-1),r]:[t,n,r]},e.normalizedViewportToViewport=(t,n,r,o)=>{const a=e.getViewportSize(o);return[t*(a[0]-1),n*(a[1]-1),r]},e.displayToLocalDisplay=(t,n,r)=>[t,e.getFramebufferSize()[1]-n-1,r],e.viewportToNormalizedDisplay=(t,n,r,o)=>{let a=o.getViewportByReference();a=e.normalizedDisplayToDisplay(a[0],a[1],0);const i=t+a[0]+.5,s=n+a[1]+.5;return e.displayToNormalizedDisplay(i,s,r)},e.getComputedDevicePixelRatio=()=>t.size[0]/e.getContainerSize()[0],e.getContainerSize=()=>{Ht.vtkErrorMacro("not implemented")},e.getPixelData=(e,t,n,r)=>{Ht.vtkErrorMacro("not implemented")},e.createSelector=()=>{Ht.vtkErrorMacro("not implemented")}}(e,t)}var Kh={newInstance:Ht.newInstance(jh,"vtkRenderWindowViewNode"),extend:jh};const{vtkDebugMacro:$h,vtkErrorMacro:qh}=Ht,Xh={position:"absolute",top:0,left:0,width:"100%",height:"100%"},Yh=["activateTexture","deactivateTexture","disableCullFace","enableCullFace","get3DContext","getActiveFramebuffer","getContext","getDefaultTextureByteSize","getDefaultTextureInternalFormat","getDefaultToWebgl2","getGLInformations","getGraphicsMemoryInfo","getGraphicsResourceForObject","getHardwareMaximumLineWidth","getPixelData","getShaderCache","getTextureUnitForTexture","getTextureUnitManager","getWebgl2","makeCurrent","releaseGraphicsResources","registerGraphicsResourceUser","unregisterGraphicsResourceUser","restoreContext","setActiveFramebuffer","setContext","setDefaultToWebgl2","setGraphicsResourceForObject"];function Zh(e,t,n){const r=e.createFramebuffer(),o=e.createTexture();e.bindTexture(e.TEXTURE_2D,o),e.texImage2D(e.TEXTURE_2D,0,t,2,2,0,t,n,null),e.bindFramebuffer(e.FRAMEBUFFER,r),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,o,0);const a=e.checkFramebufferStatus(e.FRAMEBUFFER);return e.bindFramebuffer(e.FRAMEBUFFER,null),e.bindTexture(e.TEXTURE_2D,null),a===e.FRAMEBUFFER_COMPLETE}let Qh=0;const Jh=[];function ev(e){e.preventDefault()}function tv(e,t){let n;t.classHierarchy.push("vtkOpenGLRenderWindow"),e.getViewNodeFactory=()=>t.myFactory,t.canvas.addEventListener("webglcontextlost",ev,!1),t.canvas.addEventListener("webglcontextrestored",e.restoreContext,!1);const r=[0,0];let o;e.onModified((function(){t.renderable&&(t.size[0]===r[0]&&t.size[1]===r[1]||(r[0]=t.size[0],r[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]))),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.addMissingNodes(t.renderable.getChildRenderWindowsByReference()),e.removeUnusedNodes(),e.initialize(),t.children.forEach((t=>{t.setOpenGLRenderWindow?.(e)}))}},e.initialize=()=>{if(!t.initialized){if(t.rootOpenGLRenderWindow=e.getLastAncestorOfType("vtkOpenGLRenderWindow"),t.rootOpenGLRenderWindow)t.context2D=e.get2DContext();else{t.context=e.get3DContext(),e.resizeFromChildRenderWindows(),t.context&&(Qh++,Jh.forEach((e=>e(Qh)))),t.textureUnitManager=Wh.newInstance(),t.textureUnitManager.setContext(t.context),t.shaderCache.setContext(t.context);const n=t.context;n.blendFuncSeparate(n.SRC_ALPHA,n.ONE_MINUS_SRC_ALPHA,n.ONE,n.ONE_MINUS_SRC_ALPHA),n.depthFunc(n.LEQUAL),n.enable(n.BLEND)}t.initialized=!0}},e.makeCurrent=()=>{t.context.makeCurrent()},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&qh("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>{const e=t.activeFramebuffer?.getSize();return e||t.size},e.getPixelData=(e,n,r,o)=>{const a=new Uint8Array((r-e+1)*(o-n+1)*4);return t.context.readPixels(e,n,r-e+1,o-n+1,t.context.RGBA,t.context.UNSIGNED_BYTE,a),a},e.get3DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{preserveDrawingBuffer:!1,depth:!0,alpha:!0,powerPreference:"high-performance"},r=null;const o="undefined"!=typeof WebGL2RenderingContext;return t.webgl2=!1,t.defaultToWebgl2&&o&&(r=t.canvas.getContext("webgl2",e),r&&(t.webgl2=!0,$h("using webgl2"))),r||($h("using webgl1"),r=t.canvas.getContext("webgl",e)||t.canvas.getContext("experimental-webgl",e)),new Proxy(r,(n||(n=function(){const e=new Map,t={apply(t,n,r){return e.has(r[0])?e.get(r[0]):t.apply(n,r)}},n=Object.create(null);return n.getParameter=(e,n,r,o)=>new Proxy(o.bind(e),t),n.depthMask=(t,n,r,o)=>{return new Proxy(o.bind(t),(a=t.DEPTH_WRITEMASK,{apply(t,n,r){return e.set(a,r[0]),t.apply(n,r)}}));var a},{get(e,t,r){if("__getUnderlyingContext"===t)return()=>e;let o=Reflect.get(e,t,e);o instanceof Function&&(o=o.bind(e));const a=n[t];return a?a(e,t,r,o):o}}}()),n))},e.get2DContext=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.canvas.getContext("2d",e)},e.restoreContext=()=>{const t=Ah.newInstance();t.setCurrentOperation("Release"),t.traverse(e,null)},e.activateTexture=n=>{const r=t._textureResourceIds.get(n);if(void 0!==r)return void t.context.activeTexture(t.context.TEXTURE0+r);const o=e.getTextureUnitManager().allocate();o<0?qh("Hardware does not support the number of textures defined."):(t._textureResourceIds.set(n,o),t.context.activeTexture(t.context.TEXTURE0+o))},e.deactivateTexture=n=>{const r=t._textureResourceIds.get(n);void 0!==r&&(e.getTextureUnitManager().free(r),t._textureResourceIds.delete(n))},e.getTextureUnitForTexture=e=>{const n=t._textureResourceIds.get(e);return void 0!==n?n:-1},e.getDefaultTextureByteSize=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,r=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(t.webgl2)switch(e){case is.CHAR:case is.SIGNED_CHAR:case is.UNSIGNED_CHAR:return 1;case n:case r:case is.UNSIGNED_SHORT:case is.SHORT:case is.VOID:return 2;default:return 4}return 1},e.getDefaultTextureInternalFormat=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,o=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(t.webgl2)switch(e){case is.UNSIGNED_CHAR:switch(n){case 1:return t.context.R8;case 2:return t.context.RG8;case 3:return t.context.RGB8;default:return t.context.RGBA8}case r&&!o&&is.UNSIGNED_SHORT:switch(n){case 1:return r.R16_EXT;case 2:return r.RG16_EXT;case 3:return r.RGB16_EXT;default:return r.RGBA16_EXT}case r&&!o&&is.SHORT:switch(n){case 1:return r.R16_SNORM_EXT;case 2:return r.RG16_SNORM_EXT;case 3:return r.RGB16_SNORM_EXT;default:return r.RGBA16_SNORM_EXT}default:switch(n){case 1:return o?t.context.R16F:t.context.R32F;case 2:return o?t.context.RG16F:t.context.RG32F;case 3:return o?t.context.RGB16F:t.context.RGB32F;default:return o?t.context.RGBA16F:t.context.RGBA32F}}switch(n){case 1:return t.context.LUMINANCE;case 2:return t.context.LUMINANCE_ALPHA;case 3:return t.context.RGB;default:return t.context.RGBA}},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Xh,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t.rootOpenGLRenderWindow?.resizeFromChildRenderWindows(),t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.getHardwareMaximumLineWidth=()=>{if(null!=o)return o;const t=e.get3DContext(),n=t.getParameter(t.ALIASED_LINE_WIDTH_RANGE);return o=n[1],n[1]},e.getGLInformations=()=>{if(t._glInformation)return t._glInformation;const n=e.get3DContext(),r=n.getExtension("OES_texture_float"),o=n.getExtension("OES_texture_half_float"),a=n.getExtension("WEBGL_debug_renderer_info"),i=n.getExtension("WEBGL_draw_buffers"),s=n.getExtension("EXT_texture_filter_anisotropic")||n.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),l=[["Max Vertex Attributes","MAX_VERTEX_ATTRIBS",n.getParameter(n.MAX_VERTEX_ATTRIBS)],["Max Varying Vectors","MAX_VARYING_VECTORS",n.getParameter(n.MAX_VARYING_VECTORS)],["Max Vertex Uniform Vectors","MAX_VERTEX_UNIFORM_VECTORS",n.getParameter(n.MAX_VERTEX_UNIFORM_VECTORS)],["Max Fragment Uniform Vectors","MAX_FRAGMENT_UNIFORM_VECTORS",n.getParameter(n.MAX_FRAGMENT_UNIFORM_VECTORS)],["Max Fragment Texture Image Units","MAX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_TEXTURE_IMAGE_UNITS)],["Max Vertex Texture Image Units","MAX_VERTEX_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_VERTEX_TEXTURE_IMAGE_UNITS)],["Max Combined Texture Image Units","MAX_COMBINED_TEXTURE_IMAGE_UNITS",n.getParameter(n.MAX_COMBINED_TEXTURE_IMAGE_UNITS)],["Max 2D Texture Size","MAX_TEXTURE_SIZE",n.getParameter(n.MAX_TEXTURE_SIZE)],["Max Cube Texture Size","MAX_CUBE_MAP_TEXTURE_SIZE",n.getParameter(n.MAX_CUBE_MAP_TEXTURE_SIZE)],["Max Texture Anisotropy","MAX_TEXTURE_MAX_ANISOTROPY_EXT",s&&n.getParameter(s.MAX_TEXTURE_MAX_ANISOTROPY_EXT)],["Point Size Range","ALIASED_POINT_SIZE_RANGE",n.getParameter(n.ALIASED_POINT_SIZE_RANGE).join(" - ")],["Line Width Range","ALIASED_LINE_WIDTH_RANGE",n.getParameter(n.ALIASED_LINE_WIDTH_RANGE).join(" - ")],["Max Viewport Dimensions","MAX_VIEWPORT_DIMS",n.getParameter(n.MAX_VIEWPORT_DIMS).join(" - ")],["Max Renderbuffer Size","MAX_RENDERBUFFER_SIZE",n.getParameter(n.MAX_RENDERBUFFER_SIZE)],["Framebuffer Red Bits","RED_BITS",n.getParameter(n.RED_BITS)],["Framebuffer Green Bits","GREEN_BITS",n.getParameter(n.GREEN_BITS)],["Framebuffer Blue Bits","BLUE_BITS",n.getParameter(n.BLUE_BITS)],["Framebuffer Alpha Bits","ALPHA_BITS",n.getParameter(n.ALPHA_BITS)],["Framebuffer Depth Bits","DEPTH_BITS",n.getParameter(n.DEPTH_BITS)],["Framebuffer Stencil Bits","STENCIL_BITS",n.getParameter(n.STENCIL_BITS)],["Framebuffer Subpixel Bits","SUBPIXEL_BITS",n.getParameter(n.SUBPIXEL_BITS)],["MSAA Samples","SAMPLES",n.getParameter(n.SAMPLES)],["MSAA Sample Buffers","SAMPLE_BUFFERS",n.getParameter(n.SAMPLE_BUFFERS)],["Supported Formats for UByte Render Targets     ","UNSIGNED_BYTE RENDER TARGET FORMATS",[r&&Zh(n,n.RGBA,n.UNSIGNED_BYTE)?"RGBA":"",r&&Zh(n,n.RGB,n.UNSIGNED_BYTE)?"RGB":"",r&&Zh(n,n.LUMINANCE,n.UNSIGNED_BYTE)?"LUMINANCE":"",r&&Zh(n,n.ALPHA,n.UNSIGNED_BYTE)?"ALPHA":"",r&&Zh(n,n.LUMINANCE_ALPHA,n.UNSIGNED_BYTE)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Half Float Render Targets","HALF FLOAT RENDER TARGET FORMATS",[o&&Zh(n,n.RGBA,o.HALF_FLOAT_OES)?"RGBA":"",o&&Zh(n,n.RGB,o.HALF_FLOAT_OES)?"RGB":"",o&&Zh(n,n.LUMINANCE,o.HALF_FLOAT_OES)?"LUMINANCE":"",o&&Zh(n,n.ALPHA,o.HALF_FLOAT_OES)?"ALPHA":"",o&&Zh(n,n.LUMINANCE_ALPHA,o.HALF_FLOAT_OES)?"LUMINANCE_ALPHA":""].join(" ")],["Supported Formats for Full Float Render Targets","FLOAT RENDER TARGET FORMATS",[r&&Zh(n,n.RGBA,n.FLOAT)?"RGBA":"",r&&Zh(n,n.RGB,n.FLOAT)?"RGB":"",r&&Zh(n,n.LUMINANCE,n.FLOAT)?"LUMINANCE":"",r&&Zh(n,n.ALPHA,n.FLOAT)?"ALPHA":"",r&&Zh(n,n.LUMINANCE_ALPHA,n.FLOAT)?"LUMINANCE_ALPHA":""].join(" ")],["Max Multiple Render Targets Buffers","MAX_DRAW_BUFFERS_WEBGL",i?n.getParameter(i.MAX_DRAW_BUFFERS_WEBGL):0],["High Float Precision in Vertex Shader","HIGH_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Vertex Shader","MEDIUM_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Vertex Shader","LOW_FLOAT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Float Precision in Fragment Shader","HIGH_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_FLOAT).rangeMax,"</sup>)"].join("")],["Medium Float Precision in Fragment Shader","MEDIUM_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_FLOAT).rangeMax,"</sup>)"].join("")],["Low Float Precision in Fragment Shader","LOW_FLOAT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_FLOAT).rangeMax,"</sup>)"].join("")],["High Int Precision in Vertex Shader","HIGH_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Vertex Shader","MEDIUM_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Vertex Shader","LOW_INT VERTEX_SHADER",[n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.VERTEX_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["High Int Precision in Fragment Shader","HIGH_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.HIGH_INT).rangeMax,"</sup>)"].join("")],["Medium Int Precision in Fragment Shader","MEDIUM_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.MEDIUM_INT).rangeMax,"</sup>)"].join("")],["Low Int Precision in Fragment Shader","LOW_INT FRAGMENT_SHADER",[n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).precision," (-2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMin,"</sup> - 2<sup>",n.getShaderPrecisionFormat(n.FRAGMENT_SHADER,n.LOW_INT).rangeMax,"</sup>)"].join("")],["Supported Extensions","EXTENSIONS",n.getSupportedExtensions().join("<br/>\t\t\t\t\t    ")],["WebGL Renderer","RENDERER",n.getParameter(n.RENDERER)],["WebGL Vendor","VENDOR",n.getParameter(n.VENDOR)],["WebGL Version","VERSION",n.getParameter(n.VERSION)],["Shading Language Version","SHADING_LANGUAGE_VERSION",n.getParameter(n.SHADING_LANGUAGE_VERSION)],["Unmasked Renderer","UNMASKED_RENDERER",a&&n.getParameter(a.UNMASKED_RENDERER_WEBGL)],["Unmasked Vendor","UNMASKED_VENDOR",a&&n.getParameter(a.UNMASKED_VENDOR_WEBGL)],["WebGL Version","WEBGL_VERSION",t.webgl2?2:1]],c={};for(;l.length;){const[e,t,n]=l.pop();t&&(c[t]={label:e,value:n})}return t._glInformation=c,c},e.traverseAllPasses=()=>{if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);e.copyParentContent(),t.notifyStartCaptureImage&&function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height,o.drawImage(t.canvas,0,0);const a=t.canvas.getBoundingClientRect();t.renderable.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),i=r.x-a.x,s=r.y-a.y;o.drawImage(n,i,s)}}}))}));const i=r.toDataURL(n);r.remove(),e.invokeImageReady(i)}();const n=t.renderable.getChildRenderWindowsByReference();for(let t=0;t<n.length;++t)e.getViewNodeFor(n[t])?.traverseAllPasses()},e.copyParentContent=()=>{const e=t.rootOpenGLRenderWindow;if(!e||!t.context2D||t.children.some((e=>!!e.getSelector?.())))return;const n=e.getCanvas(),r=t.canvas;t.context2D.drawImage(n,0,n.height-r.height,r.width,r.height,0,0,r.width,r.height)},e.resizeFromChildRenderWindows=()=>{const n=t.renderable.getChildRenderWindowsByReference();if(n.length>0){const t=[0,0];for(let r=0;r<n.length;++r){const o=e.getViewNodeFor(n[r])?.getSize();o&&(t[0]=o[0]>t[0]?o[0]:t[0],t[1]=o[1]>t[1]?o[1]:t[1])}e.setSize(...t)}},e.disableCullFace=()=>{t.cullFaceEnabled&&(t.context.disable(t.context.CULL_FACE),t.cullFaceEnabled=!1)},e.enableCullFace=()=>{t.cullFaceEnabled||(t.context.enable(t.context.CULL_FACE),t.cullFaceEnabled=!0)},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.createSelector=()=>{const t=dp.newInstance();return t.setOpenGLRenderWindow(e),t},e.delete=Ht.chain((()=>{t.context&&(Qh--,Jh.forEach((e=>e(Qh)))),e.setContainer(),e.setViewStream()}),(function(){t.canvas.removeEventListener("webglcontextlost",ev),t.canvas.removeEventListener("webglcontextrestored",e.restoreContext)}),e.delete),e.setActiveFramebuffer=e=>{t.activeFramebuffer=e};const a=e.setSize;e.setSize=(t,n)=>{const r=a(t,n);return r&&e.invokeWindowResizeEvent({width:t,height:n}),r},e.registerGraphicsResourceUser=(n,r)=>{t._graphicsResources.has(n)||e.setGraphicsResourceForObject(n,null,null);const o=t._graphicsResources.get(n);o?.users.add(r)},e.unregisterGraphicsResourceUser=(n,r)=>{const o=t._graphicsResources.get(n);o&&(o.users.delete(r),o.users.size||(o.oglObject?.releaseGraphicsResources(e),t._graphicsResources.delete(n)))},e.getGraphicsResourceForObject=e=>t._graphicsResources.get(e),e.setGraphicsResourceForObject=(n,r,o)=>{if(!n)return;const a=t._graphicsResources.get(n);a?.oglObject?.releaseGraphicsResources(e),t._graphicsResources.set(n,{coreObject:n,oglObject:r,hash:o,users:a?.users??new Set})},e.getGraphicsMemoryInfo=()=>{let e=0;return t._graphicsResources.forEach((t=>{let{oglObject:n}=t;e+=n.getAllocatedGPUMemoryInBytes()})),e},e.releaseGraphicsResources=()=>{null!==t.shaderCache&&t.shaderCache.releaseGraphicsResources(e),t._graphicsResources.forEach((t=>{let{oglObject:n}=t;n.releaseGraphicsResources(e)})),t._graphicsResources.clear(),null!==t.textureUnitManager&&t.textureUnitManager.freeAll(),t.renderable.getRenderersByReference().forEach((t=>{const n=e.getViewNodeFor(t);n?.releaseGraphicsResources()}))};const i={...e};Yh.forEach((n=>{e[n]=function(){return t.rootOpenGLRenderWindow?t.rootOpenGLRenderWindow[n](...arguments):i[n](...arguments)}}))}const nv={cullFaceEnabled:!1,shaderCache:null,initialized:!1,context:null,context2D:null,canvas:null,cursorVisibility:!0,cursor:"pointer",textureUnitManager:null,textureResourceIds:null,containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,webgl2:!1,defaultToWebgl2:!0,activeFramebuffer:null,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1};const rv=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,nv,n),Kh.extend(e,t,n),t.canvas||(t.canvas=document.createElement("canvas"),t.canvas.style.width="100%"),t.selector||(t.selector=dp.newInstance(),t.selector.setOpenGLRenderWindow(e)),t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",t._textureResourceIds=new Map,t._graphicsResources=new Map,t._glInformation=null,t.myFactory=rn.newInstance(),t.shaderCache=Gh.newInstance(),t.shaderCache.setOpenGLRenderWindow(e),t.renderPasses[0]=Dh.newInstance(),Ht.get(e,t,["shaderCache","textureUnitManager","webgl2","useBackgroundImage","activeFramebuffer","rootOpenGLRenderWindow"]),Ht.setGet(e,t,["initialized","context","context2D","canvas","renderPasses","notifyStartCaptureImage","defaultToWebgl2","cursor","useOffScreen"]),Ht.setGetArray(e,t,["size"],2),Ht.event(e,t,"imageReady"),Ht.event(e,t,"windowResizeEvent"),tv(e,t)}),"vtkOpenGLRenderWindow");Nm("WebGL",rv),en("vtkRenderWindow",rv);const ov={device:null,handle:null};function av(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ov,n),Ht.obj(e,t),Ht.get(e,t,["lastCameraMTime"]),Ht.setGet(e,t,["device","handle"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderModule"),e.initialize=(e,n)=>{t.device=e,t.handle=t.device.getHandle().createShaderModule({code:n.getCode()})}}(e,t)}var iv={newInstance:Ht.newInstance(av,"vtkWebGPUShaderModule"),extend:av};const sv={shaderModules:null,device:null,window:null};function lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sv,n),t._shaderModules=new Map,Ht.obj(e,t),Ht.setGet(e,t,["device","window"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderCache"),e.getShaderModule=e=>{const n=e.getType(),r=e.getHash(),o=t._shaderModules.keys();for(let e=0;e<o.length;e++){const a=o[e];if(a.getHash()===r&&a.getType()===n)return t._shaderModules.get(a)}const a=iv.newInstance();return a.initialize(t.device,e),t._shaderModules.set(e,a),a}}(e,t)}var cv={newInstance:Ht.newInstance(lv,"vtkWebGPUShaderCache"),extend:lv,substitute:function(e,t,n){let r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const o=Array.isArray(n)?n.join("\n"):n;let a=!1;-1!==e.search(t)&&(a=!0);let i="";r&&(i="g");const s=new RegExp(t,i);return{replace:a,result:e.replace(s,o)}}};const uv={device:null,handle:null,label:null};function dv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,uv,n),Ht.obj(e,t),t.bindables=[],t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),Ht.get(e,t,["bindGroupTime","handle","sizeInBytes","usage"]),Ht.setGet(e,t,["label","device","arrayInformation"]),function(e,t){t.classHierarchy.push("vtkWebGPUBindGroup"),e.setBindables=n=>{if(t.bindables.length===n.length){let e=!0;for(let r=0;r<t.bindables.length;r++)t.bindables[r]!==n[r]&&(e=!1);if(e)return}t.bindables=n,e.modified()},e.getBindGroupLayout=e=>{const n=[];for(let e=0;e<t.bindables.length;e++){const r=t.bindables[e].getBindGroupLayoutEntry();r.binding=e,n.push(r)}return e.getBindGroupLayout({entries:n})},e.getBindGroup=n=>{let r=e.getMTime();for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupTime().getMTime();r=n>r?n:r}if(r<t.bindGroupTime.getMTime())return t.bindGroup;const o=[];for(let e=0;e<t.bindables.length;e++){const n=t.bindables[e].getBindGroupEntry();n.binding=e,o.push(n)}return t.bindGroup=n.getHandle().createBindGroup({layout:e.getBindGroupLayout(n),entries:o,label:t.label}),t.bindGroupTime.modified(),t.bindGroup},e.getShaderCode=e=>{const n=[],r=e.getBindGroupLayoutCount(t.label);for(let e=0;e<t.bindables.length;e++)n.push(t.bindables[e].getShaderCode(e,r));return n.join("\n")}}(e,t)}var pv={newInstance:Ht.newInstance(dv),extend:dv};const fv={handle:null,layouts:null,renderEncoder:null,shaderDescriptions:null,vertexState:null,topology:null,pipelineDescription:null};function gv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fv,n),vt(e,t),t.layouts=[],t.shaderDescriptions=[],yt(e,t,["handle","pipelineDescription"]),St(e,t,["device","renderEncoder","topology","vertexState"]),function(e,t){t.classHierarchy.push("vtkWebGPUPipeline"),e.getShaderDescriptions=()=>t.shaderDescriptions,e.initialize=(e,n)=>{t.pipelineDescription=t.renderEncoder.getPipelineSettings(),t.pipelineDescription.primitive.topology=t.topology,t.pipelineDescription.vertex=t.vertexState,t.pipelineDescription.label=n;const r=[];for(let e=0;e<t.layouts.length;e++)r.push(t.layouts[e].layout);t.pipelineLayout=e.getHandle().createPipelineLayout({bindGroupLayouts:r}),t.pipelineDescription.layout=t.pipelineLayout;for(let n=0;n<t.shaderDescriptions.length;n++){const r=t.shaderDescriptions[n],o=e.getShaderModule(r);"vertex"===r.getType()&&(t.pipelineDescription.vertex.module=o.getHandle(),t.pipelineDescription.vertex.entryPoint="main"),"fragment"===r.getType()&&(t.pipelineDescription.fragment.module=o.getHandle(),t.pipelineDescription.fragment.entryPoint="main")}t.handle=e.getHandle().createRenderPipeline(t.pipelineDescription)},e.getShaderDescription=e=>{for(let n=0;n<t.shaderDescriptions.length;n++)if(t.shaderDescriptions[n].getType()===e)return t.shaderDescriptions[n];return null},e.addBindGroupLayout=e=>{e&&t.layouts.push({layout:e.getBindGroupLayout(t.device),label:e.getLabel()})},e.getBindGroupLayout=e=>t.layouts[e].layout,e.getBindGroupLayoutCount=e=>{for(let n=0;n<t.layouts.length;n++)if(t.layouts[n].label===e)return n;return 0},e.bindVertexInput=(e,t)=>{t.bindBuffers(e)}}(e,t)}var mv={newInstance:Et(gv,"vtkWebGPUPipeline"),extend:gv};const hv={type:null,hash:null,code:null,outputNames:null,outputTypes:null};function vv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,hv,n),t.outputNames=[],t.outputTypes=[],t.outputInterpolations=[],t.builtinOutputNames=[],t.builtinOutputTypes=[],t.builtinInputNames=[],t.builtinInputTypes=[],Ht.obj(e,t),Ht.setGet(e,t,["type","hash","code"]),Ht.getArray(e,t,["outputTypes","outputNames","outputInterpolations"]),function(e,t){t.classHierarchy.push("vtkWebGPUShaderDescription"),e.hasOutput=e=>t.outputNames.includes(e),e.addOutput=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;t.outputTypes.push(e),t.outputNames.push(n),t.outputInterpolations.push(r)},e.addBuiltinOutput=(e,n)=>{t.builtinOutputTypes.push(e),t.builtinOutputNames.push(n)},e.addBuiltinInput=(e,n)=>{t.builtinInputTypes.push(e),t.builtinInputNames.push(n)},e.replaceShaderCode=(e,n)=>{const r=[];let o=[];if(n&&r.push(n.getShaderCode()),e||t.builtinInputNames.length){const n=[];if(n.push(`struct ${t.type}Input\n{`),e){const t=e.getOutputNamesByReference(),r=e.getOutputTypesByReference(),o=e.getOutputInterpolationsByReference();for(let e=0;e<t.length;e++)void 0!==o[e]?n.push(`  @location(${e}) @interpolate(${o[e]}) ${t[e]} : ${r[e]},`):n.push(`  @location(${e}) ${t[e]} : ${r[e]},`)}for(let e=0;e<t.builtinInputNames.length;e++)n.push(`  ${t.builtinInputNames[e]} : ${t.builtinInputTypes[e]},`);n.length>1&&(n.push("};"),o=n,r[r.length-1]+=",",r.push(`input: ${t.type}Input`))}if(r.length&&(t.code=cv.substitute(t.code,"//VTK::IOStructs::Input",r).result),t.outputNames.length+t.builtinOutputNames.length){const e=[`struct ${t.type}Output\n{`];for(let n=0;n<t.outputNames.length;n++)void 0!==t.outputInterpolations[n]?e.push(`  @location(${n}) @interpolate(${t.outputInterpolations[n]}) ${t.outputNames[n]} : ${t.outputTypes[n]},`):e.push(`  @location(${n}) ${t.outputNames[n]} : ${t.outputTypes[n]},`);for(let n=0;n<t.builtinOutputNames.length;n++)e.push(`  ${t.builtinOutputNames[n]} : ${t.builtinOutputTypes[n]},`);e.push("};"),o=o.concat(e),t.code=cv.substitute(t.code,"//VTK::IOStructs::Output",[`-> ${t.type}Output`]).result}t.code=cv.substitute(t.code,"//VTK::IOStructs::Dec",o).result}}(e,t)}var Tv={newInstance:Ht.newInstance(vv,"vtkWebGPUShaderDescription"),extend:vv};const yv={r8unorm:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"float"},r8snorm:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"float"},r8uint:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},r8sint:{numComponents:1,nativeType:Int8Array,stride:1,elementSize:1,sampleType:"sint"},r16uint:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"uint"},r16sint:{numComponents:1,nativeType:Int16Array,stride:2,elementSize:2,sampleType:"sint"},r16float:{numComponents:1,nativeType:Float32Array,stride:2,elementSize:2,sampleType:"float"},rg8unorm:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"float"},rg8snorm:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"float"},rg8uint:{numComponents:2,nativeType:Uint8Array,stride:2,elementSize:1,sampleType:"uint"},rg8sint:{numComponents:2,nativeType:Int8Array,stride:2,elementSize:1,sampleType:"sint"},r32uint:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:4,sampleType:"uint"},r32sint:{numComponents:1,nativeType:Int32Array,stride:4,elementSize:4,sampleType:"sint"},r32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"unfilterable-float"},rg16uint:{numComponents:2,nativeType:Uint16Array,stride:4,elementSize:2,sampleType:"uint"},rg16sint:{numComponents:2,nativeType:Int16Array,stride:4,elementSize:2,sampleType:"sint"},rg16float:{numComponents:2,nativeType:Float32Array,stride:4,elementSize:2,sampleType:"float"},rgba8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"rgba8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgba8snorm:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"float"},rgba8uint:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"uint"},rgba8sint:{numComponents:4,nativeType:Int8Array,stride:4,elementSize:1,sampleType:"sint"},bgra8unorm:{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},"bgra8unorm-srgb":{numComponents:4,nativeType:Uint8Array,stride:4,elementSize:1,sampleType:"float"},rgb9e5ufloat:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rgb10a2unorm:{numComponents:4,nativeType:Uint32Array,stride:4,sampleType:"float"},rg11b10ufloat:{numComponents:4,nativeType:Float32Array,stride:4,sampleType:"float"},rg32uint:{numComponents:2,nativeType:Uint32Array,stride:8,elementSize:4,sampleType:"uint"},rg32sint:{numComponents:2,nativeType:Int32Array,stride:8,elementSize:4,sampleType:"sint"},rg32float:{numComponents:2,nativeType:Float32Array,stride:8,elementSize:4,sampleType:"unfilterable-float"},rgba16uint:{numComponents:4,nativeType:Uint16Array,stride:8,elementSize:2,sampleType:"uint"},rgba16sint:{numComponents:4,nativeType:Int16Array,stride:8,elementSize:2,sampleType:"sint"},rgba16float:{numComponents:4,nativeType:Float32Array,stride:8,elementSize:2,sampleType:"float"},rgba32uint:{numComponents:4,nativeType:Uint32Array,stride:16,elementSize:4,sampleType:"uint"},rgba32sint:{numComponents:4,nativeType:Int32Array,stride:16,elementSize:4,sampleType:"sint"},rgba32float:{numComponents:4,nativeType:Float32Array,stride:16,elementSize:4,sampleType:"unfilterable-float"},stencil8:{numComponents:1,nativeType:Uint8Array,stride:1,elementSize:1,sampleType:"uint"},depth16unorm:{numComponents:1,nativeType:Uint16Array,stride:2,elementSize:2,sampleType:"depth"},depth24plus:{numComponents:1,nativeType:Uint32Array,stride:4,elementSize:3,sampleType:"depth"},"depth24plus-stencil8":{numComponents:2,nativeType:Uint32Array,stride:4,sampleType:"mixed"},depth32float:{numComponents:1,nativeType:Float32Array,stride:4,elementSize:4,sampleType:"depth"}};var bv=function(e){return!e||e.length<6?0:e in yv==1?yv[e]:(tt(`unknown format ${e}`),null)},xv=function(e){if(!e||e.length<5)return 0;let t=1;"x"===e[e.length-2]&&(t=Number(e[e.length-1]));const n=1===t?e.length-1:e.length-3,r=Number(e[n]);return Number.isNaN(r)?(tt(`unknown format ${e}`),0):t*(5-r/2)},Cv=function(e){if(!e||e.length<5)return 0;let t;if("f"===e[0])t="Float";else if("s"===e[0])t="Int";else{if("u"!==e[0])return void tt(`unknown format ${e}`);t="Uint"}const n=e.split("x")[0],r=Number(n[n.length-1]);if(!Number.isNaN(r))return t+=8*(5-r/2),t+="Array",t;tt(`unknown format ${e}`)},Sv=function(e){let t;if("f"===e[0]||"n"===e[1])t="f32";else if("s"===e[0]&&"i"===e[1])t="i32";else{if("u"!==e[0]||"i"!==e[1])return void tt(`unknown format ${e}`);t="u32"}let n=1;return"x"===e[e.length-2]&&(n=Number(e[e.length-1])),4===n?`vec4<${t}>`:3===n?`vec3<${t}>`:2===n?`vec2<${t}>`:t},Av=function(e){if(!e)return 0;let t=1;return"vec"===e.substring(0,3)?t=Number(e[3]):"mat"===e.substring(0,3)&&(t=e[3]*e[5]),4*t},Iv=function(e){if(e)return e.includes("f32")?"Float32Array":e.includes("i32")?"Int32Array":e.includes("u32")?"Uint32Array":void tt(`unknown format ${e}`)};function wv(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;++n)if(!t.includes(e[n]))return!1;return!0}const Ov={inputs:null,bindingDescriptions:!1,attributeDescriptions:null,indexBuffer:null};function Pv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ov,n),vt(e,t),t.bindingDescriptions=[],t.attributeDescriptions=[],t.inputs=[],St(e,t,["created","device","handle","indexBuffer"]),function(e,t){t.classHierarchy.push("vtkWebGPUVertexInput"),e.addBuffer=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"vertex",o=n;Array.isArray(o)||(o=[o]);for(let n=0;n<t.inputs.length;n++)if(wv(t.inputs[n].names,o)){if(t.inputs[n].buffer===e)return;return void(t.inputs[n].buffer=e)}t.inputs.push({buffer:e,stepMode:r,names:o}),t.inputs=t.inputs.sort(((e,t)=>e.names[0]<t.names[0]?-1:e.names[0]>t.names[0]?1:0))},e.removeBufferIfPresent=e=>{for(let n=0;n<t.inputs.length;n++)t.inputs[n].names.includes(e)&&t.inputs.splice(n,1)},e.getBuffer=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer;return null},e.hasAttribute=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return!0;return!1},e.getAttributeTime=e=>{for(let n=0;n<t.inputs.length;n++)if(t.inputs[n].names.includes(e))return t.inputs[n].buffer.getSourceTime();return 0},e.getShaderCode=()=>{let e="",n=0;for(let r=0;r<t.inputs.length;r++)for(let o=0;o<t.inputs[r].names.length;o++){const a=t.inputs[r].buffer.getArrayInformation()[o],i=Sv(a.format);n>0&&(e+=",\n"),e=`${e}  @location(${n}) ${t.inputs[r].names[o]} : ${i}`,n++}return e},e.getVertexInputInformation=()=>{const e={};if(t.inputs.length){const n=[];let r=0;for(let e=0;e<t.inputs.length;e++){const o=t.inputs[e].buffer,a={arrayStride:o.getStrideInBytes(),stepMode:t.inputs[e].stepMode,attributes:[]},i=o.getArrayInformation();for(let n=0;n<t.inputs[e].names.length;n++)a.attributes.push({shaderLocation:r,offset:i[n].offset,format:i[n].format}),r++;n.push(a)}e.buffers=n}return e},e.bindBuffers=e=>{for(let n=0;n<t.inputs.length;n++)e.setVertexBuffer(n,t.inputs[n].buffer.getHandle());t.indexBuffer&&e.setIndexBuffer(t.indexBuffer.getHandle(),t.indexBuffer.getArrayInformation()[0].format)},e.getReady=()=>{},e.releaseGraphicsResources=()=>{t.created&&(t.inputs=[],t.bindingDescriptions=[],t.attributeDescriptions=[])}}(e,t)}var Rv={newInstance:Et(Pv,"vtkWebGPUVertexInput"),extend:Pv};const Mv={additionalBindables:void 0,bindGroup:null,device:null,fragmentShaderTemplate:null,numberOfInstances:1,numberOfVertices:0,pipelineHash:null,shaderReplacements:null,SSBO:null,textureViews:null,topology:"triangle-list",UBO:null,vertexShaderTemplate:null,WebGPURenderer:null};function Ev(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Mv,n),Xt.extend(e,t,n),t.textureViews=[],t.vertexInput=Rv.newInstance(),t.bindGroup=pv.newInstance({label:"mapperBG"}),t.additionalBindables=[],t.fragmentShaderTemplate=t.fragmentShaderTemplate||"\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::Light::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  // var computedColor:vec4<f32> = vec4<f32>(1.0,0.5,0.5,1.0);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n",t.vertexShaderTemplate=t.vertexShaderTemplate||"\n//VTK::Renderer::Dec\n\n//VTK::Color::Dec\n\n//VTK::Normal::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Select::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@vertex\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : vertexOutput;\n\n  // var vertex: vec4<f32> = vertexBC;\n\n  //VTK::Color::Impl\n\n  //VTK::Normal::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::Select::Impl\n\n  //VTK::Position::Impl\n\n  return output;\n}\n",t.shaderReplacements=new Map,Ht.get(e,t,["pipeline","vertexInput"]),Ht.setGet(e,t,["additionalBindables","device","fragmentShaderTemplate","interpolate","numberOfInstances","numberOfVertices","pipelineHash","shaderReplacements","SSBO","textureViews","topology","UBO","vertexShaderTemplate","WebGPURenderer"]),function(e,t){t.classHierarchy.push("vtkWebGPUSimpleMapper"),e.generateShaderDescriptions=(n,r,o)=>{const a=Tv.newInstance({type:"vertex",hash:n,code:t.vertexShaderTemplate}),i=Tv.newInstance({type:"fragment",hash:n,code:t.fragmentShaderTemplate}),s=r.getShaderDescriptions();s.push(a),s.push(i);const l=t.vertexShaderTemplate+t.fragmentShaderTemplate,c=new RegExp("//VTK::[^:]*::","g"),u=l.match(c).filter(((e,t,n)=>n.indexOf(e)===t)),d=u.map((e=>`replaceShader${e.substring(7,e.length-2)}`));for(let e=0;e<d.length;e++){const a=d[e];"replaceShaderIOStructs"!==a&&t.shaderReplacements.has(a)&&t.shaderReplacements.get(a)(n,r,o)}e.replaceShaderIOStructs(n,r,o)},e.replaceShaderIOStructs=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.replaceShaderCode(null,n),t.getShaderDescription("fragment").replaceShaderCode(r)},e.replaceShaderRenderEncoder=(e,n,r)=>{t.renderEncoder.replaceShaderCode(n)},t.shaderReplacements.set("replaceShaderRenderEncoder",e.replaceShaderRenderEncoder),e.replaceShaderRenderer=(e,n,r)=>{if(!t.WebGPURenderer)return;const o=t.WebGPURenderer.getBindGroup().getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=cv.substitute(i,"//VTK::Renderer::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");i=s.getCode(),i=cv.substitute(i,"//VTK::Renderer::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderRenderer",e.replaceShaderRenderer),e.replaceShaderMapper=(e,n,r)=>{const o=t.bindGroup.getShaderCode(n),a=n.getShaderDescription("vertex");let i=a.getCode();i=cv.substitute(i,"//VTK::Mapper::Dec",[o]).result,a.setCode(i);const s=n.getShaderDescription("fragment");s.addBuiltinInput("bool","@builtin(front_facing) frontFacing"),i=s.getCode(),i=cv.substitute(i,"//VTK::Mapper::Dec",[o]).result,s.setCode(i)},t.shaderReplacements.set("replaceShaderMapper",e.replaceShaderMapper),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=cv.substitute(o,"//VTK::Position::Impl",["    output.Position = rendererUBO.SCPCMatrix*vertexBC;"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderTCoord=(e,t,n)=>{t.getShaderDescription("vertex").addOutput("vec2<f32>","tcoordVS")},t.shaderReplacements.set("replaceShaderTCoord",e.replaceShaderTCoord),e.addTextureView=e=>{t.textureViews.includes(e)||t.textureViews.push(e)},e.prepareToDraw=n=>{t.renderEncoder=n,e.updateInput(),e.updateBuffers(),e.updateBindings(),e.updatePipeline()},e.updateInput=()=>{},e.updateBuffers=()=>{},e.updateBindings=()=>{t.bindGroup.setBindables(e.getBindables())},e.computePipelineHash=()=>{},e.registerDrawCallback=n=>{n.registerDrawCallback(t.pipeline,e.draw)},e.prepareAndDraw=n=>{e.prepareToDraw(n),n.setPipeline(t.pipeline),e.draw(n)},e.draw=e=>{const n=e.getBoundPipeline();e.activateBindGroup(t.bindGroup),t.WebGPURenderer&&t.WebGPURenderer.bindUBO(e),n.bindVertexInput(e,t.vertexInput);const r=t.vertexInput.getIndexBuffer();r?e.drawIndexed(r.getIndexCount(),t.numberOfInstances,0,0,0):e.draw(t.numberOfVertices,t.numberOfInstances,0,0)},e.getBindables=()=>{const e=[...t.additionalBindables];t.UBO&&e.push(t.UBO),t.SSBO&&e.push(t.SSBO);for(let n=0;n<t.textureViews.length;n++){e.push(t.textureViews[n]);const r=t.textureViews[n].getSampler();r&&e.push(r)}return e},e.updatePipeline=()=>{e.computePipelineHash(),t.pipeline=t.device.getPipeline(t.pipelineHash),t.pipeline||(t.pipeline=mv.newInstance(),t.pipeline.setDevice(t.device),t.WebGPURenderer&&t.pipeline.addBindGroupLayout(t.WebGPURenderer.getBindGroup()),t.pipeline.addBindGroupLayout(t.bindGroup),e.generateShaderDescriptions(t.pipelineHash,t.pipeline,t.vertexInput),t.pipeline.setTopology(t.topology),t.pipeline.setRenderEncoder(t.renderEncoder),t.pipeline.setVertexState(t.vertexInput.getVertexInputInformation()),t.device.createPipeline(t.pipelineHash,t.pipeline))}}(e,t)}var Vv={newInstance:Ht.newInstance(Ev,"vtkWebGPUSimpleMapper"),extend:Ev};const Dv={};function Lv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dv,n),Vv.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkWebGPUFullScreenQuad"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position"),r.addOutput("vec4<f32>","vertexVC");let o=r.getCode();o=cv.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);","output.vertexVC = vec4<f32>(vertexBC, 1);"]).result,r.setCode(o)},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.updateBuffers=()=>{const e=t.device.getBufferManager().getFullScreenQuadBuffer();t.vertexInput.addBuffer(e,["vertexBC"]),t.numberOfVertices=6}}(e,t)}var Bv={newInstance:Ht.newInstance(Lv,"vtkWebGPUFullScreenQuad"),extend:Lv};const Nv=["setBindGroup","setIndexBuffer","setVertexBuffer","draw","drawIndexed"],Fv={description:null,handle:null,boundPipeline:null,pipelineHash:null,pipelineSettings:null,replaceShaderCodeFunction:null,depthTextureView:null,label:null};function _v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Fv,n),vt(e,t),t.description={colorAttachments:[{view:void 0,loadOp:"load",storeOp:"store"}],depthStencilAttachment:{view:void 0,depthLoadOp:"clear",depthClearValue:0,depthStoreOp:"store"}},t.replaceShaderCodeFunction=e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = computedColor;"]).result,t.setCode(n)},t.pipelineSettings={primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater-equal",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}},t.colorTextureViews=[],yt(e,t,["boundPipeline","colorTextureViews"]),St(e,t,["depthTextureView","description","handle","label","pipelineHash","pipelineSettings","replaceShaderCodeFunction"]),function(e,t){t.classHierarchy.push("vtkWebGPURenderEncoder"),e.begin=e=>{t.drawCallbacks=[],t.handle=e.beginRenderPass(t.description),t.label&&t.handle.pushDebugGroup(t.label)},e.end=()=>{for(let n=0;n<t.drawCallbacks.length;n++){const r=t.drawCallbacks[n],o=r.pipeline;e.setPipeline(o);for(let t=0;t<r.callbacks.length;t++)r.callbacks[t](e)}t.label&&t.handle.popDebugGroup(),t.handle.end(),t.boundPipeline=null},e.setPipeline=e=>{if(t.boundPipeline===e)return;t.handle.setPipeline(e.getHandle());const n=e.getPipelineDescription();if(t.colorTextureViews.length!==n.fragment.targets.length)console.log(`mismatched attachment counts on pipeline ${n.fragment.targets.length} while encoder has ${t.colorTextureViews.length}`),console.trace();else for(let e=0;e<t.colorTextureViews.length;e++){const r=t.colorTextureViews[e].getTexture()?.getFormat();r&&r!==n.fragment.targets[e].format&&(console.log(`mismatched attachments for attachment ${e} on pipeline ${n.fragment.targets[e].format} while encoder has ${r}`),console.trace())}if(!t.depthTextureView!=!("depthStencil"in n))console.log("mismatched depth attachments"),console.trace();else if(t.depthTextureView){const e=t.depthTextureView.getTexture()?.getFormat();e&&e!==n.depthStencil.format&&(console.log(`mismatched depth attachments on pipeline ${n.depthStencil.format} while encoder has ${e}`),console.trace())}t.boundPipeline=e},e.replaceShaderCode=e=>{t.replaceShaderCodeFunction(e)},e.setColorTextureView=(e,n)=>{t.colorTextureViews[e]!==n&&(t.colorTextureViews[e]=n)},e.activateBindGroup=e=>{const n=t.boundPipeline.getDevice(),r=t.boundPipeline.getBindGroupLayoutCount(e.getLabel());t.handle.setBindGroup(r,e.getBindGroup(n));const o=n.getBindGroupLayoutDescription(e.getBindGroupLayout(n)),a=n.getBindGroupLayoutDescription(t.boundPipeline.getBindGroupLayout(r));o!==a&&(console.log(`renderEncoder ${t.pipelineHash} mismatched bind group layouts bind group has\n${o}\n versus pipeline\n${a}\n`),console.trace())},e.attachTextureViews=()=>{for(let e=0;e<t.colorTextureViews.length;e++)t.description.colorAttachments[e]?t.description.colorAttachments[e].view=t.colorTextureViews[e].getHandle():t.description.colorAttachments[e]={view:t.colorTextureViews[e].getHandle()};t.depthTextureView&&(t.description.depthStencilAttachment.view=t.depthTextureView.getHandle())},e.registerDrawCallback=(e,n)=>{for(let r=0;r<t.drawCallbacks.length;r++)if(t.drawCallbacks[r].pipeline===e)return void t.drawCallbacks[r].callbacks.push(n);t.drawCallbacks.push({pipeline:e,callbacks:[n]})};for(let n=0;n<Nv.length;n++)e[Nv[n]]=function(){return t.handle[Nv[n]](...arguments)}}(e,t)}var Gv={newInstance:Et(_v,"vtkWebGPURenderEncoder"),extend:_v};const kv={device:null,handle:null,label:null,options:null};function Uv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kv,n),Ht.obj(e,t),t.options={},t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,sampler:{}},t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),Ht.get(e,t,["bindGroupTime","handle","options"]),Ht.setGet(e,t,["bindGroupLayoutEntry","device","label"]),function(e,t){t.classHierarchy.push("vtkWebGPUSampler"),e.create=function(e){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};t.device=e,t.options.addressModeU=n.addressModeU?n.addressModeU:"clamp-to-edge",t.options.addressModeV=n.addressModeV?n.addressModeV:"clamp-to-edge",t.options.addressModeW=n.addressModeW?n.addressModeW:"clamp-to-edge",t.options.magFilter=n.magFilter?n.magFilter:"nearest",t.options.minFilter=n.minFilter?n.minFilter:"nearest",t.options.mipmapFilter=n.mipmapFilter?n.mipmapFilter:"nearest",t.options.label=t.label,t.handle=t.device.getHandle().createSampler(t.options),t.bindGroupTime.modified()},e.getShaderCode=(e,n)=>`@binding(${e}) @group(${n}) var ${t.label}: sampler;`,e.getBindGroupEntry=()=>({resource:t.handle})}(e,t)}var zv={newInstance:Ht.newInstance(Uv),extend:Uv};const Wv={texture:null,handle:null,sampler:null,label:null};function Hv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wv,n),Ht.obj(e,t),t.bindGroupLayoutEntry={visibility:GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT,texture:{sampleType:"float",viewDimension:"2d"}},t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),Ht.get(e,t,["bindGroupTime","texture"]),Ht.setGet(e,t,["bindGroupLayoutEntry","label","sampler"]),function(e,t){t.classHierarchy.push("vtkWebGPUTextureView"),e.create=(e,n)=>{t.texture=e,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=bv(t.texture.getFormat());t.bindGroupLayoutEntry.texture.sampleType=r.sampleType},e.createFromTextureHandle=(e,n)=>{t.texture=null,t.options=n,t.options.dimension=t.options.dimension||"2d",t.options.label=t.label,t.textureHandle=e,t.handle=t.textureHandle.createView(t.options),t.bindGroupLayoutEntry.texture.viewDimension=t.options.dimension;const r=bv(n.format);t.bindGroupLayoutEntry.texture.sampleType=r.sampleType,t.bindGroupTime.modified()},e.getBindGroupEntry=()=>({resource:e.getHandle()}),e.getShaderCode=(e,n)=>{let r="f32";"sint"===t.bindGroupLayoutEntry.texture.sampleType?r="i32":"uint"===t.bindGroupLayoutEntry.texture.sampleType&&(r="u32");let o=`@binding(${e}) @group(${n}) var ${t.label}: texture_${t.options.dimension}<${r}>;`;return"depth"===t.bindGroupLayoutEntry.texture.sampleType&&(o=`@binding(${e}) @group(${n}) var ${t.label}: texture_depth_${t.options.dimension};`),o},e.addSampler=(n,r)=>{const o=zv.newInstance({label:`${t.label}Sampler`});o.create(n,r),e.setSampler(o)},e.getBindGroupTime=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.bindGroupTime),e.getHandle=()=>(t.texture&&t.texture.getHandle()!==t.textureHandle&&(t.textureHandle=t.texture.getHandle(),t.handle=t.textureHandle.createView(t.options),t.bindGroupTime.modified()),t.handle)}(e,t)}var jv={newInstance:Ht.newInstance(Hv),extend:Hv};const Kv={device:null,handle:null,buffer:null,ready:!1,label:null};function $v(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Kv,n),Ht.obj(e,t),Ht.get(e,t,["handle","ready","width","height","depth","format","usage"]),Ht.setGet(e,t,["device","label"]),function(e,t){t.classHierarchy.push("vtkWebGPUTexture"),e.create=(e,n)=>{t.device=e,t.width=n.width,t.height=n.height,t.depth=n.depth?n.depth:1;const r=1===t.depth?"2d":"3d";t.format=n.format?n.format:"rgba8unorm",t.mipLevel=n.mipLevel?n.mipLevel:0,t.usage=n.usage?n.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label,dimension:r,mipLevelCount:t.mipLevel+1})},e.assignFromHandle=(e,n,r)=>{t.device=e,t.handle=n,t.width=r.width,t.height=r.height,t.depth=r.depth?r.depth:1,t.format=r.format?r.format:"rgba8unorm",t.usage=r.usage?r.usage:GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_DST},e.writeImageData=n=>{let r=[];const o=r=>{t.device.getHandle().queue.copyExternalImageToTexture({source:r,flipY:n.flip},{texture:t.handle,premultipliedAlpha:!0,mipLevel:0,origin:{x:0,y:0,z:0}},[r.width,r.height,t.depth]),3!==e.getDimensionality()&&t.mipLevel>0&&Hc.generateMipmaps(t.device.getHandle(),t.handle,t.mipLevel+1),t.ready=!0};if(n.canvas)return void o(n.canvas);if(n.imageBitmap)return n.width=n.imageBitmap.width,n.height=n.imageBitmap.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.imageBitmap);if(n.jsImageData)return n.width=n.jsImageData.width,n.height=n.jsImageData.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.jsImageData);if(n.image)return n.width=n.image.width,n.height=n.image.height,n.depth=1,n.format="rgba8unorm",n.flip=!0,void o(n.image);const a=bv(t.format);let i=t.width*a.stride;n.nativeArray&&(r=n.nativeArray);const s=3===e.getDimensionality(),l=((e,t,n)=>{const r=2===a.elementSize&&"float"===a.sampleType,o=e.BYTES_PER_ELEMENT,i=e.length/(t*n)*o;if(!r&&i%256==0)return[e,i];const s=i/o,l=a.elementSize,c=256*Math.floor((s*l+255)/256),u=c/l,d=Ht.newTypedArray(r?"Uint16Array":e.constructor.name,u*t*n),p=t*n;if(r)for(let t=0;t<p;t++){const n=t*s,r=t*u;for(let t=0;t<s;t++)d[r+t]=Uu.toHalf(e[n+t])}else if(u===s)d.set(e);else for(let t=0;t<p;t++)d.set(e.subarray(t*s,(t+1)*s),t*u);return[d,c]})(r,t.height,s?t.depth:1);i=l[1];const c=l[0];t.device.getHandle().queue.writeTexture({texture:t.handle,mipLevel:0,origin:{x:0,y:0,z:0}},c,{offset:0,bytesPerRow:i,rowsPerImage:t.height},{width:t.width,height:t.height,depthOrArrayLayers:s?t.depth:1}),!s&&t.mipLevel>0&&Hc.generateMipmaps(t.device.getHandle(),t.handle,t.mipLevel+1),t.ready=!0},e.getScale=()=>{const e=bv(t.format);return 2===e.elementSize&&"float"===e.sampleType?1:255},e.getNumberOfComponents=()=>bv(t.format).numComponents,e.getDimensionality=()=>{let e=0;return t.width>1&&e++,t.height>1&&e++,t.depth>1&&e++,e},e.resizeToMatch=e=>{e.getWidth()===t.width&&e.getHeight()===t.height&&e.getDepth()===t.depth||(t.width=e.getWidth(),t.height=e.getHeight(),t.depth=e.getDepth(),t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.resize=function(e,n){let r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;e===t.width&&n===t.height&&r===t.depth||(t.width=e,t.height=n,t.depth=r,t.handle=t.device.getHandle().createTexture({size:[t.width,t.height,t.depth],format:t.format,usage:t.usage,label:t.label}))},e.createView=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};r.dimension||(r.dimension=1===t.depth?"2d":"3d");const o=jv.newInstance({label:n});return o.create(e,r),o}}(e,t)}var qv={newInstance:Ht.newInstance($v),extend:$v};const Xv={renderEncoder:null,colorTexture:null,depthTexture:null};function Yv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Xv,n),Ah.extend(e,t,n),Ht.get(e,t,["colorTexture","depthTexture"]),function(e,t){t.classHierarchy.push("vtkWebGPUOpaquePass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.renderEncoder)t.colorTexture.resize(r.getCanvas().width,r.getCanvas().height),t.depthTexture.resize(r.getCanvas().width,r.getCanvas().height);else{e.createRenderEncoder(),t.colorTexture=qv.newInstance({label:"opaquePassColor"}),t.colorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const n=t.colorTexture.createView("opaquePassColorTexture");t.renderEncoder.setColorTextureView(0,n),t.depthFormat="depth32float",t.depthTexture=qv.newInstance({label:"opaquePassDepth"}),t.depthTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:t.depthFormat,usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("opaquePassDepthTexture");t.renderEncoder.setDepthTextureView(a)}t.renderEncoder.attachTextureViews(),e.setCurrentOperation("opaquePass"),n.setRenderEncoder(t.renderEncoder),n.traverse(e)},e.getColorTextureView=()=>t.renderEncoder.getColorTextureViews()[0],e.getDepthTextureView=()=>t.renderEncoder.getDepthTextureView(),e.createRenderEncoder=()=>{t.renderEncoder=Gv.newInstance({label:"OpaquePass"}),t.renderEncoder.setPipelineHash("op")}}(e,t)}var Zv={newInstance:Ht.newInstance(Yv,"vtkWebGPUOpaquePass"),extend:Yv};const Qv={colorTextureView:null,depthTextureView:null};function Jv(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Qv,n),Ah.extend(e,t,n),Ht.setGet(e,t,["colorTextureView","depthTextureView"]),function(e,t){t.classHierarchy.push("vtkWebGPUOrderIndependentTranslucentPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r;const o=r.getDevice();if(t.translucentRenderEncoder)t.translucentColorTexture.resizeToMatch(t.colorTextureView.getTexture()),t.translucentAccumulateTexture.resizeToMatch(t.colorTextureView.getTexture());else{e.createRenderEncoder(),e.createFinalEncoder(),t.translucentColorTexture=qv.newInstance({label:"translucentPassColor"}),t.translucentColorTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"rgba16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const n=t.translucentColorTexture.createView("oitpColorTexture");t.translucentRenderEncoder.setColorTextureView(0,n),t.translucentAccumulateTexture=qv.newInstance({label:"translucentPassAccumulate"}),t.translucentAccumulateTexture.create(o,{width:r.getCanvas().width,height:r.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const a=t.translucentAccumulateTexture.createView("oitpAccumTexture");t.translucentRenderEncoder.setColorTextureView(1,a),t.fullScreenQuad=Bv.newInstance(),t.fullScreenQuad.setDevice(r.getDevice()),t.fullScreenQuad.setPipelineHash("oitpfsq"),t.fullScreenQuad.setTextureViews(t.translucentRenderEncoder.getColorTextureViews()),t.fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var tcoord: vec2<i32> = vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y));\n  var reveal: f32 = textureLoad(oitpAccumTexture, tcoord, 0).r;\n  if (reveal == 1.0) { discard; }\n  var tcolor: vec4<f32> = textureLoad(oitpColorTexture, tcoord, 0);\n  var total: f32 = max(tcolor.a, 0.01);\n  var computedColor: vec4<f32> = vec4<f32>(tcolor.r/total, tcolor.g/total, tcolor.b/total, 1.0 - reveal);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n")}t.translucentRenderEncoder.setDepthTextureView(t.depthTextureView),t.translucentRenderEncoder.attachTextureViews(),e.setCurrentOperation("translucentPass"),n.setRenderEncoder(t.translucentRenderEncoder),n.traverse(e),e.finalPass(r,n)},e.finalPass=(e,n)=>{t.translucentFinalEncoder.setColorTextureView(0,t.colorTextureView),t.translucentFinalEncoder.attachTextureViews(),t.translucentFinalEncoder.begin(e.getCommandEncoder()),n.scissorAndViewport(t.translucentFinalEncoder),t.fullScreenQuad.prepareAndDraw(t.translucentFinalEncoder),t.translucentFinalEncoder.end()},e.getTextures=()=>[t.translucentColorTexture,t.translucentAccumulateTexture],e.createRenderEncoder=()=>{t.translucentRenderEncoder=Gv.newInstance({label:"translucentRender"});const e=t.translucentRenderEncoder.getDescription();e.colorAttachments=[{view:void 0,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:void 0,clearValue:[1,0,0,0],loadOp:"clear",storeOp:"store"}],e.depthStencilAttachment={view:void 0,depthLoadOp:"load",depthStoreOp:"store"},t.translucentRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addOutput("f32","outAccum"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["var w: f32 = computedColor.a * pow(0.1 + input.fragPos.z, 2.0);","output.outColor = vec4<f32>(computedColor.rgb*w, w);","output.outAccum = computedColor.a;"]).result,t.setCode(n)})),t.translucentRenderEncoder.setPipelineHash("oitpr"),t.translucentRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!1,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one"},alpha:{srcFactor:"one",dstFactor:"one"}}},{format:"r16float",blend:{color:{srcFactor:"zero",dstFactor:"one-minus-src"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createFinalEncoder=()=>{t.translucentFinalEncoder=Gv.newInstance({label:"translucentFinal"}),t.translucentFinalEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t.translucentFinalEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor"),t.addBuiltinInput("vec4<f32>","@builtin(position) fragPos");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t.translucentFinalEncoder.setPipelineHash("oitpf"),t.translucentFinalEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})}}(e,t)}var eT={newInstance:Ht.newInstance(Jv,"vtkWebGPUOrderIndependentTranslucentPass"),extend:Jv},tT={BufferUsage:{Verts:0,Lines:1,Triangles:2,Strips:3,LinesFromStrips:4,LinesFromTriangles:5,Points:6,UniformArray:7,PointArray:8,NormalsFromPoints:9,Texture:10,RawVertex:11,Storage:12,Index:13},PrimitiveTypes:{Start:0,Points:0,Lines:1,Triangles:2,TriangleStrips:3,TriangleEdges:4,TriangleStripEdges:5,End:6}};const nT=["getMappedRange","mapAsync","unmap"];const rT={device:null,handle:null,sizeInBytes:0,strideInBytes:0,arrayInformation:null,usage:null,label:null,sourceTime:null};function oT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rT,n),Ht.obj(e,t),Ht.get(e,t,["handle","sizeInBytes","usage"]),Ht.setGet(e,t,["strideInBytes","device","arrayInformation","label","sourceTime"]),function(e,t){t.classHierarchy.push("vtkWebGPUBuffer"),e.create=(e,n)=>{t.handle=t.device.getHandle().createBuffer({size:e,usage:n,label:t.label}),t.sizeInBytes=e,t.usage=n},e.write=e=>{!function(e,t,n,r){const o=r.byteLength,a=e.createBuffer({size:o,usage:GPUBufferUsage.COPY_SRC,mappedAtCreation:!0}),i=a.getMappedRange(0,o);new Uint8Array(i).set(new Uint8Array(r)),a.unmap();const s=e.createCommandEncoder();s.copyBufferToBuffer(a,0,t,0,o);const l=s.finish();e.queue.submit([l]),a.destroy()}(t.device.getHandle(),t.handle,0,e.buffer)},e.createAndWrite=(e,n)=>{const r=4*Math.ceil(e.byteLength/4);t.handle=t.device.getHandle().createBuffer({size:r,usage:n,mappedAtCreation:!0,label:t.label}),t.sizeInBytes=r,t.usage=n,new Uint8Array(t.handle.getMappedRange()).set(new Uint8Array(e.buffer)),t.handle.unmap()};for(let n=0;n<nT.length;n++)e[nT[n]]=function(){return t.handle[nT[n]](...arguments)}}(e,t)}var aT={newInstance:Ht.newInstance(oT),extend:oT,...tT};const{Representation:iT}=ts,{PrimitiveTypes:sT}=tT;class lT{constructor(){this.keys=new Uint32Array(10),this.values=new Uint32Array(10),this.count=0}clear(){this.count=0}has(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return!0}get(e){for(let t=0;t<this.count;t++)if(this.keys[t]===e)return this.values[t]}set(e,t){this.count<9&&(this.keys[this.count]=e,this.values[this.count++]=t)}}function cT(e,t,n){let r=e.pointIdToFlatId[t];return r<0&&(r=e.flatId,e.pointIdToFlatId[t]=r,e.flatIdToPointId[e.flatId]=t,e.flatIdToCellId[e.flatId]=n,e.flatId++),r}function uT(e,t,n){const r=e.length;for(let o=0;o<r;o++){let a=e[o];if(n.cellProvokedMap.has(a)){n.ibo[n.iboId++]=n.cellProvokedMap.get(a);for(let i=o+1;i<o+r;i++){a=e[i%r];const o=cT(n,a,t);n.ibo[n.iboId++]=o}return}}for(let o=0;o<r;o++){let a=e[o];if(!n.provokedPointIds[a]){let i=cT(n,a,t);n.provokedPointIds[a]=1,n.cellProvokedMap.set(a,i),n.flatIdToCellId[i]=t,n.ibo[n.iboId++]=i;for(let s=o+1;s<o+r;s++)a=e[s%r],i=cT(n,a,t),n.ibo[n.iboId++]=i;return}}let o=e[0],a=n.flatId;n.cellProvokedMap.set(o,a),n.flatIdToPointId[n.flatId]=o,n.flatIdToCellId[n.flatId]=t,n.flatId++,n.ibo[n.iboId++]=a;for(let i=1;i<r;i++)o=e[i],a=cT(n,o,t),n.ibo[n.iboId++]=a}function dT(e,t,n){const r=e.length;n.iboSize+=r;for(let t=0;t<r;t++){const r=e[t];if(n.cellProvokedMap.has(r))return}for(let t=0;t<r;t++){const r=e[t];if(!n.provokedPointIds[r])return n.provokedPointIds[r]=1,void n.cellProvokedMap.set(r,1)}n.cellProvokedMap.set(e[0],1),n.extraPoints++}let pT;const fT=new Uint32Array(1),gT=new Uint32Array(2),mT=new Uint32Array(3),hT={anythingToPoints(e,t,n,r,o){for(let a=0;a<e;++a)fT[0]=t[n+a],pT(fT,r,o)},linesToWireframe(e,t,n,r,o){for(let a=0;a<e-1;++a)gT[0]=t[n+a],gT[1]=t[n+a+1],pT(gT,r,o)},polysToWireframe(e,t,n,r,o){if(e>2)for(let a=0;a<e;++a)gT[0]=t[n+a],gT[1]=t[n+(a+1)%e],pT(gT,r,o)},stripsToWireframe(e,t,n,r,o){if(e>2){for(let a=0;a<e-1;++a)gT[0]=t[n+a],gT[1]=t[n+a+1],pT(gT,r,o);for(let a=0;a<e-2;a++)gT[0]=t[n+a],gT[1]=t[n+a+2],pT(gT,r,o)}},polysToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)mT[0]=t[n],mT[1]=t[n+a+1],mT[2]=t[n+a+2],pT(mT,r,o)},stripsToSurface(e,t,n,r,o){for(let a=0;a<e-2;a++)mT[0]=t[n+a],mT[1]=t[n+a+1+a%2],mT[2]=t[n+a+1+(a+1)%2],pT(mT,r,o)}};const vT={flatIdToPointId:null,flatIdToCellId:null,flatSize:0,indexCount:0};function TT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vT,n),aT.extend(e,t,n),Ht.setGet(e,t,["flatIdToPointId","flatIdToCellId","flatSize","indexCount"]),function(e,t){t.classHierarchy.push("vtkWebGPUIndexBuffer"),e.buildIndexBuffer=e=>{const n=e.cells,r=e.primitiveType,o=e.representation,a=e.cellOffset,i=n.getData(),s=i.length,l=function(e){switch(e){case sT.Points:return"points";case sT.Lines:return"lines";case sT.Triangles:case sT.TriangleEdges:return"polys";case sT.TriangleStripEdges:case sT.TriangleStrips:return"strips";default:return""}}(r),c=e.numberOfPoints,u={provokedPointIds:new Uint8Array(c),extraPoints:0,iboSize:0,flatId:0,iboId:0,cellProvokedMap:new lT};let d=null;d=o===iT.POINTS||r===sT.Points?hT.anythingToPoints:o===iT.WIREFRAME||r===sT.Lines?hT[`${l}ToWireframe`]:hT[`${l}ToSurface`],pT=dT;let p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;u.flatIdToPointId=c<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),c+u.extraPoints<36863?u.pointIdToFlatId=new Int16Array(c):u.pointIdToFlatId=new Int32Array(c),c+u.extraPoints<=65535?(u.ibo=new Uint16Array(u.iboSize),e.format="uint16"):(u.ibo=new Uint32Array(u.iboSize),e.format="uint32"),u.flatIdToCellId=p<=65535?new Uint16Array(c+u.extraPoints):new Uint32Array(c+u.extraPoints),u.pointIdToFlatId.fill(-1),u.provokedPointIds.fill(0),pT=uT,p=a||0;for(let e=0;e<s;)u.cellProvokedMap.clear(),d(i[e],i,e+1,p,u),e+=i[e]+1,p++;delete u.provokedPointIds,delete u.pointIdToFlatId,e.nativeArray=u.ibo,t.flatIdToPointId=u.flatIdToPointId,t.flatIdToCellId=u.flatIdToCellId,t.flatSize=u.flatId,t.indexCount=u.iboId}}(e,t)}var yT={newInstance:Ht.newInstance(TT),extend:TT,...tT};const{BufferUsage:bT}=tT,{vtkErrorMacro:xT}=jt,{VtkDataTypes:CT}=Ts;function ST(e,t,n,r,o){const a={},i=e.getFlatSize();if(!i)return a;let s=[0,0,0,0];o.shift&&(o.shift.length?s=o.shift:s.fill(o.shift));let l=[1,1,1,1];o.scale&&(o.scale.length?l=o.scale:l.fill(o.scale));const c=!!Object.prototype.hasOwnProperty.call(o,"packExtra")&&o.packExtra;let u,d=0;const p=it(r,i*(n+(c?1:0)));let f=e.getFlatIdToPointId();o.cellData&&(f=e.getFlatIdToCellId()),1===n?u=function(e){p[d++]=l[0]*t[e]+s[0]}:2===n?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1]}:3!==n||c?3===n&&c?u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=1*l[3]+s[3]}:4===n&&(u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2],p[d++]=l[3]*t[e+3]+s[3]}):u=function(e){p[d++]=l[0]*t[e]+s[0],p[d++]=l[1]*t[e+1]+s[1],p[d++]=l[2]*t[e+2]+s[2]};for(let e=0;e<i;e++)u(n*f[e]);return a.nativeArray=p,a}function AT(e,t,n,r){const o=[];return Fo([e[3*r]-e[3*n],e[3*r+1]-e[3*n+1],e[3*r+2]-e[3*n+2]],[e[3*t]-e[3*n],e[3*t+1]-e[3*n+1],e[3*t+2]-e[3*n+2]],o),Go(o),o}const IT={device:null,fullScreenQuadBuffer:null};function wT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,IT,n),vt(e,t),St(e,t,["device"]),function(e,t){function n(e){let n,r;if(e.dataArray&&!e.nativeArray&&(e.nativeArray=e.dataArray.getData()),e.usage===bT.Index&&(n=yT.newInstance({label:e.label}),n.setDevice(t.device),r=GPUBufferUsage.INDEX|GPUBufferUsage.COPY_DST,n.buildIndexBuffer(e),n.createAndWrite(e.nativeArray,r),n.setArrayInformation([{format:e.format}])),n||(n=aT.newInstance({label:e.label}),n.setDevice(t.device)),e.usage===bT.UniformArray&&(r=GPUBufferUsage.UNIFORM|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===bT.Storage&&(r=GPUBufferUsage.STORAGE|GPUBufferUsage.COPY_DST,n.createAndWrite(e.nativeArray,r)),e.usage===bT.Texture&&(r=GPUBufferUsage.COPY_SRC,n.createAndWrite(e.nativeArray,r)),e.usage===bT.PointArray){r=GPUBufferUsage.VERTEX;const t=Cv(e.format),o=ST(e.indexBuffer,e.dataArray.getData(),e.dataArray.getNumberOfComponents(),t,{packExtra:e.packExtra,shift:e.shift,scale:e.scale,cellData:e.cellData,cellOffset:e.cellOffset});n.createAndWrite(o.nativeArray,r),n.setStrideInBytes(xv(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:e.cellData?"flat":"perspective"}])}if(e.usage===bT.NormalsFromPoints){r=GPUBufferUsage.VERTEX;const t=Cv(e.format),o=function(e,t){const n=t.getData(),r=e.getData();if(!r||!n)return null;const o=new Int8Array(4*e.getNumberOfCells()),a=r.length;let i=0;for(let e=0;e<a;){const t=AT(n,r[e+1],r[e+2],r[e+3]);o[i++]=127*t[0],o[i++]=127*t[1],o[i++]=127*t[2],o[i++]=127,e+=r[e]+1}return o}(e.cells,e.dataArray),a=ST(e.indexBuffer,o,4,t,{cellData:!0});n.createAndWrite(a.nativeArray,r),n.setStrideInBytes(xv(e.format)),n.setArrayInformation([{offset:0,format:e.format,interpolation:"flat"}])}return e.usage===bT.RawVertex&&(r=GPUBufferUsage.VERTEX,n.createAndWrite(e.nativeArray,r),n.setStrideInBytes(xv(e.format)),n.setArrayInformation([{offset:0,format:e.format}])),n.setSourceTime(e.time),n}t.classHierarchy.push("vtkWebGPUBufferManager"),e.hasBuffer=e=>t.device.hasCachedObject(e),e.getBuffer=e=>e.hash?t.device.getCachedObject(e.hash,n,e):n(e),e.getBufferForPointArray=(t,n)=>{const r=function(e){let t;switch(e.getDataType()){case CT.UNSIGNED_CHAR:t="uint8";break;case CT.FLOAT:t="float32";break;case CT.UNSIGNED_INT:t="uint32";break;case CT.INT:t="sint32";break;case CT.DOUBLE:t="float32";break;case CT.UNSIGNED_SHORT:t="uint16";break;case CT.SHORT:t="sin16";break;default:t="float32"}switch(e.getNumberOfComponents()){case 2:t+="x2";break;case 3:t.includes("32")||xT(`unsupported x3 type for ${t}`),t+="x3";break;case 4:t+="x4"}return t}(t),o={hash:`${t.getMTime()}I${n.getMTime()}${r}`,usage:bT.PointArray,format:r,dataArray:t,indexBuffer:n};return e.getBuffer(o)},e.getFullScreenQuadBuffer=()=>{if(t.fullScreenQuadBuffer)return t.fullScreenQuadBuffer;t.fullScreenQuadBuffer=aT.newInstance(),t.fullScreenQuadBuffer.setDevice(t.device);const e=new Float32Array([-1,-1,0,1,-1,0,1,1,0,-1,-1,0,1,1,0,-1,1,0]);return t.fullScreenQuadBuffer.createAndWrite(e,GPUBufferUsage.VERTEX),t.fullScreenQuadBuffer.setStrideInBytes(12),t.fullScreenQuadBuffer.setArrayInformation([{offset:0,format:"float32x3"}]),t.fullScreenQuadBuffer}}(e,t)}var OT={newInstance:Et(wT),extend:wT,...tT};const{BufferUsage:PT}=OT,{vtkErrorMacro:RT}=Ht,MT={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,bindGroupLayoutEntry:null,bindGroupEntry:null};function ET(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,MT,n),Ht.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"uniform"}},t.sendTime={},Ht.obj(t.sendTime,{mtime:0}),t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),t.sendDirty=!0,t.sortDirty=!0,Ht.get(e,t,["binding","bindGroupTime"]),Ht.setGet(e,t,["bindGroupLayoutEntry","device","label","sizeInBytes"]),function(e,t){t.classHierarchy.push("vtkWebGPUUniformBuffer"),e.addEntry=(e,n)=>{t._bufferEntryNames.has(e)?RT(`entry named ${e} already exists`):(t.sortDirty=!0,t._bufferEntryNames.set(e,t.bufferEntries.length),t.bufferEntries.push({name:e,type:n,sizeInBytes:Av(n),offset:-1,nativeType:Iv(n),packed:!1}))},e.sortBufferEntries=()=>{if(!t.sortDirty)return;let e=0;const n=[];let r=4;for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];n.sizeInBytes%16==0&&(r=Math.max(16,r)),n.sizeInBytes%8==0&&(r=Math.max(8,r))}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!1===o.packed&&o.sizeInBytes%16==0&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!1===o.packed&&12===o.sizeInBytes)for(let r=0;r<t.bufferEntries.length;r++){const a=t.bufferEntries[r];if(!1===a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0)for(let a=r+1;a<t.bufferEntries.length;a++){const r=t.bufferEntries[a];if(!r.packed&&r.sizeInBytes%8==0){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,r.packed=!0,r.offset=e,n.push(r),e+=r.sizeInBytes;break}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];if(!o.packed&&o.sizeInBytes%8==0){let r=!1;for(let a=0;!r&&a<t.bufferEntries.length;a++){const i=t.bufferEntries[a];if(!i.packed&&4===i.sizeInBytes)for(let s=a+1;s<t.bufferEntries.length;s++){const a=t.bufferEntries[s];if(!a.packed&&4===a.sizeInBytes){o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes,i.packed=!0,i.offset=e,n.push(i),e+=i.sizeInBytes,a.packed=!0,a.offset=e,n.push(a),e+=a.sizeInBytes,r=!0;break}}}}}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];!o.packed&&o.sizeInBytes>4&&(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}for(let r=0;r<t.bufferEntries.length;r++){const o=t.bufferEntries[r];o.packed||(o.packed=!0,o.offset=e,n.push(o),e+=o.sizeInBytes)}t.bufferEntries=n,t._bufferEntryNames.clear();for(let e=0;e<t.bufferEntries.length;e++)t._bufferEntryNames.set(t.bufferEntries[e].name,e);t.sizeInBytes=e,t.sizeInBytes=r*Math.ceil(t.sizeInBytes/r),t.sortDirty=!1},e.sendIfNeeded=e=>{if(!t.UBO){const n={nativeArray:t.Float32Array,usage:PT.UniformArray,label:t.label};t.UBO=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),t.sendDirty=!1}t.sendDirty&&(e.getHandle().queue.writeBuffer(t.UBO.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes),t.sendDirty=!1),t.sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes)),t[e]=Ht.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void RT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];a.lastValue!==r&&(i[a.offset/i.BYTES_PER_ELEMENT]=r,t.sendDirty=!0),a.lastValue=r},e.setArray=(n,r)=>{e.sortBufferEntries();const o=t._bufferEntryNames.get(n);if(void 0===o)return void RT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];let s=!1;for(let e=0;e<r.length;e++)a.lastValue&&a.lastValue[e]===r[e]||(i[a.offset/i.BYTES_PER_ELEMENT+e]=r[e],s=!0);s&&(t.sendDirty=!0,a.lastValue=[...r])},e.getBindGroupEntry=()=>({resource:{buffer:t.UBO.getHandle()}}),e.getSendTime=()=>t.sendTime.getMTime(),e.getShaderCode=(n,r)=>{e.sortBufferEntries();const o=[`struct ${t.label}Struct\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];o.push(`  ${n.name}: ${n.type},`)}return o.push(`};\n@binding(${n}) @group(${r}) var<uniform> ${t.label}: ${t.label}Struct;`),o.join("\n")}}(e,t)}var VT={newInstance:Ht.newInstance(ET,"vtkWebGPUUniformBuffer"),extend:ET};const{BufferUsage:DT}=OT,{vtkErrorMacro:LT}=Ht,BT={bufferEntries:null,bufferEntryNames:null,sizeInBytes:0,label:null,numberOfInstances:1};function NT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,BT,n),Ht.obj(e,t),t._bufferEntryNames=new Map,t.bufferEntries=[],t._sendTime={},Ht.obj(t._sendTime,{mtime:0}),t.bindGroupTime={},Ht.obj(t.bindGroupTime,{mtime:0}),t.bindGroupLayoutEntry=t.bindGroupLayoutEntry||{buffer:{type:"read-only-storage"}},Ht.get(e,t,["bindGroupTime"]),Ht.setGet(e,t,["device","bindGroupLayoutEntry","label","numberOfInstances","sizeInBytes"]),function(e,t){t.classHierarchy.push("vtkWebGPUStorageBuffer"),e.addEntry=(e,n)=>{if(t._bufferEntryNames.has(e))return void LT(`entry named ${e} already exists`);t._bufferEntryNames.set(e,t.bufferEntries.length);const r=Av(n);t.bufferEntries.push({name:e,type:n,sizeInBytes:r,offset:t.sizeInBytes,nativeType:Iv(n)}),t.sizeInBytes+=r},e.send=e=>{if(!t._buffer){const n={nativeArray:t.Float32Array,usage:DT.Storage,label:t.label};return t._buffer=e.getBufferManager().getBuffer(n),t.bindGroupTime.modified(),void t._sendTime.modified()}e.getHandle().queue.writeBuffer(t._buffer.getHandle(),0,t.arrayBuffer,0,t.sizeInBytes*t.numberOfInstances),t._sendTime.modified()},e.createView=e=>{e in t==0&&(t.arrayBuffer||(t.arrayBuffer=new ArrayBuffer(t.sizeInBytes*t.numberOfInstances)),t[e]=Ht.newTypedArray(e,t.arrayBuffer))},e.setValue=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void LT(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType];s[(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT]=o},e.setArray=(n,r,o)=>{const a=t._bufferEntryNames.get(n);if(void 0===a)return void LT(`entry named ${n} not found in UBO`);const i=t.bufferEntries[a];e.createView(i.nativeType);const s=t[i.nativeType],l=(i.offset+r*t.sizeInBytes)/s.BYTES_PER_ELEMENT;for(let e=0;e<o.length;e++)s[l+e]=o[e]},e.setAllInstancesFromArray=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void LT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]}},e.setAllInstancesFromArrayColorToFloat=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void LT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType],s=r.length/t.numberOfInstances;for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<s;t++)i[n+t]=r[e*s+t]/255}},e.setAllInstancesFromArray3x3To4x4=(n,r)=>{const o=t._bufferEntryNames.get(n);if(void 0===o)return void LT(`entry named ${n} not found in UBO`);const a=t.bufferEntries[o];e.createView(a.nativeType);const i=t[a.nativeType];for(let e=0;e<t.numberOfInstances;e++){const n=(a.offset+e*t.sizeInBytes)/i.BYTES_PER_ELEMENT;for(let t=0;t<3;t++)for(let o=0;o<3;o++)i[n+4*t+o]=r[9*e+3*t+o]}},e.getSendTime=()=>t._sendTime.getMTime(),e.getShaderCode=(e,n)=>{const r=[`struct ${t.label}StructEntry\n{`];for(let e=0;e<t.bufferEntries.length;e++){const n=t.bufferEntries[e];r.push(`  ${n.name}: ${n.type},`)}return r.push(`\n};\nstruct ${t.label}Struct\n{\n  values: array<${t.label}StructEntry>,\n};\n@binding(${e}) @group(${n}) var<storage, read> ${t.label}: ${t.label}Struct;\n`),r.join("\n")},e.getBindGroupEntry=()=>({resource:{buffer:t._buffer.getHandle()}}),e.clearData=()=>{t.numberOfInstances=0,t.sizeInBytes=0,t.bufferEntries=[],t._bufferEntryNames=new Map,t._buffer=null,delete t.arrayBuffer,delete t.Float32Array}}(e,t)}var FT={newInstance:Ht.newInstance(NT,"vtkWebGPUStorageBuffer"),extend:NT};const _T=new Float64Array(16),GT=new Float64Array(16),kT={volumes:null,rowLength:1024,lastVolumeLength:0};function UT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,kT,n),Bv.extend(e,t,n),t.fragmentShaderTemplate="\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::Volume::TraverseDec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\nfn getTextureValue(vTex: texture_3d<f32>, tpos: vec4<f32>) -> f32\n{\n  // todo multicomponent support\n  return textureSampleLevel(vTex, clampSampler, tpos.xyz, 0.0).r;\n}\n\nfn getGradient(vTex: texture_3d<f32>, tpos: vec4<f32>, vNum: i32, scalar: f32) -> vec4<f32>\n{\n  var result: vec4<f32>;\n\n  var tstep: vec4<f32> = volumeSSBO.values[vNum].tstep;\n  result.x = getTextureValue(vTex, tpos + vec4<f32>(tstep.x, 0.0, 0.0, 1.0)) - scalar;\n  result.y = getTextureValue(vTex, tpos + vec4<f32>(0.0, tstep.y, 0.0, 1.0)) - scalar;\n  result.z = getTextureValue(vTex, tpos + vec4<f32>(0.0, 0.0, tstep.z, 1.0)) - scalar;\n  result.w = 0.0;\n\n  // divide by spacing as that is our delta\n  result = result / volumeSSBO.values[vNum].spacing;\n  // now we have a gradient in unit tcoords\n\n  var grad: f32 = length(result.xyz);\n  if (grad > 0.0)\n  {\n    // rotate to View Coords, needed for lighting and shading\n    var nMat: mat4x4<f32> = rendererUBO.SCVCMatrix * volumeSSBO.values[vNum].planeNormals;\n    result = nMat * result;\n    result = result / length(result);\n  }\n\n  // store gradient magnitude in .w\n  result.w = grad;\n\n  return result;\n}\n\nfn processVolume(vTex: texture_3d<f32>, vNum: i32, cNum: i32, posSC: vec4<f32>, tfunRows: f32) -> vec4<f32>\n{\n  var outColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n\n  // convert to tcoords and reject if outside the volume\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*posSC;\n  if (tpos.x < 0.0 || tpos.y < 0.0 || tpos.z < 0.0 ||\n      tpos.x > 1.0 || tpos.y > 1.0 || tpos.z > 1.0) { return outColor; }\n\n  var scalar: f32 = getTextureValue(vTex, tpos);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n\n  var gofactor: f32 = 1.0;\n  var normal: vec4<f32> = vec4<f32>(0.0,0.0,0.0,0.0);\n  if (componentSSBO.values[cNum].gomin <  1.0 || volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    normal = getGradient(vTex, tpos, vNum, scalar);\n    if (componentSSBO.values[cNum].gomin <  1.0)\n    {\n      gofactor = clamp(normal.a*componentSSBO.values[cNum].goScale + componentSSBO.values[cNum].goShift,\n      componentSSBO.values[cNum].gomin, componentSSBO.values[cNum].gomax);\n    }\n  }\n\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n\n  if (volumeSSBO.values[vNum].shade[0] > 0.0)\n  {\n    color = color*abs(normal.z);\n  }\n\n  outColor = vec4<f32>(color.rgb, gofactor * opacity);\n\n  return outColor;\n}\n\n// adjust the start and end point of a raycast such that it intersects the unit cube.\n// This function is used to take a raycast starting point and step vector\n// and numSteps and return the startijng and ending steps for intersecting the\n// unit cube. Recall for a 3D texture, the unit cube is the range of texture coordsinates\n// that have valid values. So this funtion can be used to take a ray in texture coordinates\n// and bound it to intersecting the texture.\n//\nfn adjustBounds(tpos: vec4<f32>, tstep: vec4<f32>, numSteps: f32) -> vec2<f32>\n{\n  var result: vec2<f32> = vec2<f32>(0.0, numSteps);\n  var tpos2: vec4<f32> = tpos + tstep*numSteps;\n\n  // move tpos to the start of the volume\n  var adjust: f32 =\n    min(\n      max(tpos.x/tstep.x, (tpos.x - 1.0)/tstep.x),\n      min(\n        max((tpos.y - 1.0)/tstep.y, tpos.y/tstep.y),\n        max((tpos.z - 1.0)/tstep.z, tpos.z/tstep.z)));\n  if (adjust < 0.0)\n  {\n    result.x = result.x - adjust;\n  }\n\n  // adjust length to the end\n  adjust =\n    max(\n      min(tpos2.x/tstep.x, (tpos2.x - 1.0)/tstep.x),\n      max(\n        min((tpos2.y - 1.0)/tstep.y, tpos2.y/tstep.y),\n        min((tpos2.z - 1.0)/tstep.z, tpos2.z/tstep.z)));\n  if (adjust > 0.0)\n  {\n    result.y = result.y - adjust;\n  }\n\n  return result;\n}\n\nfn getSimpleColor(scalar: f32, vNum: i32, cNum: i32) -> vec4<f32>\n{\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var coord: vec2<f32> =\n    vec2<f32>(scalar * componentSSBO.values[cNum].cScale + componentSSBO.values[cNum].cShift,\n      (0.5 + 2.0 * f32(vNum)) / tfunRows);\n  var color: vec4<f32> = textureSampleLevel(tfunTexture, clampSampler, coord, 0.0);\n  coord.x = (scalar * componentSSBO.values[cNum].oScale + componentSSBO.values[cNum].oShift);\n  var opacity: f32 = textureSampleLevel(ofunTexture, clampSampler, coord, 0.0).r;\n  return vec4<f32>(color.rgb, opacity);\n}\n\nfn traverseMax(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var maxVal: f32 = -1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar > maxVal)\n    {\n      maxVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(maxVal, vNum, cNum);\n}\n\nfn traverseMin(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var minVal: f32 = 1.0e37;\n  loop\n  {\n    var scalar: f32 = getTextureValue(vTex, tpos);\n    if (scalar < minVal)\n    {\n      minVal = scalar;\n    }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(minVal, vNum, cNum);\n}\n\nfn traverseAverage(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var avgVal: f32 = 0.0;\n  var sampleCount: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      avgVal = avgVal + sample;\n      sampleCount = sampleCount + 1.0;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  if (sampleCount <= 0.0)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(avgVal/sampleCount, vNum, cNum);\n}\n\nfn traverseAdditive(vTex: texture_3d<f32>, vNum: i32, cNum: i32, rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>)\n{\n  // convert to tcoords and reject if outside the volume\n  var numSteps: f32 = rayLengthSC/mapperUBO.SampleDistance;\n  var tpos: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*minPosSC;\n  var tpos2: vec4<f32> = volumeSSBO.values[vNum].SCTCMatrix*(minPosSC + rayStepSC);\n  var tstep: vec4<f32> = tpos2 - tpos;\n\n  var rayBounds: vec2<f32> = adjustBounds(tpos, tstep, numSteps);\n\n  // did we hit anything\n  if (rayBounds.x >= rayBounds.y)\n  {\n    traverseVals[vNum] = vec4<f32>(0.0,0.0,0.0,0.0);\n    return;\n  }\n\n  let ipRange: vec4<f32> = volumeSSBO.values[vNum].ipScalarRange;\n  tpos = tpos + tstep*rayBounds.x;\n  var curDist: f32 = rayBounds.x;\n  var sumVal: f32 = 0.0;\n  loop\n  {\n    var sample: f32 = getTextureValue(vTex, tpos);\n    // right now leave filtering off until WebGL changes get merged\n    // if (ipRange.z == 0.0 || sample >= ipRange.x && sample <= ipRange.y)\n    // {\n      sumVal = sumVal + sample;\n    // }\n\n    // increment position\n    curDist = curDist + 1.0;\n    tpos = tpos + tstep;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayBounds.y) { break; }\n  }\n\n  // process to get the color and opacity\n  traverseVals[vNum] = getSimpleColor(sumVal, vNum, cNum);\n}\n\nfn composite(rayLengthSC: f32, minPosSC: vec4<f32>, rayStepSC: vec4<f32>) -> vec4<f32>\n{\n  // initial ray position is at the beginning\n  var rayPosSC: vec4<f32> = minPosSC;\n\n  // how many rows (tfuns) do we have in our tfunTexture\n  var tfunRows: f32 = f32(textureDimensions(tfunTexture).y);\n\n  var curDist: f32 = 0.0;\n  var computedColor: vec4<f32> = vec4<f32>(0.0, 0.0, 0.0, 0.0);\n  var sampleColor: vec4<f32>;\n//VTK::Volume::TraverseCalls\n\n  loop\n  {\n    // for each volume, sample and accumulate color\n//VTK::Volume::CompositeCalls\n\n    // increment position\n    curDist = curDist + mapperUBO.SampleDistance;\n    rayPosSC = rayPosSC + rayStepSC;\n\n    // check if we have reached a terminating condition\n    if (curDist > rayLengthSC) { break; }\n    if (computedColor.a > 0.98) { break; }\n  }\n  return computedColor;\n}\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var rayMax: f32 = textureSampleLevel(maxTexture, clampSampler, input.tcoordVS, 0.0).r;\n  var rayMin: f32 = textureSampleLevel(minTexture, clampSampler, input.tcoordVS, 0.0).r;\n\n  // discard empty rays\n  if (rayMax <= rayMin) { discard; }\n  else\n  {\n    // compute start and end ray positions in view coordinates\n    var minPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMax, 1.0);\n    minPosSC = minPosSC * (1.0 / minPosSC.w);\n    var maxPosSC: vec4<f32> = rendererUBO.PCSCMatrix*vec4<f32>(2.0 * input.tcoordVS.x - 1.0, 1.0 - 2.0 * input.tcoordVS.y, rayMin, 1.0);\n    maxPosSC = maxPosSC * (1.0 / maxPosSC.w);\n\n    var rayLengthSC: f32 = distance(minPosSC.xyz, maxPosSC.xyz);\n    var rayStepSC: vec4<f32> = (maxPosSC - minPosSC)*(mapperUBO.SampleDistance/rayLengthSC);\n    rayStepSC.w = 0.0;\n\n    var computedColor: vec4<f32>;\n\n//VTK::Volume::Loop\n\n//VTK::RenderEncoder::Impl\n  }\n\n  return output;\n}\n",t.UBO=VT.newInstance({label:"mapperUBO"}),t.UBO.addEntry("SampleDistance","f32"),t.SSBO=FT.newInstance({label:"volumeSSBO"}),t.componentSSBO=FT.newInstance({label:"componentSSBO"}),t.lutBuildTime={},Ht.obj(t.lutBuildTime,{mtime:0}),function(e,t){t.classHierarchy.push("vtkWebGPUVolumePassFSQ"),e.replaceShaderPosition=(e,t,n)=>{const r=t.getShaderDescription("vertex");r.addBuiltinOutput("vec4<f32>","@builtin(position) Position");let o=r.getCode();o=cv.substitute(o,"//VTK::Position::Impl",["output.tcoordVS = vec2<f32>(vertexBC.x * 0.5 + 0.5, 1.0 - vertexBC.y * 0.5 - 0.5);","output.Position = vec4<f32>(vertexBC, 1.0);"]).result,r.setCode(o),t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")},t.shaderReplacements.set("replaceShaderPosition",e.replaceShaderPosition),e.replaceShaderVolume=(e,n,r)=>{const o=n.getShaderDescription("fragment");let a=o.getCode();const i=[],s=[];for(let e=0;e<t.volumes.length;e++)t.volumes[e].getRenderable().getMapper().getBlendMode()===Af.COMPOSITE_BLEND?(i.push(`    sampleColor = processVolume(volTexture${e}, ${e}, ${t.rowStarts[e]}, rayPosSC, tfunRows);`),i.push("    computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);")):(s.push(`  sampleColor = traverseVals[${e}];`),s.push("  computedColor = vec4<f32>(\n          sampleColor.a * sampleColor.rgb * (1.0 - computedColor.a) + computedColor.rgb,\n          (1.0 - computedColor.a)*sampleColor.a + computedColor.a);"));a=cv.substitute(a,"//VTK::Volume::CompositeCalls",i).result,a=cv.substitute(a,"//VTK::Volume::TraverseCalls",s).result,a=cv.substitute(a,"//VTK::Volume::TraverseDec",[`var<private> traverseVals: array<vec4<f32>,${t.volumes.length}>;`]).result;let l=!1;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();n===Af.COMPOSITE_BLEND?l=!0:n===Af.MAXIMUM_INTENSITY_BLEND?a=cv.substitute(a,"//VTK::Volume::Loop",[`    traverseMax(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===Af.MINIMUM_INTENSITY_BLEND?a=cv.substitute(a,"//VTK::Volume::Loop",[`    traverseMin(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===Af.AVERAGE_INTENSITY_BLEND?a=cv.substitute(a,"//VTK::Volume::Loop",[`    traverseAverage(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result:n===Af.ADDITIVE_INTENSITY_BLEND&&(a=cv.substitute(a,"//VTK::Volume::Loop",[`    traverseAdditive(volTexture${e}, ${e}, ${e}, rayLengthSC, minPosSC, rayStepSC);`,`    computedColor = traverseVals[${e}];`,"//VTK::Volume::Loop"]).result)}l&&(a=cv.substitute(a,"//VTK::Volume::Loop",["    computedColor = composite(rayLengthSC, minPosSC, rayStepSC);"]).result),o.setCode(a)},t.shaderReplacements.set("replaceShaderVolume",e.replaceShaderVolume),e.updateLUTImage=n=>{let r=e.getMTime();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper().getInputData();r=Math.max(r,n.getMTime(),o.getMTime())}if(r<t.lutBuildTime.getMTime())return;t.numRows=0,t.rowStarts=[];for(let e=0;e<t.volumes.length;e++){t.rowStarts.push(t.numRows);const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents()?i:1;t.numRows+=s}const o=new Uint8ClampedArray(2*t.numRows*t.rowLength*4),a=new Float32Array(2*t.numRows*t.rowLength);let i=0;const s=new Float32Array(3*t.rowLength),l=t.rowLength;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),c=n.getProperty(),u=r.getInputData(),d=(u.getPointData()&&u.getPointData().getScalars()).getNumberOfComponents(),p=c.getIndependentComponents()?d:1;for(let e=0;e<p;++e){const n=c.getRGBTransferFunction(e),r=n.getRange();n.getTable(r[0],r[1],l,s,1);let u=i*l*4;for(let e=0;e<l;++e){o[u+4*e]=255*s[3*e],o[u+4*e+1]=255*s[3*e+1],o[u+4*e+2]=255*s[3*e+2],o[u+4*e+3]=255;for(let t=0;t<4;t++)o[u+4*(l+e)+t]=o[u+4*e+t]}const d=c.getScalarOpacity(e),p=t.sampleDist/c.getScalarOpacityUnitDistance(e),f=d.getRange();d.getTable(f[0],f[1],l,s,1),u=i*l;for(let e=0;e<l;++e)a[u+e]=1-(1-s[e])**p,a[u+e+l]=a[u+e];i+=2}}{const e={nativeArray:o,width:t.rowLength,height:2*t.numRows,depth:1,format:"rgba8unorm"},r=n.getTextureManager().getTexture(e).createView("tfunTexture");t.textureViews[2]=r}{const e={nativeArray:a,width:t.rowLength,height:2*t.numRows,depth:1,format:"r16float"},r=n.getTextureManager().getTexture(e).createView("ofunTexture");t.textureViews[3]=r}t.lutBuildTime.modified()},e.updateSSBO=n=>{let r=Math.max(e.getMTime(),t.WebGPURenderer.getStabilizedTime());for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),o=n.getMapper(),a=o.getInputData();r=Math.max(r,n.getMTime(),a.getMTime(),o.getMTime())}if(r<t.SSBO.getSendTime())return;const o=t.WebGPURenderer.getStabilizedCenterByReference();t.SSBO.clearData(),t.SSBO.setNumberOfInstances(t.volumes.length);const a=new Float64Array(16*t.volumes.length),i=new Float64Array(16*t.volumes.length),s=new Float64Array(4*t.volumes.length),l=new Float64Array(4*t.volumes.length),c=new Float64Array(4*t.volumes.length),u=new Float64Array(4*t.volumes.length);for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper().getInputData();g(_T),b(_T,_T,o);const d=n.getMatrix();m(GT,d),h(GT,GT),y(_T,GT,_T);const p=r.getWorldToIndex();y(_T,p,_T);const f=r.getDimensions();g(GT),x(GT,GT,[1/f[0],1/f[1],1/f[2]]),y(_T,GT,_T);for(let t=0;t<16;t++)a[16*e+t]=_T[t];h(_T,_T);for(let t=0;t<4;t++)i[16*e+4*t]=_T[4*t],i[16*e+4*t+1]=_T[4*t+1],i[16*e+4*t+2]=_T[4*t+2],i[16*e+4*t+3]=0;s[4*e]=1/f[0],s[4*e+1]=1/f[1],s[4*e+2]=1/f[2],s[4*e+3]=1,l[4*e]=n.getProperty().getShade()?1:0;const v=r.getSpacing();c[4*e]=v[0],c[4*e+1]=v[1],c[4*e+2]=v[2],c[4*e+3]=1;const T=t.textureViews[e+4].getTexture().getScale(),C=n.getProperty().getIpScalarRange();u[4*e]=C[0]/T,u[4*e+1]=C[1]/T,u[4*e+2]=n.getProperty().getFilterMode()}t.SSBO.addEntry("SCTCMatrix","mat4x4<f32>"),t.SSBO.addEntry("planeNormals","mat4x4<f32>"),t.SSBO.addEntry("shade","vec4<f32>"),t.SSBO.addEntry("tstep","vec4<f32>"),t.SSBO.addEntry("spacing","vec4<f32>"),t.SSBO.addEntry("ipScalarRange","vec4<f32>"),t.SSBO.setAllInstancesFromArray("SCTCMatrix",a),t.SSBO.setAllInstancesFromArray("planeNormals",i),t.SSBO.setAllInstancesFromArray("shade",l),t.SSBO.setAllInstancesFromArray("tstep",s),t.SSBO.setAllInstancesFromArray("spacing",c),t.SSBO.setAllInstancesFromArray("ipScalarRange",u),t.SSBO.send(n),t.componentSSBO.clearData(),t.componentSSBO.setNumberOfInstances(t.numRows);const d=new Float64Array(t.numRows),p=new Float64Array(t.numRows),f=new Float64Array(t.numRows),v=new Float64Array(t.numRows),T=new Float64Array(t.numRows),C=new Float64Array(t.numRows),S=new Float64Array(t.numRows),A=new Float64Array(t.numRows);let I=0;for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable(),r=n.getMapper(),o=n.getProperty(),a=r.getInputData(),i=(a.getPointData()&&a.getPointData().getScalars()).getNumberOfComponents(),s=o.getIndependentComponents(),l=t.textureViews[e+4].getTexture().getFormat(),c=bv(l),u={scale:[255],offset:[0]};2===c.elementSize&&"float"===c.sampleType&&(u.scale[0]=1);for(let e=0;e<i;e++){const t=s?e:0,n=u.scale[e],r=o.getScalarOpacity(t).getRange(),a=n/(r[1]-r[0]),i=(u.offset[e]-r[0])/(r[1]-r[0]);v[I]=i,f[I]=a;const l=o.getRGBTransferFunction(t).getRange();if(p[I]=(u.offset[e]-l[0])/(l[1]-l[0]),d[I]=n/(l[1]-l[0]),o.getUseGradientOpacity(t)){const e=o.getGradientOpacityMinimumOpacity(t),r=o.getGradientOpacityMaximumOpacity(t);T[I]=e,C[I]=r;const a=[o.getGradientOpacityMinimumValue(t),o.getGradientOpacityMaximumValue(t)];A[I]=n*(r-e)/(a[1]-a[0]),S[I]=-a[0]*(r-e)/(a[1]-a[0])+e}else T[I]=1,C[I]=1,A[I]=0,S[I]=1;I++}}t.componentSSBO.addEntry("cScale","f32"),t.componentSSBO.addEntry("cShift","f32"),t.componentSSBO.addEntry("oScale","f32"),t.componentSSBO.addEntry("oShift","f32"),t.componentSSBO.addEntry("goShift","f32"),t.componentSSBO.addEntry("goScale","f32"),t.componentSSBO.addEntry("gomin","f32"),t.componentSSBO.addEntry("gomax","f32"),t.componentSSBO.setAllInstancesFromArray("cScale",d),t.componentSSBO.setAllInstancesFromArray("cShift",p),t.componentSSBO.setAllInstancesFromArray("oScale",f),t.componentSSBO.setAllInstancesFromArray("oShift",v),t.componentSSBO.setAllInstancesFromArray("goScale",A),t.componentSSBO.setAllInstancesFromArray("goShift",S),t.componentSSBO.setAllInstancesFromArray("gomin",T),t.componentSSBO.setAllInstancesFromArray("gomax",C),t.componentSSBO.send(n)};const n=e.updateBuffers;e.updateBuffers=()=>{n();let r=t.volumes[0].getRenderable().getMapper().getSampleDistance();for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getSampleDistance();n<r&&(r=n)}t.sampleDist!==r&&(t.sampleDist=r,t.UBO.setValue("SampleDistance",r),t.UBO.sendIfNeeded(t.device));for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getInputData(),r=t.device.getTextureManager().getTextureForImageData(n);if(!t.textureViews[e+4]||t.textureViews[e+4].getTexture()!==r){const n=r.createView(`volTexture${e}`);t.textureViews[e+4]=n}}if(t.volumes.length<t.lastVolumeLength)for(let e=t.volumes.length;e<t.lastVolumeLength;e++)t.textureViews.pop();t.lastVolumeLength=t.volumes.length,e.updateLUTImage(t.device),e.updateSSBO(t.device),t.clampSampler||(t.clampSampler=zv.newInstance({label:"clampSampler"}),t.clampSampler.create(t.device,{minFilter:"linear",magFilter:"linear"}))},e.computePipelineHash=()=>{t.pipelineHash="volfsq";for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getMapper().getBlendMode();t.pipelineHash+=`${n}`}},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()};const r=e.getBindables;e.getBindables=()=>{const e=r();return e.push(t.componentSSBO),e.push(t.clampSampler),e}}(e,t)}var zT={newInstance:Ht.newInstance(UT,"vtkWebGPUVolumePassFSQ"),extend:UT};const{Representation:WT}=ts,{BufferUsage:HT,PrimitiveTypes:jT}=OT,KT=[[0,4,6],[0,6,2],[1,3,7],[1,7,5],[0,5,4],[0,1,5],[2,6,7],[2,7,3],[0,3,1],[0,2,3],[4,5,7],[4,7,6]],$T={colorTextureView:null,depthTextureView:null,volumes:null};function qT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,$T,n),Ah.extend(e,t,n),t._mapper=Vv.newInstance(),t._mapper.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Select::Dec\n\n//VTK::VolumePass::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output : fragmentOutput;\n\n  //VTK::Select::Impl\n\n  //VTK::TCoord::Impl\n\n  //VTK::VolumePass::Impl\n\n  // use the maximum (closest) of the current value and the zbuffer\n  // the blend func will then take the min to find the farthest stop value\n  var stopval: f32 = max(input.fragPos.z, textureLoad(opaquePassDepthTexture, vec2<i32>(i32(input.fragPos.x), i32(input.fragPos.y)), 0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._mapper.getShaderReplacements().set("replaceShaderVolumePass",((e,t,n)=>{t.getShaderDescription("fragment").addBuiltinInput("vec4<f32>","@builtin(position) fragPos")})),t._boundsPoly=Uc.newInstance(),t._lastMTimes=[],Ht.setGet(e,t,["colorTextureView","depthTextureView"]),function(e,t){t.classHierarchy.push("vtkWebGPUVolumePass"),e.initialize=n=>{t._clearEncoder||e.createClearEncoder(n),t._mergeEncoder||e.createMergeEncoder(n),t._copyEncoder||e.createCopyEncoder(n),t._depthRangeEncoder||e.createDepthRangeEncoder(n),t.fullScreenQuad||(t.fullScreenQuad=zT.newInstance(),t.fullScreenQuad.setDevice(n.getDevice()),t.fullScreenQuad.setTextureViews([...t._depthRangeEncoder.getColorTextureViews()])),t._volumeCopyQuad||(t._volumeCopyQuad=Bv.newInstance(),t._volumeCopyQuad.setPipelineHash("volpassfsq"),t._volumeCopyQuad.setDevice(n.getDevice()),t._volumeCopyQuad.setFragmentShaderTemplate("\n//VTK::Renderer::Dec\n\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = textureSample(volumePassColorTexture,\n    volumePassColorTextureSampler, mapperUBO.tscale*input.tcoordVS);\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._copyUBO=VT.newInstance({label:"mapperUBO"}),t._copyUBO.addEntry("tscale","vec2<f32>"),t._volumeCopyQuad.setUBO(t._copyUBO),t._volumeCopyQuad.setTextureViews([t._colorTextureView]))},e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=r,e.initialize(r),e.computeTiming(r),e.renderDepthBounds(n,r),t._firstGroup=!0;const o=r.getDevice(),a=o.getHandle().limits.maxSampledTexturesPerShaderStage-4;if(t.volumes.length>a){const o=n.getRenderable().getActiveCamera().getPosition(),i=[];for(let e=0;e<t.volumes.length;e++){const n=t.volumes[e].getRenderable().getBounds(),r=[.5*(n[1]+n[0]),.5*(n[3]+n[2]),.5*(n[5]+n[4])];i[e]=Uo(r,o)}const s=[...Array(t.volumes.length).keys()];s.sort(((e,t)=>i[t]-i[e]));let l=[],c=s.length%a;for(let o=0;o<s.length;o++)l.push(t.volumes[s[o]]),l.length>=c&&(e.rayCastPass(r,n,l),l=[],c=a,t._firstGroup=!1)}else e.rayCastPass(r,n,t.volumes);if(t._volumeCopyQuad.setWebGPURenderer(n),t._useSmallViewport){const e=t._colorTextureView.getTexture().getWidth(),n=t._colorTextureView.getTexture().getHeight();t._copyUBO.setArray("tscale",[t._smallViewportWidth/e,t._smallViewportHeight/n])}else t._copyUBO.setArray("tscale",[1,1]);t._copyUBO.sendIfNeeded(o),t._copyEncoder.setColorTextureView(0,t.colorTextureView),t._copyEncoder.attachTextureViews(),t._copyEncoder.begin(r.getCommandEncoder()),n.scissorAndViewport(t._copyEncoder),t._volumeCopyQuad.prepareAndDraw(t._copyEncoder),t._copyEncoder.end()},e.delete=Ht.chain((()=>{t._animationRateSubscription&&(t._animationRateSubscription.unsubscribe(),t._animationRateSubscription=null)}),e.delete),e.computeTiming=e=>{const n=e.getRenderable().getInteractor();if(null==t._lastScale){const e=t.volumes[0].getRenderable().getMapper();t._lastScale=e.getInitialInteractionScale()||1}t._useSmallViewport=!1,n.isAnimating()&&t._lastScale>1.5&&(t._useSmallViewport=!0),t._colorTexture.resize(e.getCanvas().width,e.getCanvas().height),t._animationRateSubscription||(t._animationRateSubscription=n.onAnimationFrameRateUpdate((()=>{const e=t.volumes[0].getRenderable().getMapper();if(e.getAutoAdjustSampleDistances()){const e=n.getRecentAnimationFrameRate(),r=t._lastScale*n.getDesiredUpdateRate()/e;t._lastScale=r,t._lastScale>400&&(t._lastScale=400)}else t._lastScale=e.getImageSampleDistance()*e.getImageSampleDistance();t._lastScale<1.5&&(t._lastScale=1.5)})))},e.rayCastPass=(e,n,r)=>{const o=t._firstGroup?t._clearEncoder:t._mergeEncoder;o.attachTextureViews(),o.begin(e.getCommandEncoder());let a=t._colorTextureView.getTexture().getWidth(),i=t._colorTextureView.getTexture().getHeight();if(t._useSmallViewport){const n=e.getCanvas(),r=1/Math.sqrt(t._lastScale);t._smallViewportWidth=Math.ceil(r*n.width),t._smallViewportHeight=Math.ceil(r*n.height),a=t._smallViewportWidth,i=t._smallViewportHeight}o.getHandle().setViewport(0,0,a,i,0,1),o.getHandle().setScissorRect(0,0,a,i),t.fullScreenQuad.setWebGPURenderer(n),t.fullScreenQuad.setVolumes(r),t.fullScreenQuad.prepareAndDraw(o),o.end()},e.renderDepthBounds=(n,r)=>{e.updateDepthPolyData(n);const o=t._boundsPoly,a=o.getPoints(),i=o.getPolys();let s={hash:`vp${i.getMTime()}`,usage:HT.Index,cells:i,numberOfPoints:a.getNumberOfPoints(),primitiveType:jT.Triangles,representation:WT.SURFACE};const l=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().setIndexBuffer(l),s={usage:HT.PointArray,format:"float32x4",hash:`vp${a.getMTime()}${i.getMTime()}`,dataArray:a,indexBuffer:l,packExtra:!0};const c=r.getDevice().getBufferManager().getBuffer(s);t._mapper.getVertexInput().addBuffer(c,["vertexBC"]),t._mapper.setNumberOfVertices(c.getSizeInBytes()/c.getStrideInBytes()),e.drawDepthRange(n,r)},e.updateDepthPolyData=e=>{let n=!1;for(let e=0;e<t.volumes.length;e++){const r=t.volumes[e].getMTime();t._lastMTimes[e]&&r===t._lastMTimes[e]||(n=!0,t._lastMTimes[e]=r)}const r=e.getStabilizedTime();if((t._lastMTimes.length<=t.volumes.length||r!==t._lastMTimes[t.volumes.length])&&(n=!0,t._lastMTimes[t.volumes.length]=r),!n)return;const o=e.getStabilizedCenterByReference(),a=8*t.volumes.length,i=new Float64Array(3*a),s=12*t.volumes.length,l=new Uint16Array(4*s);for(let e=0;e<t.volumes.length;e++){t.volumes[e].getBoundingCubePoints(i,24*e);let n=12*e*4;const r=8*e;for(let e=0;e<12;e++)l[n++]=3,l[n++]=r+KT[e][0],l[n++]=r+KT[e][1],l[n++]=r+KT[e][2]}for(let e=0;e<i.length;e+=3)i[e]-=o[0],i[e+1]-=o[1],i[e+2]-=o[2];t._boundsPoly.getPoints().setData(i,3),t._boundsPoly.getPoints().modified(),t._boundsPoly.getPolys().setData(l,1),t._boundsPoly.getPolys().modified(),t._boundsPoly.modified()},e.drawDepthRange=(n,r)=>{t._depthRangeTexture.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeTexture2.resizeToMatch(t.colorTextureView.getTexture()),t._depthRangeEncoder.attachTextureViews(),e.setCurrentOperation("volumeDepthRangePass"),n.setRenderEncoder(t._depthRangeEncoder),n.volumeDepthRangePass(!0),t._mapper.setWebGPURenderer(n),t._mapper.prepareToDraw(t._depthRangeEncoder),t._mapper.registerDrawCallback(t._depthRangeEncoder),n.volumeDepthRangePass(!1)},e.createDepthRangeEncoder=e=>{const n=e.getDevice();t._depthRangeEncoder=Gv.newInstance({label:"VolumePass DepthRange"}),t._depthRangeEncoder.setPipelineHash("volr"),t._depthRangeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor1"),t.addOutput("vec4<f32>","outColor2");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor1 = vec4<f32>(input.fragPos.z, 0.0, 0.0, 0.0);","output.outColor2 = vec4<f32>(stopval, 0.0, 0.0, 0.0);"]).result,t.setCode(n)})),t._depthRangeEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"},{view:null,clearValue:[1,1,1,1],loadOp:"clear",storeOp:"store"}]}),t._depthRangeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"max"},alpha:{srcFactor:"one",dstFactor:"one",operation:"max"}}},{format:"r16float",blend:{color:{srcFactor:"one",dstFactor:"one",operation:"min"},alpha:{srcFactor:"one",dstFactor:"one",operation:"min"}}}]}}),t._depthRangeTexture=qv.newInstance({label:"volumePassMaxDepth"}),t._depthRangeTexture.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const r=t._depthRangeTexture.createView("maxTexture");t._depthRangeEncoder.setColorTextureView(0,r),t._depthRangeTexture2=qv.newInstance({label:"volumePassDepthMin"}),t._depthRangeTexture2.create(n,{width:e.getCanvas().width,height:e.getCanvas().height,format:"r16float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING});const o=t._depthRangeTexture2.createView("minTexture");t._depthRangeEncoder.setColorTextureView(1,o),t._mapper.setDevice(e.getDevice()),t._mapper.setTextureViews([t.depthTextureView])},e.createClearEncoder=e=>{t._colorTexture=qv.newInstance({label:"volumePassColor"}),t._colorTexture.create(e.getDevice(),{width:e.getCanvas().width,height:e.getCanvas().height,format:"bgra8unorm",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.COPY_SRC}),t._colorTextureView=t._colorTexture.createView("volumePassColorTexture"),t._colorTextureView.addSampler(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._clearEncoder=Gv.newInstance({label:"VolumePass Clear"}),t._clearEncoder.setColorTextureView(0,t._colorTextureView),t._clearEncoder.setDescription({colorAttachments:[{view:null,clearValue:[0,0,0,0],loadOp:"clear",storeOp:"store"}]}),t._clearEncoder.setPipelineHash("volpf"),t._clearEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createCopyEncoder=e=>{t._copyEncoder=Gv.newInstance({label:"volumePassCopy"}),t._copyEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._copyEncoder.setPipelineHash("volcopypf"),t._copyEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"rgba16float",blend:{color:{srcFactor:"one",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.createMergeEncoder=e=>{t._mergeEncoder=Gv.newInstance({label:"volumePassMerge"}),t._mergeEncoder.setColorTextureView(0,t._colorTextureView),t._mergeEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._mergeEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<f32>","outColor");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<f32>(computedColor.rgb, computedColor.a);"]).result,t.setCode(n)})),t._mergeEncoder.setPipelineHash("volpf"),t._mergeEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:"bgra8unorm",blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}})},e.setVolumes=n=>{if(!t.volumes||t.volumes.length!==n.length)return t.volumes=[...n],void e.modified();for(let r=0;r<n.length;r++)if(n[r]!==t.volumes[r])return t.volumes=[...n],void e.modified()}}(e,t)}var XT={newInstance:Ht.newInstance(qT,"vtkWebGPUVolumePass"),extend:qT};const YT={opaqueActorCount:0,translucentActorCount:0,volumes:null,opaqueRenderEncoder:null,translucentPass:null,volumePass:null};function ZT(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,YT,n),Ah.extend(e,t,n),Ht.setGet(e,t,["opaquePass","translucentPass","volumePass"]),function(e,t){t.classHierarchy.push("vtkForwardPass"),e.traverse=function(n){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;if(t.deleted)return;t._currentParent=r,e.setCurrentOperation("buildPass"),n.traverse(e),t.opaquePass||(t.opaquePass=Zv.newInstance());const o=n.getRenderable().getNumberOfLayers(),a=n.getChildren();for(let r=0;r<o;r++)for(let o=0;o<a.length;o++){const i=a[o],s=n.getRenderable().getRenderers()[o];s.getDraw()&&s.getLayer()===r&&(t.opaqueActorCount=0,t.translucentActorCount=0,t.volumes=[],e.setCurrentOperation("queryPass"),i.traverse(e),e.setCurrentOperation("cameraPass"),i.traverse(e),t.opaquePass.traverse(i,n),t.translucentActorCount>0&&(t.translucentPass||(t.translucentPass=eT.newInstance()),t.translucentPass.setColorTextureView(t.opaquePass.getColorTextureView()),t.translucentPass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.translucentPass.traverse(i,n)),t.volumes.length>0&&(t.volumePass||(t.volumePass=XT.newInstance()),t.volumePass.setColorTextureView(t.opaquePass.getColorTextureView()),t.volumePass.setDepthTextureView(t.opaquePass.getDepthTextureView()),t.volumePass.setVolumes(t.volumes),t.volumePass.traverse(i,n)),e.finalPass(n,i))}},e.finalPass=(n,r)=>{t._finalBlitEncoder||e.createFinalBlitEncoder(n),t._finalBlitOutputTextureView.createFromTextureHandle(n.getCurrentTexture(),{depth:1,format:n.getPresentationFormat()}),t._finalBlitEncoder.attachTextureViews(),t._finalBlitEncoder.begin(n.getCommandEncoder()),r.scissorAndViewport(t._finalBlitEncoder),t._fullScreenQuad.prepareAndDraw(t._finalBlitEncoder),t._finalBlitEncoder.end()},e.createFinalBlitEncoder=e=>{t._finalBlitEncoder=Gv.newInstance({label:"forwardPassBlit"}),t._finalBlitEncoder.setDescription({colorAttachments:[{view:null,loadOp:"load",storeOp:"store"}]}),t._finalBlitEncoder.setPipelineHash("fpf"),t._finalBlitEncoder.setPipelineSettings({primitive:{cullMode:"none"},fragment:{targets:[{format:e.getPresentationFormat(),blend:{color:{srcFactor:"src-alpha",dstFactor:"one-minus-src-alpha"},alpha:{srcFactor:"one",dstFactor:"one-minus-src-alpha"}}}]}}),t._fsqSampler=zv.newInstance({label:"finalPassSampler"}),t._fsqSampler.create(e.getDevice(),{minFilter:"linear",magFilter:"linear"}),t._fullScreenQuad=Bv.newInstance(),t._fullScreenQuad.setDevice(e.getDevice()),t._fullScreenQuad.setPipelineHash("fpfsq"),t._fullScreenQuad.setTextureViews([t.opaquePass.getColorTextureView()]),t._fullScreenQuad.setAdditionalBindables([t._fsqSampler]),t._fullScreenQuad.setFragmentShaderTemplate("\n//VTK::Mapper::Dec\n\n//VTK::TCoord::Dec\n\n//VTK::RenderEncoder::Dec\n\n//VTK::IOStructs::Dec\n\n@fragment\nfn main(\n//VTK::IOStructs::Input\n)\n//VTK::IOStructs::Output\n{\n  var output: fragmentOutput;\n\n  var computedColor: vec4<f32> = clamp(textureSampleLevel(opaquePassColorTexture, finalPassSampler, input.tcoordVS, 0.0),vec4<f32>(0.0),vec4<f32>(1.0));\n\n  //VTK::RenderEncoder::Impl\n  return output;\n}\n"),t._finalBlitOutputTextureView=jv.newInstance(),t._finalBlitEncoder.setColorTextureView(0,t._finalBlitOutputTextureView)},e.incrementOpaqueActorCount=()=>t.opaqueActorCount++,e.incrementTranslucentActorCount=()=>t.translucentActorCount++,e.addVolume=e=>{t.volumes.push(e)}}(e,t)}var QT={newInstance:Ht.newInstance(ZT,"vtkForwardPass"),extend:ZT};const{VtkDataTypes:JT}=Ts,ey={handle:null,device:null};function ty(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ey,n),Ht.obj(e,t),Ht.setGet(e,t,["device"]),function(e,t){function n(e){if(e.imageData){e.dataArray=e.imageData.getPointData().getScalars(),e.time=e.dataArray.getMTime(),e.nativeArray=e.dataArray.getData();const t=e.imageData.getDimensions();switch(e.width=t[0],e.height=t[1],e.depth=t[2],e.dataArray.getNumberOfComponents()){case 1:e.format="r";break;case 2:e.format="rg";break;default:e.format="rgba"}switch(e.dataArray.getDataType()){case JT.UNSIGNED_CHAR:e.format+="8unorm";break;case JT.FLOAT:case JT.UNSIGNED_INT:case JT.INT:case JT.DOUBLE:case JT.UNSIGNED_SHORT:case JT.SHORT:default:e.format+="16float"}}e.image&&(e.width=e.image.width,e.height=e.image.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.jsImageData&&(e.width=e.jsImageData.width,e.height=e.jsImageData.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.nativeArray=e.jsImageData.data,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.imageBitmap&&(e.width=e.imageBitmap.width,e.height=e.imageBitmap.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT),e.canvas&&(e.width=e.canvas.width,e.height=e.canvas.height,e.depth=1,e.format="rgba8unorm",e.flip=!0,e.usage=GPUTextureUsage.STORAGE_BINDING|GPUTextureUsage.COPY_DST|GPUTextureUsage.TEXTURE_BINDING|GPUTextureUsage.RENDER_ATTACHMENT)}function r(e){const n=qv.newInstance({label:e.label});return n.create(t.device,{width:e.width,height:e.height,depth:e.depth,format:e.format,usage:e.usage,mipLevel:e.mipLevel}),(e.nativeArray||e.image||e.canvas||e.imageBitmap)&&n.writeImageData(e),n}t.classHierarchy.push("vtkWebGPUTextureManager"),e.getTexture=e=>e.hash?t.device.getCachedObject(e.hash,r,e):r(e),e.getTextureForImageData=e=>{const r={time:e.getMTime()};return r.imageData=e,n(r),r.hash=r.time+r.format+r.mipLevel,t.device.getTextureManager().getTexture(r)},e.getTextureForVTKTexture=function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0;const o={time:e.getMTime(),label:r};return e.getInputData()?o.imageData=e.getInputData():e.getImage()?o.image=e.getImage():e.getJsImageData()?o.jsImageData=e.getJsImageData():e.getImageBitmap()?o.imageBitmap=e.getImageBitmap():e.getCanvas()&&(o.canvas=e.getCanvas()),n(o),o.mipLevel=e.getMipLevel(),o.hash=o.time+o.format+o.mipLevel,t.device.getTextureManager().getTexture(o)}}(e,t)}var ny={newInstance:Ht.newInstance(ty),extend:ty};class ry extends Map{constructor(){super(),this.registry=new FinalizationRegistry((e=>{const t=super.get(e);t&&t.deref&&void 0===t.deref()&&super.delete(e)}))}getValue(e){const t=super.get(e);if(t){const n=t.deref();if(void 0!==n)return n;super.delete(e)}}setValue(e,t){let n;return t&&"object"==typeof t&&(n=new WeakRef(t),this.registry.register(t,e),super.set(e,n)),n}}const oy={handle:null,pipelines:null,shaderCache:null,bindGroupLayouts:null,bufferManager:null,textureManager:null};function ay(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,oy,n),vt(e,t),St(e,t,["handle"]),yt(e,t,["bufferManager","shaderCache","textureManager"]),t.objectCache=new ry,t.shaderCache=cv.newInstance(),t.shaderCache.setDevice(e),t.bindGroupLayouts=[],t.bufferManager=OT.newInstance(),t.bufferManager.setDevice(e),t.textureManager=ny.newInstance(),t.textureManager.setDevice(e),t.pipelines={},function(e,t){t.classHierarchy.push("vtkWebGPUDevice"),e.initialize=e=>{t.handle=e},e.createCommandEncoder=()=>t.handle.createCommandEncoder(),e.submitCommandEncoder=e=>{t.handle.queue.submit([e.finish()])},e.getShaderModule=e=>t.shaderCache.getShaderModule(e),e.getBindGroupLayout=e=>{if(!e.entries)return null;for(let t=0;t<e.entries.length;t++){const n=e.entries[t];n.binding=n.binding||0,n.visibility=n.visibility||GPUShaderStage.VERTEX|GPUShaderStage.FRAGMENT}const n=JSON.stringify(e);for(let e=0;e<t.bindGroupLayouts.length;e++)if(t.bindGroupLayouts[e].sval===n)return t.bindGroupLayouts[e].layout;const r=t.handle.createBindGroupLayout(e);return t.bindGroupLayouts.push({sval:n,layout:r}),r},e.getBindGroupLayoutDescription=e=>{for(let n=0;n<t.bindGroupLayouts.length;n++)if(t.bindGroupLayouts[n].layout===e)return t.bindGroupLayouts[n].sval;return vtkErrorMacro("layout not found"),console.trace(),null},e.getPipeline=e=>e in t.pipelines?t.pipelines[e]:null,e.createPipeline=(n,r)=>{r.initialize(e,n),t.pipelines[n]=r},e.onSubmittedWorkDone=()=>t.handle.queue.onSubmittedWorkDone(),e.hasCachedObject=e=>t.objectCache.getValue(e),e.getCachedObject=function(e,n){if(!e)return vtkErrorMacro("attempt to cache an object without a hash"),null;const r=t.objectCache.getValue(e);if(r)return r;for(var o=arguments.length,a=new Array(o>2?o-2:0),i=2;i<o;i++)a[i-2]=arguments[i];const s=n(...a);return t.objectCache.setValue(e,s),s}}(e,t)}var iy={newInstance:Et(ay,"vtkWebGPUDevice"),extend:ay};const sy={selectionRenderEncoder:null,colorTexture:null,depthTexture:null};function ly(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,sy,n),Ah.extend(e,t,n),Ht.get(e,t,["colorTexture","depthTexture"]),function(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelectionPass"),e.traverse=(n,r)=>{if(t.deleted)return;t._currentParent=null,e.setCurrentOperation("buildPass"),n.traverse(e);const o=n.getDevice();if(t.selectionRenderEncoder)t.colorTexture.resize(n.getCanvas().width,n.getCanvas().height),t.depthTexture.resizeToMatch(t.colorTexture);else{e.createRenderEncoder(),t.colorTexture=qv.newInstance({label:"hardwareSelectorColor"}),t.colorTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"rgba32uint",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const r=t.colorTexture.createView("hardwareSelectColorTexture");t.selectionRenderEncoder.setColorTextureView(0,r),t.depthTexture=qv.newInstance({label:"hardwareSelectorDepth"}),t.depthTexture.create(o,{width:n.getCanvas().width,height:n.getCanvas().height,format:"depth32float",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_SRC});const a=t.depthTexture.createView("hardwareSelectDepthTexture");t.selectionRenderEncoder.setDepthTextureView(a)}t.selectionRenderEncoder.attachTextureViews(),r.setRenderEncoder(t.selectionRenderEncoder),e.setCurrentOperation("cameraPass"),r.traverse(e),e.setCurrentOperation("opaquePass"),r.traverse(e)},e.createRenderEncoder=()=>{t.selectionRenderEncoder=Gv.newInstance({label:"HardwareSelectionPass"}),t.selectionRenderEncoder.setPipelineHash("sel"),t.selectionRenderEncoder.setReplaceShaderCodeFunction((e=>{const t=e.getShaderDescription("fragment");t.addOutput("vec4<u32>","outColor");let n=t.getCode();n=cv.substitute(n,"//VTK::RenderEncoder::Impl",["output.outColor = vec4<u32>(mapperUBO.PropID, compositeID, 0u, 0u);"]).result,t.setCode(n)})),t.selectionRenderEncoder.getDescription().colorAttachments[0].clearValue=[0,0,0,0],t.selectionRenderEncoder.setPipelineSettings({primitive:{cullMode:"none"},depthStencil:{depthWriteEnabled:!0,depthCompare:"greater",format:"depth32float"},fragment:{targets:[{format:"rgba32uint",blend:void 0}]}})}}(e,t)}var cy={newInstance:Ht.newInstance(ly,"vtkWebGPUHardwareSelectionPass"),extend:ly};const{SelectionContent:uy,SelectionField:dy}=Zd,{FieldAssociations:py}=_s,{vtkErrorMacro:fy}=Ht;function gy(e){return`${e.propID} ${e.compositeID}`}function my(e,t,n,r){const o=4*((n.height-t-1)*n.colorBufferWidth+e)+r;return n.colorValues[o]}function hy(e,t,n,r){const o=n<0?0:n;if(0===o){if(r[0]=t[0],r[1]=t[1],t[0]<0||t[0]>=e.width||t[1]<0||t[1]>=e.height)return null;const n=my(t[0],t[1],e,0);if(n<=0)return null;const o={};o.propID=n;let a=my(t[0],t[1],e,1);if((a<0||a>16777215)&&(a=0),o.compositeID=a,e.captureZValues){const n=(e.height-t[1]-1)*e.zbufferBufferWidth+t[0];o.zValue=e.depthValues[n],o.zValue=e.webGPURenderer.convertToOpenGLDepth(o.zValue),o.displayPosition=t}return o}const a=[t[0],t[1]],i=[0,0];let s=hy(e,t,0,r);if(s)return s;for(let t=1;t<o;++t){for(let n=a[1]>t?a[1]-t:0;n<=a[1]+t;++n){if(i[1]=n,a[0]>=t&&(i[0]=a[0]-t,s=hy(e,i,0,r),s))return s;if(i[0]=a[0]+t,s=hy(e,i,0,r),s)return s}for(let n=a[0]>=t?a[0]-(t-1):0;n<=a[0]+(t-1);++n){if(i[0]=n,a[1]>=t&&(i[1]=a[1]-t,s=hy(e,i,0,r),s))return s;if(i[1]=a[1]+t,s=hy(e,i,0,r),s)return s}}return r[0]=t[0],r[1]=t[1],null}const vy={};function Ty(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,vy,n),jd.extend(e,t,n),t._selectionPass=cy.newInstance(),Ht.setGet(e,t,["_WebGPURenderWindow"]),Ht.moveToProtected(e,t,["WebGPURenderWindow"]),function(e,t){t.classHierarchy.push("vtkWebGPUHardwareSelector"),e.endSelection=()=>{t.WebGPURenderer.setSelector(null)},e.getSourceDataAsync=async e=>{if(!e||!t._WebGPURenderWindow)return fy("Renderer and view must be set before calling Select."),!1;t._WebGPURenderWindow.getRenderable().preRender(),t._WebGPURenderWindow.getInitialized()||(t._WebGPURenderWindow.initialize(),await new Promise((e=>{t._WebGPURenderWindow.onInitialized(e)})));const n=t._WebGPURenderWindow.getViewNodeFor(e);if(!n)return!1;const r=n.getSuppressClear();n.setSuppressClear(!0),t._selectionPass.traverse(t._WebGPURenderWindow,n),n.setSuppressClear(r);const o=t._WebGPURenderWindow.getDevice(),a=t._selectionPass.getColorTexture(),i=t._selectionPass.getDepthTexture(),s={area:[0,0,a.getWidth()-1,a.getHeight()-1],captureZValues:t.captureZValues,fieldAssociation:t.fieldAssociation,renderer:e,webGPURenderer:n,webGPURenderWindow:t._WebGPURenderWindow,width:a.getWidth(),height:a.getHeight()};s.colorBufferWidth=16*Math.floor((s.width+15)/16),s.colorBufferSizeInBytes=s.colorBufferWidth*s.height*4*4;const l=aT.newInstance({label:"hardwareSelectColorBuffer"});l.setDevice(o),l.create(s.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const c=t._WebGPURenderWindow.getCommandEncoder();let u;c.copyTextureToBuffer({texture:a.getHandle()},{buffer:l.getHandle(),bytesPerRow:16*s.colorBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1}),t.captureZValues&&(s.zbufferBufferWidth=64*Math.floor((s.width+63)/64),u=aT.newInstance({label:"hardwareSelectDepthBuffer"}),u.setDevice(o),s.zbufferSizeInBytes=s.height*s.zbufferBufferWidth*4,u.create(s.zbufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST),c.copyTextureToBuffer({texture:i.getHandle(),aspect:"depth-only"},{buffer:u.getHandle(),bytesPerRow:4*s.zbufferBufferWidth,rowsPerImage:s.height},{width:s.width,height:s.height,depthOrArrayLayers:1})),o.submitCommandEncoder(c);const d=l.mapAsync(GPUMapMode.READ);if(t.captureZValues){const e=u.mapAsync(GPUMapMode.READ);await Promise.all([d,e]),s.depthValues=new Float32Array(u.getMappedRange().slice()),u.unmap()}else await d;return s.colorValues=new Uint32Array(l.getMappedRange().slice()),l.unmap(),s.generateSelection=(e,t,n,r)=>function(e,t,n,r,o){const a=Math.floor(t),i=Math.floor(n),s=Math.floor(r),l=Math.floor(o),c=new Map,u=[0,0];for(let t=i;t<=l;t++)for(let n=a;n<=s;n++){const r=hy(e,[n,t],0,u);if(r){const t=gy(r);if(c.has(t)){const n=c.get(t);n.pixelCount++,e.captureZValues&&r.zValue<n.info.zValue&&(n.info=r),-1===n.attributeIDs.indexOf(r.attributeID)&&n.attributeIDs.push(r.attributeID)}else c.set(t,{info:r,pixelCount:1,attributeIDs:[r.attributeID]})}}return function(e,t,n){const r=[];let o=0;return t.forEach(((t,a)=>{const i=Zd.newInstance();switch(i.setContentType(uy.INDICES),e){case py.FIELD_ASSOCIATION_CELLS:i.setFieldType(dy.CELL);break;case py.FIELD_ASSOCIATION_POINTS:i.setFieldType(dy.POINT);break;default:fy("Unknown field association")}i.getProperties().propID=t.info.propID;const s=n.webGPURenderer.getPropFromID(t.info.propID);i.getProperties().prop=s.getRenderable(),i.getProperties().compositeID=t.info.compositeID,i.getProperties().pixelCount=t.pixelCount,n.captureZValues&&(i.getProperties().displayPosition=[t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue],i.getProperties().worldPosition=n.webGPURenderWindow.displayToWorld(t.info.displayPosition[0],t.info.displayPosition[1],t.info.zValue,n.renderer)),i.setSelectionList(t.attributeIDs),r[o]=i,o++})),r}(e.fieldAssociation,c,e)}(s,e,t,n,r),s}}(e,t)}var yy={newInstance:Ht.newInstance(Ty,"vtkWebGPUHardwareSelector"),extend:Ty};const by=Object.create(null),xy={};function Cy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,xy,n),t.overrides=by,Qt.extend(e,t,n),function(e,t){t.classHierarchy.push("vtkWebGPUViewNodeFactory")}(0,t)}var Sy={newInstance:Ht.newInstance(Cy,"vtkWebGPUViewNodeFactory"),extend:Cy};const{vtkErrorMacro:Ay}=Ht,Iy={position:"absolute",top:0,left:0,width:"100%",height:"100%"};const wy={initialized:!1,context:null,adapter:null,device:null,canvas:null,cursorVisibility:!0,cursor:"pointer",containerSize:null,renderPasses:[],notifyStartCaptureImage:!1,imageFormat:"image/png",useOffScreen:!1,useBackgroundImage:!1,nextPropID:1,xrSupported:!1,presentationFormat:null};const Oy=Ht.newInstance((function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,wy,n),t.canvas=document.createElement("canvas"),t.canvas.style.width="100%",t.bgImage=new Image,t.bgImage.style.position="absolute",t.bgImage.style.left="0",t.bgImage.style.top="0",t.bgImage.style.width="100%",t.bgImage.style.height="100%",t.bgImage.style.zIndex="-1",Kh.extend(e,t,n),t.myFactory=Sy.newInstance(),t.renderPasses[0]=QT.newInstance(),t.selector||(t.selector=yy.newInstance(),t.selector.setWebGPURenderWindow(e)),Ht.event(e,t,"imageReady"),Ht.event(e,t,"initialized"),Ht.get(e,t,["commandEncoder","device","presentationFormat","useBackgroundImage","xrSupported"]),Ht.setGet(e,t,["initialized","context","canvas","device","renderPasses","notifyStartCaptureImage","cursor","useOffScreen"]),Ht.setGetArray(e,t,["size"],2),Ht.event(e,t,"windowResizeEvent"),function(e,t){t.classHierarchy.push("vtkWebGPURenderWindow"),e.getViewNodeFactory=()=>t.myFactory;const n=[0,0];e.onModified((function(){t.renderable&&(t.size[0]===n[0]&&t.size[1]===n[1]||(n[0]=t.size[0],n[1]=t.size[1],t.canvas.setAttribute("width",t.size[0]),t.canvas.setAttribute("height",t.size[1]),e.recreateSwapChain())),t.viewStream&&t.viewStream.setSize(t.size[0],t.size[1]),t.canvas.style.display=t.useOffScreen?"none":"block",t.el&&(t.el.style.cursor=t.cursorVisibility?t.cursor:"none"),t.containerSize=null})),e.recreateSwapChain=()=>{t.context&&(t.context.unconfigure(),t.presentationFormat=navigator.gpu.getPreferredCanvasFormat(t.adapter),t.context.configure({device:t.device.getHandle(),format:t.presentationFormat,alphaMode:"premultiplied",usage:GPUTextureUsage.RENDER_ATTACHMENT|GPUTextureUsage.COPY_DST,width:t.size[0],height:t.size[1]}),t._configured=!0)},e.getCurrentTexture=()=>t.context.getCurrentTexture(),e.buildPass=n=>{if(n){if(!t.renderable)return;e.prepareNodes(),e.addMissingNodes(t.renderable.getRenderersByReference()),e.removeUnusedNodes(),e.initialize()}else t.initialized&&(t._configured||e.recreateSwapChain(),t.commandEncoder=t.device.createCommandEncoder())},e.initialize=()=>{if(!t.initializing){if(t.initializing=!0,!navigator.gpu)return void Ay("WebGPU is not enabled.");e.create3DContextAsync().then((()=>{t.initialized=!0,t.deleted||e.invokeInitialized()}))}},e.setContainer=n=>{t.el&&t.el!==n&&(t.canvas.parentNode!==t.el&&Ay("Error: canvas parent node does not match container"),t.el.removeChild(t.canvas),t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)),t.el!==n&&(t.el=n,t.el&&(t.el.appendChild(t.canvas),t.useBackgroundImage&&t.el.appendChild(t.bgImage)),e.modified())},e.getContainer=()=>t.el,e.getContainerSize=()=>{if(!t.containerSize&&t.el){const{width:e,height:n}=t.el.getBoundingClientRect();t.containerSize=[e,n]}return t.containerSize||t.size},e.getFramebufferSize=()=>t.size,e.create3DContextAsync=async()=>{t.adapter=await navigator.gpu.requestAdapter({powerPreference:"high-performance"}),t.deleted||(t.device=iy.newInstance(),t.device.initialize(await t.adapter.requestDevice()),t.deleted?t.device=null:t.context=t.canvas.getContext("webgpu"))},e.releaseGraphicsResources=()=>{const n=Ah.newInstance();n.setCurrentOperation("Release"),n.traverse(e,null),t.adapter=null,t.device=null,t.context=null,t.initialized=!1,t.initializing=!1},e.setBackgroundImage=e=>{t.bgImage.src=e.src},e.setUseBackgroundImage=e=>{t.useBackgroundImage=e,t.useBackgroundImage&&!t.el.contains(t.bgImage)?t.el.appendChild(t.bgImage):!t.useBackgroundImage&&t.el.contains(t.bgImage)&&t.el.removeChild(t.bgImage)},e.captureNextImage=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"image/png",{resetCamera:r=!1,size:o=null,scale:a=1}=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};if(t.deleted)return null;t.imageFormat=n;const i=t.notifyStartCaptureImage;return t.notifyStartCaptureImage=!0,t._screenshot={size:o||1!==a?o||t.size.map((e=>e*a)):null},new Promise(((n,o)=>{const a=e.onImageReady((o=>{if(null===t._screenshot.size)t.notifyStartCaptureImage=i,a.unsubscribe(),t._screenshot.placeHolder&&(t.size=t._screenshot.originalSize,e.modified(),t._screenshot.cameras&&t._screenshot.cameras.forEach((e=>{let{restoreParamsFn:t,arg:n}=e;return t(n)})),e.traverseAllPasses(),t.el.removeChild(t._screenshot.placeHolder),t._screenshot.placeHolder.remove(),t._screenshot=null),n(o);else{const n=document.createElement("img");if(n.style=Iy,n.src=o,t._screenshot.placeHolder=t.el.appendChild(n),t.canvas.style.display="none",t._screenshot.originalSize=t.size,t.size=t._screenshot.size,t._screenshot.size=null,e.modified(),r){const e=!0!==r;t._screenshot.cameras=t.renderable.getRenderers().map((t=>{const n=t.getActiveCamera(),o=n.get("focalPoint","position","parallelScale");return{resetCameraArgs:e?{renderer:t}:void 0,resetCameraFn:e?r:t.resetCamera,restoreParamsFn:n.set,arg:JSON.parse(JSON.stringify(o))}})),t._screenshot.cameras.forEach((e=>{let{resetCameraFn:t,resetCameraArgs:n}=e;return t(n)}))}e.traverseAllPasses()}}))}))},e.traverseAllPasses=()=>{if(!t.deleted)if(t.initialized){if(t.renderPasses)for(let n=0;n<t.renderPasses.length;++n)t.renderPasses[n].traverse(e,null);t.commandEncoder&&(t.device.submitCommandEncoder(t.commandEncoder),t.commandEncoder=null,t.notifyStartCaptureImage&&t.device.onSubmittedWorkDone().then((()=>{!async function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.imageFormat;const r=document.createElement("canvas"),o=r.getContext("2d");r.width=t.canvas.width,r.height=t.canvas.height;const a=await e.getPixelsAsync(),i=new ImageData(a.colorValues,a.width,a.height);o.putImageData(i,0,0);const s=t.canvas.getBoundingClientRect();t.renderable.getRenderers().forEach((e=>{e.getViewProps().forEach((e=>{if(e.getContainer){const t=e.getContainer().getElementsByTagName("canvas");for(let e=0;e<t.length;e++){const n=t[e],r=n.getBoundingClientRect(),a=r.x-s.x,i=r.y-s.y;o.drawImage(n,a,i)}}}))}));const l=r.toDataURL(n);r.remove(),e.invokeImageReady(l)}()})))}else{e.initialize();const t=e.onInitialized((()=>{t.unsubscribe(),e.traverseAllPasses()}))}},e.setViewStream=n=>t.viewStream!==n&&(t.subscription&&(t.subscription.unsubscribe(),t.subscription=null),t.viewStream=n,t.viewStream&&(t.renderable.getRenderers()[0].getBackgroundByReference()[3]=0,e.setUseBackgroundImage(!0),t.subscription=t.viewStream.onImageReady((t=>e.setBackgroundImage(t.image))),t.viewStream.setSize(t.size[0],t.size[1]),t.viewStream.invalidateCache(),t.viewStream.render(),e.modified()),!0),e.getUniquePropID=()=>t.nextPropID++,e.getPropFromID=e=>{for(let n=0;n<t.children.length;n++){const r=t.children[n].getPropFromID(e);if(null!==r)return r}return null},e.getPixelsAsync=async()=>{const e=t.device,n=t.renderPasses[0].getOpaquePass().getColorTexture(),r={width:n.getWidth(),height:n.getHeight()};r.colorBufferWidth=32*Math.floor((r.width+31)/32),r.colorBufferSizeInBytes=r.colorBufferWidth*r.height*8;const o=aT.newInstance();o.setDevice(e),o.create(r.colorBufferSizeInBytes,GPUBufferUsage.MAP_READ|GPUBufferUsage.COPY_DST);const a=t.device.createCommandEncoder();a.copyTextureToBuffer({texture:n.getHandle()},{buffer:o.getHandle(),bytesPerRow:8*r.colorBufferWidth,rowsPerImage:r.height},{width:r.width,height:r.height,depthOrArrayLayers:1}),e.submitCommandEncoder(a);const i=o.mapAsync(GPUMapMode.READ);await i,r.colorValues=new Uint16Array(o.getMappedRange().slice()),o.unmap();const s=new Uint8ClampedArray(r.height*r.width*4);for(let e=0;e<r.height;e++)for(let t=0;t<r.width;t++){const n=4*(e*r.width+t),o=4*(e*r.colorBufferWidth+t);s[n]=255*Uu.fromHalf(r.colorValues[o]),s[n+1]=255*Uu.fromHalf(r.colorValues[o+1]),s[n+2]=255*Uu.fromHalf(r.colorValues[o+2]),s[n+3]=255*Uu.fromHalf(r.colorValues[o+3])}return r.colorValues=s,r},e.createSelector=()=>{const t=yy.newInstance();return t.setWebGPURenderWindow(e),t};const r=e.setSize;e.setSize=(t,n)=>{const o=r(t,n);return o&&e.invokeWindowResizeEvent({width:t,height:n}),o},e.delete=Ht.chain(e.delete,e.setViewStream)}(e,t)}),"vtkWebGPURenderWindow");var Py;Nm("WebGPU",Oy),Py=Oy,by.vtkRenderWindow=Py;const Ry=xh(),My={margin:"0",padding:"0",position:"absolute",top:"0",left:"0",width:"100%",height:"100%",overflow:"hidden"},Ey={position:"absolute",left:"25px",top:"25px",backgroundColor:"white",borderRadius:"5px",listStyle:"none",padding:"5px 10px",margin:"0",display:"block",border:"solid 1px black",maxWidth:"calc(100% - 70px)",maxHeight:"calc(100% - 60px)",overflow:"auto"};function Vy(e,t){Object.keys(t).forEach((n=>{e.style[n]=t[n]}))}const Dy={background:[.32,.34,.43],containerStyle:null,controlPanelStyle:null,listenWindowResize:!0,resizeCallback:null,controllerVisibility:!0};function Ly(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Dy,n),Ht.obj(e,t),Ht.get(e,t,["renderWindow","renderer","apiSpecificRenderWindow","interactor","rootContainer","container","controlContainer"]),function(e,t){t.classHierarchy.push("vtkFullScreenRenderWindow");const n=document.querySelector("body");function r(t){"c"===String.fromCharCode(t.charCode)&&e.toggleControllerVisibility()}t.rootContainer||(t.rootContainer=n),t.container||(t.container=document.createElement("div"),Vy(t.container,t.containerStyle||My),t.rootContainer.appendChild(t.container)),t.rootContainer===n&&(document.documentElement.style.height="100%",n.style.height="100%",n.style.padding="0",n.style.margin="0"),t.renderWindow=km.newInstance(),t.renderer=Lm.newInstance(),t.renderWindow.addRenderer(t.renderer),t.apiSpecificRenderWindow=t.renderWindow.newAPISpecificView(Ry.viewAPI??t.defaultViewAPI),t.apiSpecificRenderWindow.setContainer(t.container),t.renderWindow.addView(t.apiSpecificRenderWindow),t.interactor=rh.newInstance(),t.interactor.setInteractorStyle(Th.newInstance()),t.interactor.setView(t.apiSpecificRenderWindow),t.interactor.initialize(),t.interactor.bindEvents(t.container),e.setBackground=t.renderer.setBackground,e.removeController=()=>{const e=t.controlContainer;e&&e.parentNode.removeChild(e)},e.setControllerVisibility=e=>{t.controllerVisibility=e,t.controlContainer&&(t.controlContainer.style.display=e?"block":"none")},e.toggleControllerVisibility=()=>{e.setControllerVisibility(!t.controllerVisibility)},e.addController=n=>{t.controlContainer=document.createElement("div"),Vy(t.controlContainer,t.controlPanelStyle||Ey),t.rootContainer.appendChild(t.controlContainer),t.controlContainer.innerHTML=n,e.setControllerVisibility(t.controllerVisibility),t.rootContainer.addEventListener("keypress",r)},e.setBackground(...t.background),e.addRepresentation=e=>{e.getActors().forEach((e=>{t.renderer.addActor(e)}))},e.removeRepresentation=e=>{e.getActors().forEach((e=>t.renderer.removeActor(e)))},e.delete=Ht.chain(e.setContainer,t.apiSpecificRenderWindow.delete,(()=>{t.rootContainer?.removeEventListener("keypress",r),window.removeEventListener("resize",e.resize)}),e.delete),e.resize=()=>{const e=t.container.getBoundingClientRect(),n=window.devicePixelRatio||1;t.apiSpecificRenderWindow.setSize(Math.floor(e.width*n),Math.floor(e.height*n)),t.resizeCallback&&t.resizeCallback(e),t.renderWindow.render()},e.setResizeCallback=n=>{t.resizeCallback=n,e.resize()},t.listenWindowResize&&window.addEventListener("resize",e.resize),e.resize()}(e,t)}var By={newInstance:Ht.newInstance(Ly),extend:Ly},Ny={ColorSpace:{RGB:0,HSV:1,LAB:2,DIVERGING:3},Scale:{LINEAR:0,LOG10:1}};const{ColorSpace:Fy,Scale:_y}=Ny,{ScalarMappingTarget:Gy}=il,{vtkDebugMacro:ky,vtkErrorMacro:Uy,vtkWarningMacro:zy}=Ht;function Wy(e,t){const n=e[0],r=e[1],o=e[2],a=Math.sqrt(n*n+r*r+o*o),i=a>.001?Math.acos(n/a):0,s=i>.001?Math.atan2(o,r):0;t[0]=a,t[1]=i,t[2]=s}function Hy(e,t){if(e[0]>=t-.1)return e[2];const n=e[1]*Math.sqrt(t*t-e[0]*e[0])/(e[0]*Math.sin(e[1]));return e[2]>-.3*Math.PI?e[2]+n:e[2]-n}function jy(e,t,n,r){const o=[],a=[];va(t,o),va(n,a);const i=[],s=[];Wy(o,i),Wy(a,s);let l=e;if(i[1]>.05&&s[1]>.05&&function(e,t){let n=e-t;for(n<0&&(n=-n);n>=2*Math.PI;)n-=2*Math.PI;return n>Math.PI&&(n=2*Math.PI-n),n}(i[2],s[2])>.33*Math.PI){let t=Math.max(i[0],s[0]);t=Math.max(88,t),e<.5?(s[0]=t,s[1]=0,s[2]=0,l*=2):(i[0]=t,i[1]=0,i[2]=0,l=2*l-1)}i[1]<.05&&s[1]>.05?i[2]=Hy(s,i[0]):s[1]<.05&&i[1]>.05&&(s[2]=Hy(i,s[0]));const c=[];c[0]=(1-l)*i[0]+l*s[0],c[1]=(1-l)*i[1]+l*s[1],c[2]=(1-l)*i[2]+l*s[2];const u=[];!function(e,t){const n=e[0],r=e[1],o=e[2];t[0]=n*Math.cos(r),t[1]=n*Math.sin(r)*Math.cos(o),t[2]=n*Math.sin(r)*Math.sin(o)}(c,u),Ta(u,r)}const Ky={clamping:!0,colorSpace:Fy.RGB,hSVWrap:!0,scale:_y.LINEAR,nanColor:null,belowRangeColor:null,aboveRangeColor:null,useAboveRangeColor:!1,useBelowRangeColor:!1,allowDuplicateScalars:!1,table:null,tableSize:0,buildTime:null,nodes:null,discretize:!1,numberOfValues:256};function $y(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ky,n),il.extend(e,t,n),t.table=[],t.nodes=[],t.nanColor=[.5,0,0,1],t.belowRangeColor=[0,0,0,1],t.aboveRangeColor=[1,1,1,1],t.buildTime={},Ht.obj(t.buildTime),Ht.get(e,t,["buildTime","mappingRange"]),Ht.setGet(e,t,["useAboveRangeColor","useBelowRangeColor","discretize","numberOfValues",{type:"enum",name:"colorSpace",enum:Fy},{type:"enum",name:"scale",enum:_y}]),Ht.setArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"],4),Ht.getArray(e,t,["nanColor","belowRangeColor","aboveRangeColor"]),function(e,t){t.classHierarchy.push("vtkColorTransferFunction"),e.getSize=()=>t.nodes.length,e.addRGBPoint=(t,n,r,o)=>e.addRGBPointLong(t,n,r,o,.5,0),e.addRGBPointLong=function(n,r,o,a){let i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;if(i<0||i>1)return Uy("Midpoint outside range [0.0, 1.0]"),-1;if(s<0||s>1)return Uy("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const l={x:n,r:r,g:o,b:a,midpoint:i,sharpness:s};t.nodes.push(l),e.sortAndUpdateRange();let c=0;for(;c<t.nodes.length&&t.nodes[c].x!==n;c++);return c<t.nodes.length?c:-1},e.addHSVPoint=(t,n,r,o)=>e.addHSVPointLong(t,n,r,o,.5,0),e.addHSVPointLong=function(t,n,r,o){let a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5,i=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const s=[];return pa([n,r,o],s),e.addRGBPoint(t,s[0],s[1],s[2],a,i)},e.setNodes=n=>{if(t.nodes!==n){const r=JSON.stringify(t.nodes);t.nodes=n;const o=JSON.stringify(t.nodes);if(e.sortAndUpdateRange()||r!==o)return e.modified(),!0}return!1},e.sortAndUpdateRange=()=>{const n=JSON.stringify(t.nodes);t.nodes.sort(((e,t)=>e.x-t.x));const r=JSON.stringify(t.nodes),o=e.updateRange();return o||n===r?o:(e.modified(),!0)},e.updateRange=()=>{const n=[2];n[0]=t.mappingRange[0],n[1]=t.mappingRange[1];const r=t.nodes.length;return r?(t.mappingRange[0]=t.nodes[0].x,t.mappingRange[1]=t.nodes[r-1].x):(t.mappingRange[0]=0,t.mappingRange[1]=0),(n[0]!==t.mappingRange[0]||n[1]!==t.mappingRange[1])&&(e.modified(),!0)},e.removePoint=n=>{let r=0;for(;r<t.nodes.length&&t.nodes[r].x!==n;r++);const o=r;if(r>=t.nodes.length)return-1;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.movePoint=(n,r)=>{if(n!==r){e.removePoint(r);for(let o=0;o<t.nodes.length;o++)if(t.nodes[o].x===n){t.nodes[o].x=r,e.sortAndUpdateRange();break}}},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addRGBSegment=(n,r,o,a,i,s,l,c)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=i?t.nodes.splice(e,1):e++;e.addRGBPointLong(n,r,o,a,.5,0),e.addRGBPointLong(i,s,l,c,.5,0),e.modified()},e.addHSVSegment=(t,n,r,o,a,i,s,l)=>{const c=[i,s,l],u=[],d=[];pa([n,r,o],u),pa(c,d),e.addRGBSegment(t,u[0],u[1],u[2],a,d[0],d[1],d[2])},e.mapValue=t=>{const n=[];return e.getColor(t,n),[Math.floor(255*n[0]+.5),Math.floor(255*n[1]+.5),Math.floor(255*n[2]+.5),255]},e.getColor=(n,r)=>{if(t.indexedLookup){const t=e.getSize(),o=e.getAnnotatedValueIndexInternal(n);if(o<0||0===t){const t=e.getNanColorByReference();r[0]=t[0],r[1]=t[1],r[2]=t[2]}else{const n=[];e.getNodeValue(o%t,n),r[0]=n[1],r[1]=n[2],r[2]=n[3]}}else e.getTable(n,n,1,r)},e.getRedValue=t=>{const n=[];return e.getColor(t,n),n[0]},e.getGreenValue=t=>{const n=[];return e.getColor(t,n),n[1]},e.getBlueValue=t=>{const n=[];return e.getColor(t,n),n[2]},e.logScaleEnabled=()=>t.scale===_y.LOG10,e.usingLogScale=()=>e.logScaleEnabled()&&t.mappingRange[0]>0,e.getTable=(n,r,o,a)=>{const i=e.usingLogScale(),s=i?Math.log10(Number(n)):Number(n),l=i?Math.log10(Number(r)):Number(r);if(Pa(s)||Pa(l)){for(let e=0;e<o;e++)a[3*e+0]=t.nanColor[0],a[3*e+1]=t.nanColor[1],a[3*e+2]=t.nanColor[2];return}let c=0;const u=t.nodes.length;let d=0,p=0,f=0;0!==u&&(d=t.nodes[u-1].r,p=t.nodes[u-1].g,f=t.nodes[u-1].b);let g=0,m=0,h=0;const v=[0,0,0],T=[0,0,0];let y=0,b=0;const x=[];let C=t.mappingRange;i&&(C=[Math.log10(t.mappingRange[0]),Math.log10(t.mappingRange[1])]);for(let n=0;n<o;n++){const r=3*n;if(g=o>1?s+n/(o-1)*(l-s):.5*(s+l),t.discretize){const e=C;if(g>=e[0]&&g<=e[1]){const n=t.numberOfValues,r=e[1]-e[0];if(n<=1)g=e[0]+r/2;else{const t=(g-e[0])/r,o=Co(n*t);g=e[0]+o/(n-1)*r}}}for(;c<u&&g>t.nodes[c].x;)c++,c<u&&(m=t.nodes[c-1].x,h=t.nodes[c].x,v[0]=t.nodes[c-1].r,T[0]=t.nodes[c].r,v[1]=t.nodes[c-1].g,T[1]=t.nodes[c].g,v[2]=t.nodes[c-1].b,T[2]=t.nodes[c].b,y=t.nodes[c-1].midpoint,b=t.nodes[c-1].sharpness,y<1e-5&&(y=1e-5),y>.99999&&(y=.99999));if(g>C[1])a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseAboveRangeColor()?(a[r]=t.aboveRangeColor[0],a[r+1]=t.aboveRangeColor[1],a[r+2]=t.aboveRangeColor[2]):(a[r]=d,a[r+1]=p,a[r+2]=f));else if(g<C[0]||Ia(g)&&g<0)a[r]=0,a[r+1]=0,a[r+2]=0,t.clamping&&(e.getUseBelowRangeColor()?(a[r]=t.belowRangeColor[0],a[r+1]=t.belowRangeColor[1],a[r+2]=t.belowRangeColor[2]):u>0&&(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b));else if(0===c&&(Math.abs(g-s)<1e-6||t.discretize))u>0?(a[r]=t.nodes[0].r,a[r+1]=t.nodes[0].g,a[r+2]=t.nodes[0].b):(a[r]=0,a[r+1]=0,a[r+2]=0);else{let e=0;if(e=(g-m)/(h-m),e=e<y?.5*e/y:.5+.5*(e-y)/(1-y),b>.99){if(e<.5){a[r]=v[0],a[r+1]=v[1],a[r+2]=v[2];continue}a[r]=T[0],a[r+1]=T[1],a[r+2]=T[2];continue}if(b<.01){if(t.colorSpace===Fy.RGB)a[r]=(1-e)*v[0]+e*T[0],a[r+1]=(1-e)*v[1]+e*T[1],a[r+2]=(1-e)*v[2]+e*T[2];else if(t.colorSpace===Fy.HSV){const n=[],o=[];da(v,n),da(T,o),t.hSVWrap&&(n[0]-o[0]>.5||o[0]-n[0]>.5)&&(n[0]>o[0]?n[0]-=1:o[0]-=1);const i=[];i[0]=(1-e)*n[0]+e*o[0],i[0]<0&&(i[0]+=1),i[1]=(1-e)*n[1]+e*o[1],i[2]=(1-e)*n[2]+e*o[2],pa(i,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else if(t.colorSpace===Fy.LAB){const t=[],n=[];va(v,t),va(T,n);const o=[];o[0]=(1-e)*t[0]+e*n[0],o[1]=(1-e)*t[1]+e*n[1],o[2]=(1-e)*t[2]+e*n[2],Ta(o,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else t.colorSpace===Fy.DIVERGING?(jy(e,v,T,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]):Uy("ColorSpace set to invalid value.",t.colorSpace);continue}e<.5?e=.5*(2*e)**(1+10*b):e>.5&&(e=1-.5*(2*(1-e))**(1+10*b));const n=e*e,o=n*e,i=2*o-3*n+1,s=-2*o+3*n,l=o-2*n+e,c=o-n;let u,d;if(t.colorSpace===Fy.RGB)for(let e=0;e<3;e++)u=T[e]-v[e],d=(1-b)*u,a[r+e]=i*v[e]+s*T[e]+l*d+c*d;else if(t.colorSpace===Fy.HSV){const e=[],n=[];da(v,e),da(T,n),t.hSVWrap&&(e[0]-n[0]>.5||n[0]-e[0]>.5)&&(e[0]>n[0]?e[0]-=1:n[0]-=1);const o=[];for(let t=0;t<3;t++)u=n[t]-e[t],d=(1-b)*u,o[t]=i*e[t]+s*n[t]+l*d+c*d,0===t&&o[t]<0&&(o[t]+=1);pa(o,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else if(t.colorSpace===Fy.LAB){const e=[],t=[];va(v,e),va(T,t);const n=[];for(let r=0;r<3;r++)u=t[r]-e[r],d=(1-b)*u,n[r]=i*e[r]+s*t[r]+l*d+c*d;Ta(n,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]}else t.colorSpace===Fy.DIVERGING?(jy(e,v,T,x),a[r]=x[0],a[r+1]=x[1],a[r+2]=x[2]):Uy("ColorSpace set to invalid value.");for(let e=0;e<3;e++)a[r+e]=a[r+e]<0?0:a[r+e],a[r+e]=a[r+e]>1?1:a[r+e]}}},e.getUint8Table=function(n,r,o){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(e.getMTime()<=t.buildTime&&t.tableSize===o&&t.tableWithAlpha!==a)return t.table;if(0===t.nodes.length)return Uy("Attempting to lookup a value with no points in the function"),t.table;const i=a?4:3;t.tableSize===o&&t.tableWithAlpha===a||(t.table=new Uint8Array(o*i),t.tableSize=o,t.tableWithAlpha=a);const s=[];e.getTable(n,r,o,s);for(let e=0;e<o;e++)t.table[e*i+0]=Math.floor(255*s[3*e+0]+.5),t.table[e*i+1]=Math.floor(255*s[3*e+1]+.5),t.table[e*i+2]=Math.floor(255*s[3*e+2]+.5),a&&(t.table[e*i+3]=255);return t.buildTime.modified(),t.table},e.buildFunctionFromArray=n=>{e.removeAllPoints();const r=n.getNumberOfComponents();for(let e=0;e<n.getNumberOfTuples();e++)switch(r){case 3:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:.5,sharpness:0});break;case 4:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:.5,sharpness:0});break;case 5:t.nodes.push({x:e,r:n.getComponent(e,0),g:n.getComponent(e,1),b:n.getComponent(e,2),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)});break;case 6:t.nodes.push({x:n.getComponent(e,0),r:n.getComponent(e,1),g:n.getComponent(e,2),b:n.getComponent(e,3),midpoint:n.getComponent(e,4),sharpness:n.getComponent(e,5)})}e.sortAndUpdateRange()},e.buildFunctionFromTable=(n,r,o,a)=>{let i=0;e.removeAllPoints(),o>1&&(i=(r-n)/(o-1));for(let e=0;e<o;e++){const r={x:n+i*e,r:a[3*e],g:a[3*e+1],b:a[3*e+2],sharpness:0,midpoint:.5};t.nodes.push(r)}e.sortAndUpdateRange()},e.getNodeValue=(e,n)=>e<0||e>=t.nodes.length?(Uy("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].r,n[2]=t.nodes[e].g,n[3]=t.nodes[e].b,n[4]=t.nodes[e].midpoint,n[5]=t.nodes[e].sharpness,1),e.setNodeValue=(n,r)=>{if(n<0||n>=t.nodes.length)return Uy("Index out of range!"),-1;const o=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].r=r[1],t.nodes[n].g=r[2],t.nodes[n].b=r[3],t.nodes[n].midpoint=r[4],t.nodes[n].sharpness=r[5],o!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.getNumberOfAvailableColors=()=>{if(t.indexedLookup&&e.getSize())return e.getSize();if(t.tableSize)return t.tableSize;const n=t.nodes?.length??0;return Math.max(4094,n)},e.getIndexedColor=(t,n)=>{const r=e.getSize();if(r>0&&t>=0){const o=[];e.getNodeValue(t%r,o);for(let e=0;e<3;++e)n[e]=o[e+1];return void(n[3]=1)}const o=e.getNanColorByReference();n[0]=o[0],n[1]=o[1],n[2]=o[2],n[3]=1},e.fillFromDataPointer=(t,n)=>{if(!(t<=0)&&n){e.removeAllPoints();for(let r=0;r<t;r++)e.addRGBPoint(n[4*r],n[4*r+1],n[4*r+2],n[4*r+3])}},e.setMappingRange=(n,r)=>{const o=[n,r],a=[n,r],i=e.getRange(),s=e.logScaleEnabled();if(i[1]===o[1]&&i[0]===o[0])return;if(o[1]===o[0])return void Uy("attempt to set zero width color range");s&&(o[0]<=0?console.warn("attempt to set log scale color range with non-positive minimum"):(a[0]=Math.log10(o[0]),a[1]=Math.log10(o[1])));const l=(a[1]-a[0])/(i[1]-i[0]),c=a[0]-i[0]*l;for(let e=0;e<t.nodes.length;++e)t.nodes[e].x=t.nodes[e].x*l+c;t.mappingRange[0]=o[0],t.mappingRange[1]=o[1],e.modified()},e.adjustRange=n=>{const r=e.getRange(),o=[];r[0]<n[0]?(e.getColor(n[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])):(e.getColor(r[0],o),e.addRGBPoint(n[0],o[0],o[1],o[2])),r[1]>n[1]?(e.getColor(n[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])):(e.getColor(r[1],o),e.addRGBPoint(n[1],o[0],o[1],o[2])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return 1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{if(t.nodes.length<2)return-1;let e=Number.MAX_VALUE;for(let n=0;n<t.nodes.length-1;n++){const r=t.nodes[n+1].x-t.nodes[n].x;r<e&&(e=r)}return e},e.mapScalarsThroughTable=(n,r,o,a)=>{0!==e.getSize()?t.indexedLookup?e.mapDataIndexed(n,r,o,a):e.mapData(n,r,o,a):ky("Transfer Function Has No Points!")},e.mapData=(t,n,r,o)=>{if(0===e.getSize())return void zy("Transfer Function Has No Points!");const a=Math.floor(255*e.getAlpha()+.5),i=t.getNumberOfTuples(),s=t.getNumberOfComponents(),l=n.getData(),c=t.getData(),u=[];if(r===Gy.RGBA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[4*t]=Math.floor(255*u[0]+.5),l[4*t+1]=Math.floor(255*u[1]+.5),l[4*t+2]=Math.floor(255*u[2]+.5),l[4*t+3]=a}if(r===Gy.RGB)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[3*t]=Math.floor(255*u[0]+.5),l[3*t+1]=Math.floor(255*u[1]+.5),l[3*t+2]=Math.floor(255*u[2]+.5)}if(r===Gy.LUMINANCE)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5)}if(r===Gy.LUMINANCE_ALPHA)for(let t=0;t<i;t++){const n=c[t*s+o];e.getColor(n,u),l[2*t]=Math.floor(76.5*u[0]+150.45*u[1]+28.05*u[2]+.5),l[2*t+1]=a}},e.applyColorMap=n=>{const r=JSON.stringify(t.colorSpace);n.ColorSpace&&(t.colorSpace=Fy[n.ColorSpace.toUpperCase()],void 0===t.colorSpace&&(Uy(`ColorSpace ${n.ColorSpace} not supported, using RGB instead`),t.colorSpace=Fy.RGB));let o=r!==JSON.stringify(t.colorSpace);const a=o||JSON.stringify(t.nanColor);if(n.NanColor)for(t.nanColor=[].concat(n.NanColor);t.nanColor.length<4;)t.nanColor.push(1);o=o||a!==JSON.stringify(t.nanColor);const i=o||JSON.stringify(t.nodes);if(n.RGBPoints){const e=n.RGBPoints.length;t.nodes=[];const r=.5,o=0;for(let a=0;a<e;a+=4)t.nodes.push({x:n.RGBPoints[a],r:n.RGBPoints[a+1],g:n.RGBPoints[a+2],b:n.RGBPoints[a+3],midpoint:r,sharpness:o})}const s=e.sortAndUpdateRange(),l=!s&&(o||i!==JSON.stringify(t.nodes));return l&&e.modified(),s||l}}(e,t)}var qy={newInstance:Ht.newInstance($y,"vtkColorTransferFunction"),extend:$y,...Ny},Xy={OrientationModes:{DIRECTION:0,ROTATION:1,MATRIX:2},ScaleModes:{SCALE_BY_CONSTANT:0,SCALE_BY_MAGNITUDE:1,SCALE_BY_COMPONENTS:2}};const{OrientationModes:Yy,ScaleModes:Zy}=Xy,{vtkErrorMacro:Qy}=Ht,Jy={orient:!0,orientationMode:Yy.DIRECTION,orientationArray:null,scaling:!0,scaleFactor:1,scaleMode:Zy.SCALE_BY_MAGNITUDE,scaleArray:null,matrixArray:null,normalArray:null,colorArray:null};function eb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Jy,n),Fl.extend(e,t,n),Ht.algo(e,t,2,0),t.buildTime={},Ht.obj(t.buildTime,{mtime:0}),t.boundsTime={},Ht.obj(t.boundsTime,{mtime:0}),Ht.setGet(e,t,["orient","orientationMode","orientationArray","scaleArray","scaleFactor","scaleMode","scaling"]),Ht.get(e,t,["colorArray","matrixArray","normalArray","buildTime"]),function(e,t){t.classHierarchy.push("vtkGlyph3DMapper"),e.getOrientationModeAsString=()=>Ht.enumToString(Yy,t.orientationMode),e.setOrientationModeToDirection=()=>e.setOrientationMode(Yy.DIRECTION),e.setOrientationModeToRotation=()=>e.setOrientationMode(Yy.ROTATION),e.setOrientationModeToMatrix=()=>e.setOrientationMode(Yy.MATRIX),e.getOrientationArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.orientationArray?n.getPointData().getArray(t.orientationArray):n.getPointData().getVectors():null},e.getScaleModeAsString=()=>Ht.enumToString(Zy,t.scaleMode),e.setScaleModeToScaleByMagnitude=()=>e.setScaleMode(Zy.SCALE_BY_MAGNITUDE),e.setScaleModeToScaleByComponents=()=>e.setScaleMode(Zy.SCALE_BY_COMPONENTS),e.setScaleModeToScaleByConstant=()=>e.setScaleMode(Zy.SCALE_BY_CONSTANT),e.getScaleArrayData=()=>{const n=e.getInputData(0);return n&&n.getPointData()?t.scaleArray?n.getPointData().getArray(t.scaleArray):n.getPointData().getScalars():null},e.getBounds=()=>{const n=e.getInputData(0),r=e.getInputData(1);return n&&r?(e.buildArrays(),t.bounds):Ra()},e.buildArrays=()=>{const n=e.getInputData(0),r=e.getInputData(1);if(t.buildTime.getMTime()<r.getMTime()||t.buildTime.getMTime()<n.getMTime()||t.buildTime.getMTime()<e.getMTime()){const o=n.getPoints().getData();let a=e.getScaleArrayData(),i=null,s=0;a&&(i=a.getData(),s=a.getNumberOfComponents()),t.scaling&&a&&t.scaleMode===Zy.SCALE_BY_COMPONENTS&&3!==a.getNumberOfComponents()&&(Qy("Cannot scale by components since scale array does not have 3 components."),a=null);const l=r.getBounds(),c=[];Fi.getCorners(l,c),t.bounds[0]=Fi.INIT_BOUNDS[0],t.bounds[1]=Fi.INIT_BOUNDS[1],t.bounds[2]=Fi.INIT_BOUNDS[2],t.bounds[3]=Fi.INIT_BOUNDS[3],t.bounds[4]=Fi.INIT_BOUNDS[4],t.bounds[5]=Fi.INIT_BOUNDS[5];const u=new Float64Array(3),d=e.getOrientationArrayData(),p=g(new Float64Array(16)),f=[],m=[],h=o.length/3;t.matrixArray=new Float32Array(16*h);const v=t.matrixArray.buffer;t.normalArray=new Float32Array(9*h);const T=t.normalArray.buffer,w=[],O=[];for(let e=0;e<h;++e){const n=new Float32Array(v,64*e,16);if(f[0]=o[3*e],f[1]=o[3*e+1],f[2]=o[3*e+2],b(n,p,f),d)switch(d.getTuple(e,O),t.orientationMode){case Yy.MATRIX:y(n,n,[...O.slice(0,3),0,...O.slice(3,6),0,...O.slice(6,9),0,0,0,0,1]);break;case Yy.ROTATION:I(n,n,O[2]),S(n,n,O[0]),A(n,n,O[1]);break;case Yy.DIRECTION:if(0===O[1]&&0===O[2])O[0]<0&&A(n,n,3.1415926);else{const e=_o(O),t=[];t[0]=(O[0]+e)/2,t[1]=O[1]/2,t[2]=O[2]/2,C(n,n,3.1415926,t)}}if(t.scaling){if(m[0]=t.scaleFactor,m[1]=t.scaleFactor,m[2]=t.scaleFactor,a)switch(t.scaleMode){case Zy.SCALE_BY_MAGNITUDE:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=_o(w,s),m[1]=m[0],m[2]=m[0];break;case Zy.SCALE_BY_COMPONENTS:for(let t=0;t<s;++t)w[t]=i[e*s+t];m[0]*=w[0],m[1]*=w[1],m[2]*=w[2];case Zy.SCALE_BY_CONSTANT:}0===m[0]&&(m[0]=1e-10),0===m[1]&&(m[1]=1e-10),0===m[2]&&(m[2]=1e-10),x(n,n,m)}for(let e=0;e<8;++e)wn(u,c[e],n),u[0]<t.bounds[0]&&(t.bounds[0]=u[0]),u[1]<t.bounds[2]&&(t.bounds[2]=u[1]),u[2]<t.bounds[4]&&(t.bounds[4]=u[2]),u[0]>t.bounds[1]&&(t.bounds[1]=u[0]),u[1]>t.bounds[3]&&(t.bounds[3]=u[1]),u[2]>t.bounds[5]&&(t.bounds[5]=u[2]);const r=new Float32Array(T,36*e,9);se(r,n),ge(r,r),fe(r,r)}const P=e.getAbstractScalars(n,t.scalarMode,t.arrayAccessMode,t.arrayId,t.colorByArrayName).scalars;t.useLookupTableScalarRange||e.getLookupTable().setRange(t.scalarRange[0],t.scalarRange[1]),t.colorArray=null;const R=e.getLookupTable();R&&P&&(R.build(),t.colorArray=R.mapScalars(P,t.colorMode,0)),t.buildTime.modified()}},e.getPrimitiveCount=()=>{const t=e.getInputData(1),n=e.getInputData().getPoints().getNumberOfValues()/3;return{points:n*t.getPoints().getNumberOfValues()/3,verts:n*(t.getVerts().getNumberOfValues()-t.getVerts().getNumberOfCells()),lines:n*(t.getLines().getNumberOfValues()-2*t.getLines().getNumberOfCells()),triangles:n*(t.getPolys().getNumberOfValues()-3*t.getLines().getNumberOfCells())}},e.setSourceConnection=t=>e.setInputConnection(t,1)}(e,t)}var tb={newInstance:Ht.newInstance(eb,"vtkGlyph3DMapper"),extend:eb,...Xy};const{vtkErrorMacro:nb}=Ht,rb={range:[0,0],clamping:!0,allowDuplicateScalars:!1};function ob(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,rb,n),Ht.obj(e,t),t.nodes=[],Ht.setGet(e,t,["allowDuplicateScalars","clamping"]),Ht.setArray(e,t,["range"],2),Ht.getArray(e,t,["range"]),function(e,t){t.classHierarchy.push("vtkPiecewiseFunction"),e.getSize=()=>t.nodes.length,e.getType=()=>{let e,n=0,r=0;t.nodes.length>0&&(n=t.nodes[0].y);for(let o=1;o<t.nodes.length;o++){if(e=t.nodes[o].y,e!==n)if(e>n)switch(r){case 0:case 1:r=1;break;default:r=3}else switch(r){case 0:case 2:r=2;break;default:r=3}if(n=e,3===r)break}switch(r){case 0:return"Constant";case 1:return"NonDecreasing";case 2:return"NonIncreasing";default:return"Varied"}},e.getDataPointer=()=>{const e=t.nodes.length;if(t.function=null,e>0){t.function=[];for(let n=0;n<e;n++)t.function[2*n]=t.nodes[n].x,t.function[2*n+1]=t.nodes[n].y}return t.function},e.getFirstNonZeroValue=()=>{if(0===t.nodes.length)return 0;let e=1,n=0,r=0;for(;r<t.nodes.length;r++)if(0!==t.nodes[r].y){e=0;break}return n=e?Number.MAX_VALUE:r>0?t.nodes[r-1].x:t.clamping?-Number.MAX_VALUE:t.nodes[0].x,n},e.getNodeValue=(e,n)=>{const r=t.nodes.length;return e<0||e>=r?(nb("Index out of range!"),-1):(n[0]=t.nodes[e].x,n[1]=t.nodes[e].y,n[2]=t.nodes[e].midpoint,n[3]=t.nodes[e].sharpness,1)},e.setNodeValue=(n,r)=>{const o=t.nodes.length;if(n<0||n>=o)return nb("Index out of range!"),-1;const a=t.nodes[n].x;return t.nodes[n].x=r[0],t.nodes[n].y=r[1],t.nodes[n].midpoint=r[2],t.nodes[n].sharpness=r[3],a!==r[0]?e.sortAndUpdateRange():e.modified(),1},e.addPoint=(t,n)=>e.addPointLong(t,n,.5,0),e.addPointLong=(n,r,o,a)=>{if(o<0||o>1)return nb("Midpoint outside range [0.0, 1.0]"),-1;if(a<0||a>1)return nb("Sharpness outside range [0.0, 1.0]"),-1;t.allowDuplicateScalars||e.removePoint(n);const i={x:n,y:r,midpoint:o,sharpness:a};let s;for(t.nodes.push(i),e.sortAndUpdateRange(),s=0;s<t.nodes.length&&t.nodes[s].x!==n;s++);return s<t.nodes.length?s:-1},e.setNodes=n=>{t.nodes!==n&&(t.nodes=n,e.sortAndUpdateRange())},e.sortAndUpdateRange=()=>{t.nodes.sort(((e,t)=>e.x-t.x)),e.updateRange()||e.modified()},e.updateRange=()=>{const n=t.range.slice(),r=t.nodes.length;return r?(t.range[0]=t.nodes[0].x,t.range[1]=t.nodes[r-1].x):(t.range[0]=0,t.range[1]=0),(n[0]!==t.range[0]||n[1]!==t.range[1])&&(e.modified(),!0)},e.removePoint=n=>{let r;for(r=0;r<t.nodes.length&&t.nodes[r].x!==n;r++);if(r>=t.nodes.length)return-1;const o=r;let a=!1;return t.nodes.splice(r,1),0!==r&&r!==t.nodes.length||(a=e.updateRange()),a||e.modified(),o},e.removeAllPoints=()=>{t.nodes=[],e.sortAndUpdateRange()},e.addSegment=(n,r,o,a)=>{e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n&&t.nodes[e].x<=o?t.nodes.splice(e,1):e++;e.addPoint(n,r,.5,0),e.addPoint(o,a,.5,0)},e.getValue=t=>{const n=[];return e.getTable(t,t,1,n),n[0]},e.adjustRange=n=>{if(n.length<2)return 0;const r=e.getRange();r[0]<n[0]?e.addPoint(n[0],e.getValue(n[0])):e.addPoint(n[0],e.getValue(r[0])),r[1]>n[1]?e.addPoint(n[1],e.getValue(n[1])):e.addPoint(n[1],e.getValue(r[1])),e.sortAndUpdateRange();for(let e=0;e<t.nodes.length;)t.nodes[e].x>=n[0]&&t.nodes[e].x<=n[1]?t.nodes.splice(e,1):++e;return e.sortAndUpdateRange(),1},e.estimateMinNumberOfSamples=(t,n)=>{const r=e.findMinimumXDistance();return Math.ceil((n-t)/r)},e.findMinimumXDistance=()=>{const e=t.nodes.length;if(e<2)return-1;let n=t.nodes[1].x-t.nodes[0].x;for(let r=0;r<e-1;r++){const e=t.nodes[r+1].x-t.nodes[r].x;e<n&&(n=e)}return n},e.getTable=function(e,n,r,o){let a,i=arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,s=0;const l=t.nodes.length;let c=0;0!==l&&(c=t.nodes[l-1].y);let u=0,d=0,p=0,f=0,g=0,m=0,h=0;for(a=0;a<r;a++){const v=i*a;for(u=r>1?e+a/(r-1)*(n-e):.5*(e+n);s<l&&u>t.nodes[s].x;)s++,s<l&&(d=t.nodes[s-1].x,p=t.nodes[s].x,f=t.nodes[s-1].y,g=t.nodes[s].y,m=t.nodes[s-1].midpoint,h=t.nodes[s-1].sharpness,m<1e-5&&(m=1e-5),m>.99999&&(m=.99999));if(s>=l)o[v]=t.clamping?c:0;else if(0===s)o[v]=t.clamping?t.nodes[0].y:0;else{let e=(u-d)/(p-d);if(e=e<m?.5*e/m:.5+.5*(e-m)/(1-m),h>.99){if(e<.5){o[v]=f;continue}o[v]=g;continue}if(h<.01){o[v]=(1-e)*f+e*g;continue}e<.5?e=.5*(2*e)**(1+10*h):e>.5&&(e=1-.5*(2*(1-e))**(1+10*h));const t=e*e,n=t*e,r=2*n-3*t+1,a=-2*n+3*t,i=n-2*t+e,s=n-t,l=(1-h)*(g-f);o[v]=r*f+a*g+i*l+s*l;const c=f<g?f:g,T=f>g?f:g;o[v]=o[v]<c?c:o[v],o[v]=o[v]>T?T:o[v]}}}}(e,t)}var ab={newInstance:Ht.newInstance(ob,"vtkPiecewiseFunction"),extend:ob};const{InterpolationType:ib,OpacityMode:sb,FilterMode:lb,ColorMixPreset:cb}=Sf,{vtkErrorMacro:ub}=Ht;function db(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,(e=>({colorMixPreset:cb.DEFAULT,independentComponents:!0,interpolationType:ib.FAST_LINEAR,shade:!1,ambient:.1,diffuse:.7,specular:.2,specularPower:10,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1,ipScalarRange:[-1e6,1e6],filterMode:lb.OFF,preferSizeOverAccuracy:!1,computeNormalFromOpacity:!1,volumetricScatteringBlending:0,globalIlluminationReach:0,anisotropy:0,localAmbientOcclusion:!1,LAOKernelSize:15,LAOKernelRadius:7,updatedExtents:[],...e}))(n)),Ht.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;++e)t.componentData.push({colorChannels:1,grayTransferFunction:null,rGBTransferFunction:null,scalarOpacity:null,scalarOpacityUnitDistance:1,opacityMode:sb.FRACTIONAL,gradientOpacityMinimumValue:0,gradientOpacityMinimumOpacity:0,gradientOpacityMaximumValue:1,gradientOpacityMaximumOpacity:1,useGradientOpacity:!1,componentWeight:1,forceNearestInterpolation:!1})}Ht.setGet(e,t,["colorMixPreset","independentComponents","interpolationType","shade","ambient","diffuse","specular","specularPower","useLabelOutline","labelOutlineOpacity","filterMode","preferSizeOverAccuracy","computeNormalFromOpacity","volumetricScatteringBlending","globalIlluminationReach","anisotropy","localAmbientOcclusion","LAOKernelSize","LAOKernelRadius","updatedExtents"]),Ht.setGetArray(e,t,["ipScalarRange"],2),Ht.setGetArray(e,t,["labelOutlineThickness"]),function(e,t){t.classHierarchy.push("vtkVolumeProperty");const n={...e};e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)1===t.componentData[r].colorChannels?t.componentData[r].grayTransferFunction&&(e=t.componentData[r].grayTransferFunction.getMTime(),n=n>e?n:e):3===t.componentData[r].colorChannels&&t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].scalarOpacity&&(e=t.componentData[r].scalarOpacity.getMTime(),n=n>e?n:e),t.componentData[r].gradientOpacity&&(t.componentData[r].disableGradientOpacity||(e=t.componentData[r].gradientOpacity.getMTime(),n=n>e?n:e));return n},e.getColorChannels=e=>e<0||e>3?(ub("Bad index - must be between 0 and 3"),0):t.componentData[e].colorChannels,e.setGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].grayTransferFunction!==r&&(t.componentData[n].grayTransferFunction=r,o=!0),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1,o=!0),o&&e.modified(),o},e.getGrayTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].grayTransferFunction&&(t.componentData[n].grayTransferFunction=ab.newInstance(),t.componentData[n].grayTransferFunction.addPoint(0,0),t.componentData[n].grayTransferFunction.addPoint(1024,1),1!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=1),e.modified()),t.componentData[n].grayTransferFunction},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,o=!1;return t.componentData[n].rGBTransferFunction!==r&&(t.componentData[n].rGBTransferFunction=r,o=!0),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3,o=!0),o&&e.modified(),o},e.getRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].rGBTransferFunction&&(t.componentData[n].rGBTransferFunction=qy.newInstance(),t.componentData[n].rGBTransferFunction.addRGBPoint(0,0,0,0),t.componentData[n].rGBTransferFunction.addRGBPoint(1024,1,1,1),3!==t.componentData[n].colorChannels&&(t.componentData[n].colorChannels=3),e.modified()),t.componentData[n].rGBTransferFunction},e.setScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return t.componentData[n].scalarOpacity!==r&&(t.componentData[n].scalarOpacity=r,e.modified(),!0)},e.getScalarOpacity=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return null===t.componentData[n].scalarOpacity&&(t.componentData[n].scalarOpacity=ab.newInstance(),t.componentData[n].scalarOpacity.addPoint(0,1),t.componentData[n].scalarOpacity.addPoint(1024,1),e.modified()),t.componentData[n].scalarOpacity},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return ub("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(ub("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(ib.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(ib.LINEAR),e.setInterpolationTypeToFastLinear=()=>e.setInterpolationType(ib.FAST_LINEAR),e.getInterpolationTypeAsString=()=>Ht.enumToString(ib,t.interpolationType),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=Ht.capitalize(n);e[`set${r}`]=(r,o)=>t.componentData[r][`${n}`]!==o&&(t.componentData[r][`${n}`]=o,e.modified(),!0)})),["useGradientOpacity","scalarOpacityUnitDistance","gradientOpacityMinimumValue","gradientOpacityMinimumOpacity","gradientOpacityMaximumValue","gradientOpacityMaximumOpacity","opacityMode","forceNearestInterpolation"].forEach((n=>{const r=Ht.capitalize(n);e[`get${r}`]=e=>t.componentData[e][`${n}`]})),e.setAverageIPScalarRange=(t,n)=>{console.warn("setAverageIPScalarRange is deprecated use setIpScalarRange"),e.setIpScalarRange(t,n)},e.getFilterModeAsString=()=>Ht.enumToString(lb,t.filterMode),e.setFilterModeToOff=()=>{e.setFilterMode(lb.OFF)},e.setFilterModeToNormalized=()=>{e.setFilterMode(lb.NORMALIZED)},e.setFilterModeToRaw=()=>{e.setFilterMode(lb.RAW)},e.setGlobalIlluminationReach=e=>n.setGlobalIlluminationReach(xa(e,0,1)),e.setVolumetricScatteringBlending=e=>n.setVolumetricScatteringBlending(xa(e,0,1)),e.setAnisotropy=e=>n.setAnisotropy(xa(e,-.99,.99)),e.setLAOKernelSize=e=>n.setLAOKernelSize(Co(xa(e,1,32))),e.setLAOKernelRadius=e=>n.setLAOKernelRadius(e>=1?e:1)}(e,t)}var pb={newInstance:Ht.newInstance(db,"vtkVolumeProperty"),extend:db,...Sf};const fb={mapper:null};function gb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,fb,n),Ki.extend(e,t,n),t.boundsMTime={},Ht.obj(t.boundsMTime),Ht.setGet(e,t,["mapper"]),function(e,t){t.classHierarchy.push("vtkVolume"),e.getVolumes=()=>[e],e.makeProperty=pb.newInstance,e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return e}}(e,t)}var mb={newInstance:Ht.newInstance(gb,"vtkVolume"),extend:gb};const{BlendMode:hb}=If,vb=["getAnisotropy","getComputeNormalFromOpacity","getFilterMode","getFilterModeAsString","getGlobalIlluminationReach","getIpScalarRange","getIpScalarRangeByReference","getLAOKernelRadius","getLAOKernelSize","getLocalAmbientOcclusion","getPreferSizeOverAccuracy","getVolumetricScatteringBlending","setAnisotropy","setAverageIPScalarRange","setComputeNormalFromOpacity","setFilterMode","setFilterModeToNormalized","setFilterModeToOff","setFilterModeToRaw","setGlobalIlluminationReach","setIpScalarRange","setIpScalarRangeFrom","setLAOKernelRadius","setLAOKernelSize","setLocalAmbientOcclusion","setPreferSizeOverAccuracy","setVolumetricScatteringBlending"],Tb={createRadonTransferFunction:function(e,t,n,r,o){let a=null;return o?(a=o,a.removeAllPoints()):a=ab.newInstance(),a.addPointLong(-1024,0,1,1),a.addPoint(e,t),a.addPoint(n,r),a}};function yb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,(e=>({bounds:[...Fi.INIT_BOUNDS],sampleDistance:1,imageSampleDistance:1,maximumSamplesPerRay:1e3,autoAdjustSampleDistances:!0,initialInteractionScale:1,interactionSampleDistanceFactor:1,blendMode:hb.COMPOSITE_BLEND,volumeShadowSamplingDistFactor:5,colorTextureWidth:1024,opacityTextureWidth:1024,labelOutlineTextureWidth:1024,...e}))(n)),xs(e,t,n),Ht.setGet(e,t,["sampleDistance","imageSampleDistance","maximumSamplesPerRay","autoAdjustSampleDistances","initialInteractionScale","interactionSampleDistanceFactor","blendMode","volumeShadowSamplingDistFactor","colorTextureWidth","opacityTextureWidth","labelOutlineTextureWidth"]),Ht.event(e,t,"lightingActivated"),function(e,t){t.classHierarchy.push("vtkVolumeMapper");const n={...e};e.getBounds=()=>(t.static||e.update(),t.bounds=[...e.getInputData().getBounds()],t.bounds),e.setBlendModeToComposite=()=>{e.setBlendMode(hb.COMPOSITE_BLEND)},e.setBlendModeToMaximumIntensity=()=>{e.setBlendMode(hb.MAXIMUM_INTENSITY_BLEND)},e.setBlendModeToMinimumIntensity=()=>{e.setBlendMode(hb.MINIMUM_INTENSITY_BLEND)},e.setBlendModeToAverageIntensity=()=>{e.setBlendMode(hb.AVERAGE_INTENSITY_BLEND)},e.setBlendModeToAdditiveIntensity=()=>{e.setBlendMode(hb.ADDITIVE_INTENSITY_BLEND)},e.setBlendModeToRadonTransform=()=>{e.setBlendMode(hb.RADON_TRANSFORM_BLEND)},e.getBlendModeAsString=()=>Ht.enumToString(hb,t.blendMode),e.setVolumeShadowSamplingDistFactor=e=>n.setVolumeShadowSamplingDistFactor(e>=1?e:1),vb.forEach((t=>{e[t]=()=>{throw new Error(`The method "volumeMapper.${t}()" doesn't exist anymore. It is a rendering property that has been moved to the volume property. Replace your code with:\nvolumeActor.getProperty().${t}()\n`)}}))}(e,t)}var bb={newInstance:Ht.newInstance(yb,"vtkVolumeMapper"),extend:yb,...Tb};const{InterpolationType:xb}=Qp,{vtkErrorMacro:Cb}=Ht;function Sb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(Object.assign(t,(e=>({independentComponents:!1,interpolationType:xb.LINEAR,colorWindow:255,colorLevel:127.5,ambient:1,diffuse:0,opacity:1,useLookupTableScalarRange:!1,useLabelOutline:!1,labelOutlineThickness:[1],labelOutlineOpacity:1,updatedExtents:[],...e}))(n)),Ht.obj(e,t),!t.componentData){t.componentData=[];for(let e=0;e<4;e++)t.componentData.push({rGBTransferFunction:null,piecewiseFunction:null,componentWeight:1})}Ht.setGet(e,t,["independentComponents","interpolationType","colorWindow","colorLevel","ambient","diffuse","opacity","useLookupTableScalarRange","useLabelOutline","labelOutlineOpacity","updatedExtents"]),Ht.setGetArray(e,t,["labelOutlineThickness"]),function(e,t){t.classHierarchy.push("vtkImageProperty"),e.getMTime=()=>{let e,n=t.mtime;for(let r=0;r<4;r++)t.componentData[r].rGBTransferFunction&&(e=t.componentData[r].rGBTransferFunction.getMTime(),n=n>e?n:e),t.componentData[r].piecewiseFunction&&(e=t.componentData[r].piecewiseFunction.getMTime(),n=n>e?n:e);return n},e.setRGBTransferFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(n)||(o=n,r=0),t.componentData[r].rGBTransferFunction!==o&&(t.componentData[r].rGBTransferFunction=o,e.modified(),!0)},e.getRGBTransferFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].rGBTransferFunction},e.setPiecewiseFunction=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=n,o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(n)||(o=n,r=0),t.componentData[r].piecewiseFunction!==o&&(t.componentData[r].piecewiseFunction=o,e.modified(),!0)},e.getPiecewiseFunction=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return t.componentData[e].piecewiseFunction},e.setScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,n=t,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return Number.isInteger(t)||(r=t,n=0),e.setPiecewiseFunction(n,r)},e.getScalarOpacity=function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e.getPiecewiseFunction(t)},e.setComponentWeight=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(n<0||n>=4)return Cb("Invalid index"),!1;const o=Math.min(1,Math.max(0,r));return t.componentData[n].componentWeight!==o&&(t.componentData[n].componentWeight=o,e.modified(),!0)},e.getComponentWeight=function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0;return e<0||e>=4?(Cb("Invalid index"),0):t.componentData[e].componentWeight},e.setInterpolationTypeToNearest=()=>e.setInterpolationType(xb.NEAREST),e.setInterpolationTypeToLinear=()=>e.setInterpolationType(xb.LINEAR),e.getInterpolationTypeAsString=()=>Ht.enumToString(xb,t.interpolationType)}(e,t)}var Ab={newInstance:Ht.newInstance(Sb,"vtkImageProperty"),extend:Sb};const Ib={mapper:null,forceOpaque:!1,forceTranslucent:!1};function wb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Ib,n),Ki.extend(e,t,n),t.boundsMTime={},Ht.obj(t.boundsMTime),Ht.setGet(e,t,["mapper","forceOpaque","forceTranslucent"]),function(e,t){t.classHierarchy.push("vtkImageSlice"),e.getActors=()=>e,e.getImages=()=>e,e.getIsOpaque=()=>{if(t.forceOpaque)return!0;if(t.forceTranslucent)return!1;t.properties[0]||e.getProperty();let n=t.properties[0].getOpacity()>=1;return n=n&&(!t.mapper||t.mapper.getIsOpaque()),n},e.hasTranslucentPolygonalGeometry=()=>!1,e.makeProperty=Ab.newInstance,e.getBoundsForSlice=(n,r)=>{const o=t.mapper.getBoundsForSlice(n,r);if(!Fi.isValid(o))return o;e.computeMatrix();const a=new Float64Array(16);return m(a,t.matrix),Fi.transformBounds(o,a)},e.getMinXBound=()=>e.getBounds()[0],e.getMaxXBound=()=>e.getBounds()[1],e.getMinYBound=()=>e.getBounds()[2],e.getMaxYBound=()=>e.getBounds()[3],e.getMinZBound=()=>e.getBounds()[4],e.getMaxZBound=()=>e.getBounds()[5],e.getRedrawMTime=()=>{let e=t.mtime;if(null!==t.mapper){let n=t.mapper.getMTime();e=n>e?n:e,null!==t.mapper.getInput()&&(t.mapper.getInputAlgorithm().update(),n=t.mapper.getInput().getMTime(),e=n>e?n:e)}return t.properties.forEach((t=>{e=Math.max(e,t.getMTime());const n=t.getRGBTransferFunction();null!==n&&(e=Math.max(e,n.getMTime()))})),e},e.getSupportsSelection=()=>!!t.mapper&&t.mapper.getSupportsSelection()}(e,t)}var Ob={newInstance:Ht.newInstance(wb,"vtkImageSlice"),extend:wb};const Pb={slice:0,customDisplayExtent:[0,0,0,0,0,0],useCustomExtents:!1,backgroundColor:[0,0,0,1],colorTextureWidth:1024,opacityTextureWidth:1024,labelOutlineTextureWidth:1024};var Rb=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Pb,n),xs(e,t,n),Ht.setGet(e,t,["slice","useCustomExtents","colorTextureWidth","opacityTextureWidth","labelOutlineTextureWidth"]),Ht.setGetArray(e,t,["customDisplayExtent"],6),Ht.setGetArray(e,t,["backgroundColor"],4),function(e,t){t.classHierarchy.push("vtkAbstractImageMapper"),e.getIsOpaque=()=>!0,e.getCurrentImage=()=>null,e.getBoundsForSlice=()=>(Ht.vtkErrorMacro("vtkAbstractImageMapper.getBoundsForSlice - NOT IMPLEMENTED"),Ra())}(e,t)};function Mb(e,t,n){const r=n.getCurrentImage(),o=r.getExtent(),a=[o[0],o[2],o[4]],{ijkMode:i}=n.getClosestIJKAxis();let s=n.isA("vtkImageArrayMapper")?n.getSubSlice():n.getSlice();i!==n.getSlicingMode()&&(s=n.getSliceAtPosition(s)),a[i]+=s;const l=[0,0,0];r.indexToWorld(a,l),a[i]+=1;const c=[0,0,0];r.indexToWorld(a,c),c[0]-=l[0],c[1]-=l[1],c[2]-=l[2],Sn(c,c);const u=ti.intersectWithLine(e,t,l,c);if(u.intersection){const e=u.x,t=[0,0,0];return r.worldToIndex(e,t),{t:u.t,absoluteIJK:t}}return null}const{staticOffsetAPI:Eb,otherStaticMethods:Vb}=bl,{SlicingMode:Db}=rf;const Lb={slicingMode:Db.NONE,closestIJKAxis:{ijkMode:Db.NONE,flip:!1},renderToRectangle:!1,sliceAtFocalPoint:!1,preferSizeOverAccuracy:!1};function Bb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Lb,n),Rb(e,t,n),Ht.get(e,t,["slicingMode"]),Ht.setGet(e,t,["closestIJKAxis","renderToRectangle","sliceAtFocalPoint","preferSizeOverAccuracy"]),bl.implementCoincidentTopologyMethods(e,t),function(e,t){function n(){let n;switch(t.slicingMode){case Db.X:n=0;break;case Db.Y:n=1;break;case Db.Z:n=2;break;default:return void(t.closestIJKAxis={ijkMode:t.slicingMode,flip:!1})}const r=Ma(e.getCurrentImage().getDirection());let o=0;for(;o<3&&0===r[n+3*o];++o);const a=r[n+3*o]<0;t.closestIJKAxis={ijkMode:o,flip:a}}t.classHierarchy.push("vtkImageMapper"),e.getSliceAtPosition=n=>{const r=e.getCurrentImage();let o;if(3===n.length)o=n;else if(Number.isFinite(n)){const e=r.getBounds();switch(t.slicingMode){case Db.X:o=[n,(e[3]+e[2])/2,(e[5]+e[4])/2];break;case Db.Y:o=[(e[1]+e[0])/2,n,(e[5]+e[4])/2];break;case Db.Z:o=[(e[1]+e[0])/2,(e[3]+e[2])/2,n]}}const a=[0,0,0];r.worldToIndex(o,a);const i=r.getExtent(),{ijkMode:s}=e.getClosestIJKAxis();let l=0;switch(s){case Db.I:l=xa(a[0],i[0],i[1]);break;case Db.J:l=xa(a[1],i[2],i[3]);break;case Db.K:l=xa(a[2],i[4],i[5]);break;default:return 0}return l},e.setSliceFromCamera=n=>{const r=n.getFocalPoint();switch(t.slicingMode){case Db.I:case Db.J:case Db.K:{const t=e.getSliceAtPosition(r);e.setSlice(t)}break;case Db.X:e.setSlice(r[0]);break;case Db.Y:e.setSlice(r[1]);break;case Db.Z:e.setSlice(r[2])}},e.setXSlice=t=>{e.setSlicingMode(Db.X),e.setSlice(t)},e.setYSlice=t=>{e.setSlicingMode(Db.Y),e.setSlice(t)},e.setZSlice=t=>{e.setSlicingMode(Db.Z),e.setSlice(t)},e.setISlice=t=>{e.setSlicingMode(Db.I),e.setSlice(t)},e.setJSlice=t=>{e.setSlicingMode(Db.J),e.setSlice(t)},e.setKSlice=t=>{e.setSlicingMode(Db.K),e.setSlice(t)},e.getSlicingModeNormal=()=>{const n=[0,0,0],r=e.getCurrentImage().getDirection();switch(t.slicingMode){case Db.X:n[0]=1;break;case Db.Y:n[1]=1;break;case Db.Z:n[2]=1;break;case Db.I:jo(r,[1,0,0],n);break;case Db.J:jo(r,[0,1,0],n);break;case Db.K:jo(r,[0,0,1],n)}return n},e.setSlicingMode=r=>{t.slicingMode!==r&&(t.slicingMode=r,e.getCurrentImage()&&n(),e.modified())},e.getClosestIJKAxis=()=>(void 0!==t.closestIJKAxis&&t.closestIJKAxis.ijkMode!==Db.NONE||!e.getCurrentImage()||n(),t.closestIJKAxis),e.getBounds=()=>{const n=e.getCurrentImage();if(!n)return Ra();if(!t.useCustomExtents)return n.getBounds();const r=t.customDisplayExtent.slice(),{ijkMode:o}=e.getClosestIJKAxis();let a=t.slice;switch(o!==t.slicingMode&&(a=e.getSliceAtPosition(t.slice)),o){case Db.I:r[0]=a,r[1]=a;break;case Db.J:r[2]=a,r[3]=a;break;case Db.K:r[4]=a,r[5]=a}return n.extentToBounds(r)},e.getBoundsForSlice=function(){let n=arguments.length>0&&void 0!==arguments[0]?arguments[0]:t.slice,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const o=e.getCurrentImage();if(!o)return Ra();const a=o.getSpatialExtent(),{ijkMode:i}=e.getClosestIJKAxis();let s=n;switch(i!==t.slicingMode&&(s=e.getSliceAtPosition(n)),i){case Db.I:a[0]=s-r,a[1]=s+r;break;case Db.J:a[2]=s-r,a[3]=s+r;break;case Db.K:a[4]=s-r,a[5]=s+r}return o.extentToBounds(a)},e.intersectWithLineForPointPicking=(t,n)=>function(e,t,n){const r=Mb(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=[Math.round(r.absoluteIJK[0]),Math.round(r.absoluteIJK[1]),Math.round(r.absoluteIJK[2])];return t[0]<e[0]||t[0]>e[1]||t[1]<e[2]||t[1]>e[3]||t[2]<e[4]||t[2]>e[5]?null:{t:r.t,ijk:t}}return null}(t,n,e),e.intersectWithLineForCellPicking=(t,n)=>function(e,t,n){const r=Mb(e,t,n);if(r){const e=n.getCurrentImage().getExtent(),t=r.absoluteIJK,o=[Math.floor(t[0]),Math.floor(t[1]),Math.floor(t[2])];if(o[0]<e[0]||o[0]>e[1]-1||o[1]<e[2]||o[1]>e[3]-1||o[2]<e[4]||o[2]>(e[5]?e[5]-1:e[5]))return null;const a=[t[0]-o[0],t[1]-o[1],t[2]-o[2]];return{t:r.t,ijk:o,pCoords:a}}return null}(t,n,e),e.getCurrentImage=()=>e.getInputData()}(e,t)}var Nb={newInstance:Ht.newInstance(Bb,"vtkImageMapper"),extend:Bb,...Eb,...Vb,...rf};const{vtkErrorMacro:Fb}=Ht;function _b(e,t,n,r){e.set(function(e,t){let n=0;return e.map(((e,r)=>r===n?(n+=e+1,e):e+t))}(t,n),r)}const Gb={outputPointsPrecision:Os.DEFAULT};function kb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Gb,n),Ht.setGet(e,t,["outputPointsPrecision"]),Ht.obj(e,t),Ht.algo(e,t,1,1),function(e,t){t.classHierarchy.push("vtkAppendPolyData"),e.requestData=(n,r)=>{const o=e.getNumberOfInputPorts();if(!o)return void Fb("No input specified.");if(1===o)return void(r[0]=n[0]);const a=Uc.newInstance();let i=0,s=0,l=1,c=1,u=0,d=0,p=0,f=0,g=!0,m=!0,h=!0;for(let e=0;e<o;e++){const t=n[e];if(!t)continue;const r=t.getPoints().getNumberOfPoints();i+=r,u+=t.getVerts().getNumberOfValues(),d+=t.getLines().getNumberOfValues(),p+=t.getStrips().getNumberOfValues(),f+=t.getPolys().getNumberOfValues(),r&&(c&&(c=0,s=t.getPoints().getDataType()),l=t.getPoints().getDataType(),s=s>l?s:l);const o=t.getPointData();o?(g=g&&null!==o.getNormals(),m=m&&null!==o.getTCoords(),h=h&&null!==o.getScalars()):(g=!1,m=!1,h=!1)}t.outputPointsPrecision===Os.SINGLE?s=is.FLOAT:t.outputPointsPrecision===Os.DOUBLE&&(s=is.DOUBLE);const v=ql.newInstance({dataType:s});v.setNumberOfPoints(i);const T=v.getData(),y=new Uint32Array(u),b=new Uint32Array(d),x=new Uint32Array(p),C=new Uint32Array(f);let S=null,A=null,I=null;const w=n[o-1];if(g){const e=w.getPointData().getNormals();S=Ts.newInstance({numberOfComponents:3,numberOfTuples:i,size:3*i,dataType:e.getDataType(),name:e.getName()})}if(m){const e=w.getPointData().getTCoords();A=Ts.newInstance({numberOfComponents:2,numberOfTuples:i,size:2*i,dataType:e.getDataType(),name:e.getName()})}if(h){const e=w.getPointData().getScalars();I=Ts.newInstance({numberOfComponents:e.getNumberOfComponents(),numberOfTuples:i,size:i*e.getNumberOfComponents(),dataType:e.getDataType(),name:e.getName()})}i=0,u=0,d=0,p=0,f=0;for(let e=0;e<o;e++){const t=n[e];T.set(t.getPoints().getData(),3*i),_b(y,t.getVerts().getData(),i,u),u+=t.getVerts().getNumberOfValues(),_b(b,t.getLines().getData(),i,d),d+=t.getLines().getNumberOfValues(),_b(x,t.getStrips().getData(),i,p),p+=t.getStrips().getNumberOfValues(),_b(C,t.getPolys().getData(),i,f),f+=t.getPolys().getNumberOfValues();const r=t.getPointData();if(g){const e=r.getNormals();S.getData().set(e.getData(),3*i)}if(m){const e=r.getTCoords();A.getData().set(e.getData(),2*i)}if(h){const e=r.getScalars();I.getData().set(e.getData(),i*I.getNumberOfComponents())}i+=t.getPoints().getNumberOfPoints()}a.setPoints(v),a.getVerts().setData(y),a.getLines().setData(b),a.getStrips().setData(x),a.getPolys().setData(C),S&&a.getPointData().setNormals(S),A&&a.getPointData().setTCoords(A),I&&a.getPointData().setScalars(I),r[0]=a}}(e,t)}var Ub={newInstance:Ht.newInstance(kb,"vtkAppendPolyData"),extend:kb};const zb={height:1,radius:.5,resolution:6,center:[0,0,0],direction:[1,0,0],capping:!0,pointType:"Float64Array"};function Wb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,zb,n),Ht.obj(e,t),Ht.setGet(e,t,["height","radius","resolution","capping"]),Ht.setGetArray(e,t,["center","direction"],3),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkConeSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution,a=-t.height/2,i=t.resolution+1,s=4*t.resolution+1+t.resolution;let l=0;const c=Ht.newTypedArray(t.pointType,3*i);let u=0;const d=new Uint32Array(s);c[0]=t.height/2,c[1]=0,c[2]=0,t.capping&&(d[u++]=t.resolution);for(let e=0;e<t.resolution;e++)l++,c[3*l+0]=a,c[3*l+1]=t.radius*Math.cos(e*o),c[3*l+2]=t.radius*Math.sin(e*o),t.capping&&(d[t.resolution-u+++1]=l);for(let e=0;e<t.resolution;e++)d[u++]=3,d[u++]=0,d[u++]=e+1,d[u++]=e+2>t.resolution?1:e+2;Lp().translate(...t.center).rotateFromDirections([1,0,0],t.direction).apply(c),r=Uc.newInstance(),r.getPoints().setData(c,3),r.getPolys().setData(d,1),n[0]=r}}(e,t)}var Hb={newInstance:Ht.newInstance(Wb,"vtkConeSource"),extend:Wb};const jb={height:1,initAngle:0,radius:1,resolution:6,center:[0,0,0],direction:[0,1,0],capping:!0,pointType:"Float64Array"};function Kb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,jb,n),Ht.obj(e,t),Ht.setGet(e,t,["height","initAngle","otherRadius","radius","resolution","capping"]),Ht.setGetArray(e,t,["center","direction"],3),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkCylinderSource"),e.requestData=function(e,n){if(t.deleted)return;let r=n[0];const o=2*Math.PI/t.resolution;let a=2*t.resolution,i=5*t.resolution;t.capping&&(a=4*t.resolution,i=7*t.resolution+2);const s=Ht.newTypedArray(t.pointType,3*a);let l=0;const c=new Uint32Array(i),u=new Float32Array(3*a),d=Ts.newInstance({numberOfComponents:3,values:u,name:"Normals"}),p=new Float32Array(2*a),f=Ts.newInstance({numberOfComponents:2,values:p,name:"TCoords"}),g=[0,0,0],m=[0,0,0],h=[0,0,0],v=[0,0,0],T=[0,0],y=[0,0],b=null==t.otherRadius?t.radius:t.otherRadius;for(let e=0;e<t.resolution;e++){g[0]=Math.cos(e*o+t.initAngle),m[0]=g[0],h[0]=t.radius*g[0]+t.center[0],v[0]=h[0],T[0]=Math.abs(2*e/t.resolution-1),y[0]=T[0],h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],T[1]=0,y[1]=1,g[2]=-Math.sin(e*o+t.initAngle),m[2]=g[2],h[2]=b*g[2]+t.center[2],v[2]=h[2];const n=2*e;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*(n+1)+e]=m[e],s[3*n+e]=h[e],s[3*(n+1)+e]=v[e],e<2&&(p[2*n+e]=T[e],p[2*(n+1)+e]=y[e])}for(let e=0;e<t.resolution;e++){c[l++]=4,c[l++]=2*e,c[l++]=2*e+1;const n=(2*e+3)%(2*t.resolution);c[l++]=n,c[l++]=n-1}if(t.capping){for(let e=0;e<t.resolution;e++){h[0]=t.radius*Math.cos(e*o+t.initAngle),v[0]=h[0],T[0]=h[0],y[0]=h[0],h[0]+=t.center[0],v[0]+=t.center[0],g[1]=1,m[1]=-1,h[1]=.5*t.height+t.center[1],v[1]=-.5*t.height+t.center[1],h[2]=-b*Math.sin(e*o+t.initAngle),v[2]=h[2],T[1]=h[2],y[1]=h[2],h[2]+=t.center[2],v[2]+=t.center[2];const n=2*t.resolution+e,r=3*t.resolution+t.resolution-e-1;for(let e=0;e<3;e++)u[3*n+e]=g[e],u[3*r+e]=m[e],s[3*n+e]=h[e],s[3*r+e]=v[e],e<2&&(p[2*n+e]=T[e],p[2*r+e]=y[e])}c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=2*t.resolution+e;c[l++]=t.resolution;for(let e=0;e<t.resolution;e++)c[l++]=3*t.resolution+e}Lp().translate(...t.center).rotateFromDirections([0,1,0],t.direction).translate(...t.center.map((e=>-1*e))).apply(s),r=Uc.newInstance(),r.getPoints().setData(s,3),r.getPolys().setData(c,1),r.getPointData().setNormals(d),r.getPointData().setTCoords(f),n[0]=r}}(e,t)}var $b={newInstance:Ht.newInstance(Kb,"vtkCylinderSource"),extend:Kb};const qb={tipResolution:6,tipRadius:.1,tipLength:.35,shaftResolution:6,shaftRadius:.03,invert:!1,direction:[1,0,0],pointType:"Float64Array"};function Xb(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,qb,n),Ht.obj(e,t),Ht.setGet(e,t,["tipResolution","tipRadius","tipLength","shaftResolution","shaftRadius","invert"]),Ht.setGetArray(e,t,["direction"],3),Ht.algo(e,t,0,1),function(e,t){t.classHierarchy.push("vtkArrowSource"),e.requestData=function(e,n){if(t.deleted)return;const r=$b.newInstance({capping:!0});r.setResolution(t.shaftResolution),r.setRadius(t.shaftRadius),r.setHeight(1-t.tipLength),r.setCenter(0,.5*(1-t.tipLength),0);const o=r.getOutputData(),a=o.getPoints().getData(),i=o.getPointData().getNormals().getData();Dp().rotateZ(-90).apply(a).apply(i);const s=Hb.newInstance();s.setResolution(t.tipResolution),s.setHeight(t.tipLength),s.setRadius(t.tipRadius);const l=s.getOutputData(),c=l.getPoints().getData();Lp().translate(1-.5*t.tipLength,0,0).apply(c);const u=Ub.newInstance();u.setInputData(o),u.addInputData(l);const d=u.getOutputData(),p=d.getPoints().getData();Lp().translate(.5*t.tipLength-.5,0,0).apply(p),t.invert?(Lp().rotateFromDirections([1,0,0],t.direction).scale(-1,-1,-1).apply(p),n[0]=d):(Lp().rotateFromDirections([1,0,0],t.direction).scale(1,1,1).apply(p),n[0]=u.getOutputData())}}(e,t)}var Yb={newInstance:Ht.newInstance(Xb,"vtkArrowSource"),extend:Xb};function Zb(e){const t=e.getPoints().getBounds(),n=[.5*-(t[0]+t[1]),.5*-(t[2]+t[3]),.5*-(t[4]+t[5])];Dp().translate(...n).apply(e.getPoints().getData())}function Qb(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const r=e.getPoints().getBounds(),o=[0,0,0];o[t]=n?-r[2*t+1]:-r[2*t],Dp().translate(...o).apply(e.getPoints().getData())}function Jb(e,t,n,r){const o=e.getPoints().getData().length,a=new Uint8ClampedArray(o);let i=0;for(;i<o;)a[i++]=t,a[i++]=n,a[i++]=r;e.getPointData().setScalars(Ts.newInstance({name:"color",numberOfComponents:3,values:a}))}function ex(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};os.extend(e,t,function(e){return{config:{recenter:!0,tipResolution:60,tipRadius:.1,tipLength:.2,shaftResolution:60,shaftRadius:.03,invert:!1,...e?.config},xConfig:{color:[255,0,0],invert:!1,...e?.xConfig},yConfig:{color:[255,255,0],invert:!1,...e?.yConfig},zConfig:{color:[0,128,0],invert:!1,...e?.zConfig}}}(n)),Ht.setGet(e,t,["config","xConfig","yConfig","zConfig"]),function(e,t){t.classHierarchy.push("vtkAxesActor");const n=Fl.newInstance();e.setMapper(n),e.update=()=>{let e={...t.config,...t.xConfig};const r=Yb.newInstance({direction:[1,0,0],...e}).getOutputData();t.config.recenter?Zb(r):Qb(r,0,e.invert),Jb(r,...e.color),e={...t.config,...t.yConfig};const o=Yb.newInstance({direction:[0,1,0],...e}).getOutputData();t.config.recenter?Zb(o):Qb(o,1,e.invert),Jb(o,...e.color),e={...t.config,...t.zConfig};const a=Yb.newInstance({direction:[0,0,1],...e}).getOutputData();t.config.recenter?Zb(a):Qb(a,2,e.invert),Jb(a,...e.color);const i=Ub.newInstance();i.setInputData(r),i.addInputData(o),i.addInputData(a),n.setInputConnection(i.getOutputPort())},e.update();const r=Ht.debounce(e.update,0);e.setXAxisColor=t=>e.setXConfig({...e.getXConfig(),color:t}),e.setYAxisColor=t=>e.setYConfig({...e.getYConfig(),color:t}),e.setZAxisColor=t=>e.setZConfig({...e.getZConfig(),color:t}),e.getXAxisColor=()=>t.getXConfig().color,e.getYAxisColor=()=>t.getYConfig().color,e.getZAxisColor=()=>t.getZConfig().color,t._onConfigChanged=r,t._onXConfigChanged=r,t._onYConfigChanged=r,t._onZConfigChanged=r}(e,t)}var tx={newInstance:Ht.newInstance(ex,"vtkAxesActor"),extend:ex};const nx="resetcamera",rx="orientation",ox={MODE_RESET_CAMERA:nx,MODE_ORIENTATION:rx,MODE_SAME:"same"};const ax={mode:rx,focalPoint:[0,0,0],distance:6.8,active:!0};function ix(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,ax,n),vt(e,t),St(e,t,["mode","active","srcRenderer","dstRenderer","distance"]),wt(e,t,["focalPoint"],3,0),function(e,t){t.classHierarchy.push("vtkCameraSynchronizer");const n=new Float64Array(9),r=new Float64Array(3),o=[];function a(){for(;o.length;)o.pop().unsubscribe();if(!t.srcRenderer||!t.dstRenderer)return;const n=t.srcRenderer.getActiveCamera(),r=t.srcRenderer.getRenderWindow().getInteractor();o.push(n.onModified((()=>{r.isAnimating()||e.update()}))),o.push(r.onAnimation(e.update)),o.push(r.onEndAnimation(e.update))}t._onSrcRendererChanged=a,t._onDstRendererChanged=a,e.update=()=>{if(!t.active||!t.srcRenderer||!t.dstRenderer)return;const e=t.srcRenderer.getActiveCamera(),o=t.dstRenderer.getActiveCamera(),a=(i=e.getReferenceByName("position"),s=e.getReferenceByName("focalPoint"),l=e.getReferenceByName("viewUp"),(n[0]!==i[0]||n[1]!==i[1]||n[2]!==i[2]||n[3]!==s[0]||n[4]!==s[1]||n[5]!==s[2]||n[6]!==l[0]||n[7]!==l[1]||n[8]!==l[2])&&(n[0]=i[0],n[1]=i[1],n[2]=i[2],n[3]=s[0],n[4]=s[1],n[5]=s[2],n[6]=l[0],n[7]=l[1],n[8]=l[2],n));var i,s,l;a&&(t.mode===rx?(r[0]=a[0]-a[3],r[1]=a[1]-a[4],r[2]=a[2]-a[5],Go(r),o.setPosition(t.focalPoint[0]+t.distance*r[0],t.focalPoint[1]+t.distance*r[1],t.focalPoint[2]+t.distance*r[2]),o.setFocalPoint(t.focalPoint[0],t.focalPoint[1],t.focalPoint[2]),o.setViewUp(a[6],a[7],a[8])):(o.setPosition(a[0],a[1],a[2]),o.setFocalPoint(a[3],a[4],a[5]),o.setViewUp(a[6],a[7],a[8])),t.mode===nx&&t.dstRenderer.resetCamera())},e.delete=Vt((()=>e.setSrcRenderer(null)),e.delete),a()}(e,t)}var sx={newInstance:Et(ix,"vtkCameraSynchronizer"),extend:ix,SynchronizationMode:ox};const lx={},cx={CameraSync:class{constructor(e,t){this.ctx=e,this.behavior=sx.newInstance(this.getProperties(t)),this.behavior.update()}getProperties(e){let{actorBounds:t,srcRenderer:n,dstRenderer:r}=e;return{distance:3.4*Math.max(t[1]-t[0],t[3]-t[2],t[5]-t[4]),focalPoint:[.5*(t[0]+t[1]),.5*(t[2]+t[3]),.5*(t[4]+t[5])],mode:sx.SynchronizationMode.MODE_ORIENTATION,srcRenderer:this.ctx.getInstance(n),dstRenderer:this.ctx.getInstance(r)}}update(e){this.behavior.set(this.getProperties(e)),this.behavior.update()}delete(){this.behavior.delete()}}};var ux=function(e,t,n){const r=e.get("synchronizedViewId").synchronizedViewId;if(!t.behaviors||!r)return;lx[r]||(lx[r]={});const o=lx[r];if(t.behaviors.autoOrientation){const t=e.getRenderers();if(!o.autoOrientationAxes&&2===t.length){let e=null,n=null;for(let r=0;r<t.length;r++){const o=t[r];o.getInteractive()?e=o:n=o}e&&n&&(o.autoOrientationAxes=sx.newInstance({srcRenderer:e,dstRenderer:n}))}o.autoOrientationAxes&&2!==t.length&&(o.autoOrientationAxes.delete(),delete o.autoOrientationAxes)}const a=Object.keys(t.behaviors),i=Object.keys(o);for(let e=0;e<a.length;e++){const r=a[e];if(o[r])o[r].update(t.behaviors[r]);else{const e=t.behaviors[r];cx[e.type]?o[r]=new cx[e.type](n,e):console.log("No mapping for",e)}}for(let e=0;e<i.length;e++){const n=a[e];t.behaviors[n]||(o[n].delete(),delete o[n])}};const dx={},px=/instance:\${([^}]+)}/,fx={},gx=[],mx={},hx={vtkPoints:ql,vtkCellArray:Wl,vtkDataArray:Ts};function vx(e){return e.map((e=>px.exec(e))).filter((e=>e)).map((e=>e[1]))}function Tx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[];return e.dependencies&&e.dependencies.forEach((e=>{t.push(e.id),Tx(e,t)})),t}function yx(e,t,n,r){if(!t)return Promise.reject(new Error("No instance provided."));const o=dx[e];return o&&o.update?o.update(t,n,r):Promise.reject(new Error(`No updater for ${e}`))}function bx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=dx[e];return n&&n.build?n.build(t):(console.log("No builder for",e),null)}function xx(){Object.keys(dx).forEach((e=>{delete dx[e]}))}function Cx(e){if(1===e[1].length)return-1===gx.indexOf(e[1][0]);let t=!1;for(let n=0;n<e[1].length;n++)t=t||-1===gx.indexOf(e[1][n]);return t}function Sx(e,t,n){n.start(),e.set(t.properties),t.dependencies&&t.dependencies.forEach((e=>{const{id:t,type:r}=e;if(mx[r]){const{key:n,value:o}=mx[r];if(!n||e.properties[n]===o)return void gx.push((e=>`instance:\${${e}}`)(t))}let o=n.getInstance(t);o||(o=bx(r,{managedInstanceId:t}),n.registerInstance(t,o)),yx(r,o,e,n)})),t.calls&&t.calls.filter(Cx).forEach((t=>{var r;e[t[0]].apply(null,(r=n,t[1].map((e=>{const t=px.exec(e);return t?r.getInstance(t[1]):e}))))}));const r=[];if(t.arrays){const o=[],a=Object.values(t.arrays).map((t=>(n.start(),n.getArray(t.hash,t.dataType,n).then(function(e,t,n){return r=>{const o=t.registration?t.registration:"addArray",a=t.location?e.getReferenceByName(t.location):e;let i=null;if(i=t.location?e.getReferenceByName(t.location).getArray(t.name):e[`get${o.substring(3)}`](),i)return i.getData()!==r&&n.push([i.setData,[r,t.numberOfComponents]]),i;const s=t.vtkClass?t.vtkClass:"vtkDataArray",l=hx[s].newInstance({...t,values:r});return n.push([a[o],[l]]),l}}(e,t,o)).catch((e=>{console.log("Error fetching array",JSON.stringify(t),e)})).finally(n.end))));n.start(),r.push(Promise.all(a).then((()=>(o.length&&e.modified(),function(e){for(;e.length;){const[t,n]=e.shift();t(...n)}}(o),!0))).catch((e=>{console.error("Error in array handling for state",JSON.stringify(t),e)})).finally(n.end))}return n.end(),Promise.all(r)}function Ax(e,t,n){fx[t.id]||Sx(e,t,n),fx[t.id]=!0}function Ix(e,t){const n=[],r=e.getNumberOfArrays();for(let o=0;o<r;o++){const r=e.getArray(o).getName();t.has(r)||n.push(r)}for(let t=0;t<n.length;t++)e.removeArray(n[t])}function wx(e){const t=e.name?`_${e.name}`:"";return`${e.hash}_${e.dataType}${t}`}function Ox(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[];return(t,n,r)=>{r.start();const o={...n.properties};n.arrays||(n.arrays={});for(let t=0;t<e.length;t++){const r=e[t];if(n.properties[r]){const e=n.properties[r];e.registration=`set${lt(r)}`;const t=wx(e);n.arrays[t]=e,delete o[r]}}const a=n.properties.fields||[];for(let e=0;e<a.length;e++){const t=a[e],r=wx(t);n.arrays[r]=t}delete o.fields;const i={pointData:new Set,cellData:new Set,fieldData:new Set};a.forEach((e=>{let{location:t,name:n}=e;i[t].add(n)})),Ix(t.getPointData(),i.pointData),Ix(t.getCellData(),i.cellData);const s={...n};s.properties=o;const l=Sx(t,s,r);return r.end(),l}}const Px=Ox(["points","polys","verts","lines","strips"]),Rx=Ox([]);function Mx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:Sx;bx||yx?dx[e]={build:t,update:n}:delete dx[e]}const Ex={vtkMapper:["vtkOpenGLPolyDataMapper","vtkCompositePolyDataMapper2","vtkDataSetMapper"],vtkProperty:["vtkOpenGLProperty"],vtkRenderer:["vtkOpenGLRenderer"],vtkCamera:["vtkOpenGLCamera"],vtkColorTransferFunction:["vtkPVDiscretizableColorTransferFunction"],vtkActor:["vtkOpenGLActor","vtkPVLODActor"],vtkLight:["vtkOpenGLLight","vtkPVLight"],vtkTexture:["vtkOpenGLTexture"],vtkImageMapper:["vtkOpenGLImageSliceMapper"],vtkVolumeMapper:["vtkFixedPointVolumeRayCastMapper"]},Vx={vtkAxesActor:{build:tx.newInstance,update:Sx},vtkRenderWindow:{build:km.newInstance,update:function(e,t,n){t.calls&&t.calls.filter(Cx).filter((e=>"removeRenderer"===e[0])).forEach((e=>{vx(e[1]).forEach((e=>{n.getInstance(e).getViewProps().forEach((e=>{const t=e.get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>n.unregisterInstance(e))),n.unregisterInstance(n.getInstanceId(e))}))}))})),e.render(),Sx(e,t,n),ux(e,t,n)}},vtkRenderer:{build:Lm.newInstance,update:function(e,t,n){Sx(e,t,n);const r=new Set;t.dependencies&&t.dependencies.forEach((e=>{const t=n.getInstance(e.id);if(t){const n=Tx(e);t.set({flattenedDepIds:n},!0),n.forEach((e=>r.add(e)))}}));const o=new Set;t.calls&&t.calls.filter(Cx).filter((e=>"removeViewProp"===e[0])).forEach((e=>{vx(e[1]).forEach((e=>{const t=n.getInstance(e).get("flattenedDepIds").flattenedDepIds;t&&t.forEach((e=>o.add(e))),o.add(e)}))})),[...o].filter((e=>!r.has(e))).forEach((e=>n.unregisterInstance(e)))}},vtkLookupTable:{build:ul.newInstance,update:Sx},vtkCamera:{build:bm.newInstance,update:Ax},vtkPolyData:{build:Uc.newInstance,update:Px},vtkImageData:{build:Ks.newInstance,update:Rx},vtkMapper:{build:Fl.newInstance,update:Sx},vtkGlyph3DMapper:{build:tb.newInstance,update:Sx},vtkProperty:{build:ts.newInstance,update:Sx},vtkActor:{build:os.newInstance,update:Sx},vtkLight:{build:Sm.newInstance,update:Sx},vtkColorTransferFunction:{build:qy.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o,a,i]=e;return{x:t,r:n,g:r,b:o,midpoint:a,sharpness:i}}));e.set({...t.properties,nodes:n},!0)}else e.set(t.properties);n.end()}},vtkTexture:{build:Hc.newInstance,update:Sx},vtkVolume:{build:mb.newInstance,update:Sx},vtkVolumeMapper:{build:bb.newInstance,update:Sx},vtkVolumeProperty:{build:pb.newInstance,update:Sx},vtkImageSlice:{build:Ob.newInstance,update:Sx},vtkImageMapper:{build:Nb.newInstance,update:Sx},vtkImageProperty:{build:Ab.newInstance,update:Sx},vtkPiecewiseFunction:{build:ab.newInstance,update:function(e,t,n){if(n.start(),t.properties.nodes){const n=t.properties.nodes.map((e=>{let[t,n,r,o]=e;return{x:t,y:n,midpoint:r,sharpness:o}}));e.set({...t.properties,nodes:n},!0),e.sortAndUpdateRange()}else e.set(t.properties);n.end()}},vtkCubeAxesActor:{build:su.newInstance,update:Sx},vtkScalarBarActor:{build:Nd.newInstance,update:Sx}};function Dx(){(!(arguments.length>0&&void 0!==arguments[0])||arguments[0])&&xx(),Object.keys(Vx).forEach((e=>{const t=Vx[e];Mx(e,t.build,t.update)}))}function Lx(){Object.keys(Ex).forEach((e=>{Ex[e].forEach((t=>{dx[t]=dx[e]}))}))}Dx(),Lx(),mx.vtkPVLight={};var Bx={build:bx,update:yx,genericUpdater:Sx,oneTimeGenericUpdater:Ax,setTypeMapping:Mx,clearTypeMapping:xx,getSupportedTypes:function(){return Object.keys(dx)},clearOneTimeUpdaters:function(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];if(0===t.length)return void Object.keys(fx).forEach((e=>{delete fx[e]}));let r=t;return 1===r.length&&Array.isArray(r[0])&&(r=r[0]),r.forEach((e=>{delete fx[e]})),r},updateRenderWindow:function(e,t,n){return yx("vtkRenderWindow",e,t,n)},excludeInstance:function(e,t,n){mx[e]={key:t,value:n}},setDefaultMapping:Dx,applyDefaultAliases:Lx,alwaysUpdateCamera:function(){Mx("vtkCamera",bm.newInstance),Lx()}};const Nx={};function Fx(){const e={};let t=null;return{setFetchArrayFunction:function(e){t=e},getArray:function(n,r,o){const a=e[n];return a?(a.mtimes[o.getActiveViewId()]=o.getMTime(),new Promise(((e,t)=>{e(a.array)}))):t?new Promise(((a,i)=>{t(n).then((t=>{let i=t;if("string"==typeof t&&(i=vg.toArrayBuffer(t)),i instanceof Blob){const t=new FileReader;t.onload=()=>{const i=it(r,t.result),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:i},a(i)},t.readAsArrayBuffer(i)}else{const t=it(r,i),s={[o.getActiveViewId()]:o.getMTime()};e[n]={mtimes:s,array:t},a(t)}}),(e=>{console.log("Error getting data array:"),console.log(e),i(e)}))})):Promise.reject(new Error('No array fetcher found, please use "setArrayFetcher" to provide one'))},emptyCachedArrays:function(){Object.keys(e).forEach((t=>{delete e[t]}))},freeOldArrays:function(t,n){const r=n.getMTime()-t;Object.keys(e).filter((t=>e[t].mtimes[n.getActiveViewId()])).filter((t=>e[t].mtimes[n.getActiveViewId()]<r)).forEach((t=>{delete e[t]}))}}}function _x(){const e={};return{getInstance:function(t){return e[t]},getInstanceId:function(t){let n=null;return Object.keys(e).forEach((r=>{t===e[r]&&(n=r)})),n},registerInstance:function(t,n){e[t]=n,n.set({remoteId:t},!0,!0)},unregisterInstance:function(t){delete e[t]},emptyCachedInstances:function(){Object.keys(e).forEach((t=>{delete e[t]}))}}}function Gx(){let e=0;const t={start(){e+=1,t.invokeProgressEvent(e)},end(){e-=1,t.invokeProgressEvent(e),0===e&&t.invokeProgressDone()},resetProgress(){e=0}},n={};return Mt(t,n,"progressEvent"),Mt(t,n,"progressDone"),t}function kx(){const e={};let t="default";return{getMTime:function(n){return e[n||t]||1},incrementMTime:function(n){const r=n||t;e[r]||(e[r]=1),e[r]+=1},setActiveViewId:function(e){t=e},getActiveViewId:function(){return t}}}function Ux(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"default",t=Nx[e];return t||(t={...Fx(),..._x(),...Gx(),...kx()},Nx[e]=t),t}function zx(e,t){let n=-1,r=100;const o=e=>e.get("managedInstanceId").managedInstanceId,a=()=>Lt(e,o);function i(t){e.set({synchronizedViewId:t},!0,!0)}function s(){return e.get("synchronizedViewId").synchronizedViewId}return{synchronize:function(o){s()||i(o.id);const a=o.mtime||0;return s()===o.id&&n<a?new Promise(((i,s)=>{const l=t.onProgressDone((()=>{l.unsubscribe(),e.render(),i(!0)}));n=a,t.setActiveViewId(o.id),t.incrementMTime(),Bx.updateRenderWindow(e,o,t),t.freeOldArrays(r,t)})):Promise.resolve(!1)},setSynchronizedViewId:i,getSynchronizedViewId:s,updateGarbageCollectorThreshold:function(e){r=e},getManagedInstanceIds:a,clearOneTimeUpdaters:function(){Bx.clearOneTimeUpdaters(a())}}}const Wx={synchronizerContextName:"default",synchronizerContext:null,synchronizedViewId:null};function Hx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};Object.assign(t,Wx,n),km.extend(e,t),yt(e,t,["synchronizerContext"]),function(e,t){t.classHierarchy.push("vtkSynchronizableRenderWindow"),t.synchronizerContext||(t.synchronizerContext=Ux(t.synchronizerContextName));const n=zx(e,t.synchronizerContext);Object.keys(n).forEach((t=>{e[t]?e[t]=Vt(e[t],n[t]):e[t]=n[t]}))}(e,t)}var jx={newInstance:Et(Hx,"vtkSynchronizableRenderWindow"),extend:Hx,getSynchronizerContext:Ux,setSynchronizerContext:function(e,t){Nx[e]=t},clearSynchronizerContext:function(e){if(e&&Nx[e]&&delete Nx[e],!e){const e=Object.keys(Nx);for(let t=0;t<e.length;t++)delete Nx[e[t]]}},decorate:function(e){const t=zx(e,Ux(arguments.length>1&&void 0!==arguments[1]?arguments[1]:"default"));return{...t,...e,delete:Vt(e.delete,t.delete)}},createInstanceMap:_x,createArrayHandler:Fx,createProgressHandler:Gx,createSceneMtimeHandler:kx,vtkObjectManager:Bx};const{vtkErrorMacro:Kx,vtkDebugMacro:$x}=Ht;let qx=0;function Xx(e){const t=document.querySelector(`.webResource[data-url="${e}"]`);return t?t.innerHTML:null}function Yx(e){return"/"===e[0]?e.substr(1):e}const Zx={fetchJSON:function(e,t){return new Promise(((e,n)=>{const r=Xx(Yx(t));null===r?n(new Error(`No such JSON ${t}`)):e(JSON.parse(r))}))},fetchText:function(e,t){return new Promise(((e,n)=>{const r=Xx(t);null===r?n(new Error(`No such text ${t}`)):e(r)}))},fetchArray:function(e,t,n){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((o,a)=>{const i=Yx([t,n.ref.basepath,r.compression?`${n.ref.id}.gz`:n.ref.id].join("/")),s=Xx(i);if(null===s)a(new Error(`No such array ${i}`));else{if("string"===n.dataType){let e=atob(s);r.compression&&(e=om(tm(e))),n.values=JSON.parse(e)}else{const e=new Uint8Array(vg.toArrayBuffer(s));n.buffer=new ArrayBuffer(e.length),new Uint8Array(n.buffer).set(e),r.compression&&("string"===n.dataType||"JSON"===n.dataType?n.buffer=om(tm(new Uint8Array(n.buffer))):n.buffer=tm(new Uint8Array(n.buffer)).buffer),"JSON"===n.ref.encode?n.values=JSON.parse(n.buffer):(um!==n.ref.encode&&um&&($x(`Swap bytes of ${n.name}`),dm(n.buffer,as[n.dataType])),n.values=Ht.newTypedArray(n.dataType,n.buffer)),n.values.length!==n.size&&Kx(`Error in FetchArray: ${n.name} does not have the proper array size. Got ${n.values.length}, instead of ${n.size}`)}delete n.ref,0==--qx&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),o(n)}}))},fetchImage:function(e,t){return new Promise(((e,n)=>{const r=function(e){return document.querySelector(`.webResource[data-url="${e}"]`)}(t);r?e(r):n(new Error(`No such image ${t}`))}))}};yg("html",(e=>Zx));const{vtkErrorMacro:Qx,vtkDebugMacro:Jx}=Ht;function eC(e){return function(e){return"/"===e[0]?e.substr(1):e}(function(e){return new URL(e,"http://any").pathname}(e))}const tC=function(e){let t=!1,n=0,r=null,o="";var a;return(a=e.zipContent,new Promise(((e,t)=>{"string"==typeof a?e(function(e,t){if(t){for(var n=new xg(e.length),r=0;r<e.length;++r)n[r]=e.charCodeAt(r);return n}if(nm)return nm.encode(e);var o=e.length,a=new xg(e.length+(e.length>>1)),i=0,s=function(e){a[i++]=e};for(r=0;r<o;++r){if(i+5>a.length){var l=new xg(i+8+(o-r<<1));l.set(a),a=l}var c=e.charCodeAt(r);c<128||t?s(c):c<2048?(s(192|c>>6),s(128|63&c)):c>55295&&c<57344?(s(240|(c=65536+(1047552&c)|1023&e.charCodeAt(++r))>>18),s(128|c>>12&63),s(128|c>>6&63),s(128|63&c)):(s(224|c>>12),s(128|c>>6&63),s(128|63&c))}return Hg(a,0,i)}(a)):a instanceof Blob?e(a.arrayBuffer().then((e=>new Uint8Array(e)))):a instanceof ArrayBuffer?e(new Uint8Array(a)):a?.buffer instanceof ArrayBuffer?e(new Uint8Array(a.buffer)):t(new Error("Invalid datatype to unpack."))}))).then((n=>{r=lm(n),t=!0;const a=[];Object.keys(r).forEach((e=>{e.endsWith("index.json")&&a.push(e)})),a.sort(((e,t)=>e.length-t.length)),o=a[0].replace(/index\.json$/,""),e.callback&&e.callback(r)})),{fetchArray(e,a,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return new Promise(((l,c)=>{t||Qx("ERROR!!! zip not ready...");const u=eC([a,i.ref.basepath,s.compression?`${i.ref.id}.gz`:i.ref.id].join("/"));function d(){delete i.ref,0==--n&&e?.invokeBusy&&e.invokeBusy(!1),e?.modified&&e.modified(),l(i)}1==++n&&e?.invokeBusy&&e.invokeBusy(!0);const p=r[`${o}${u}`];if("string"!==i.dataType||s.compression){const e=function(e,t,n){return r=>{e.buffer=new ArrayBuffer(r.length),new Uint8Array(e.buffer).set(r),t&&("string"===e.dataType||"JSON"===e.dataType?e.buffer=om(tm(new Uint8Array(e.buffer))):e.buffer=tm(new Uint8Array(e.buffer)).buffer),"JSON"===e.ref.encode?e.values=JSON.parse(e.buffer):(um!==e.ref.encode&&um&&(Jx(`Swap bytes of ${e.name}`),dm(e.buffer,as[e.dataType])),e.values=Ht.newTypedArray(e.dataType,e.buffer)),e.values.length!==e.size&&Qx(`Error in FetchArray: ${e.name} does not have the proper array size. Got ${e.values.length}, instead of ${e.size}`),n()}}(i,s.compression,d);e(p)}else{const e=function(e,t,n){return r=>{e.values=t?JSON.parse(om(tm(r))):JSON.parse(r),n()}}(i,s.compression,d);e(om(p))}}))},fetchJSON(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=eC(n);t||Qx("ERROR!!! zip not ready...");const s=r[`${o}${i}`];if(a.compression){if("gz"===a.compression){const e=om(tm(s));return Promise.resolve(JSON.parse(e))}return Promise.reject(new Error("Invalid compression"))}return Promise.resolve(JSON.parse(om(s)))},fetchText(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=eC(n);t||Qx("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(om(lm(s))):Promise.reject(new Error("Invalid compression")):Promise.resolve(om(s))},fetchImage(e,n){const a=eC(n);t||Qx("ERROR!!! zip not ready...");const i=r[`${o}${a}`];return new Promise(((e,t)=>{const n=new Image;n.onload=()=>e(n),n.onerror=t;const r=hg(i.buffer);n.src=`data:image/${function(e){const t=e.split(".").pop().toLowerCase();return"jpg"===t?"jpeg":t}(a)};base64,${r}`}))},fetchBinary(e,n){let a=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const i=eC(n);t||Qx("ERROR!!! zip not ready...");const s=r[`${o}${i}`];return a.compression?"gz"===a.compression?Promise.resolve(tm(s).buffer):Promise.reject(new Error("Invalid compression")):Promise.resolve(s.buffer)}}};yg("zip",(e=>tC(e)));var nC=n(911),rC=n.n(nC),oC=n(893),aC=n.n(oC),iC=n(383),sC=n.n(iC),lC=n(884),cC=n.n(lC),uC=n(88),dC=n.n(uC),pC=n(997),fC=n.n(pC),gC=n(96),mC={};mC.styleTagTransform=fC(),mC.setAttributes=cC(),mC.insert=sC().bind(null,"head"),mC.domAPI=aC(),mC.insertStyleElement=dC(),rC()(gC.A,mC);var hC=gC.A&&gC.A.locals?gC.A.locals:void 0;let vC=!0;function TC(e){e.preventDefault(),e.stopPropagation()}function yC(e,t){vC=!1,function(e){for(;e.firstChild;)e.removeChild(e.firstChild)}(e);const r=By.newInstance({background:[1,1,1],rootContainer:e,containerStyle:{height:"100%",width:"100%",position:"absolute"}}).getRenderWindow(),o=jx.getSynchronizerContext(),a=jx.decorate(r);function i(e){o.setFetchArrayFunction((t=>Promise.resolve(e.hashes[t].content))),console.log(Object.keys(e)),a.synchronize(e.scene),a.render()}if(n.g.renderWindow=r,t.fileURL||t.url){const n=document.createElement("div");n.setAttribute("class",hC.progress),e.appendChild(n);const r=e=>{if(e.lengthComputable){const t=Math.floor(100*e.loaded/e.total);n.innerHTML=`Loading ${t}%`}else n.innerHTML=Ht.formatBytesToProperUnit(e.loaded)};t.fileURL?hm.fetchBinary(t.fileURL,{progressCallback:r}).then((t=>{e.removeChild(n);const r=bg.get("zip",{zipContent:t,callback:e=>{r.fetchJSON(null,"index.json").then(i)}})})):hm.fetchJSON(t.url,{progressCallback:r}).then((t=>{e.removeChild(n),i(t)}))}else if(t.file){const e=bg.get("zip",{zipContent:t.file,callback:t=>{e.fetchJSON(null,"index.json").then(i)}})}else if(t.base64Str){const e=vg.toArrayBuffer(t.base64Str),n=bg.get("zip",{zipContent:e,callback:e=>{n.fetchJSON(null,"index.json").then(i)}})}}function bC(e){vC=!1;const t=document.querySelector(".content"),n=document.querySelector("body"),r=e||t||n;r!==e?(r.classList.add(hC.fullScreen),n.style.margin="0",n.style.padding="0"):(n.style.margin="0",n.style.padding="0");const o=document.createElement("div");o.innerHTML=`<div class="${hC.bigFileDrop}"/><input type="file" accept=".zip,.vtksz" style="display: none;"/>`,r.appendChild(o);const a=o.querySelector("input");function i(e){TC(e);const t=e.dataTransfer,n=e.target.files||t.files;if(1===n.length){r.removeChild(o);const e=n[0].name.split(".").slice(-1)[0];yC(r,{file:n[0],ext:e})}}a.addEventListener("change",i),o.addEventListener("drop",i),o.addEventListener("click",(e=>a.click())),o.addEventListener("dragover",TC)}const xC=xh();if(xC.url||xC.fileURL){const e=document.querySelector(".content"),t=document.querySelector("body"),n=e||t;n&&(n.classList.add(hC.fullScreen),t.style.margin="0",t.style.padding="0"),vC=!1,function(e){if(!window.frameElement)return e(),!0;window.frameElement.getClientRects().length>0?e():function(e,t){new window.parent.IntersectionObserver(((e,n)=>{e.forEach((e=>{e.intersectionRatio>0&&(t(),n.disconnect())}))})).observe(e)}(window.frameElement,e)}((()=>yC(n,xC)))}setTimeout((()=>{vC&&bC()}),100),window.OfflineLocalView={initLocalFileLoader:bC,load:yC}},613:function(e){"use strict";e.exports=function(e){var t=[];return t.toString=function(){return this.map((function(t){var n="",r=void 0!==t[5];return t[4]&&(n+="@supports (".concat(t[4],") {")),t[2]&&(n+="@media ".concat(t[2]," {")),r&&(n+="@layer".concat(t[5].length>0?" ".concat(t[5]):""," {")),n+=e(t),r&&(n+="}"),t[2]&&(n+="}"),t[4]&&(n+="}"),n})).join("")},t.i=function(e,n,r,o,a){"string"==typeof e&&(e=[[null,e,void 0]]);var i={};if(r)for(var s=0;s<this.length;s++){var l=this[s][0];null!=l&&(i[l]=!0)}for(var c=0;c<e.length;c++){var u=[].concat(e[c]);r&&i[u[0]]||(void 0!==a&&(void 0===u[5]||(u[1]="@layer".concat(u[5].length>0?" ".concat(u[5]):""," {").concat(u[1],"}")),u[5]=a),n&&(u[2]?(u[1]="@media ".concat(u[2]," {").concat(u[1],"}"),u[2]=n):u[2]=n),o&&(u[4]?(u[1]="@supports (".concat(u[4],") {").concat(u[1],"}"),u[4]=o):u[4]="".concat(o)),t.push(u))}},t}},336:function(e){"use strict";e.exports=function(e,t){return t||(t={}),e?(e=String(e.__esModule?e.default:e),/^['"].*['"]$/.test(e)&&(e=e.slice(1,-1)),t.hash&&(e+=t.hash),/["'() \t\n]|(%20)/.test(e)||t.needQuotes?'"'.concat(e.replace(/"/g,'\\"').replace(/\n/g,"\\n"),'"'):e):e}},20:function(e){"use strict";e.exports=function(e){return e[1]}},555:function(e,t,n){"use strict";var r=n(382),o="function"==typeof Symbol&&"symbol"==typeof Symbol("foo"),a=Object.prototype.toString,i=Array.prototype.concat,s=Object.defineProperty,l=s&&function(){var e={};try{for(var t in s(e,"x",{enumerable:!1,value:e}),e)return!1;return e.x===e}catch(e){return!1}}(),c=function(e,t,n,r){var o;(!(t in e)||"function"==typeof(o=r)&&"[object Function]"===a.call(o)&&r())&&(l?s(e,t,{configurable:!0,enumerable:!1,value:n,writable:!0}):e[t]=n)},u=function(e,t){var n=arguments.length>2?arguments[2]:{},a=r(t);o&&(a=i.call(a,Object.getOwnPropertySymbols(t)));for(var s=0;s<a.length;s+=1)c(e,a[s],t[a[s]],n[a[s]])};u.supportsDescriptors=!!l,e.exports=u},77:function(e,t,n){"use strict";e.exports=function(){if("object"==typeof globalThis)return globalThis;var e;try{e=this||new Function("return this")()}catch(e){if("object"==typeof window)return window;if("object"==typeof self)return self;if(void 0!==n.g)return n.g}return e}()},730:function(e){"use strict";e.exports=function e(t,n){if(t===n)return!0;if(t&&n&&"object"==typeof t&&"object"==typeof n){if(t.constructor!==n.constructor)return!1;var r,o,a;if(Array.isArray(t)){if((r=t.length)!=n.length)return!1;for(o=r;0!=o--;)if(!e(t[o],n[o]))return!1;return!0}if(t.constructor===RegExp)return t.source===n.source&&t.flags===n.flags;if(t.valueOf!==Object.prototype.valueOf)return t.valueOf()===n.valueOf();if(t.toString!==Object.prototype.toString)return t.toString()===n.toString();if((r=(a=Object.keys(t)).length)!==Object.keys(n).length)return!1;for(o=r;0!=o--;)if(!Object.prototype.hasOwnProperty.call(n,a[o]))return!1;for(o=r;0!=o--;){var i=a[o];if(!e(t[i],n[i]))return!1}return!0}return t!=t&&n!=n}},979:function(e){"use strict";"undefined"!=typeof self?e.exports=self:"undefined"!=typeof window?e.exports=window:e.exports=Function("return this")()},59:function(e,t,n){"use strict";var r=n(555),o=n(979),a=n(920),i=n(482),s=a(),l=function(){return s};r(l,{getPolyfill:a,implementation:o,shim:i}),e.exports=l},920:function(e,t,n){"use strict";var r=n(979);e.exports=function(){return"object"==typeof n.g&&n.g&&n.g.Math===Math&&n.g.Array===Array?n.g:r}},482:function(e,t,n){"use strict";var r=n(555),o=n(920);e.exports=function(){var e=o();if(r.supportsDescriptors){var t=Object.getOwnPropertyDescriptor(e,"globalThis");t&&(!t.configurable||!t.enumerable&&t.writable&&globalThis===e)||Object.defineProperty(e,"globalThis",{configurable:!0,enumerable:!1,value:e,writable:!0})}else"object"==typeof globalThis&&globalThis===e||(e.globalThis=e);return e}},982:function(e,t,n){"use strict";var r;if(!Object.keys){var o=Object.prototype.hasOwnProperty,a=Object.prototype.toString,i=n(642),s=Object.prototype.propertyIsEnumerable,l=!s.call({toString:null},"toString"),c=s.call((function(){}),"prototype"),u=["toString","toLocaleString","valueOf","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","constructor"],d=function(e){var t=e.constructor;return t&&t.prototype===e},p={$applicationCache:!0,$console:!0,$external:!0,$frame:!0,$frameElement:!0,$frames:!0,$innerHeight:!0,$innerWidth:!0,$onmozfullscreenchange:!0,$onmozfullscreenerror:!0,$outerHeight:!0,$outerWidth:!0,$pageXOffset:!0,$pageYOffset:!0,$parent:!0,$scrollLeft:!0,$scrollTop:!0,$scrollX:!0,$scrollY:!0,$self:!0,$webkitIndexedDB:!0,$webkitStorageInfo:!0,$window:!0},f=function(){if("undefined"==typeof window)return!1;for(var e in window)try{if(!p["$"+e]&&o.call(window,e)&&null!==window[e]&&"object"==typeof window[e])try{d(window[e])}catch(e){return!0}}catch(e){return!0}return!1}();r=function(e){var t=null!==e&&"object"==typeof e,n="[object Function]"===a.call(e),r=i(e),s=t&&"[object String]"===a.call(e),p=[];if(!t&&!n&&!r)throw new TypeError("Object.keys called on a non-object");var g=c&&n;if(s&&e.length>0&&!o.call(e,0))for(var m=0;m<e.length;++m)p.push(String(m));if(r&&e.length>0)for(var h=0;h<e.length;++h)p.push(String(h));else for(var v in e)g&&"prototype"===v||!o.call(e,v)||p.push(String(v));if(l)for(var T=function(e){if("undefined"==typeof window||!f)return d(e);try{return d(e)}catch(e){return!1}}(e),y=0;y<u.length;++y)T&&"constructor"===u[y]||!o.call(e,u[y])||p.push(u[y]);return p}}e.exports=r},382:function(e,t,n){"use strict";var r=Array.prototype.slice,o=n(642),a=Object.keys,i=a?function(e){return a(e)}:n(982),s=Object.keys;i.shim=function(){if(Object.keys){var e=function(){var e=Object.keys(arguments);return e&&e.length===arguments.length}(1,2);e||(Object.keys=function(e){return o(e)?s(r.call(e)):s(e)})}else Object.keys=i;return Object.keys||i},e.exports=i},642:function(e){"use strict";var t=Object.prototype.toString;e.exports=function(e){var n=t.call(e),r="[object Arguments]"===n;return r||(r="[object Array]"!==n&&null!==e&&"object"==typeof e&&"number"==typeof e.length&&e.length>=0&&"[object Function]"===t.call(e.callee)),r}},318:function(e,t,n){var r=n(767),o=n(698),a=n(744),i=n(402),s=n(576),l=n(886),c=n(262);c.alea=r,c.xor128=o,c.xorwow=a,c.xorshift7=i,c.xor4096=s,c.tychei=l,e.exports=c},767:function(e,t,n){var r;!function(e,o){function a(e){var t,n=this,r=(t=4022871197,function(e){e=String(e);for(var n=0;n<e.length;n++){var r=.02519603282416938*(t+=e.charCodeAt(n));r-=t=r>>>0,t=(r*=t)>>>0,t+=4294967296*(r-=t)}return 2.3283064365386963e-10*(t>>>0)});n.next=function(){var e=2091639*n.s0+2.3283064365386963e-10*n.c;return n.s0=n.s1,n.s1=n.s2,n.s2=e-(n.c=0|e)},n.c=1,n.s0=r(" "),n.s1=r(" "),n.s2=r(" "),n.s0-=r(e),n.s0<0&&(n.s0+=1),n.s1-=r(e),n.s1<0&&(n.s1+=1),n.s2-=r(e),n.s2<0&&(n.s2+=1),r=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function s(e,t){var n=new a(e),r=t&&t.state,o=n.next;return o.int32=function(){return 4294967296*n.next()|0},o.double=function(){return o()+11102230246251565e-32*(2097152*o()|0)},o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.alea=s}(0,e=n.nmd(e),n.amdD)},886:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,r=t.d,o=t.a;return e=e<<25^e>>>7^n,n=n-r|0,r=r<<24^r>>>8^o,o=o-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-r|0,t.d=r<<16^n>>>16^o,t.a=o-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var r=0;r<n.length+20;r++)t.b^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.tychei=s}(0,e=n.nmd(e),n.amdD)},698:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xor128=s}(0,e=n.nmd(e),n.amdD)},576:function(e,t,n){var r;!function(e,o){function a(e){var t=this;t.next=function(){var e,n,r=t.w,o=t.X,a=t.i;return t.w=r=r+1640531527|0,n=o[a+34&127],e=o[a=a+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=o[a]=n^e,t.i=a,n+(r^r>>>16)|0},function(e,t){var n,r,o,a,i,s=[],l=128;for(t===(0|t)?(r=t,t=null):(t+="\0",r=0,l=Math.max(l,t.length)),o=0,a=-32;a<l;++a)t&&(r^=t.charCodeAt((a+32)%t.length)),0===a&&(i=r),r^=r<<10,r^=r>>>15,r^=r<<4,r^=r>>>13,a>=0&&(i=i+1640531527|0,o=0==(n=s[127&a]^=r+i)?o+1:0);for(o>=128&&(s[127&(t&&t.length||0)]=-1),o=127,a=512;a>0;--a)r=s[o+34&127],n=s[o=o+1&127],r^=r<<13,n^=n<<17,r^=r>>>15,n^=n>>>12,s[o]=r^n;e.w=i,e.X=s,e.i=o}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.X&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xor4096=s}(0,e=n.nmd(e),n.amdD)},402:function(e,t,n){var r;!function(e,o){function a(e){var t=this;t.next=function(){var e,n,r=t.x,o=t.i;return e=r[o],n=(e^=e>>>7)^e<<24,n^=(e=r[o+1&7])^e>>>10,n^=(e=r[o+3&7])^e>>>3,n^=(e=r[o+4&7])^e<<7,e=r[o+7&7],n^=(e^=e<<13)^e<<9,r[o]=n,t.i=o+1&7,n},function(e,t){var n,r=[];if(t===(0|t))r[0]=t;else for(t=""+t,n=0;n<t.length;++n)r[7&n]=r[7&n]<<15^t.charCodeAt(n)+r[n+1&7]<<13;for(;r.length<8;)r.push(0);for(n=0;n<8&&0===r[n];++n);for(8==n?r[7]=-1:r[n],e.x=r,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function s(e,t){null==e&&(e=+new Date);var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&(r.x&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xorshift7=s}(0,e=n.nmd(e),n.amdD)},744:function(e,t,n){var r;!function(e,o){function a(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var r=0;r<n.length+64;r++)t.x^=0|n.charCodeAt(r),r==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function s(e,t){var n=new a(e),r=t&&t.state,o=function(){return(n.next()>>>0)/4294967296};return o.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},o.int32=n.next,o.quick=o,r&&("object"==typeof r&&i(r,n),o.state=function(){return i(n,{})}),o}o&&o.exports?o.exports=s:n.amdD&&n.amdO?void 0===(r=function(){return s}.call(t,n,t,o))||(o.exports=r):this.xorwow=s}(0,e=n.nmd(e),n.amdD)},262:function(e,t,n){var r;!function(o,a,i){var s,l=256,c=i.pow(l,6),u=i.pow(2,52),d=2*u,p=255;function f(e,t,n){var r=[],p=v(h((t=1==t?{entropy:!0}:t||{}).entropy?[e,T(a)]:null==e?function(){try{var e;return s&&(e=s.randomBytes)?e=e(l):(e=new Uint8Array(l),(o.crypto||o.msCrypto).getRandomValues(e)),T(e)}catch(e){var t=o.navigator,n=t&&t.plugins;return[+new Date,o,n,o.screen,T(a)]}}():e,3),r),f=new g(r),y=function(){for(var e=f.g(6),t=c,n=0;e<u;)e=(e+n)*l,t*=l,n=f.g(1);for(;e>=d;)e/=2,t/=2,n>>>=1;return(e+n)/t};return y.int32=function(){return 0|f.g(4)},y.quick=function(){return f.g(4)/4294967296},y.double=y,v(T(f.S),a),(t.pass||n||function(e,t,n,r){return r&&(r.S&&m(r,f),e.state=function(){return m(f,{})}),n?(i.random=e,t):e})(y,p,"global"in t?t.global:this==i,t.state)}function g(e){var t,n=e.length,r=this,o=0,a=r.i=r.j=0,i=r.S=[];for(n||(e=[n++]);o<l;)i[o]=o++;for(o=0;o<l;o++)i[o]=i[a=p&a+e[o%n]+(t=i[o])],i[a]=t;(r.g=function(e){for(var t,n=0,o=r.i,a=r.j,i=r.S;e--;)t=i[o=p&o+1],n=n*l+i[p&(i[o]=i[a=p&a+t])+(i[a]=t)];return r.i=o,r.j=a,n})(l)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function h(e,t){var n,r=[],o=typeof e;if(t&&"object"==o)for(n in e)try{r.push(h(e[n],t-1))}catch(e){}return r.length?r:"string"==o?e:e+"\0"}function v(e,t){for(var n,r=e+"",o=0;o<r.length;)t[p&o]=p&(n^=19*t[p&o])+r.charCodeAt(o++);return T(t)}function T(e){return String.fromCharCode.apply(0,e)}if(v(i.random(),a),e.exports){e.exports=f;try{s=n(1)}catch(e){}}else void 0===(r=function(){return f}.call(t,n,t,e))||(e.exports=r)}("undefined"!=typeof self?self:this,[],Math)},292:function(e){e.exports=function(){"use strict";var e=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];function t(e,t){var n=e[0],r=e[1],o=e[2],a=e[3];r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[0]-680876936|0)<<7|n>>>25)+r|0)&r|~n&o)+t[1]-389564586|0)<<12|a>>>20)+n|0)&n|~a&r)+t[2]+606105819|0)<<17|o>>>15)+a|0)&a|~o&n)+t[3]-1044525330|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[4]-176418897|0)<<7|n>>>25)+r|0)&r|~n&o)+t[5]+1200080426|0)<<12|a>>>20)+n|0)&n|~a&r)+t[6]-1473231341|0)<<17|o>>>15)+a|0)&a|~o&n)+t[7]-45705983|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[8]+1770035416|0)<<7|n>>>25)+r|0)&r|~n&o)+t[9]-1958414417|0)<<12|a>>>20)+n|0)&n|~a&r)+t[10]-42063|0)<<17|o>>>15)+a|0)&a|~o&n)+t[11]-1990404162|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&o|~r&a)+t[12]+1804603682|0)<<7|n>>>25)+r|0)&r|~n&o)+t[13]-40341101|0)<<12|a>>>20)+n|0)&n|~a&r)+t[14]-1502002290|0)<<17|o>>>15)+a|0)&a|~o&n)+t[15]+1236535329|0)<<22|r>>>10)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[1]-165796510|0)<<5|n>>>27)+r|0)&o|r&~o)+t[6]-1069501632|0)<<9|a>>>23)+n|0)&r|n&~r)+t[11]+643717713|0)<<14|o>>>18)+a|0)&n|a&~n)+t[0]-373897302|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[5]-701558691|0)<<5|n>>>27)+r|0)&o|r&~o)+t[10]+38016083|0)<<9|a>>>23)+n|0)&r|n&~r)+t[15]-660478335|0)<<14|o>>>18)+a|0)&n|a&~n)+t[4]-405537848|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[9]+568446438|0)<<5|n>>>27)+r|0)&o|r&~o)+t[14]-1019803690|0)<<9|a>>>23)+n|0)&r|n&~r)+t[3]-187363961|0)<<14|o>>>18)+a|0)&n|a&~n)+t[8]+1163531501|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r&a|o&~a)+t[13]-1444681467|0)<<5|n>>>27)+r|0)&o|r&~o)+t[2]-51403784|0)<<9|a>>>23)+n|0)&r|n&~r)+t[7]+1735328473|0)<<14|o>>>18)+a|0)&n|a&~n)+t[12]-1926607734|0)<<20|r>>>12)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[5]-378558|0)<<4|n>>>28)+r|0)^r^o)+t[8]-2022574463|0)<<11|a>>>21)+n|0)^n^r)+t[11]+1839030562|0)<<16|o>>>16)+a|0)^a^n)+t[14]-35309556|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[1]-1530992060|0)<<4|n>>>28)+r|0)^r^o)+t[4]+1272893353|0)<<11|a>>>21)+n|0)^n^r)+t[7]-155497632|0)<<16|o>>>16)+a|0)^a^n)+t[10]-1094730640|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[13]+681279174|0)<<4|n>>>28)+r|0)^r^o)+t[0]-358537222|0)<<11|a>>>21)+n|0)^n^r)+t[3]-722521979|0)<<16|o>>>16)+a|0)^a^n)+t[6]+76029189|0)<<23|r>>>9)+o|0,r=((r+=((o=((o+=((a=((a+=((n=((n+=(r^o^a)+t[9]-640364487|0)<<4|n>>>28)+r|0)^r^o)+t[12]-421815835|0)<<11|a>>>21)+n|0)^n^r)+t[15]+530742520|0)<<16|o>>>16)+a|0)^a^n)+t[2]-995338651|0)<<23|r>>>9)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[0]-198630844|0)<<6|n>>>26)+r|0)|~o))+t[7]+1126891415|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[14]-1416354905|0)<<15|o>>>17)+a|0)|~n))+t[5]-57434055|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[12]+1700485571|0)<<6|n>>>26)+r|0)|~o))+t[3]-1894986606|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[10]-1051523|0)<<15|o>>>17)+a|0)|~n))+t[1]-2054922799|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[8]+1873313359|0)<<6|n>>>26)+r|0)|~o))+t[15]-30611744|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[6]-1560198380|0)<<15|o>>>17)+a|0)|~n))+t[13]+1309151649|0)<<21|r>>>11)+o|0,r=((r+=((a=((a+=(r^((n=((n+=(o^(r|~a))+t[4]-145523070|0)<<6|n>>>26)+r|0)|~o))+t[11]-1120210379|0)<<10|a>>>22)+n|0)^((o=((o+=(n^(a|~r))+t[2]+718787259|0)<<15|o>>>17)+a|0)|~n))+t[9]-343485551|0)<<21|r>>>11)+o|0,e[0]=n+e[0]|0,e[1]=r+e[1]|0,e[2]=o+e[2]|0,e[3]=a+e[3]|0}function n(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e.charCodeAt(t)+(e.charCodeAt(t+1)<<8)+(e.charCodeAt(t+2)<<16)+(e.charCodeAt(t+3)<<24);return n}function r(e){var t,n=[];for(t=0;t<64;t+=4)n[t>>2]=e[t]+(e[t+1]<<8)+(e[t+2]<<16)+(e[t+3]<<24);return n}function o(e){var r,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(r=64;r<=c;r+=64)t(u,n(e.substring(r-64,r)));for(o=(e=e.substring(r-64)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],r=0;r<o;r+=1)a[r>>2]|=e.charCodeAt(r)<<(r%4<<3);if(a[r>>2]|=128<<(r%4<<3),r>55)for(t(u,a),r=0;r<16;r+=1)a[r]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,t(u,a),u}function a(t){var n,r="";for(n=0;n<4;n+=1)r+=e[t>>8*n+4&15]+e[t>>8*n&15];return r}function i(e){var t;for(t=0;t<e.length;t+=1)e[t]=a(e[t]);return e.join("")}function s(e){return/[\u0080-\uFFFF]/.test(e)&&(e=unescape(encodeURIComponent(e))),e}function l(e){var t,n=[],r=e.length;for(t=0;t<r-1;t+=2)n.push(parseInt(e.substr(t,2),16));return String.fromCharCode.apply(String,n)}function c(){this.reset()}return i(o("hello")),"undefined"==typeof ArrayBuffer||ArrayBuffer.prototype.slice||function(){function e(e,t){return(e=0|e||0)<0?Math.max(e+t,0):Math.min(e,t)}ArrayBuffer.prototype.slice=function(t,n){var r,o,a,i,s=this.byteLength,l=e(t,s),c=s;return undefined!==n&&(c=e(n,s)),l>c?new ArrayBuffer(0):(r=c-l,o=new ArrayBuffer(r),a=new Uint8Array(o),i=new Uint8Array(this,l,r),a.set(i),o)}}(),c.prototype.append=function(e){return this.appendBinary(s(e)),this},c.prototype.appendBinary=function(e){this._buff+=e,this._length+=e.length;var r,o=this._buff.length;for(r=64;r<=o;r+=64)t(this._hash,n(this._buff.substring(r-64,r)));return this._buff=this._buff.substring(r-64),this},c.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r.charCodeAt(t)<<(t%4<<3);return this._finish(a,o),n=i(this._hash),e&&(n=l(n)),this.reset(),n},c.prototype.reset=function(){return this._buff="",this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},c.prototype.getState=function(){return{buff:this._buff,length:this._length,hash:this._hash.slice()}},c.prototype.setState=function(e){return this._buff=e.buff,this._length=e.length,this._hash=e.hash,this},c.prototype.destroy=function(){delete this._hash,delete this._buff,delete this._length},c.prototype._finish=function(e,n){var r,o,a,i=n;if(e[i>>2]|=128<<(i%4<<3),i>55)for(t(this._hash,e),i=0;i<16;i+=1)e[i]=0;r=(r=8*this._length).toString(16).match(/(.*?)(.{0,8})$/),o=parseInt(r[2],16),a=parseInt(r[1],16)||0,e[14]=o,e[15]=a,t(this._hash,e)},c.hash=function(e,t){return c.hashBinary(s(e),t)},c.hashBinary=function(e,t){var n=i(o(e));return t?l(n):n},c.ArrayBuffer=function(){this.reset()},c.ArrayBuffer.prototype.append=function(e){var n,o,a,i,s,l=(o=this._buff.buffer,a=e,i=!0,(s=new Uint8Array(o.byteLength+a.byteLength)).set(new Uint8Array(o)),s.set(new Uint8Array(a),o.byteLength),i?s:s.buffer),c=l.length;for(this._length+=e.byteLength,n=64;n<=c;n+=64)t(this._hash,r(l.subarray(n-64,n)));return this._buff=n-64<c?new Uint8Array(l.buffer.slice(n-64)):new Uint8Array(0),this},c.ArrayBuffer.prototype.end=function(e){var t,n,r=this._buff,o=r.length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];for(t=0;t<o;t+=1)a[t>>2]|=r[t]<<(t%4<<3);return this._finish(a,o),n=i(this._hash),e&&(n=l(n)),this.reset(),n},c.ArrayBuffer.prototype.reset=function(){return this._buff=new Uint8Array(0),this._length=0,this._hash=[1732584193,-271733879,-1732584194,271733878],this},c.ArrayBuffer.prototype.getState=function(){var e,t=c.prototype.getState.call(this);return t.buff=(e=t.buff,String.fromCharCode.apply(null,new Uint8Array(e))),t},c.ArrayBuffer.prototype.setState=function(e){return e.buff=function(e,t){var n,r=e.length,o=new ArrayBuffer(r),a=new Uint8Array(o);for(n=0;n<r;n+=1)a[n]=e.charCodeAt(n);return t?a:o}(e.buff,!0),c.prototype.setState.call(this,e)},c.ArrayBuffer.prototype.destroy=c.prototype.destroy,c.ArrayBuffer.prototype._finish=c.prototype._finish,c.ArrayBuffer.hash=function(e,n){var o=i(function(e){var n,o,a,i,s,l,c=e.length,u=[1732584193,-271733879,-1732584194,271733878];for(n=64;n<=c;n+=64)t(u,r(e.subarray(n-64,n)));for(o=(e=n-64<c?e.subarray(n-64):new Uint8Array(0)).length,a=[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],n=0;n<o;n+=1)a[n>>2]|=e[n]<<(n%4<<3);if(a[n>>2]|=128<<(n%4<<3),n>55)for(t(u,a),n=0;n<16;n+=1)a[n]=0;return i=(i=8*c).toString(16).match(/(.*?)(.{0,8})$/),s=parseInt(i[2],16),l=parseInt(i[1],16)||0,a[14]=s,a[15]=l,t(u,a),u}(new Uint8Array(e)));return n?l(o):o},c}()},96:function(e,t,n){"use strict";var r=n(20),o=n.n(r),a=n(613),i=n.n(a),s=n(336),l=n.n(s),c=new URL(n(183),n.b),u=i()(o()),d=l()(c);u.push([e.id,".viewer-module-fullScreen_bbk9Y {\n  position: absolute;\n  width: 100vw;\n  height: 100vh;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n  background: black;\n  margin: 0;\n  padding: 0;\n  z-index: -1;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n}\n\n.viewer-module-fullParentSize_ETopO {\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  overflow: hidden;\n}\n\n.viewer-module-bigFileDrop_aqCgh {\n  position: absolute;\n  left: 50%;\n  top: 50%;\n  transform: translate(-50%, -50%);\n  background-color: white;\n  background-image: url("+d+");\n  background-repeat: no-repeat;\n  background-position: center;\n  background-size: contain;\n  border-radius: 10px;\n  width: 50px;\n  padding: calc(50vh - 2em) calc(50vw - 25px - 2em);\n  cursor: pointer;\n}\n\n.viewer-module-progress_cYjQJ {\n  flex: none;\n  font-size: 50px;\n  color: black;\n  z-index: 1;\n  background: rgba(128,128,128,.5);\n  padding: 20px;\n  border-radius: 10px;\n  -webkit-user-select: none;\n     -moz-user-select: none;\n          user-select: none;\n}\n\nbody {\n  margin: 0;\n}\n\nhtml { \n  overflow: hidden; \n}\n",""]),u.locals={fullScreen:"viewer-module-fullScreen_bbk9Y",fullParentSize:"viewer-module-fullParentSize_ETopO",bigFileDrop:"viewer-module-bigFileDrop_aqCgh",progress:"viewer-module-progress_cYjQJ"},t.A=u},50:function(e,t,n){var r=n(975),o=n(77);void 0===o.OfflineLocalView&&(o.OfflineLocalView=r),e.exports=r},911:function(e){"use strict";var t=[];function n(e){for(var n=-1,r=0;r<t.length;r++)if(t[r].identifier===e){n=r;break}return n}function r(e,r){for(var a={},i=[],s=0;s<e.length;s++){var l=e[s],c=r.base?l[0]+r.base:l[0],u=a[c]||0,d="".concat(c," ").concat(u);a[c]=u+1;var p=n(d),f={css:l[1],media:l[2],sourceMap:l[3],supports:l[4],layer:l[5]};if(-1!==p)t[p].references++,t[p].updater(f);else{var g=o(f,r);r.byIndex=s,t.splice(s,0,{identifier:d,updater:g,references:1})}i.push(d)}return i}function o(e,t){var n=t.domAPI(t);return n.update(e),function(t){if(t){if(t.css===e.css&&t.media===e.media&&t.sourceMap===e.sourceMap&&t.supports===e.supports&&t.layer===e.layer)return;n.update(e=t)}else n.remove()}}e.exports=function(e,o){var a=r(e=e||[],o=o||{});return function(e){e=e||[];for(var i=0;i<a.length;i++){var s=n(a[i]);t[s].references--}for(var l=r(e,o),c=0;c<a.length;c++){var u=n(a[c]);0===t[u].references&&(t[u].updater(),t.splice(u,1))}a=l}}},383:function(e){"use strict";var t={};e.exports=function(e,n){var r=function(e){if(void 0===t[e]){var n=document.querySelector(e);if(window.HTMLIFrameElement&&n instanceof window.HTMLIFrameElement)try{n=n.contentDocument.head}catch(e){n=null}t[e]=n}return t[e]}(e);if(!r)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");r.appendChild(n)}},88:function(e){"use strict";e.exports=function(e){var t=document.createElement("style");return e.setAttributes(t,e.attributes),e.insert(t,e.options),t}},884:function(e,t,n){"use strict";e.exports=function(e){var t=n.nc;t&&e.setAttribute("nonce",t)}},893:function(e){"use strict";e.exports=function(e){var t=e.insertStyleElement(e);return{update:function(n){!function(e,t,n){var r="";n.supports&&(r+="@supports (".concat(n.supports,") {")),n.media&&(r+="@media ".concat(n.media," {"));var o=void 0!==n.layer;o&&(r+="@layer".concat(n.layer.length>0?" ".concat(n.layer):""," {")),r+=n.css,o&&(r+="}"),n.media&&(r+="}"),n.supports&&(r+="}");var a=n.sourceMap;a&&"undefined"!=typeof btoa&&(r+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleTagTransform(r,e,t.options)}(t,e,n)},remove:function(){!function(e){if(null===e.parentNode)return!1;e.parentNode.removeChild(e)}(t)}}}},997:function(e){"use strict";e.exports=function(e,t){if(t.styleSheet)t.styleSheet.cssText=e;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(e))}}},183:function(e,t,n){"use strict";e.exports=n.p+"138e7b1469f64156810a.jpg"},1:function(){}},t={};function n(r){var o=t[r];if(void 0!==o)return o.exports;var a=t[r]={id:r,loaded:!1,exports:{}};return e[r].call(a.exports,a,a.exports,n),a.loaded=!0,a.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,{a:t}),t},n.d=function(e,t){for(var r in t)n.o(t,r)&&!n.o(e,r)&&Object.defineProperty(e,r,{enumerable:!0,get:t[r]})},n.g=function(){if("object"==typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"==typeof window)return window}}(),n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=function(e){return e.paths=[],e.children||(e.children=[]),e},n.p="",n.b=document.baseURI||self.location.href,n.nc=void 0,n(50)}();
</script>
<script>
var container = document.querySelector('.content');
var base64Str = "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";

OfflineLocalView.load(container, { base64Str });
</script>
</body>
</html>
