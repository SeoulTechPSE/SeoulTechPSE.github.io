<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">

<head>

<meta charset="utf-8" />
<meta name="generator" content="quarto-1.8.26" />

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />


<title>Appendix K — The FEniCS computing platform – Engineering Mathematics</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>

<!-- htmldependencies:E3FAD763 -->
<script id="quarto-search-options" type="application/json">{
  "location": "sidebar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "start",
  "type": "textbox",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<script src="https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js" integrity="sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js" integrity="sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2" crossorigin="anonymous" data-relocate-top="true"></script>
<script type="application/javascript">define('jquery', [],function() {return window.jQuery;})</script>
<script src="https://cdn.jsdelivr.net/npm/@jupyter-widgets/html-manager@*/dist/embed-amd.js" crossorigin="anonymous"></script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN" && texText && texText.data) {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body>

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
  <nav class="quarto-secondary-nav">
    <div class="container-fluid d-flex">
      <button type="button" class="quarto-btn-toggle btn"
      data-bs-toggle="collapse" role="button" data-bs-target=".quarto-sidebar-collapse-item" 
      aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation"
      onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
        <i class="bi bi-layout-text-sidebar-reverse"></i>
      </button>
        <h1 class="quarto-secondary-nav-title no-breadcrumbs"></h1>
        <a class="flex-grow-1" role="navigation" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" role="link"
        aria-controls="quarto-sidebar" aria-expanded="false" aria-label="Toggle sidebar navigation"
        onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">      
        </a>
      <button type="button" class="btn quarto-search-button" aria-label="Search" onclick="window.quartoOpenSearch();">
        <i class="bi bi-search"></i>
      </button>
    </div>
  </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article">
<!-- sidebar -->
  <nav id="quarto-sidebar" class="sidebar collapse collapse-horizontal quarto-sidebar-collapse-item sidebar-navigation floating overflow-auto">
    <div class="pt-lg-2 mt-2 text-left sidebar-header">
    <div class="sidebar-title mb-0 py-0">
      <a href="/">
      Engineering Mathematics
      </a> 
    </div>
      </div>
        <div class="mt-2 flex-shrink-0 align-items-center">
        <div class="sidebar-search">
        <div id="quarto-search" class="" title="Search"></div>
        </div>
        </div>
    <div class="sidebar-menu-container"> 
    <ul class="list-unstyled mt-1">
        <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/index.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text">Welcome</span></a>
  </div>
</li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1"  role="navigation" aria-expanded="true">
 <span class="menu-text">**First Semester**</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-1" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-1" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/ch_01_Introduction_to_Differential_Equations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>1</span>  <span class='chapter-title'>Introduction to Differential Equations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/ch_02_First-Order_Differential_Equations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>2</span>  <span class='chapter-title'>First-Order Differential Equations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/ch_03_Higher-Order_Differential_Equations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>3</span>  <span class='chapter-title'>Higher-Order Differential Equations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/ch_04_The_Laplace_Transform.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>4</span>  <span class='chapter-title'>The Laplace Transform</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/ch_05_Series_Solutions_of_Linear_Differential_Equations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>5</span>  <span class='chapter-title'>Series Solutions of Linear Differential Equations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/ch_08_Matrices.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>6</span>  <span class='chapter-title'>Matrices</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/ch_10_Systems_of_Linear_Differential_Equations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>7</span>  <span class='chapter-title'>Systems of Linear Differential Equations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/ch_11_Systems_of_Nonlinear_Differential_Equations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>8</span>  <span class='chapter-title'>Systems of Nonlinear Differential Equations</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2"  role="navigation" aria-expanded="true">
 <span class="menu-text">**Second Semester**</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-2" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-2" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/ch_07_Vectors.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>9</span>  <span class='chapter-title'>Vectors</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/ch_09_Vector_Calculus.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>10</span>  <span class='chapter-title'>Vector Calculus</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/ch_12_Orthogonal_Functions_and_Fourier_Series.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>11</span>  <span class='chapter-title'>Orthogonal Functions and Fourier Series</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/ch_x1_Parabolic_PDEs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>12</span>  <span class='chapter-title'>Parabolic Partial Differential Equations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/ch_x2_Hyperbolic_PDEs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>13</span>  <span class='chapter-title'>Hyperbolic Partial Differential Equations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/ch_x3_Elliptic_PDEs.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>14</span>  <span class='chapter-title'>Elliptic Partial Differential Equations</span></span></a>
  </div>
</li>
      </ul>
  </li>
        <li class="sidebar-item sidebar-item-section">
      <div class="sidebar-item-container"> 
            <a class="sidebar-item-text sidebar-link text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3"  role="navigation" aria-expanded="true">
 <span class="menu-text">Appendices</span></a>
          <a class="sidebar-item-toggle text-start" data-bs-toggle="collapse" data-bs-target="#quarto-sidebar-section-3" role="navigation" aria-expanded="true" aria-label="Toggle section">
            <i class="bi bi-chevron-right ms-2"></i>
          </a> 
      </div>
      <ul id="quarto-sidebar-section-3" class="collapse list-unstyled sidebar-section depth1 show">  
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/x_numpy_vectors_matrices_and_multidimensional_arrays.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>A</span>  <span class='chapter-title'>Numpy: Vectors, Matrices, and Multidimensional Arrays</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/x_sympy_symbolic_computing.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>B</span>  <span class='chapter-title'>Sympy: Symbolic Computing</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/x_sympy_Laplace_transform.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>C</span>  <span class='chapter-title'>Sympy: Laplace Transform</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/x_equation_solving.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>D</span>  <span class='chapter-title'>Equation Solving</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/x_optimization.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>E</span>  <span class='chapter-title'>Optimization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/x_interpolation.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>F</span>  <span class='chapter-title'>Interpolation</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/x_integration.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>G</span>  <span class='chapter-title'>Integration</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/x_ordinary_differential_equations.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>H</span>  <span class='chapter-title'>Ordinary Differential Equations</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/x_double_pendulum.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>I</span>  <span class='chapter-title'>Double Pendulum</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/x_PDE_dedalus.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>J</span>  <span class='chapter-title'>DEDALUS</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/x_PDE_FEniCS.html" class="sidebar-item-text sidebar-link active">
 <span class="menu-text"><span class='chapter-number'>K</span>  <span class='chapter-title'>The FEniCS computing platform</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/x_matplotlib.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>L</span>  <span class='chapter-title'>Matplotlib: Plotting and Visualization</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/x_Mandelbrot_set.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>M</span>  <span class='chapter-title'>Mandelbrot Set in Python</span></span></a>
  </div>
</li>
          <li class="sidebar-item">
  <div class="sidebar-item-container"> 
  <a href="/x_hydrogen_orbital.html" class="sidebar-item-text sidebar-link">
 <span class="menu-text"><span class='chapter-number'>N</span>  <span class='chapter-title'>Hydrogen Atomic Orbitals</span></span></a>
  </div>
</li>
      </ul>
  </li>
    </ul>
    </div>
</nav>
<div id="quarto-sidebar-glass" class="quarto-sidebar-collapse-item" data-bs-toggle="collapse" data-bs-target=".quarto-sidebar-collapse-item" ></div>
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <div id="quarto-toc-target"></div>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title"><span id="sec-fenicsx" class="quarto-section-identifier">Appendix K — The FEniCS computing platform</span></h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>

<nav id="TOC" role="doc-toc">
    <h2 id="toc-title">Table of contents</h2>
   
  <ul>
  <li><a href="#sec-fenicsx-getting-started" id="toc-sec-fenicsx-getting-started"><span class="header-section-number">K.1</span> Getting started</a></li>
  <li><a href="#sec-fenicsx-overview" id="toc-sec-fenicsx-overview"><span class="header-section-number">K.2</span> An Overview of the FEniCS Project</a></li>
  <li><a href="#what-you-will-learn" id="toc-what-you-will-learn"><span class="header-section-number">K.3</span> What you will learn</a></li>
  <li><a href="#sec-fenicsx-Poisson" id="toc-sec-fenicsx-Poisson"><span class="header-section-number">K.4</span> Solving the Poisson equation</a>
  <ul>
  <li><a href="#finite-element-variational-formulation" id="toc-finite-element-variational-formulation"><span class="header-section-number">K.4.1</span> Finite element variational formulation</a></li>
  <li><a href="#abstract-finite-element-variational-formulation" id="toc-abstract-finite-element-variational-formulation"><span class="header-section-number">K.4.2</span> Abstract finite element variational formulation</a></li>
  <li><a href="#implementation" id="toc-implementation"><span class="header-section-number">K.4.3</span> Implementation</a></li>
  </ul></li>
  <li><a href="#weak-imposition-of-dirichlet-conditions-for-the-poisson-problem" id="toc-weak-imposition-of-dirichlet-conditions-for-the-poisson-problem"><span class="header-section-number">K.5</span> Weak imposition of Dirichlet conditions for the Poisson problem</a></li>
  <li><a href="#deflection-of-a-membrane" id="toc-deflection-of-a-membrane"><span class="header-section-number">K.6</span> Deflection of a membrane</a>
  <ul>
  <li><a href="#scaling-the-equation" id="toc-scaling-the-equation"><span class="header-section-number">K.6.1</span> Scaling the equation</a></li>
  <li><a href="#implementation-1" id="toc-implementation-1"><span class="header-section-number">K.6.2</span> Implementation</a></li>
  </ul></li>
  <li><a href="#a-gallery-of-finite-element-solvers" id="toc-a-gallery-of-finite-element-solvers"><span class="header-section-number">K.7</span> A Gallery of finite element solvers</a>
  <ul>
  <li><a href="#the-heat-equation" id="toc-the-heat-equation"><span class="header-section-number">K.7.1</span> The heat equation</a></li>
  <li><a href="#singular-poisson-problem" id="toc-singular-poisson-problem"><span class="header-section-number">K.7.2</span> Singular Poisson problem</a></li>
  <li><a href="#a-nonlinear-poisson-equation" id="toc-a-nonlinear-poisson-equation"><span class="header-section-number">K.7.3</span> A nonlinear Poisson equation</a></li>
  <li><a href="#the-equations-of-linear-elasticity" id="toc-the-equations-of-linear-elasticity"><span class="header-section-number">K.7.4</span> The equations of linear elasticity</a></li>
  <li><a href="#the-navier-stokes-equations" id="toc-the-navier-stokes-equations"><span class="header-section-number">K.7.5</span> The Navier-Stokes equations</a></li>
  <li><a href="#hyperelasticity" id="toc-hyperelasticity"><span class="header-section-number">K.7.6</span> Hyperelasticity</a></li>
  <li><a href="#sec-fenicsx-helmholtz" id="toc-sec-fenicsx-helmholtz"><span class="header-section-number">K.7.7</span> The Helmholtz equation</a></li>
  <li><a href="#sec-fenicsx-adaptive-mesh" id="toc-sec-fenicsx-adaptive-mesh"><span class="header-section-number">K.7.8</span> Adaptive mesh refinement with GMSH/FEniCSx</a></li>
  </ul></li>
  <li><a href="#subdomains-and-boundary-conditions" id="toc-subdomains-and-boundary-conditions"><span class="header-section-number">K.8</span> Subdomains and boundary conditions</a>
  <ul>
  <li><a href="#combining-dirichlet-and-neumann-conditions" id="toc-combining-dirichlet-and-neumann-conditions"><span class="header-section-number">K.8.1</span> Combining Dirichlet and Neumann conditions</a></li>
  <li><a href="#setting-multiple-dirichlet-condition" id="toc-setting-multiple-dirichlet-condition"><span class="header-section-number">K.8.2</span> Setting multiple Dirichlet condition</a></li>
  <li><a href="#defining-subdomains-for-different-materials" id="toc-defining-subdomains-for-different-materials"><span class="header-section-number">K.8.3</span> Defining subdomains for different materials</a></li>
  <li><a href="#setting-multiple-dirichlet-neumann-and-robin-conditions" id="toc-setting-multiple-dirichlet-neumann-and-robin-conditions"><span class="header-section-number">K.8.4</span> Setting multiple Dirichlet, Neumann, and Robin conditions</a></li>
  <li><a href="#component-wise-dirichlet-bc" id="toc-component-wise-dirichlet-bc"><span class="header-section-number">K.8.5</span> Component-wise Dirichlet BC</a></li>
  <li><a href="#electromagnetics-example" id="toc-electromagnetics-example"><span class="header-section-number">K.8.6</span> Electromagnetics example</a></li>
  </ul></li>
  <li><a href="#best-practices-for-fenicsx" id="toc-best-practices-for-fenicsx"><span class="header-section-number">K.9</span> Best Practices for FEniCSx</a>
  <ul>
  <li><a href="#solver-configuration" id="toc-solver-configuration"><span class="header-section-number">K.9.1</span> Solver configuration</a></li>
  <li><a href="#jit-options-and-visualization-using-pandas" id="toc-jit-options-and-visualization-using-pandas"><span class="header-section-number">K.9.2</span> JIT options and visualization using Pandas</a></li>
  <li><a href="#error-control-computing-convergence-rates" id="toc-error-control-computing-convergence-rates"><span class="header-section-number">K.9.3</span> Error control: Computing convergence rates</a></li>
  <li><a href="#custom-newton-solvers" id="toc-custom-newton-solvers"><span class="header-section-number">K.9.4</span> Custom Newton solvers</a></li>
  </ul></li>
  </ul>
</nav>
<p><strong>FEniCS</strong> is a popular open-source computing platform for solving partial differential equations (PDEs) with the finite element method (FEM). FEniCS enables users to quickly translate scientific models into efficient finite element code. With the high-level Python and C++ interfaces to FEniCS, it is easy to get started, but FEniCS offers also powerful capabilities for more experienced programmers. FEniCS runs on a multitude of platforms ranging from laptops to high-performance computers</p>
<div class="quarto-figure quarto-figure-center">
<figure>
<p><a href="https://fenicsproject.org"><img src="https://fenicsproject.org/assets/logo/fenics_logo.png" class="img-fluid quarto-figure quarto-figure-center" style="width:25.0%" /></a></p>
</figure>
</div>
<section id="sec-fenicsx-getting-started" class="level2" data-number="K.1">
<h2 data-number="K.1"><span class="header-section-number">K.1</span> Getting started</h2>
<p>The latest stable release of FEniCSx is version 0.9, which was released in October 2024. The easiest way to start using <code>FEniCSx</code> on MacOS and other systems is to install it using <code>conda</code>:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> conda create <span class="at">-n</span> fenicsx</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> conda activate fenicsx</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> conda install <span class="at">-c</span> conda-forge fenics-dolfinx mpich pyvista </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> conda install <span class="at">-c</span> conda-forge petsc petsc4py</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> conda install ipykernel</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> python <span class="at">-m</span> ipykernel install <span class="dt">\</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="op">&gt;</span>       --user <span class="at">--name</span> fenicsx <span class="at">--display-name</span> <span class="st">&quot;FEniCSx&quot;</span></span></code></pre></div>
<div id="1fe757f0" class="cell" data-execution_count="1">
<div class="sourceCode" id="cb2"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dolfinx</span>
<span id="cb2-2"><a href="#cb2-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&#39;DOLFINx version: </span><span class="sc">{</span>dolfinx<span class="sc">.</span>__version__<span class="sc">}</span><span class="ss">&#39;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>DOLFINx version: 0.9.0</code></pre>
</div>
</div>
</section>
<section id="sec-fenicsx-overview" class="level2" data-number="K.2">
<h2 data-number="K.2"><span class="header-section-number">K.2</span> An Overview of the FEniCS Project</h2>
<ul>
<li><p>The <code>FEniCS</code> Project is a research and software initiative focused on developing mathematical methods and software for solving partial differential equations (PDEs). Its goal is to provide intuitive, efficient, and flexible tools for scientific computing. Launched in 2003, the project is the result of collaboration among researchers from universities and research institutes worldwide. For the latest updates and more information, visit the <a href="https://fenicsproject.org/">FEniCS Project</a></p></li>
<li><p>The latest version of the <code>FEniCS</code> project, <code>FEniCSx</code>, consists of several building blocks, namely <code>DOLFINx</code>, <code>UFL</code>, <code>FFCx</code>, and <code>Basix</code>. We will now go through the main objectives of each of these building blocks</p>
<ul>
<li><code>DOLFINx</code> is the high performance <code>C++</code> backend of <code>FEniCSx</code>, where structures such as meshes, function spaces and functions are implemented. Additionally, <code>DOLFINx</code> also contains compute intensive functions such as finite element assembly and mesh refinement algorithms. It also provides an interface to linear algebra solvers and data-structures, such as <code>PETSc</code></li>
<li><code>UFL</code> is a high-level form language for describing variational formulations with a high-level mathematical syntax</li>
<li><code>FFCx</code> is the form compiler of <code>FEniCSx</code>; given variational formulations written with <code>UFL</code>, it generates efficient <code>C</code> code</li>
<li><code>Basix</code> is the finite element backend of <code>FEniCSx</code>, responsible for generating finite element basis functions</li>
</ul></li>
</ul>
</section>
<section id="what-you-will-learn" class="level2" data-number="K.3">
<h2 data-number="K.3"><span class="header-section-number">K.3</span> What you will learn</h2>
<p>The goal of this tutorial is to demonstrate how to apply the finite element to solve PDEs using <code>FEniCS</code>. Through a series of examples, we will demonstrate how to:</p>
<ul>
<li>Solve linear PDEs (such as the Poisson equation)</li>
<li>Solve time-dependent PDEs (such as the heat equation)</li>
<li>Solve non-linear PDEs</li>
<li>Solve systems of time-dependent non-linear PDEs</li>
</ul>
<p>Important topics include: how to set boundary conditions of various types (Dirichlet, Neumann, Robin), how to create meshes, how to define variable coefficients, how to interact with linear and non-linear solvers, and how to post-process and visualize solutions</p>
</section>
<section id="sec-fenicsx-Poisson" class="level2" data-number="K.4">
<h2 data-number="K.4"><span class="header-section-number">K.4</span> Solving the Poisson equation</h2>
<p>Authors: Hans Petter Langtangen, Anders Logg, Jørgen S. Dokken</p>
<p>The goal of this section is to solve one of the most basic PDEs, the Poisson equation, with a few lines of code in <code>FEniCSx</code>. We start by introducing some fundamental <code>FEniCSx</code> objects, such as <code>functionspace</code>,<code>Function</code>, <code>TrialFunction</code> and <code>TestFunction</code>, and learn how to write a basic PDE solver. This will include:</p>
<ul>
<li>How to formulate a mathematical variational problem</li>
<li>How to apply boundary conditions</li>
<li>How to solve the discrete linear system</li>
<li>How to visualize the solution</li>
</ul>
<p>The Poisson equation is the following boundary-value problem:</p>
<p><span class="math display">\[\begin{aligned}
  -\nabla^2 u(\mathbf{x}) &amp;= f(\mathbf{x})&amp;&amp;\mathbf{x} \in \Omega\\
  u(\mathbf{x}) &amp;= u_D(\mathbf{x})&amp;&amp; \mathbf{x} \in \partial\Omega
\end{aligned}\]</span></p>
<p>Here, <span class="math inline">\(u=u(\mathbf{x})\)</span> is the unknown function, <span class="math inline">\(f=f(\mathbf{x})\)</span> is a prescribed function, <span class="math inline">\(\nabla^2\)</span> (often written as <span class="math inline">\(\Delta\)</span>) is the Laplace operator, <span class="math inline">\(\Omega\)</span> is the spatial domain, and <span class="math inline">\(\partial\Omega\)</span> is its boundary. The Poisson problem — consisting of the PDE <span class="math inline">\(-\nabla^2 u = f\)</span> together with the boundary condition <span class="math inline">\(u=u_D\)</span> on <span class="math inline">\(\partial\Omega\)</span> — is a boundary value problem that must be precisely defined before we can solve it numerically with <code>FEniCSx</code></p>
<ul>
<li>In the two-dimensional space with coordinates <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, we can expand the Poisson equation as</li>
</ul>
<p><span class="math display">\[-\frac{\partial^2 u}{\partial x^2} - \frac{\partial^2 u}{\partial y^2} = f(x,y)\]</span></p>
<p>The unknown <span class="math inline">\(u\)</span> is now a function of two variables, <span class="math inline">\(u=u(x,y)\)</span>, defined over the two-dimensional domain <span class="math inline">\(\Omega\)</span></p>
<ul>
<li>The Poisson equation arises in numerous physical contexts, including heat conduction, electrostatics, diffusion of substances, twisting of elastic rods, inviscid fluid flow, and water waves. Moreover, the equation appears in numerical splitting strategies for more complicated systems of PDEs, in particular the Navier–Stokes equations</li>
</ul>
<p>Solving a boundary value problem in <code>FEniCSx</code> consists of the following steps:</p>
<ol type="1">
<li>Identify the computational domain <span class="math inline">\(\Omega\)</span>, the PDE, and its corresponding boundary conditions and source terms <span class="math inline">\(f\)</span></li>
<li>Reformulate the PDE as a finite element variational problem</li>
<li>Write a Python program defining the computational domain, the boundary conditions, the variational problem, and the source terms, using <code>FEniCSx</code></li>
<li>Run the Python program to solve the boundary-value problem. Optionally, you can extend the program to derive quantities such as fluxes and averages, and visualize the results</li>
</ol>
<p>As we have already covered step 1, we shall now cover steps 2-4</p>
<section id="finite-element-variational-formulation" class="level3" data-number="K.4.1">
<h3 data-number="K.4.1"><span class="header-section-number">K.4.1</span> Finite element variational formulation</h3>
<p><code>FEniCSx</code> is based on the finite element method, which is a general and efficient mathematical technique for the numerical solution of PDEs. The starting point for finite element methods is a PDE expressed in <em>variational form</em></p>
<p>The basic recipe for turning a PDE into a variational problem is:</p>
<ul>
<li>Multiply the PDE by a function <span class="math inline">\(v\)</span></li>
<li>Integrate the resulting equation over the domain <span class="math inline">\(\Omega\)</span></li>
<li>Perform integration by parts of those terms with second order derivatives</li>
</ul>
<p>The function <span class="math inline">\(v\)</span> that multiplies the PDE is called a <em>test function</em>, while the unknown function <span class="math inline">\(u\)</span> to be approximated is referred to as a <em>trial function</em>. The terms <em>trial function</em> and <em>test function</em> are also used in <code>FEniCSx</code>. Both test and trial functions belong to certain <em>specific function spaces</em> that define their properties</p>
<ul>
<li><p>In the present case, we multiply the Poisson equation by a test function <span class="math inline">\(v\)</span> and integrate over <span class="math inline">\(\Omega\)</span>:</p>
<p><span class="math display">\[\int_\Omega (-\nabla^2 u) v~\mathrm{d} x = \int_\Omega f v~\mathrm{d} x\]</span></p>
<p>Here <span class="math inline">\(\mathrm{d} x\)</span> denotes the differential element for integration over the domain <span class="math inline">\(\Omega\)</span>. We will later let <span class="math inline">\(\mathrm{d} s\)</span> denote the differential element for integration over <span class="math inline">\(\partial\Omega\)</span>, the boundary of <span class="math inline">\(\Omega\)</span></p></li>
<li><p>A rule of thumb when deriving variational formulations is that one tries to keep the order of derivatives of <span class="math inline">\(u\)</span> and <span class="math inline">\(v\)</span> as small as possible. Here, we have a second-order differential of <span class="math inline">\(u\)</span>, which can be transformed to a first derivative by employing the technique of <a href="https://en.wikipedia.org/wiki/Integration_by_parts">integration by parts</a>. The formula reads</p>
<p><span class="math display">\[-\int_\Omega (\nabla^2 u)v~\mathrm{d}x
= \int_\Omega\nabla u\cdot\nabla v~\mathrm{d}x -
\underbrace{\int_\Omega \nabla\cdot (v\nabla u) ~\mathrm{d}x}_{\displaystyle \scriptsize\int_{\partial\Omega}\frac{\partial u}{\partial n}v~\mathrm{d}s}\]</span></p>
<p>where <span class="math inline">\(\frac{\partial u}{\partial n}=\nabla u \cdot \mathbf{n}\)</span> is the derivative of <span class="math inline">\(u\)</span> in the outward normal direction <span class="math inline">\(\mathbf{n}\)</span> on the boundary</p></li>
<li><p>Another feature of variational formulations is that the test function <span class="math inline">\(v\)</span> must vanish on the parts of the boundary where the solution <span class="math inline">\(u\)</span> is prescribed. In the present problem, this means that <span class="math inline">\(v = 0\)</span> on the entire boundary <span class="math inline">\(\partial\Omega\)</span>. Consequently, the second term in the integration by parts formula vanishes, and we obtain</p>
<p><span class="math display">\[\int_\Omega \nabla u \cdot \nabla v~\mathrm{d} x = \int_\Omega f v~\mathrm{d} x\]</span></p></li>
<li><p>If we require that this equation holds for all test functions <span class="math inline">\(v\)</span> in some suitable space <span class="math inline">\(\hat{V}\)</span>, the so-called <em>test space</em>, we obtain a well-defined mathematical problem that uniquely determines the solution <span class="math inline">\(u\)</span>, which lies in some function space <span class="math inline">\(V\)</span>. Note that <span class="math inline">\(V\)</span> does not necessarily coincide with <span class="math inline">\(\hat{V}\)</span>. We call the space <span class="math inline">\(V\)</span> the <em>trial space</em>. The equation above is referred to as the <em>weak form</em>(or <em>variational form</em>) of the original boundary-value problem. We can now state our variational problem more precisely: <span class="math inline">\(~\)</span> Find <span class="math inline">\(u\in V\)</span> such that</p>
<p><span class="math display">\[\int_\Omega \nabla u \cdot \nabla v~\mathrm{d} x = \int_\Omega f v~\mathrm{d} x\qquad \forall v \in \hat{V}\]</span></p></li>
<li><p>For the present problem, the trial and test spaces, <span class="math inline">\(V\)</span> and <span class="math inline">\(\hat{V}\)</span>, are defined as follows</p>
<p><span class="math display">\[\color{red}{\begin{aligned}
   V&amp;=\{v\in H^1(\Omega) \,\vert\, v=u_D \;\text{on } \partial \Omega \}\\
   \hat{V}&amp;=\{v\in H^1(\Omega) \,\vert\, v=0 \;\text{on } \partial \Omega \}
\end{aligned}}\]</span></p>
<p>In short, <span class="math inline">\(H^1(\Omega)\)</span> is the Sobolev space consisting of functions <span class="math inline">\(v\)</span> for which both <span class="math inline">\(v^2\)</span> and <span class="math inline">\(\lvert \nabla v \rvert^2\)</span> have finite integrals over <span class="math inline">\(\Omega\)</span>. The solution of the underlying PDE must belong to a function space in which derivatives are continuous. However, the Sobolev space <span class="math inline">\(H^1(\Omega)\)</span> also admits functions with discontinuous derivatives</p>
<p>This weaker continuity requirement in the weak formulation (arising from the integration by parts) is crucial for constructing finite element function spaces. In particular, it permits the use of piecewise polynomial function spaces. Such spaces are built by stitching together polynomial functions over simple domains, such as intervals, triangles, quadrilaterals, tetrahedra, and hexahedra</p></li>
<li><p>The variational problem is a <em>continuous problem</em>: it defines the solution <span class="math inline">\(u\)</span> in the infinite-dimensional function space <span class="math inline">\(V\)</span>. The finite element method for the Poisson equation approximates this solution by replacing the infinite-dimensional function spaces <span class="math inline">\(V\)</span> and <span class="math inline">\(\hat{V}\)</span>, with <em>discrete</em> (finite-dimensional) spaces <span class="math inline">\(V_h\subset V\)</span> and <span class="math inline">\(\hat{V}_h \subset \hat{V}\)</span>. The resulting discrete variational problem is then stated as: <span class="math inline">\(~\)</span> <font color="red">Find <span class="math inline">\(u_h\in V_h\)</span> such that</font></p>
<p><span class="math display">\[\color{red}{
\begin{aligned}
   \int_\Omega \nabla u_h \cdot \nabla v~\mathrm{d} x &amp;= \int_\Omega fv~\mathrm{d} x &amp;&amp; \forall v \in \hat{V}_h
\end{aligned}}
\]</span></p></li>
<li><p>This variational problem, together with appropriate definitions of <span class="math inline">\(V_h\)</span> and <span class="math inline">\(\hat{V}_h,\)</span> uniquely determines our approximate numerical solution to the Poisson equation. Note that the boundary condition is incorporated into the trial and test spaces. While this may appear complicated at first, it ensures that the finite element variational problem has the same form as the continuous variational problem</p></li>
</ul>
</section>
<section id="abstract-finite-element-variational-formulation" class="level3" data-number="K.4.2">
<h3 data-number="K.4.2"><span class="header-section-number">K.4.2</span> Abstract finite element variational formulation</h3>
<p>We will introduce the following notation for variational problems: <span class="math inline">\(\,\)</span> Find <span class="math inline">\(u\in V\)</span> such that</p>
<p><span class="math display">\[\begin{aligned}
  a(u,v)&amp;=L(v)&amp;&amp; \forall v \in \hat{V}
\end{aligned}\]</span></p>
<p>For the Poisson equation, we have:</p>
<p><span class="math display">\[\begin{aligned}
a(u,v) &amp;= \int_{\Omega} \nabla u \cdot \nabla v~\mathrm{d} x\\
L(v) &amp;= \int_{\Omega} fv~\mathrm{d} x
\end{aligned}\]</span></p>
<p>In the literature <span class="math inline">\(a(u,v)\)</span> is known as the <em>bilinear form</em> and <span class="math inline">\(L(v)\)</span> as a <em>linear form</em>. For every linear problem, we will identify all terms with the unknown <span class="math inline">\(u\)</span> and collect them in <span class="math inline">\(a(u,v)\)</span>, and collect all terms with only known functions in <span class="math inline">\(L(v)\)</span>.</p>
<p>To solve a linear PDE in <code>FEniCSx</code>, such as the Poisson equation, a user thus needs to perform two steps:</p>
<ol type="1">
<li>Choose the finite element spaces <span class="math inline">\(V\)</span> and <span class="math inline">\(\hat{V}\)</span> by specifying the domain (the mesh) and the type of function space (polynomial degree and type)</li>
<li>Express the PDE as a (discrete) variational problem: <span class="math inline">\(\,\)</span> Find <span class="math inline">\(u\in V\)</span> such that <span class="math inline">\(a(u,v)=L(v)\)</span> for all <span class="math inline">\(v \in \hat{V}\)</span></li>
</ol>
</section>
<section id="implementation" class="level3" data-number="K.4.3">
<h3 data-number="K.4.3"><span class="header-section-number">K.4.3</span> Implementation</h3>
<p>In this section, you will learn:</p>
<ul>
<li>How to use the <em>built-in meshes</em> in <code>DOLFINx</code></li>
<li>How to create <em>a spatially varying Dirichlet boundary conditions</em> on the whole domain boundary</li>
<li>How to define a weak formulation of your PDE</li>
<li>How <em>to solve the resulting system of linear equations</em></li>
<li>How <em>to visualize the solution using a variety of tools</em></li>
<li>How <em>to compute the <span class="math inline">\(L^2(\Omega)\)</span> error and the error at mesh vertices</em></li>
</ul>
<p>Up to this point, we’ve looked at the Poisson problem in very general terms: the domain <span class="math inline">\(\Omega\)</span>, the boundary condition <span class="math inline">\(u_D\)</span>, and the right-hand side <span class="math inline">\(f\)</span> were all left unspecified. To actually solve something, we now need to pick concrete choices for <span class="math inline">\(\Omega\)</span>, <span class="math inline">\(u_D\)</span>, and <span class="math inline">\(f\)</span></p>
<p>A good strategy is to set up the problem in a way that we already know the exact solution. That way, we can easily check whether our numerical solution is correct. Polynomials of low degree are usually the best choice here, because continuous Galerkin finite element spaces of degree <span class="math inline">\(r\)</span> can reproduce any polynomial of degree <span class="math inline">\(r\)</span> exactly</p>
<ul>
<li><p>To test our solver, we’ll construct a problem where we already know the exact solution. This approach is known as the method of manufactured solutions. The idea is simple:</p>
<ol type="1">
<li>Start by picking a function <span class="math inline">\(u_e(x,y)\)</span> that looks nice and simple</li>
<li>Plug <span class="math inline">\(u_e\)</span> into the PDE to figure out what the right-hand side <span class="math inline">\(f(x,y)\)</span> should be</li>
<li>Use <span class="math inline">\(u_e\)</span> as the boundary condition <span class="math inline">\(u_D\)</span></li>
<li>Finally, solve the problem numerically and compare the computed solution with <span class="math inline">\(u_e\)</span></li>
</ol></li>
</ul>
<p><strong>Step 1:</strong> Choosing the exact solution</p>
<p>Let’s take a quadratic function in 2D:</p>
<p><span class="math display">\[ u_e(x,y) = 1 + x^2 + 2y^2 \]</span></p>
<p><strong>Step 2:</strong> Computing the source term</p>
<p>If we insert <span class="math inline">\(u_e\)</span> into the Poisson equation, we obtain</p>
<p><span class="math display">\[f(x,y) = -6,
\;\;
u_D(x,y) = u_e(x,y) = 1 + x^2 + 2y^2\]</span></p>
<p>Notice that this holds regardless of the domain shape, as long as we prescribe <span class="math inline">\(u_e\)</span> on the boundary</p>
<p><strong>Step 3:</strong> Choosing the domain</p>
<p>For simplicity, let’s use the unit square:</p>
<p><span class="math display">\[\Omega = [0,1] \times [0,1]\]</span></p>
<p><strong>Step 4:</strong> Summary</p>
<p>This small example illustrates a very powerful strategy:</p>
<ul>
<li>Pick an exact solution</li>
<li>Plug it into the PDE to generate the corresponding source term</li>
<li>Solve the PDE with these inputs</li>
<li>Verify that the numerical solution reproduces the exact solution</li>
</ul>
<p>This workflow is at the heart of <em>the method of manufactured solutions</em>, and it provides a simple but rigorous way to validate our solver</p>
<p><strong>Generating simple meshes</strong></p>
<p>The next step is to define the discrete domain, called the mesh. We do this using one of <code>FEniCSx</code>’s built-in mesh generators</p>
<p>Here, we create a unit square mesh spanning <span class="math inline">\([0,1]\times[0,1]\)</span>. The cells of the mesh can be either triangles or quadrilaterals:</p>
<div id="cf4a1939" class="cell" data-execution_count="2">
<div class="sourceCode" id="cb4"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-3"><a href="#cb4-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb4-4"><a href="#cb4-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> mesh</span>
<span id="cb4-5"><a href="#cb4-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb4-6"><a href="#cb4-6" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb4-7"><a href="#cb4-7" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> mesh.create_unit_square(</span>
<span id="cb4-8"><a href="#cb4-8" aria-hidden="true" tabindex="-1"></a>  MPI.COMM_WORLD, </span>
<span id="cb4-9"><a href="#cb4-9" aria-hidden="true" tabindex="-1"></a>  nx<span class="op">=</span>N, </span>
<span id="cb4-10"><a href="#cb4-10" aria-hidden="true" tabindex="-1"></a>  ny<span class="op">=</span>N, </span>
<span id="cb4-11"><a href="#cb4-11" aria-hidden="true" tabindex="-1"></a>  cell_type<span class="op">=</span>mesh.CellType.quadrilateral</span>
<span id="cb4-12"><a href="#cb4-12" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
<p>Notice that we need to provide an MPI communicator. This determines how the program behaves in parallel:</p>
<ul>
<li>If we pass <code>MPI.COMM_WORLD</code>, a single mesh is created and distributed across the number of processors we specify. For example, to run the program on two processors, we can use:</li>
</ul>
<div class="sourceCode" id="cb5"><pre class="sourceCode bash"><code class="sourceCode bash"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="ex">$</span> mpirun <span class="at">-n</span> 2 python tutorial_poisson.py</span></code></pre></div>
<ul>
<li>If instead we use <code>MPI.COMM_SELF</code>, each processor will create its own independent copy of the mesh. This can be useful when running many small problems in parallel, for example when sweeping over different parameters</li>
</ul>
<p><strong>Defining the finite element function space</strong></p>
<p>Once the mesh is created, the next step is to define the finite element function space <span class="math inline">\(V\)</span>. <code>DOLFINx</code> supports a wide variety of finite element spaces of arbitrary order. For a full overview, see the list of <a href="https://defelement.org/lists/implementations/basix.ufl.html">Supported elements in DOLFINx</a></p>
<p>When creating a function space, we need to specify:</p>
<ol type="1">
<li>The mesh on which the space is defined</li>
<li>The element family (e.g., Lagrange, Raviart–Thomas, etc.)</li>
<li>The polynomial degree of the element</li>
</ol>
<p>In <code>DOLFINx</code>, this can be done by passing a tuple of the form <code>("family", degree)</code>, as shown below:</p>
<div id="69639723" class="cell" data-execution_count="3">
<div class="sourceCode" id="cb6"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> fem</span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span></code></pre></div>
</div>
<p>See <a href="https://defelement.org/elements/examples/quadrilateral-lagrange-equispaced-1.html">Degree 1 Lagrange on a quadrilateral</a></p>
<p>The next step is to create a function that stores the Dirichlet boundary condition. We then use interpolation to fill this function with the prescribed values</p>
<div id="8445c176" class="cell" data-execution_count="4">
<div class="sourceCode" id="cb7"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a>uD <span class="op">=</span> fem.Function(V)</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>uD.interpolate(<span class="kw">lambda</span> x: <span class="dv">1</span> <span class="op">+</span>x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span><span class="dv">2</span> <span class="op">*</span>x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span>)</span></code></pre></div>
</div>
<p>With the boundary data defined (which, in this case, coincides with the exact solution of our finite element problem), we now need to enforce it along the boundary of the mesh</p>
<p>The first step is to identify which parts of the mesh correspond to the outer boundary. In <code>DOLFINx</code>, the boundary is represented by facets (that is, the line segments making up the outer edges in 2D or surfaces in 3D).</p>
<p>We can extract the indices of all exterior facets using:</p>
<div id="a3ac010d" class="cell" data-execution_count="5">
<div class="sourceCode" id="cb8"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb8-1"><a href="#cb8-1" aria-hidden="true" tabindex="-1"></a>tdim <span class="op">=</span> domain.topology.dim</span>
<span id="cb8-2"><a href="#cb8-2" aria-hidden="true" tabindex="-1"></a>fdim <span class="op">=</span> tdim <span class="op">-</span><span class="dv">1</span></span>
<span id="cb8-3"><a href="#cb8-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb8-4"><a href="#cb8-4" aria-hidden="true" tabindex="-1"></a>domain.topology.create_connectivity(fdim, tdim)</span>
<span id="cb8-5"><a href="#cb8-5" aria-hidden="true" tabindex="-1"></a>boundary_facets <span class="op">=</span> mesh.exterior_facet_indices(domain.topology)</span></code></pre></div>
</div>
<p>This gives us the set of facets lying on the boundary of our discrete domain. Once we know where the boundary is, we can proceed to apply the Dirichlet boundary conditions to all degrees of freedom (DoFs) located on these facets</p>
<p>For our current problem, we are using the “Lagrange” degree-1 function space. In this case, the degrees of freedom (DoFs) are located at the vertices of each cell, so every boundary facet contains exactly two DoFs</p>
<p>To identify the local indices of these boundary DoFs, we use <code>dolfinx.fem.locate_dofs_topological</code>. This function takes three arguments:</p>
<ol type="1">
<li>the function space</li>
<li>the dimension of the mesh entities we want to target, and</li>
<li>the list of entities (in our case, the boundary facets)</li>
</ol>
<p>Once we have the boundary DoFs, we can create the Dirichlet boundary condition as follows:</p>
<div id="5df5d31a" class="cell" data-execution_count="6">
<div class="sourceCode" id="cb9"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>boundary_dofs <span class="op">=</span> fem.locate_dofs_topological(V, fdim, boundary_facets)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>bc <span class="op">=</span> fem.dirichletbc(uD, boundary_dofs)</span></code></pre></div>
</div>
<p><strong>Defining the trial and test function</strong></p>
<p>In mathematics, we usually distinguish between the trial space <span class="math inline">\(V\)</span> and the test space <span class="math inline">\(\hat{V}\)</span>. For the present problem, the only difference between the two would be the treatment of boundary conditions</p>
<p>In <code>FEniCSx</code>, however, boundary conditions are not built directly into the function space. This means we can simply use the same space for both the trial and test functions</p>
<p>To express the variational formulation, we make use of the <a href="https://github.com/FEniCS/ufl/">Unified Form Language</a> (UFL)</p>
<div id="8f6bff36" class="cell" data-execution_count="7">
<div class="sourceCode" id="cb10"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ufl</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> ufl.TrialFunction(V)</span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> ufl.TestFunction(V)</span></code></pre></div>
</div>
<p><strong>Defining the source term</strong></p>
<p>Since the source term is constant throughout the domain, we can represent it using <code>dolfinx.fem.Constant</code>:</p>
<div id="031116eb" class="cell" data-execution_count="8">
<div class="sourceCode" id="cb11"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> default_scalar_type</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> fem.Constant(domain, default_scalar_type(<span class="op">-</span><span class="dv">6</span>))</span></code></pre></div>
</div>
<p>While we could simply define the source term as <code>f = -6</code>, this has a limitation: if we later want to change its value, we would need to redefine the entire variational problem. By using <code>dolfinx.fem.Constant</code>, we can easily update the value during the simulation, for example with <code>f.value = 5</code></p>
<p>Another advantage is performance: declaring <code>f</code> as a constant allows the compiler to optimize the variational formulation, leading to faster assembly of the resulting linear system</p>
<p><strong>Defining the variational problem</strong></p>
<p>Now that we have defined all the components of our variational problem, we can write down the weak formulation:</p>
<div id="537a4e9c" class="cell" data-execution_count="9">
<div class="sourceCode" id="cb12"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb12-1"><a href="#cb12-1" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> ufl.dot(ufl.grad(u), ufl.grad(v)) <span class="op">*</span>ufl.dx</span>
<span id="cb12-2"><a href="#cb12-2" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> f <span class="op">*</span>v <span class="op">*</span>ufl.dx</span></code></pre></div>
</div>
<p>Notice how closely the Python syntax mirrors the mathematical expressions:</p>
<p><span class="math display">\[a(u,v) = \int_{\Omega} \nabla u \cdot \nabla v \,\mathrm{d}x,
\;\;
L(v) = \int_{\Omega} f v \,\mathrm{d}x\]</span></p>
<p>Here, <code>ufl.dx</code> represents integration over the domain <span class="math inline">\(\Omega\)</span>, i.e. over all cells of the mesh. This illustrates one of the major strengths of <code>FEniCSx</code>: <span class="math inline">\(\,\)</span> variational formulations can be written in Python in a way that almost directly matches their mathematical form, making it both natural and convenient to specify and solve complex PDE problems</p>
<p><strong>Expressing inner products</strong></p>
<p>The inner product</p>
<p><span class="math display">\[\int_\Omega \nabla u \cdot \nabla v \,\mathrm{d}x\]</span></p>
<p>can be expressed in different ways in <code>UFL</code>. In our example, we wrote it as: <code>ufl.dot(ufl.grad(u), ufl.grad(v)) *ufl.dx</code>. In UFL, the dot operator performs a contraction: it sums over the last index of the first argument and the first index of the second argument. Since both <span class="math inline">\(\nabla u\)</span> and <span class="math inline">\(\nabla v\)</span> are rank-1 tensors (vectors), this reduces to a simple dot product.</p>
<p>For higher-rank tensors, such as matrices (rank-2 tensors), the appropriate operator is <code>ufl.inner</code>, which computes the full Frobenius inner product. For vectors, however, <code>ufl.dot</code> and <code>ufl.inner</code> are equivalent</p>
<p><strong>Forming and solving the linear system</strong></p>
<p>Having defined the finite element variational problem and boundary conditions, we can now create a <code>dolfinx.fem.petsc.LinearProblem</code>. This class provides a convenient interface for solving</p>
<p>Find <span class="math inline">\(u_h\in V\)</span> such that <span class="math inline">\(a(u_h, v)=L(v), \;\; \forall v \in \hat{V}\)</span></p>
<p>In this example, we will use <code>PETSc</code> as the linear algebra backend, together with a direct solver (LU factorization)</p>
<p>For more details on Krylov subspace(KSP) solvers and preconditioners, see the <a href="https://petsc.org/main/docs/manual/ksp/?highlight=ksp#ksp-linear-system-solvers">PETSc-documentation</a>. Note that <code>PETSc</code> is not a required dependency of <code>DOLFINx</code>, so we explicitly import the <code>DOLFINx</code> wrapper to interface with <code>PETSc</code>. Finally, to ensure that the solver options passed to the <code>LinearProblem</code> apply only to this specific KSP solver, we assign a <strong>unique</strong> option prefix</p>
<div id="ee2b8078" class="cell" data-execution_count="10">
<div class="sourceCode" id="cb13"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> LinearProblem</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>problem <span class="op">=</span> LinearProblem(</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a>    a, L, bcs<span class="op">=</span>[bc],</span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a>    petsc_options<span class="op">=</span>{</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Direct solver using LU factorization</span></span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;preonly&quot;</span>,</span>
<span id="cb13-8"><a href="#cb13-8" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;lu&quot;</span></span>
<span id="cb13-9"><a href="#cb13-9" aria-hidden="true" tabindex="-1"></a>    }</span>
<span id="cb13-10"><a href="#cb13-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb13-11"><a href="#cb13-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-12"><a href="#cb13-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Solve the system</span></span>
<span id="cb13-13"><a href="#cb13-13" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> problem.solve()</span>
<span id="cb13-14"><a href="#cb13-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-15"><a href="#cb13-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Optionally, view solver information</span></span>
<span id="cb13-16"><a href="#cb13-16" aria-hidden="true" tabindex="-1"></a><span class="co">#ksp = problem.solver</span></span>
<span id="cb13-17"><a href="#cb13-17" aria-hidden="true" tabindex="-1"></a><span class="co">#ksp.view()</span></span></code></pre></div>
</div>
<p>The <code>ksp_type</code> option in <code>PETSc</code> KSP solver specifies which algorithm to use for solving the linear system, while <code>pc_type</code> specifies the type of preconditioner. For most FEM problems, Symmetric Positive Definite(SPD) systems typically use <code>cg</code> with <code>ilu</code> or <code>amg</code>, and if a direct LU solver is desired, one can use <code>ksp_type="preonly"</code> with <code>pc_type="lu"</code></p>
<p>Using <code>problem.solve()</code>, we solve the linear system of equations and return a <code>dolfinx.fem.Function</code> containing the solution</p>
<p><strong>Computing the error</strong></p>
<p>Finally, we want to compute the error to check the accuracy of the solution. We do this by comparing the finite element solution <code>uh</code> with the exact solution. We do this by interpolating the exact solution into the the <span class="math inline">\(P_2\)</span>-function space</p>
<div id="e9ac4e72" class="cell" data-execution_count="11">
<div class="sourceCode" id="cb14"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb14-1"><a href="#cb14-1" aria-hidden="true" tabindex="-1"></a>V2 <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">2</span>))</span>
<span id="cb14-2"><a href="#cb14-2" aria-hidden="true" tabindex="-1"></a>uex <span class="op">=</span> fem.Function(V2)</span>
<span id="cb14-3"><a href="#cb14-3" aria-hidden="true" tabindex="-1"></a>uex.interpolate(<span class="kw">lambda</span> x: <span class="dv">1</span> <span class="op">+</span>x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span><span class="dv">2</span> <span class="op">*</span>x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span>)</span></code></pre></div>
</div>
<p>We compute the error in two different ways. First, we compute the <span class="math inline">\(L^2\)</span> norm of the error, defined by</p>
<p><span class="math display">\[E=\sqrt{\int_\Omega (u_D-u_h)^2 \,\mathrm{d} x}\]</span></p>
<p>We use <code>UFL</code> to express the <span class="math inline">\(L^2\)</span> error, and use <code>dolfinx.fem.assemble_scalar</code> to compute the scalar value. In <code>DOLFINx</code>, <code>assemble_scalar</code> only assembles over the cells on the local process. This means that if we use 2 processes to solve our problem, we need to gather the solution to one. We can do this with the <code>MPI.allreduce</code> function</p>
<div id="a45892f5" class="cell" data-execution_count="12">
<div class="sourceCode" id="cb15"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a>L2_error <span class="op">=</span> fem.form(ufl.inner(uh <span class="op">-</span>uex, uh <span class="op">-</span>uex) <span class="op">*</span>ufl.dx)</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a>error_local <span class="op">=</span> fem.assemble_scalar(L2_error)</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a>error_L2 <span class="op">=</span> np.sqrt(domain.comm.allreduce(error_local, op<span class="op">=</span>MPI.SUM))</span></code></pre></div>
</div>
<p>Secondly, we compute the maximum error at any degree of freedom (dof). The finite element solution <code>uh</code> can be expressed as a linear combination of the basis functions <span class="math inline">\(\phi_j\)</span> spanning the space <span class="math inline">\(V\)</span>:</p>
<p><span class="math display">\[u = \sum_{j=1}^N U_j \phi_j\]</span></p>
<p>When we call <code>problem.solve()</code>, we obtain all coefficients <span class="math inline">\(U_1\)</span>, <span class="math inline">\(\dots\)</span>, <span class="math inline">\(U_N\)</span>. These coefficients are the degrees of freedom (dofs). We can access the dofs by retrieving the underlying vector from <code>uh</code></p>
<p>However, note that a second-order function space contains more dofs than a first-order space, so the corresponding arrays cannot be compared directly. Fortunately, since we have already interpolated the exact solution into the first-order space when defining the boundary condition, we can compare the maximum values at the dofs of the approximation space</p>
<div id="3c508c53" class="cell" data-execution_count="13">
<div class="sourceCode" id="cb16"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>error_max <span class="op">=</span> np.<span class="bu">max</span>(np.<span class="bu">abs</span>(uD.x.array <span class="op">-</span>uh.x.array))</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Only print the error on one process</span></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> domain.comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Error_L2 : </span><span class="sc">{</span>error_L2<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Error_max : </span><span class="sc">{</span>error_max<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Error_L2 : 8.24e-03
Error_max : 5.33e-15</code></pre>
</div>
</div>
<p><strong>Plotting the mesh using pyvista</strong></p>
<p>First, prepare a folder to store the output figures as follows:</p>
<div id="f472fe4a" class="cell" data-execution_count="14">
<div class="sourceCode" id="cb18"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/fundamentals&quot;</span>)</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span></code></pre></div>
</div>
<p>We will visualize the mesh using <a href="https://docs.pyvista.org/">pyvista</a>, a Python interface to the VTK toolkit. To begin, We convert the mesh into a format compatible with <code>pyvista</code> using the function <code>dolfinx.plot.vtk_mesh</code>. The first step is to create an unstructured grid that <code>pyvista</code> can work with</p>
<p>You can check the current plotting backend with:</p>
<div id="5bdf01d1" class="cell" data-execution_count="15">
<div class="sourceCode" id="cb19"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> plot</span>
<span id="cb19-3"><a href="#cb19-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb19-4"><a href="#cb19-4" aria-hidden="true" tabindex="-1"></a>topology, cell_types, geometry <span class="op">=</span> plot.vtk_mesh(domain, tdim)</span>
<span id="cb19-5"><a href="#cb19-5" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> pyvista.UnstructuredGrid(topology, cell_types, geometry)</span></code></pre></div>
</div>
<p><code>PyVista</code> supports several backends, each with its own advantages and limitations. For more information and installation instructions, see the <a href="https://docs.pyvista.org/user-guide/jupyter/index.html#state-of-3d-interactive-jupyterlab-plotting">pyvista documentation</a></p>
<p>We can now use the <code>pyvista.Plotter</code> to visualize the mesh. We will display it both as a 2D and as a 3D warped representation. Provided that a proper X server connection is available, the default setting <code>pyvista.OFF_SCREEN=False</code> can be used to render the plots directly within the notebook</p>
<div id="c24b8ad5" class="cell" data-execution_count="16">
<div class="sourceCode" id="cb20"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>plotter.add_mesh(grid, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a>plotter.add_axes()</span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>plotter.view_xy()</span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co"># if not pyvista.OFF_SCREEN:</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a><span class="co">#   plotter.show()</span></span>
<span id="cb20-8"><a href="#cb20-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-9"><a href="#cb20-9" aria-hidden="true" tabindex="-1"></a><span class="co"># HTML 저장</span></span>
<span id="cb20-10"><a href="#cb20-10" aria-hidden="true" tabindex="-1"></a>plotter.export_html(<span class="st">&quot;fenicsx/fundamentals/unit_square_mesh.html&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/fundamentals/unit_square_mesh.html"
        width="100%" height="400px"
        style="border:none;"
        allowfullscreen
        loading="lazy">
</iframe>
<p><strong>Plotting a function using pyvista</strong></p>
<p>We want to plot the solution <code>uh</code>. Since the function space used to define <code>uh</code> is disconnected from the one used to define the mesh, we first create a mesh based on the DoF coordinates of the function space <code>V</code>. We then use <code>dolfinx.plot.vtk_mesh</code>, passing the function space as input, to generate a mesh whose geometry is based on these DoF coordinates</p>
<div id="12a08023" class="cell" data-execution_count="17">
<div class="sourceCode" id="cb21"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>u_topology, u_cell_types, u_geometry <span class="op">=</span> plot.vtk_mesh(V)</span></code></pre></div>
</div>
<p>Next, we create the <code>pyvista.UnstructuredGrid</code> and add the DoF-values to the mesh</p>
<div id="7aec6c79" class="cell" data-execution_count="18">
<div class="sourceCode" id="cb22"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>u_grid <span class="op">=</span> pyvista.UnstructuredGrid(u_topology, u_cell_types, u_geometry)</span>
<span id="cb22-2"><a href="#cb22-2" aria-hidden="true" tabindex="-1"></a>u_grid.point_data[<span class="st">&quot;u&quot;</span>] <span class="op">=</span> uh.x.array.real</span>
<span id="cb22-3"><a href="#cb22-3" aria-hidden="true" tabindex="-1"></a>u_grid.set_active_scalars(<span class="st">&quot;u&quot;</span>)</span>
<span id="cb22-4"><a href="#cb22-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-5"><a href="#cb22-5" aria-hidden="true" tabindex="-1"></a>u_plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb22-6"><a href="#cb22-6" aria-hidden="true" tabindex="-1"></a>u_plotter.add_mesh(</span>
<span id="cb22-7"><a href="#cb22-7" aria-hidden="true" tabindex="-1"></a>    u_grid, </span>
<span id="cb22-8"><a href="#cb22-8" aria-hidden="true" tabindex="-1"></a>    show_edges<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb22-9"><a href="#cb22-9" aria-hidden="true" tabindex="-1"></a>    scalar_bar_args<span class="op">=</span>{</span>
<span id="cb22-10"><a href="#cb22-10" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;title&quot;</span>: <span class="st">&quot;u&quot;</span>,</span>
<span id="cb22-11"><a href="#cb22-11" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;fmt&quot;</span>: <span class="st">&quot;</span><span class="sc">%.1f</span><span class="st">&quot;</span>,</span>
<span id="cb22-12"><a href="#cb22-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;color&quot;</span>: <span class="st">&quot;black&quot;</span>,</span>
<span id="cb22-13"><a href="#cb22-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;label_font_size&quot;</span>: <span class="dv">12</span>,</span>
<span id="cb22-14"><a href="#cb22-14" aria-hidden="true" tabindex="-1"></a>        <span class="co"># &quot;vertical&quot;: True,</span></span>
<span id="cb22-15"><a href="#cb22-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;n_labels&quot;</span>: <span class="dv">7</span>,</span>
<span id="cb22-16"><a href="#cb22-16" aria-hidden="true" tabindex="-1"></a>    },</span>
<span id="cb22-17"><a href="#cb22-17" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb22-18"><a href="#cb22-18" aria-hidden="true" tabindex="-1"></a>u_plotter.add_axes()</span>
<span id="cb22-19"><a href="#cb22-19" aria-hidden="true" tabindex="-1"></a>u_plotter.view_xy()</span>
<span id="cb22-20"><a href="#cb22-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-21"><a href="#cb22-21" aria-hidden="true" tabindex="-1"></a><span class="co"># if not pyvista.OFF_SCREEN:</span></span>
<span id="cb22-22"><a href="#cb22-22" aria-hidden="true" tabindex="-1"></a><span class="co">#     u_plotter.show()</span></span>
<span id="cb22-23"><a href="#cb22-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb22-24"><a href="#cb22-24" aria-hidden="true" tabindex="-1"></a><span class="co"># HTML 저장</span></span>
<span id="cb22-25"><a href="#cb22-25" aria-hidden="true" tabindex="-1"></a>u_plotter.export_html(<span class="st">&quot;fenicsx/fundamentals/poisson_solution_2D.html&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/fundamentals/poisson_solution_2D.html"
        width="100%" height="400px"
        style="border:none;"
        allowfullscreen
        loading="lazy">
</iframe>
<p><strong>External post-processing</strong></p>
<p>For post-processing outside Python, it is recommended to save the solution to a file using either <code>dolfinx.io.VTXWriter</code> or <code>dolfinx.io.XDMFFile</code>, and then visualize it in <a href="https://www.paraview.org/">ParaView</a>. This approach is especially useful for 3D visualization</p>
<div id="68201f8e" class="cell" data-execution_count="19">
<div class="sourceCode" id="cb23"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> io</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>filename <span class="op">=</span> results_folder<span class="op">/</span><span class="st">&quot;poisson&quot;</span></span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb23-5"><a href="#cb23-5" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> io.VTXWriter(domain.comm, filename.with_suffix(<span class="st">&quot;.bp&quot;</span>), [uh]) <span class="im">as</span> vtx:</span>
<span id="cb23-6"><a href="#cb23-6" aria-hidden="true" tabindex="-1"></a>    vtx.write(<span class="fl">0.0</span>)</span>
<span id="cb23-7"><a href="#cb23-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb23-8"><a href="#cb23-8" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> io.XDMFFile(domain.comm, filename.with_suffix(<span class="st">&quot;.xdmf&quot;</span>), <span class="st">&quot;w&quot;</span>) <span class="im">as</span> xdmf:</span>
<span id="cb23-9"><a href="#cb23-9" aria-hidden="true" tabindex="-1"></a>    xdmf.write_mesh(domain)</span>
<span id="cb23-10"><a href="#cb23-10" aria-hidden="true" tabindex="-1"></a>    xdmf.write_function(uh)</span></code></pre></div>
</div>
</section>
</section>
<section id="weak-imposition-of-dirichlet-conditions-for-the-poisson-problem" class="level2" data-number="K.5">
<h2 data-number="K.5"><span class="header-section-number">K.5</span> Weak imposition of Dirichlet conditions for the Poisson problem</h2>
<p>Author: Jørgen S. Dokken</p>
<p>This section shows how to solve the previous Poisson problem using Nitsche’s method. Weak imposition works by adding terms to the variational formulation to enforce the boundary condition, instead of altering the matrix system via strong imposition (lifting)</p>
<p>First, we import the necessary modules and set up the mesh and function space for the solution</p>
<div id="e3737906" class="cell" data-execution_count="20">
<div class="sourceCode" id="cb24"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> fem, mesh, plot, default_scalar_type</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> LinearProblem</span>
<span id="cb24-6"><a href="#cb24-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-7"><a href="#cb24-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ufl <span class="im">import</span> (</span>
<span id="cb24-8"><a href="#cb24-8" aria-hidden="true" tabindex="-1"></a>  Circumradius, </span>
<span id="cb24-9"><a href="#cb24-9" aria-hidden="true" tabindex="-1"></a>  FacetNormal, </span>
<span id="cb24-10"><a href="#cb24-10" aria-hidden="true" tabindex="-1"></a>  SpatialCoordinate, </span>
<span id="cb24-11"><a href="#cb24-11" aria-hidden="true" tabindex="-1"></a>  TrialFunction, </span>
<span id="cb24-12"><a href="#cb24-12" aria-hidden="true" tabindex="-1"></a>  TestFunction,</span>
<span id="cb24-13"><a href="#cb24-13" aria-hidden="true" tabindex="-1"></a>  dx, </span>
<span id="cb24-14"><a href="#cb24-14" aria-hidden="true" tabindex="-1"></a>  ds, </span>
<span id="cb24-15"><a href="#cb24-15" aria-hidden="true" tabindex="-1"></a>  div, </span>
<span id="cb24-16"><a href="#cb24-16" aria-hidden="true" tabindex="-1"></a>  grad, </span>
<span id="cb24-17"><a href="#cb24-17" aria-hidden="true" tabindex="-1"></a>  inner,</span>
<span id="cb24-18"><a href="#cb24-18" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb24-19"><a href="#cb24-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-20"><a href="#cb24-20" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">8</span></span>
<span id="cb24-21"><a href="#cb24-21" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> mesh.create_unit_square(MPI.COMM_WORLD, N, N)</span>
<span id="cb24-22"><a href="#cb24-22" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span></code></pre></div>
</div>
<p>Next, we create a function for the exact solution (also used in the Dirichlet boundary condition) and the corresponding source function for the right-hand side. The exact solution is defined using <code>ufl.SpatialCoordinate</code>, then interpolated into <code>uD</code> and used to generate the source function <code>f</code></p>
<div id="27eab6e7" class="cell" data-execution_count="21">
<div class="sourceCode" id="cb25"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> SpatialCoordinate(domain)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a>u_ex <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span>x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span><span class="dv">2</span> <span class="op">*</span>x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span></span>
<span id="cb25-3"><a href="#cb25-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb25-4"><a href="#cb25-4" aria-hidden="true" tabindex="-1"></a>uD <span class="op">=</span> fem.Function(V)</span>
<span id="cb25-5"><a href="#cb25-5" aria-hidden="true" tabindex="-1"></a>uD.interpolate(fem.Expression(u_ex, V.element.interpolation_points()))</span>
<span id="cb25-6"><a href="#cb25-6" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="op">-</span>div(grad(u_ex))</span></code></pre></div>
</div>
<p>Unlike the first tutorial, we now need to revisit the variational form. We begin by integrating the problem by parts to obtain</p>
<p><span class="math display">\[\begin{aligned}
    \int_{\Omega} \nabla u \cdot \nabla v~\mathrm{d}x - \int_{\partial\Omega}\nabla u \cdot \mathbf{n}\, v~\mathrm{d}s = \int_{\Omega} f v~\mathrm{d}x
\end{aligned}\]</span></p>
<p>As we are not enforcing the boundary condition strongly, the trace of the test function is not set to zero on the boundary. We instead add the following two terms to the variational formulation:</p>
<p><span class="math display">\[\begin{aligned}
    -\int_{\partial\Omega} \nabla  v \cdot \mathbf{n}\, (u-u_D)~\mathrm{d}s + \frac{\alpha}{h} \int_{\partial\Omega} (u-u_D)v~\mathrm{d}s
\end{aligned}\]</span></p>
<p>The first term enforces symmetry in the bilinear form, and the second term ensures coercivity. <span class="math inline">\(u_D\)</span> denotes the known Dirichlet condition, and <span class="math inline">\(h\)</span> is the diameter of the circumscribed sphere of the mesh element. The bilinear and linear forms, <span class="math inline">\(a\)</span> and <span class="math inline">\(L\)</span>, are then defined as</p>
<p><span class="math display">\[\begin{aligned}
    a(u, v) &amp;= \int_{\Omega} \nabla u \cdot \nabla v ~\mathrm{d}x + \int_{\partial\Omega} -(\mathbf{n}\, \cdot\nabla u) v - (\mathbf{n}\, \cdot \nabla v) u + \frac{\alpha}{h} uv ~\mathrm{d}s \\
    L(v) &amp;= \int_{\Omega} fv ~\mathrm{d}x + \int_{\partial\Omega} -(\mathbf{n}\, \cdot \nabla v) u_D + \frac{\alpha}{h} u_D v ~\mathrm{d}s
\end{aligned}\]</span></p>
<div id="0f77148a" class="cell" data-execution_count="22">
<div class="sourceCode" id="cb26"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> TrialFunction(V)</span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> TestFunction(V)</span>
<span id="cb26-3"><a href="#cb26-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-4"><a href="#cb26-4" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> FacetNormal(domain)</span>
<span id="cb26-5"><a href="#cb26-5" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span>Circumradius(domain)</span>
<span id="cb26-6"><a href="#cb26-6" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> fem.Constant(domain, default_scalar_type(<span class="dv">10</span>))</span>
<span id="cb26-7"><a href="#cb26-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb26-8"><a href="#cb26-8" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> inner(grad(u), grad(v)) <span class="op">*</span>dx <span class="op">-</span>inner(n, grad(u)) <span class="op">*</span>v <span class="op">*</span>ds</span>
<span id="cb26-9"><a href="#cb26-9" aria-hidden="true" tabindex="-1"></a>a <span class="op">+=</span> <span class="op">-</span>inner(n, grad(v)) <span class="op">*</span>u <span class="op">*</span>ds <span class="op">+</span>alpha <span class="op">/</span>h <span class="op">*</span>inner(u, v) <span class="op">*</span>ds</span>
<span id="cb26-10"><a href="#cb26-10" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> inner(f, v) <span class="op">*</span>dx </span>
<span id="cb26-11"><a href="#cb26-11" aria-hidden="true" tabindex="-1"></a>L <span class="op">+=</span> <span class="op">-</span>inner(n, grad(v)) <span class="op">*</span>uD <span class="op">*</span>ds <span class="op">+</span>alpha <span class="op">/</span>h <span class="op">*</span>inner(uD, v) <span class="op">*</span>ds</span></code></pre></div>
</div>
<p>With the variational form in place, we can solve the linear problem</p>
<div id="e517a4f5" class="cell" data-execution_count="23">
<div class="sourceCode" id="cb27"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>problem <span class="op">=</span> LinearProblem(a, L)</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> problem.solve()</span></code></pre></div>
</div>
<p>We compute the error by comparing the numerical solution with the analytical solution</p>
<div id="a687382e" class="cell" data-execution_count="24">
<div class="sourceCode" id="cb28"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>error_form <span class="op">=</span> fem.form(inner(uh <span class="op">-</span>uD, uh <span class="op">-</span>uD) <span class="op">*</span>dx)</span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>error_local <span class="op">=</span> fem.assemble_scalar(error_form)</span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>error_L2 <span class="op">=</span> np.sqrt(domain.comm.allreduce(error_local, op<span class="op">=</span>MPI.SUM))</span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> domain.comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb28-5"><a href="#cb28-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Error_L2: </span><span class="sc">{</span>error_L2<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Error_L2: 1.59e-03</code></pre>
</div>
</div>
<p>The <span class="math inline">\(L^2\)</span>-error has the same order of magnitude as in the first tutorial, and we also compute the maximum error over all degrees of freedom</p>
<div id="6cf16e1b" class="cell" data-execution_count="25">
<div class="sourceCode" id="cb30"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>error_max <span class="op">=</span> domain.comm.allreduce(</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a>  np.<span class="bu">max</span>(np.<span class="bu">abs</span>(uD.x.array <span class="op">-</span>uh.x.array)), </span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a>  op<span class="op">=</span>MPI.MAX)</span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> domain.comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Error_max : </span><span class="sc">{</span>error_max<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Error_max : 5.41e-03</code></pre>
</div>
</div>
<p>We observe that, due to the weak imposition of the boundary condition, the equation is not satisfied to machine precision at the mesh vertices. The solution is subsequently visualized using <code>pyvista</code></p>
<div id="b5afd0c7" class="cell" data-execution_count="26">
<div class="sourceCode" id="cb32"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>u_grid <span class="op">=</span> pyvista.UnstructuredGrid(<span class="op">*</span>plot.vtk_mesh(V))</span>
<span id="cb32-4"><a href="#cb32-4" aria-hidden="true" tabindex="-1"></a>u_grid.point_data[<span class="st">&quot;u&quot;</span>] <span class="op">=</span> uh.x.array.real</span>
<span id="cb32-5"><a href="#cb32-5" aria-hidden="true" tabindex="-1"></a>u_grid.set_active_scalars(<span class="st">&quot;u&quot;</span>)</span>
<span id="cb32-6"><a href="#cb32-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-7"><a href="#cb32-7" aria-hidden="true" tabindex="-1"></a>u_plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb32-8"><a href="#cb32-8" aria-hidden="true" tabindex="-1"></a>u_plotter.add_mesh(</span>
<span id="cb32-9"><a href="#cb32-9" aria-hidden="true" tabindex="-1"></a>  u_grid, </span>
<span id="cb32-10"><a href="#cb32-10" aria-hidden="true" tabindex="-1"></a>  show_edges<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb32-11"><a href="#cb32-11" aria-hidden="true" tabindex="-1"></a>  scalar_bar_args<span class="op">=</span>{</span>
<span id="cb32-12"><a href="#cb32-12" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;title&quot;</span>: <span class="st">&quot;u&quot;</span>,</span>
<span id="cb32-13"><a href="#cb32-13" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;fmt&quot;</span>: <span class="st">&quot;</span><span class="sc">%.1f</span><span class="st">&quot;</span>,</span>
<span id="cb32-14"><a href="#cb32-14" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;color&quot;</span>: <span class="st">&quot;black&quot;</span>,</span>
<span id="cb32-15"><a href="#cb32-15" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;label_font_size&quot;</span>: <span class="dv">12</span>,</span>
<span id="cb32-16"><a href="#cb32-16" aria-hidden="true" tabindex="-1"></a>        <span class="co"># &quot;vertical&quot;: True,</span></span>
<span id="cb32-17"><a href="#cb32-17" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;n_labels&quot;</span>: <span class="dv">7</span>,</span>
<span id="cb32-18"><a href="#cb32-18" aria-hidden="true" tabindex="-1"></a>  },  </span>
<span id="cb32-19"><a href="#cb32-19" aria-hidden="true" tabindex="-1"></a>  show_scalar_bar<span class="op">=</span><span class="va">True</span></span>
<span id="cb32-20"><a href="#cb32-20" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb32-21"><a href="#cb32-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-22"><a href="#cb32-22" aria-hidden="true" tabindex="-1"></a>u_plotter.add_axes()</span>
<span id="cb32-23"><a href="#cb32-23" aria-hidden="true" tabindex="-1"></a>u_plotter.view_xy()</span>
<span id="cb32-24"><a href="#cb32-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-25"><a href="#cb32-25" aria-hidden="true" tabindex="-1"></a><span class="co"># if not pyvista.OFF_SCREEN:</span></span>
<span id="cb32-26"><a href="#cb32-26" aria-hidden="true" tabindex="-1"></a><span class="co">#     u_plotter.show()</span></span>
<span id="cb32-27"><a href="#cb32-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-28"><a href="#cb32-28" aria-hidden="true" tabindex="-1"></a><span class="co"># HTML 저장</span></span>
<span id="cb32-29"><a href="#cb32-29" aria-hidden="true" tabindex="-1"></a>u_plotter.export_html(</span>
<span id="cb32-30"><a href="#cb32-30" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;fenicsx/fundamentals/poisson_nitsche_solution_2D.html&quot;</span></span>
<span id="cb32-31"><a href="#cb32-31" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
<iframe src="fenicsx/fundamentals/poisson_nitsche_solution_2D.html"
        width="100%" height="400px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
</section>
<section id="deflection-of-a-membrane" class="level2" data-number="K.6">
<h2 data-number="K.6"><span class="header-section-number">K.6</span> Deflection of a membrane</h2>
<p>Authors: Hans Petter Langtangen, Anders Logg, Jørgen S. Dokken</p>
<p>In the first <code>FEniCSx</code> example, we addressed a simple, easily verifiable problem. In this section, we consider a more physically relevant case that produces solutions with richer structure. In particular, we compute the deflection <span class="math inline">\(D(x,y)\)</span> of a two-dimensional circular membrane of radius <span class="math inline">\(R\)</span>, under a load distribution <span class="math inline">\(p(x,y)\)</span>. The governing PDE is:</p>
<p><span class="math display">\[
\begin{aligned}
     -T \nabla^2D&amp;=p \quad\text{in }\; \Omega=\{(x,y)\,\vert\, x^2+y^2\leq R^2 \}
\end{aligned}
\]</span></p>
<p>Here, <span class="math inline">\(T\)</span> denotes the constant membrane tension, and <span class="math inline">\(p\)</span> represents the external pressure load. The boundary of the membrane is fixed, implying the boundary condition <span class="math inline">\(D=0\)</span>. We model a localized load using a Gaussian function:</p>
<p><span class="math display">\[
\begin{aligned}
     p(x,y)&amp;=\frac{A}{2\pi\sigma}\exp\left(-\frac{1}{2}\left[\left(\frac{x-x_0}{\sigma}\right)^2 +\left(\frac{y-y_0}{\sigma}\right)^2\right] \right)
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(A\)</span> is the load amplitude, <span class="math inline">\((x_0, y_0)\)</span> is the location of the load maximum, and <span class="math inline">\(\sigma\)</span> characterizes the <em>width</em> of <span class="math inline">\(p\)</span>. We place the load center at <span class="math inline">\((x_0, y_0) = (0, R_0)\)</span>, with <span class="math inline">\(0 &lt; R_0 &lt; R\)</span>. The resulting expression becomes</p>
<p><span class="math display">\[
\begin{aligned}
     p(x,y)&amp;=\frac{A}{2\pi\sigma}\exp\left(-\frac{1}{2}\left[\left(\frac{x}{\sigma}\right)^2
     +\left(\frac{y-R_0}{\sigma}\right)^2\right]\right)
\end{aligned}
\]</span></p>
<section id="scaling-the-equation" class="level3" data-number="K.6.1">
<h3 data-number="K.6.1"><span class="header-section-number">K.6.1</span> Scaling the equation</h3>
<p>This problem involves several physical parameters, and it is useful to simplify the formulation by introducing dimensionless variables. We define the scaled coordinates <span class="math inline">\(\bar{x} = \tfrac{x}{R}\)</span>, <span class="math inline">\(\bar{y} = \tfrac{y}{R}\)</span>, and the dimensionless deflection <span class="math inline">\(w = \tfrac{D}{D_e}\)</span>, where <span class="math inline">\(D_e\)</span> is a characteristic deflection. Introducing <span class="math inline">\(\bar{R}_0 = \tfrac{R_0}{R}\)</span>, we obtain</p>
<p><span class="math display">\[
\begin{aligned}
    -\left(\frac{\partial^2 w}{\partial \bar{x}^2} +\frac{\partial^2 w}{\partial \bar{y}^2} \right)
    &amp;=\frac{R^2A}{2\pi\sigma TD_e} \exp\left(-\frac{R^2}{2\sigma^2}\left[\bar{x}^2+(\bar{y}-\bar{R}_0)^2\right]\right)\\
    &amp;=\alpha \exp\left(-\beta^2 \left[\bar{x}^2+(\bar{y}-\bar{R}_0)^2\right]\right)
\end{aligned}
\]</span></p>
<p>valid for <span class="math inline">\(\bar{x}^2+\bar{y}^2&lt;1\)</span>, where <span class="math inline">\(\alpha = \frac{R^2A}{2\pi\sigma TD_e}\)</span> and <span class="math inline">\(\beta=\frac{R}{\sqrt{2}\sigma}\)</span></p>
<p>With an appropriate scaling, both <span class="math inline">\(w\)</span> and its derivatives are of order unity. Consequently, the left-hand side of the scaled PDE is also of order unity, while the right-hand side is governed by the parameter <span class="math inline">\(\alpha\)</span>. This motivates choosing <span class="math inline">\(\alpha\)</span> to be of order one; in this case, we set <span class="math inline">\(\alpha = 4\)</span>. (Alternatively, one can derive the analytical solution in scaled coordinates and verify that the maximum deflection equals <span class="math inline">\(D_e\)</span> when <span class="math inline">\(\alpha = 4\)</span>, which provides the definition of <span class="math inline">\(D_e\)</span>)</p>
<p>With <span class="math inline">\(D_e = \tfrac{R^2 A}{8 \pi \sigma T}\)</span> and omitting the overbars, the scaled problem becomes</p>
<p><span class="math display">\[-\nabla^2 w = 4 \exp\left(-\beta^2 \left[x^2 + (y-R_0)^2\right]\right)\]</span></p>
<p>to be solved over the unit disk, with <span class="math inline">\(w=0\)</span> on the boundary</p>
<p>In the nondimensional formulation, the problem depends only on two parameters: the dimensionless width of the pressure distribution <span class="math inline">\(\beta\)</span> and the location of the pressure maximum <span class="math inline">\(R_0 \in [0,1]\)</span>. In the limit <span class="math inline">\(\beta \to 0\)</span>, the solution converges to the special case <span class="math inline">\(w = 1 - x^2 - y^2\)</span></p>
<p>Given a computed scaled solution <span class="math inline">\(w\)</span>, the corresponding physical deflection is recovered as</p>
<p><span class="math display">\[
\begin{aligned}
    D=\frac{AR^2}{8\pi\sigma T}w
\end{aligned}
\]</span></p>
</section>
<section id="implementation-1" class="level3" data-number="K.6.2">
<h3 data-number="K.6.2"><span class="header-section-number">K.6.2</span> Implementation</h3>
<p>Author: Jørgen S. Dokken</p>
<p>In this section, we will solve the membrane deflection problem. By the end of this section, you should be able to:</p>
<ul>
<li>Construct a simple mesh using the <code>GMSH</code> Python API and import it into <code>DOLFINx</code></li>
<li>Specify constant boundary conditions via a geometrical identifier</li>
<li>Employ <code>ufl.SpatialCoordinate</code> to define a spatially varying function</li>
<li>Interpolate a <code>ufl.Expression</code> into a suitable function space</li>
<li>Evaluate a <code>dolfinx.Function</code> at arbitrary points</li>
</ul>
<p><strong>Creating the mesh</strong></p>
<p>To construct the computational geometry, we use the Python API of <a href="https://gmsh.info/">GMSH</a>. We begin by importing the gmsh module and initializing it</p>
<div id="c14f7697" class="cell" data-execution_count="27">
<div class="sourceCode" id="cb33"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a><span class="co"># $ conda install -c conda-forge python-gmsh</span></span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> gmsh</span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> gmsh.isInitialized():</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>    gmsh.initialize()</span></code></pre></div>
</div>
<p>Next, we define the membrane geometry and begin the setup using the <code>GMSH</code> CAD kernel, which automatically generates the required data structures in the background. When calling <code>addDisk</code>, the first three arguments specify the <span class="math inline">\(x,\)</span> <span class="math inline">\(y,\)</span> and <span class="math inline">\(z\)</span> coordinates of the circle’s center, while the final two define the radii in the <span class="math inline">\(x\)</span>- and <span class="math inline">\(y\)</span>-directions</p>
<div id="85fd92b2" class="cell" data-execution_count="28">
<div class="sourceCode" id="cb34"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># gmsh.model.occ.addDisk(xc, yc, zc, rx, ry)</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a><span class="co">#   xc, yc, zc : center coordinates</span></span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a><span class="co">#   rx, ry     : radii in x- and y-directions</span></span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a>membrane <span class="op">=</span> gmsh.model.occ.addDisk(<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Synchronize the CAD kernel with the gmsh model</span></span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>gmsh.model.occ.synchronize()</span></code></pre></div>
</div>
<p>Next, we define the membrane as a physical surface so that <code>GMSH</code> will recognize it during mesh generation. Because a surface is a two-dimensional entity, we pass <code>2</code> as the first argument, the membrane’s entity tag as the second, and the physical tag as the last. In a later example, we will explain in more detail when and why this physical tag becomes important</p>
<div id="3c53bcf0" class="cell" data-execution_count="29">
<div class="sourceCode" id="cb35"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>gdim <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a>physical_tag <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove any existing physical groups with the same (dim, tag)</span></span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> dim, tag <span class="kw">in</span> gmsh.model.getPhysicalGroups():</span>
<span id="cb35-6"><a href="#cb35-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> dim <span class="op">==</span> gdim <span class="kw">and</span> tag <span class="op">==</span> physical_tag:</span>
<span id="cb35-7"><a href="#cb35-7" aria-hidden="true" tabindex="-1"></a>        gmsh.model.removePhysicalGroups([(dim, tag)])</span>
<span id="cb35-8"><a href="#cb35-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-9"><a href="#cb35-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Now safely add the new physical group</span></span>
<span id="cb35-10"><a href="#cb35-10" aria-hidden="true" tabindex="-1"></a>pg <span class="op">=</span> gmsh.model.addPhysicalGroup(gdim, [membrane], physical_tag)</span>
<span id="cb35-11"><a href="#cb35-11" aria-hidden="true" tabindex="-1"></a>gmsh.model.setPhysicalName(gdim, pg, <span class="st">&quot;Circular Membrane&quot;</span>)</span></code></pre></div>
</div>
<p>Finally, we generate the two-dimensional mesh, setting a uniform element size by adjusting the <code>GMSH</code> options</p>
<div id="978d7244" class="cell" data-execution_count="30">
<div class="sourceCode" id="cb36"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>gmsh.option.setNumber(<span class="st">&quot;Mesh.CharacteristicLengthMin&quot;</span>, <span class="fl">0.05</span>)</span>
<span id="cb36-2"><a href="#cb36-2" aria-hidden="true" tabindex="-1"></a>gmsh.option.setNumber(<span class="st">&quot;Mesh.CharacteristicLengthMax&quot;</span>, <span class="fl">0.05</span>)</span>
<span id="cb36-3"><a href="#cb36-3" aria-hidden="true" tabindex="-1"></a>gmsh.model.mesh.generate(gdim)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Info    : Meshing 1D...
Info    : Meshing curve 1 (Ellipse)
Info    : Done meshing 1D (Wall 0.000262041s, CPU 0.000409s)
Info    : Meshing 2D...
Info    : Meshing surface 1 (Plane, Frontal-Delaunay)
Info    : Done meshing 2D (Wall 0.0594613s, CPU 0.091718s)
Info    : 1552 nodes 3103 elements</code></pre>
</div>
</div>
<p><strong>Interfacing with GMSH in DOLFINx</strong></p>
<p>We import the <code>GMSH</code>-generated mesh directly into <code>DOLFINx</code> using the <code>dolfinx.io.gmshio</code> interface. In this example, we did not specify which process created the <code>GMSH</code> model, so a copy of the model is created on each MPI process. However, our goal is to work with a single mesh distributed across all processes. To accomplish this, we take the model generated on rank <code>0</code> of <code>MPI.COMM_WORLD</code> and distribute it to all available ranks</p>
<p>The import also provides two sets of mesh tags: one for cells defined by physical groups and one for facets defined by physical groups. Since we did not add any physical groups of dimension <code>gdim -1</code>, the <code>facet_tags</code> object will be empty</p>
<div id="ef047d23" class="cell" data-execution_count="31">
<div class="sourceCode" id="cb38"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb38-2"><a href="#cb38-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.io <span class="im">import</span> gmshio</span>
<span id="cb38-3"><a href="#cb38-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> LinearProblem</span>
<span id="cb38-4"><a href="#cb38-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-5"><a href="#cb38-5" aria-hidden="true" tabindex="-1"></a>domain, cell_tags, facet_tags <span class="op">=</span> gmshio.model_to_mesh(</span>
<span id="cb38-6"><a href="#cb38-6" aria-hidden="true" tabindex="-1"></a>  gmsh.model, </span>
<span id="cb38-7"><a href="#cb38-7" aria-hidden="true" tabindex="-1"></a>  MPI.COMM_WORLD, </span>
<span id="cb38-8"><a href="#cb38-8" aria-hidden="true" tabindex="-1"></a>  rank<span class="op">=</span><span class="dv">0</span>, </span>
<span id="cb38-9"><a href="#cb38-9" aria-hidden="true" tabindex="-1"></a>  gdim<span class="op">=</span>gdim</span>
<span id="cb38-10"><a href="#cb38-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb38-11"><a href="#cb38-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb38-12"><a href="#cb38-12" aria-hidden="true" tabindex="-1"></a>gmsh.finalize()</span></code></pre></div>
</div>
<p>We define the function space as in the previous tutorial</p>
<div id="593b67c0" class="cell" data-execution_count="32">
<div class="sourceCode" id="cb39"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> fem, plot</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb39-3"><a href="#cb39-3" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span></code></pre></div>
</div>
<div id="6a217b41" class="cell" data-execution_count="33">
<div class="sourceCode" id="cb40"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract topology from mesh and create pyvista mesh</span></span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a>topology, cell_types, x <span class="op">=</span> plot.vtk_mesh(V)</span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> pyvista.UnstructuredGrid(topology, cell_types, x)</span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb40-8"><a href="#cb40-8" aria-hidden="true" tabindex="-1"></a>plotter.add_mesh(grid, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb40-9"><a href="#cb40-9" aria-hidden="true" tabindex="-1"></a>plotter.add_axes()</span>
<span id="cb40-10"><a href="#cb40-10" aria-hidden="true" tabindex="-1"></a>plotter.view_xy()</span>
<span id="cb40-11"><a href="#cb40-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-12"><a href="#cb40-12" aria-hidden="true" tabindex="-1"></a><span class="co"># if not pyvista.OFF_SCREEN:</span></span>
<span id="cb40-13"><a href="#cb40-13" aria-hidden="true" tabindex="-1"></a><span class="co">#     plotter.show()</span></span>
<span id="cb40-14"><a href="#cb40-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-15"><a href="#cb40-15" aria-hidden="true" tabindex="-1"></a><span class="co"># HTML 저장</span></span>
<span id="cb40-16"><a href="#cb40-16" aria-hidden="true" tabindex="-1"></a>plotter.export_html(<span class="st">&quot;fenicsx/fundamentals/membrane_mesh.html&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/fundamentals/membrane_mesh.html"
        width="100%" height="450px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
<p><strong>Defining a spatially varying load</strong></p>
<p>The pressure function on the right-hand side is defined with <code>ufl.SpatialCoordinate</code> and two constants, <span class="math inline">\(\beta\)</span> and <span class="math inline">\(R_0\)</span></p>
<div id="8f10537b" class="cell" data-execution_count="34">
<div class="sourceCode" id="cb41"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb41-1"><a href="#cb41-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> default_scalar_type</span>
<span id="cb41-2"><a href="#cb41-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ufl</span>
<span id="cb41-3"><a href="#cb41-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-4"><a href="#cb41-4" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> ufl.SpatialCoordinate(domain)</span>
<span id="cb41-5"><a href="#cb41-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-6"><a href="#cb41-6" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> fem.Constant(domain, default_scalar_type(<span class="dv">12</span>))</span>
<span id="cb41-7"><a href="#cb41-7" aria-hidden="true" tabindex="-1"></a>R0 <span class="op">=</span> fem.Constant(domain, default_scalar_type(<span class="fl">0.3</span>))</span>
<span id="cb41-8"><a href="#cb41-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb41-9"><a href="#cb41-9" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> <span class="dv">4</span> <span class="op">*</span>ufl.exp(<span class="op">-</span>beta<span class="op">**</span><span class="dv">2</span> <span class="op">*</span>(x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span>(x[<span class="dv">1</span>] <span class="op">-</span>R0)<span class="op">**</span><span class="dv">2</span>))</span></code></pre></div>
</div>
<p><strong>Interpolation of a <code>ufl</code> expression</strong></p>
<p>Since the load <code>p</code> is defined as a spatially varying function, we interpolate it into an appropriate function space for visualization. To do this, we use <code>dolfinx.Expression</code>, which accepts any <code>UFL</code> expression together with a set of points on the reference element. In practice, we provide the interpolation points of the target space. Because <code>p</code> exhibits rapid spatial variation, we select a high-order function space to represent it</p>
<div id="a14c8cb5" class="cell" data-execution_count="35">
<div class="sourceCode" id="cb42"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">5</span>))</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a>expr <span class="op">=</span> fem.Expression(p, Q.element.interpolation_points())</span>
<span id="cb42-3"><a href="#cb42-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb42-4"><a href="#cb42-4" aria-hidden="true" tabindex="-1"></a>pressure <span class="op">=</span> fem.Function(Q)</span>
<span id="cb42-5"><a href="#cb42-5" aria-hidden="true" tabindex="-1"></a>pressure.interpolate(expr)</span></code></pre></div>
</div>
<p>We next plot the load on the domain</p>
<div id="1b112adb" class="cell" data-execution_count="36">
<div class="sourceCode" id="cb43"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb43-1"><a href="#cb43-1" aria-hidden="true" tabindex="-1"></a>p_grid <span class="op">=</span> pyvista.UnstructuredGrid(<span class="op">*</span>plot.vtk_mesh(Q))</span>
<span id="cb43-2"><a href="#cb43-2" aria-hidden="true" tabindex="-1"></a>p_grid.point_data[<span class="st">&quot;p&quot;</span>] <span class="op">=</span> pressure.x.array.real</span>
<span id="cb43-3"><a href="#cb43-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-4"><a href="#cb43-4" aria-hidden="true" tabindex="-1"></a>warped_p <span class="op">=</span> p_grid.warp_by_scalar(<span class="st">&quot;p&quot;</span>, factor<span class="op">=</span><span class="fl">0.5</span>)</span>
<span id="cb43-5"><a href="#cb43-5" aria-hidden="true" tabindex="-1"></a>warped_p.set_active_scalars(<span class="st">&quot;p&quot;</span>)</span>
<span id="cb43-6"><a href="#cb43-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-7"><a href="#cb43-7" aria-hidden="true" tabindex="-1"></a>load_plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb43-8"><a href="#cb43-8" aria-hidden="true" tabindex="-1"></a>load_plotter.add_mesh(</span>
<span id="cb43-9"><a href="#cb43-9" aria-hidden="true" tabindex="-1"></a>  warped_p,</span>
<span id="cb43-10"><a href="#cb43-10" aria-hidden="true" tabindex="-1"></a>  show_edges<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb43-11"><a href="#cb43-11" aria-hidden="true" tabindex="-1"></a>  show_scalar_bar<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb43-12"><a href="#cb43-12" aria-hidden="true" tabindex="-1"></a>  cmap<span class="op">=</span><span class="st">&quot;jet&quot;</span></span>
<span id="cb43-13"><a href="#cb43-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb43-14"><a href="#cb43-14" aria-hidden="true" tabindex="-1"></a>load_plotter.add_axes() </span>
<span id="cb43-15"><a href="#cb43-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-16"><a href="#cb43-16" aria-hidden="true" tabindex="-1"></a><span class="co"># if not pyvista.OFF_SCREEN:</span></span>
<span id="cb43-17"><a href="#cb43-17" aria-hidden="true" tabindex="-1"></a><span class="co">#     load_plotter.show()</span></span>
<span id="cb43-18"><a href="#cb43-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb43-19"><a href="#cb43-19" aria-hidden="true" tabindex="-1"></a><span class="co"># HTML 저장</span></span>
<span id="cb43-20"><a href="#cb43-20" aria-hidden="true" tabindex="-1"></a>load_plotter.export_html(<span class="st">&quot;fenicsx/fundamentals/membrane_load.html&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/fundamentals/membrane_load.html"
        width="100%" height="500px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
<p><strong>Create a Dirichlet boundary condition using geometrical conditions</strong></p>
<p>The next step is to define the homogeneous boundary condition. Unlike in the first tutorial, we use <code>dolfinx.fem.locate_dofs_geometrical</code> to identify the degrees of freedom on the boundary. Since our domain is the unit circle, these degrees of freedom correspond to coordinates <span class="math inline">\((x, y)\)</span> such that <span class="math inline">\(\sqrt{x^2 + y^2} = 1\)</span></p>
<div id="62cf57ed" class="cell" data-execution_count="37">
<div class="sourceCode" id="cb44"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb44-1"><a href="#cb44-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb44-2"><a href="#cb44-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-3"><a href="#cb44-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> on_boundary(x):</span>
<span id="cb44-4"><a href="#cb44-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.isclose(np.sqrt(x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span>x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span>), <span class="dv">1</span>)</span>
<span id="cb44-5"><a href="#cb44-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb44-6"><a href="#cb44-6" aria-hidden="true" tabindex="-1"></a>boundary_dofs <span class="op">=</span> fem.locate_dofs_geometrical(V, on_boundary)</span></code></pre></div>
</div>
<p>Since our Dirichlet condition is homogeneous (<code>u=0</code> on the entire boundary), we can define it using <code>dolfinx.fem.dirichletbc</code> by specifying a constant value, the boundary degrees of freedom and the function space on which it should be applied</p>
<div id="dc31bcff" class="cell" data-execution_count="38">
<div class="sourceCode" id="cb45"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb45-1"><a href="#cb45-1" aria-hidden="true" tabindex="-1"></a>bc <span class="op">=</span> fem.dirichletbc(default_scalar_type(<span class="dv">0</span>), boundary_dofs, V)</span></code></pre></div>
</div>
<p><strong>Defining and solving the variational problem</strong></p>
<p>The variational problem is identical to our first Poisson problem, with <code>p</code> replacing <code>f</code></p>
<div id="8f90a3e1" class="cell" data-execution_count="39">
<div class="sourceCode" id="cb46"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb46-1"><a href="#cb46-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> ufl.TrialFunction(V)</span>
<span id="cb46-2"><a href="#cb46-2" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> ufl.TestFunction(V)</span>
<span id="cb46-3"><a href="#cb46-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-4"><a href="#cb46-4" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> ufl.dot(ufl.grad(u), ufl.grad(v)) <span class="op">*</span>ufl.dx</span>
<span id="cb46-5"><a href="#cb46-5" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> p <span class="op">*</span>v <span class="op">*</span>ufl.dx</span>
<span id="cb46-6"><a href="#cb46-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb46-7"><a href="#cb46-7" aria-hidden="true" tabindex="-1"></a>problem <span class="op">=</span> LinearProblem(</span>
<span id="cb46-8"><a href="#cb46-8" aria-hidden="true" tabindex="-1"></a>  a, </span>
<span id="cb46-9"><a href="#cb46-9" aria-hidden="true" tabindex="-1"></a>  L, </span>
<span id="cb46-10"><a href="#cb46-10" aria-hidden="true" tabindex="-1"></a>  bcs<span class="op">=</span>[bc], </span>
<span id="cb46-11"><a href="#cb46-11" aria-hidden="true" tabindex="-1"></a>  petsc_options<span class="op">=</span>{<span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;preonly&quot;</span>, <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;lu&quot;</span>}</span>
<span id="cb46-12"><a href="#cb46-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb46-13"><a href="#cb46-13" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> problem.solve()</span></code></pre></div>
</div>
<p>We plot the deflection <code>uh</code> over the domain <span class="math inline">\(\Omega\)</span></p>
<div id="23fe90d9" class="cell" data-execution_count="40">
<div class="sourceCode" id="cb47"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb47-1"><a href="#cb47-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Set deflection values and add it to plotter</span></span>
<span id="cb47-2"><a href="#cb47-2" aria-hidden="true" tabindex="-1"></a>grid.point_data[<span class="st">&quot;u&quot;</span>] <span class="op">=</span> uh.x.array</span>
<span id="cb47-3"><a href="#cb47-3" aria-hidden="true" tabindex="-1"></a>warped <span class="op">=</span> grid.warp_by_scalar(<span class="st">&quot;u&quot;</span>, factor<span class="op">=</span><span class="dv">25</span>)</span>
<span id="cb47-4"><a href="#cb47-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-5"><a href="#cb47-5" aria-hidden="true" tabindex="-1"></a>u_plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb47-6"><a href="#cb47-6" aria-hidden="true" tabindex="-1"></a>u_plotter.add_mesh(</span>
<span id="cb47-7"><a href="#cb47-7" aria-hidden="true" tabindex="-1"></a>  warped, </span>
<span id="cb47-8"><a href="#cb47-8" aria-hidden="true" tabindex="-1"></a>  show_edges<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb47-9"><a href="#cb47-9" aria-hidden="true" tabindex="-1"></a>  show_scalar_bar<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb47-10"><a href="#cb47-10" aria-hidden="true" tabindex="-1"></a>  scalars<span class="op">=</span><span class="st">&quot;u&quot;</span>,</span>
<span id="cb47-11"><a href="#cb47-11" aria-hidden="true" tabindex="-1"></a>  cmap<span class="op">=</span><span class="st">&#39;jet&#39;</span></span>
<span id="cb47-12"><a href="#cb47-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb47-13"><a href="#cb47-13" aria-hidden="true" tabindex="-1"></a>u_plotter.add_axes() </span>
<span id="cb47-14"><a href="#cb47-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-15"><a href="#cb47-15" aria-hidden="true" tabindex="-1"></a><span class="co"># if not pyvista.OFF_SCREEN:</span></span>
<span id="cb47-16"><a href="#cb47-16" aria-hidden="true" tabindex="-1"></a><span class="co">#     u_plotter.show()</span></span>
<span id="cb47-17"><a href="#cb47-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb47-18"><a href="#cb47-18" aria-hidden="true" tabindex="-1"></a><span class="co"># HTML 저장</span></span>
<span id="cb47-19"><a href="#cb47-19" aria-hidden="true" tabindex="-1"></a>u_plotter.export_html(<span class="st">&quot;fenicsx/fundamentals/membrane_u.html&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/fundamentals/membrane_u.html"
        width="100%" height="350px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
<p><strong>Plotting along a line in the domain</strong></p>
<p>A convenient way to compare the load and deflection is by plotting them along <span class="math inline">\(x=0\)</span>, using a set of points along the <span class="math inline">\(y\)</span>-axis to evaluate the finite element functions <span class="math inline">\(u\)</span> and <span class="math inline">\(p\)</span></p>
<div id="cbb039a0" class="cell" data-execution_count="41">
<div class="sourceCode" id="cb48"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb48-1"><a href="#cb48-1" aria-hidden="true" tabindex="-1"></a>tol <span class="op">=</span> <span class="fl">0.001</span>  <span class="co"># Avoid hitting the outside of the domain</span></span>
<span id="cb48-2"><a href="#cb48-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> np.linspace(<span class="op">-</span><span class="dv">1</span> <span class="op">+</span>tol, <span class="dv">1</span> <span class="op">-</span>tol, <span class="dv">101</span>)</span>
<span id="cb48-3"><a href="#cb48-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb48-4"><a href="#cb48-4" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> np.zeros((<span class="dv">3</span>, <span class="dv">101</span>))</span>
<span id="cb48-5"><a href="#cb48-5" aria-hidden="true" tabindex="-1"></a>points[<span class="dv">1</span>] <span class="op">=</span> y</span>
<span id="cb48-6"><a href="#cb48-6" aria-hidden="true" tabindex="-1"></a>u_values <span class="op">=</span> []</span>
<span id="cb48-7"><a href="#cb48-7" aria-hidden="true" tabindex="-1"></a>p_values <span class="op">=</span> []</span></code></pre></div>
</div>
<p>A finite element function can be expressed as a linear combination of all its degrees of freedom:</p>
<p><span class="math display">\[u_h(x) = \sum_{i=1}^N c_i \, \phi_i(x)\]</span></p>
<p>where <span class="math inline">\(c_i\)</span> are the coefficients of <span class="math inline">\(u_h\)</span> and <span class="math inline">\(\phi_i\)</span> are the basis functions. In principle, this allows us to evaluate the solution at any point in <span class="math inline">\(\Omega\)</span></p>
<p>However, since a mesh typically contains a large number of degrees of freedom (i.e., <span class="math inline">\(N\)</span> is large), evaluating every basis function at each point would be inefficient. Instead, we first identify which mesh cell contains the point <span class="math inline">\(x\)</span>. This can be done efficiently using a <em>bounding box tree</em>, which enables a fast recursive search through the mesh cells</p>
<div id="fbffefa2" class="cell" data-execution_count="42">
<div class="sourceCode" id="cb49"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb49-1"><a href="#cb49-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> geometry</span>
<span id="cb49-2"><a href="#cb49-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb49-3"><a href="#cb49-3" aria-hidden="true" tabindex="-1"></a>bb_tree <span class="op">=</span> geometry.bb_tree(domain, domain.topology.dim)</span></code></pre></div>
</div>
<p>We can now determine which cells each point intersects by using <code>dolfinx.geometry.compute_collisions_points</code>. This function returns, for every input point, a list of cells whose bounding boxes overlap with that point. Since different points may correspond to a varying number of cells, the results are stored in a <code>dolfinx.cpp.graph.AdjacencyList_int32</code>. The cells associated with the <span class="math inline">\(i\)</span>-th point can be accessed with <code>links(i)</code></p>
<p>Because a cell’s bounding box generally extends beyond the cell itself in <span class="math inline">\(\mathbb{R}^n\)</span>, we must verify whether the point actually inside the cell. This is done with <code>dolfinx.geometry.compute_colliding_cells</code>, which computes the exact distance between the point and the cell (approximating higher-order cells as convex hulls). Like the previous function, it also returns an adjacency list, since a point may lie on a facet, edge, or vertex shared by multiple cells</p>
<p>Finally, to ensure that the code runs correctly in parallel when the mesh is distributed across multiple processors, we create a subset, <code>points_on_proc</code>, that includes only the points located on the current processor</p>
<div id="4401a26f" class="cell" data-execution_count="43">
<div class="sourceCode" id="cb50"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb50-1"><a href="#cb50-1" aria-hidden="true" tabindex="-1"></a>cells <span class="op">=</span> []</span>
<span id="cb50-2"><a href="#cb50-2" aria-hidden="true" tabindex="-1"></a>points_on_proc <span class="op">=</span> []</span>
<span id="cb50-3"><a href="#cb50-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-4"><a href="#cb50-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Find cells whose bounding-box collide with the the points</span></span>
<span id="cb50-5"><a href="#cb50-5" aria-hidden="true" tabindex="-1"></a>cell_candidates <span class="op">=</span> geometry.compute_collisions_points(</span>
<span id="cb50-6"><a href="#cb50-6" aria-hidden="true" tabindex="-1"></a>  bb_tree, </span>
<span id="cb50-7"><a href="#cb50-7" aria-hidden="true" tabindex="-1"></a>  points.T</span>
<span id="cb50-8"><a href="#cb50-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb50-9"><a href="#cb50-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-10"><a href="#cb50-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Choose one of the cells that contains the point</span></span>
<span id="cb50-11"><a href="#cb50-11" aria-hidden="true" tabindex="-1"></a>colliding_cells <span class="op">=</span> geometry.compute_colliding_cells(</span>
<span id="cb50-12"><a href="#cb50-12" aria-hidden="true" tabindex="-1"></a>  domain, </span>
<span id="cb50-13"><a href="#cb50-13" aria-hidden="true" tabindex="-1"></a>  cell_candidates, </span>
<span id="cb50-14"><a href="#cb50-14" aria-hidden="true" tabindex="-1"></a>  points.T</span>
<span id="cb50-15"><a href="#cb50-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb50-16"><a href="#cb50-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb50-17"><a href="#cb50-17" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, point <span class="kw">in</span> <span class="bu">enumerate</span>(points.T):</span>
<span id="cb50-18"><a href="#cb50-18" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> <span class="bu">len</span>(colliding_cells.links(i)) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb50-19"><a href="#cb50-19" aria-hidden="true" tabindex="-1"></a>        points_on_proc.append(point)</span>
<span id="cb50-20"><a href="#cb50-20" aria-hidden="true" tabindex="-1"></a>        cells.append(colliding_cells.links(i)[<span class="dv">0</span>])</span></code></pre></div>
</div>
<p>We now have a list of points associated with the processor and the cell each point belongs to. This allows us to use <code>uh.eval</code> and <code>pressure.eval</code> to compute the function values at these points</p>
<div id="1d51dbc1" class="cell" data-execution_count="44">
<div class="sourceCode" id="cb51"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb51-1"><a href="#cb51-1" aria-hidden="true" tabindex="-1"></a>points_on_proc <span class="op">=</span> np.array(points_on_proc, dtype<span class="op">=</span>np.float64)</span>
<span id="cb51-2"><a href="#cb51-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb51-3"><a href="#cb51-3" aria-hidden="true" tabindex="-1"></a>u_values <span class="op">=</span> uh.<span class="bu">eval</span>(points_on_proc, cells)</span>
<span id="cb51-4"><a href="#cb51-4" aria-hidden="true" tabindex="-1"></a>p_values <span class="op">=</span> pressure.<span class="bu">eval</span>(points_on_proc, cells)</span></code></pre></div>
</div>
<p>With the coordinates and the corresponding function values, we can now plot the results using <code>matplotlib</code></p>
<div id="f2549c21" class="cell" data-execution_count="45">
<div class="sourceCode" id="cb52"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb52-1"><a href="#cb52-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb52-2"><a href="#cb52-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-3"><a href="#cb52-3" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure()</span>
<span id="cb52-4"><a href="#cb52-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-5"><a href="#cb52-5" aria-hidden="true" tabindex="-1"></a>plt.plot(points_on_proc[:, <span class="dv">1</span>], <span class="dv">50</span> <span class="op">*</span>u_values, </span>
<span id="cb52-6"><a href="#cb52-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;k&quot;</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">&quot;Deflection ($</span><span class="ch">\\</span><span class="st">times 50$)&quot;</span>)</span>
<span id="cb52-7"><a href="#cb52-7" aria-hidden="true" tabindex="-1"></a>plt.plot(points_on_proc[:, <span class="dv">1</span>], p_values, </span>
<span id="cb52-8"><a href="#cb52-8" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;b--&quot;</span>, lw<span class="op">=</span><span class="dv">2</span>, label<span class="op">=</span><span class="st">&quot;Load&quot;</span>)</span>
<span id="cb52-9"><a href="#cb52-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb52-10"><a href="#cb52-10" aria-hidden="true" tabindex="-1"></a>plt.grid(<span class="va">True</span>)</span>
<span id="cb52-11"><a href="#cb52-11" aria-hidden="true" tabindex="-1"></a>plt.legend()</span>
<span id="cb52-12"><a href="#cb52-12" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&quot;y&quot;</span>)</span>
<span id="cb52-13"><a href="#cb52-13" aria-hidden="true" tabindex="-1"></a>plt.show()</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img src="x_PDE_FEniCS_files/figure-html/cell-46-output-1.png" width="571" height="429" /></p>
</figure>
</div>
</div>
</div>
<p><strong>Saving functions to file</strong></p>
<p>To visualize the solution in <a href="https://www.paraview.org/"><code>ParaView</code></a>, we can save it to a file as follows:</p>
<div id="9cd9c8f4" class="cell" data-execution_count="46">
<div class="sourceCode" id="cb53"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb53-1"><a href="#cb53-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb53-2"><a href="#cb53-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dolfinx.io</span>
<span id="cb53-3"><a href="#cb53-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-4"><a href="#cb53-4" aria-hidden="true" tabindex="-1"></a>results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/fundamentals&quot;</span>)</span>
<span id="cb53-5"><a href="#cb53-5" aria-hidden="true" tabindex="-1"></a>results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb53-6"><a href="#cb53-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-7"><a href="#cb53-7" aria-hidden="true" tabindex="-1"></a>filename <span class="op">=</span> results_folder<span class="op">/</span><span class="st">&quot;membrane&quot;</span></span>
<span id="cb53-8"><a href="#cb53-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-9"><a href="#cb53-9" aria-hidden="true" tabindex="-1"></a>pressure.name <span class="op">=</span> <span class="st">&quot;Load&quot;</span></span>
<span id="cb53-10"><a href="#cb53-10" aria-hidden="true" tabindex="-1"></a>uh.name <span class="op">=</span> <span class="st">&quot;Deflection&quot;</span></span>
<span id="cb53-11"><a href="#cb53-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-12"><a href="#cb53-12" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> dolfinx.io.VTXWriter(</span>
<span id="cb53-13"><a href="#cb53-13" aria-hidden="true" tabindex="-1"></a>  MPI.COMM_WORLD, results_folder<span class="op">/</span><span class="st">&quot;membrane_pressure.bp&quot;</span>, </span>
<span id="cb53-14"><a href="#cb53-14" aria-hidden="true" tabindex="-1"></a>  [pressure], engine<span class="op">=</span><span class="st">&quot;BP4&quot;</span>) <span class="im">as</span> vtx:</span>
<span id="cb53-15"><a href="#cb53-15" aria-hidden="true" tabindex="-1"></a>    vtx.write(<span class="fl">0.0</span>)</span>
<span id="cb53-16"><a href="#cb53-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb53-17"><a href="#cb53-17" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> dolfinx.io.VTXWriter(</span>
<span id="cb53-18"><a href="#cb53-18" aria-hidden="true" tabindex="-1"></a>  MPI.COMM_WORLD, results_folder<span class="op">/</span><span class="st">&quot;membrane_deflection.bp&quot;</span>, </span>
<span id="cb53-19"><a href="#cb53-19" aria-hidden="true" tabindex="-1"></a>  [uh], engine<span class="op">=</span><span class="st">&quot;BP4&quot;</span>) <span class="im">as</span> vtx:</span>
<span id="cb53-20"><a href="#cb53-20" aria-hidden="true" tabindex="-1"></a>    vtx.write(<span class="fl">0.0</span>)</span></code></pre></div>
</div>
</section>
</section>
<section id="a-gallery-of-finite-element-solvers" class="level2" data-number="K.7">
<h2 data-number="K.7"><span class="header-section-number">K.7</span> A Gallery of finite element solvers</h2>
<p>The aim of this chapter is to demonstrate how a variety of important PDEs from science and engineering can be solved using just a few lines of <code>DOLFINx</code> code. We start with the heat equation, then proceed to the nonlinear Poisson equation, the equations of linear elasticity, and the Navier–Stokes equations. These examples illustrate how to handle time-dependent problems, nonlinear problems, vector-valued problems, and systems of PDEs. For each case, we derive the variational formulation and implement the problem in <code>Python</code> in a way that closely mirrors the underlying mathematics</p>
<section id="the-heat-equation" class="level3" data-number="K.7.1">
<h3 data-number="K.7.1"><span class="header-section-number">K.7.1</span> The heat equation</h3>
<p>Authors: Hans Petter Langtangen, Anders Logg, Jørgen S. Dokken</p>
<p>As a first extension of the Poisson problem introduced in the previous chapter, we now turn to the time-dependent heat equation (also known as the time-dependent diffusion equation). This equation can be viewed as the natural generalization of the Poisson equation, which describes the stationary distribution of heat in a body, to the case where the distribution evolves over time. By discretizing time into small intervals and applying standard time-stepping methods, we can solve the heat equation as a sequence of variational problems, in much the same way as we solved the Poisson equation</p>
<p><strong>The PDE problem</strong></p>
<p>The model problem for the time-dependent PDE is given by</p>
<p><span class="math display">\[
\begin{aligned}
\frac{\partial u}{\partial t}&amp;=\nabla^2 u + f &amp;&amp; \text{in } \Omega \times (0, T] \\
u &amp;= u_D &amp;&amp; \text{on } \partial\Omega \times (0,T] \\
u &amp;= u_0 &amp;&amp; \text{at } t=0
\end{aligned}\]</span></p>
<p>Here, <span class="math inline">\(u\)</span> depends on both space and time; for example, <span class="math inline">\(u = u(x,y,t)\)</span> if the spatial domain <span class="math inline">\(\Omega\)</span> is two-dimensional. The source term <span class="math inline">\(f\)</span> and the boundary condition <span class="math inline">\(u_D\)</span> may also vary with space and time, while the initial condition <span class="math inline">\(u_0\)</span> is a function of space alone</p>
<p><strong>The variational formulation</strong></p>
<p>A simple approach to solving time-dependent PDEs with the finite element method is to first discretize the time derivative using a finite difference approximation. This reduces the problem to a sequence of stationary equations, each of which can then be written in variational form. We use the superscript <span class="math inline">\(n\)</span> to denote a quantity at time <span class="math inline">\(t_n\)</span>, where <span class="math inline">\(n\)</span> indexes the discrete time levels. For example, <span class="math inline">\(u^n\)</span> represents the value of <span class="math inline">\(u\)</span> at time level <span class="math inline">\(n\)</span>. The first step in a finite difference discretization of time is to evaluate the PDE at a chosen time level, such as <span class="math inline">\(t_{n+1}\)</span></p>
<p><span class="math display">\[
\begin{aligned}
    \left(\frac{\partial u }{\partial t}\right)^{n+1}= \nabla^2 u^{n+1}+ f^{n+1}
\end{aligned}\]</span></p>
<p>The time derivative can be approximated by a difference quotient. For reasons of both simplicity and stability, we adopt the backward difference scheme:</p>
<p><span class="math display">\[\begin{aligned}
\left(\frac{\partial u }{\partial t}\right)^{n+1}\approx \frac{u^{n+1}-u^n}{\Delta t}
\end{aligned}\]</span></p>
<p>where <span class="math inline">\(\Delta t\)</span> denotes the time-step size. Substituting this expression into the equation at time level <span class="math inline">\(n +1\)</span> gives</p>
<p><span class="math display">\[\begin{aligned}
\frac{u^{n+1}-u^n}{\Delta t}= \nabla^2 u^{n+1}+ f^{n+1}
\end{aligned}\]</span></p>
<p>This is the time-discrete form of the heat equation, known as the backward Euler or implicit Euler scheme</p>
<p>We rearrange the equation so that the left-hand side contains only the unknown <span class="math inline">\(u^{n+1}\)</span>, while the right-hand side contains terms that are already known. This yields a sequence of stationary problems for <span class="math inline">\(u^{n+1}\)</span>, given that <span class="math inline">\(u^{n}\)</span> is available from the previous time step:</p>
<p><span class="math display">\[\begin{aligned}
u^0 &amp;= u_0\\
u^{n+1} - \Delta t \nabla^2 u^{n+1} &amp;= u^{n} + \Delta t f^{n+1}, \quad n = 0,1,2,\dots
\end{aligned}\]</span></p>
<p>Starting from the initial condition <span class="math inline">\(u_0\)</span>, we can then compute <span class="math inline">\(u^0\)</span>, <span class="math inline">\(u^1\)</span>, <span class="math inline">\(u^2\)</span>, and so forth</p>
<p>Next, we apply the finite element method. To do this, we first derive the weak formulation of the equation: we multiply by a test function <span class="math inline">\(v \in \hat{V}\)</span> and integrate the second-order derivatives by parts. For simplicity, we now denote <span class="math inline">\(u^{n+1}\)</span> by <span class="math inline">\(u\)</span>. The resulting weak formulation can be written as</p>
<p><span class="math display">\[\begin{aligned}
a(u,v) &amp;= L_{n+1}(v)
\end{aligned}\]</span></p>
<p>where</p>
<p><span class="math display">\[\begin{aligned}
a(u,v) &amp;= \int_{\Omega} \big( u v + \Delta t \nabla u \cdot \nabla v \big)\,\mathrm{d}x \\
L_{n+1}(v) &amp;= \int_{\Omega} \big(u^n + \Delta t f^{n+1}\big)\, v \,\mathrm{d}x
\end{aligned}\]</span></p>
<p><strong>Projection or interpolation of the initial condition</strong></p>
<p>In addition to the variational problem solved at each time step, we also need to approximate the initial condition. This can likewise be expressed as a variational problem:</p>
<p><span class="math display">\[\begin{aligned}
a_0(u,v) &amp;= L_0(v)
\end{aligned}\]</span></p>
<p>with</p>
<p><span class="math display">\[\begin{aligned}
a_0(u,v) &amp;= \int_{\Omega} u v \,\mathrm{d}x\\
L_0(v) &amp;= \int_{\Omega} u_0 v \,\mathrm{d}x
\end{aligned}\]</span></p>
<p>Solving this variational problem gives <span class="math inline">\(u^0\)</span>, which is the <span class="math inline">\(L^2\)</span> projection of the prescribed initial condition <span class="math inline">\(u_0\)</span> onto the finite element space</p>
<p>An alternative way to construct <span class="math inline">\(u^0\)</span> is by directly interpolating the initial value <span class="math inline">\(u_0\)</span>. We discussed the use of interpolation in <code>DOLFINx</code> in the membrane deflection</p>
<p>In <code>DOLFINx</code>, the initial condition can be obtained either by projection or by interpolation. The most common approach is projection, which provides an approximation of <span class="math inline">\(u_0\)</span>. However, in applications where we want to verify the implementation against exact solutions, interpolation must be used. In this chapter, we will consider such a case</p>
<section id="diffusion-of-a-gaussian-function" class="level4" data-number="K.7.1.1">
<h4 data-number="K.7.1.1"><span class="header-section-number">K.7.1.1</span> Diffusion of a Gaussian function</h4>
<p>Author: Jørgen S. Dokken</p>
<p>Let us now consider a more interesting problem: the diffusion of a Gaussian hill. We take the initial condition to be</p>
<p><span class="math display">\[\begin{aligned}
u_0(x,y) &amp;= e^{-a (x^2 +y^2)}
\end{aligned}\]</span></p>
<p>with <span class="math inline">\(a = 5\)</span> on the domain <span class="math inline">\([-2,2]\times[-2,2]\)</span>. For this problem, we impose homogeneous Dirichlet boundary conditions (<span class="math inline">\(u_D = 0\)</span>)</p>
<p>The first difference from the previous problem is that the domain is no longer the unit square. We create the rectangular domain using <code>dolfinx.mesh.create_rectangle</code></p>
<div id="60a9f310" class="cell" data-execution_count="47">
<div class="sourceCode" id="cb54"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb54-1"><a href="#cb54-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb54-2"><a href="#cb54-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib <span class="im">as</span> mpl</span>
<span id="cb54-3"><a href="#cb54-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-4"><a href="#cb54-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb54-5"><a href="#cb54-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> petsc4py <span class="im">import</span> PETSc</span>
<span id="cb54-6"><a href="#cb54-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb54-7"><a href="#cb54-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-8"><a href="#cb54-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> fem, mesh, io, plot</span>
<span id="cb54-9"><a href="#cb54-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> (</span>
<span id="cb54-10"><a href="#cb54-10" aria-hidden="true" tabindex="-1"></a>  assemble_vector, assemble_matrix,</span>
<span id="cb54-11"><a href="#cb54-11" aria-hidden="true" tabindex="-1"></a>  create_vector, apply_lifting, set_bc</span>
<span id="cb54-12"><a href="#cb54-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-13"><a href="#cb54-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ufl</span>
<span id="cb54-14"><a href="#cb54-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-15"><a href="#cb54-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Define temporal parameters</span></span>
<span id="cb54-16"><a href="#cb54-16" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="fl">0.0</span>            <span class="co"># Start time</span></span>
<span id="cb54-17"><a href="#cb54-17" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="fl">1.0</span>            <span class="co"># Final time</span></span>
<span id="cb54-18"><a href="#cb54-18" aria-hidden="true" tabindex="-1"></a>num_steps <span class="op">=</span> <span class="dv">50</span></span>
<span id="cb54-19"><a href="#cb54-19" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> T <span class="op">/</span>num_steps  <span class="co"># time step size</span></span>
<span id="cb54-20"><a href="#cb54-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-21"><a href="#cb54-21" aria-hidden="true" tabindex="-1"></a><span class="co"># Define mesh</span></span>
<span id="cb54-22"><a href="#cb54-22" aria-hidden="true" tabindex="-1"></a>nx, ny <span class="op">=</span> <span class="dv">50</span>, <span class="dv">50</span></span>
<span id="cb54-23"><a href="#cb54-23" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> mesh.create_rectangle(</span>
<span id="cb54-24"><a href="#cb54-24" aria-hidden="true" tabindex="-1"></a>  MPI.COMM_WORLD, </span>
<span id="cb54-25"><a href="#cb54-25" aria-hidden="true" tabindex="-1"></a>  [np.array([<span class="op">-</span><span class="dv">2</span>, <span class="op">-</span><span class="dv">2</span>]), np.array([<span class="dv">2</span>, <span class="dv">2</span>])],</span>
<span id="cb54-26"><a href="#cb54-26" aria-hidden="true" tabindex="-1"></a>  [nx, ny], </span>
<span id="cb54-27"><a href="#cb54-27" aria-hidden="true" tabindex="-1"></a>  mesh.CellType.triangle</span>
<span id="cb54-28"><a href="#cb54-28" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb54-29"><a href="#cb54-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb54-30"><a href="#cb54-30" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span></code></pre></div>
</div>
<div id="d8d940ce" class="cell" data-execution_count="48">
<div class="sourceCode" id="cb55"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb55-1"><a href="#cb55-1" aria-hidden="true" tabindex="-1"></a>results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/heat&quot;</span>)</span>
<span id="cb55-2"><a href="#cb55-2" aria-hidden="true" tabindex="-1"></a>results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb55-3"><a href="#cb55-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-4"><a href="#cb55-4" aria-hidden="true" tabindex="-1"></a>tdim <span class="op">=</span> domain.topology.dim</span>
<span id="cb55-5"><a href="#cb55-5" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> pyvista.UnstructuredGrid(<span class="op">*</span>plot.vtk_mesh(domain, tdim))</span>
<span id="cb55-6"><a href="#cb55-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-7"><a href="#cb55-7" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb55-8"><a href="#cb55-8" aria-hidden="true" tabindex="-1"></a>plotter.add_mesh(grid, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb55-9"><a href="#cb55-9" aria-hidden="true" tabindex="-1"></a>plotter.add_axes()</span>
<span id="cb55-10"><a href="#cb55-10" aria-hidden="true" tabindex="-1"></a>plotter.view_xy()</span>
<span id="cb55-11"><a href="#cb55-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-12"><a href="#cb55-12" aria-hidden="true" tabindex="-1"></a><span class="co"># if not pyvista.OFF_SCREEN:</span></span>
<span id="cb55-13"><a href="#cb55-13" aria-hidden="true" tabindex="-1"></a><span class="co">#     plotter.show()</span></span>
<span id="cb55-14"><a href="#cb55-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb55-15"><a href="#cb55-15" aria-hidden="true" tabindex="-1"></a><span class="co"># HTML 저장</span></span>
<span id="cb55-16"><a href="#cb55-16" aria-hidden="true" tabindex="-1"></a>plotter.export_html(results_folder<span class="op">/</span><span class="st">&quot;heat_mesh.html&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/heat/heat_mesh.html"
        width="100%" height="350px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
<p>Note that we have used a much higher resolution than before to better capture the features of the solution. We can also easily update the initial and boundary conditions. Instead of defining the initial condition using a class, we simply use a function</p>
<div id="b883db00" class="cell" data-execution_count="49">
<div class="sourceCode" id="cb56"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb56-1"><a href="#cb56-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Create initial condition</span></span>
<span id="cb56-2"><a href="#cb56-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> initial_condition(x, a<span class="op">=</span><span class="dv">5</span>):</span>
<span id="cb56-3"><a href="#cb56-3" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> np.exp(<span class="op">-</span>a <span class="op">*</span>(x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span>x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb56-4"><a href="#cb56-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-5"><a href="#cb56-5" aria-hidden="true" tabindex="-1"></a>u_n <span class="op">=</span> fem.Function(V)</span>
<span id="cb56-6"><a href="#cb56-6" aria-hidden="true" tabindex="-1"></a>u_n.name <span class="op">=</span> <span class="st">&quot;u_n&quot;</span></span>
<span id="cb56-7"><a href="#cb56-7" aria-hidden="true" tabindex="-1"></a>u_n.interpolate(initial_condition)</span>
<span id="cb56-8"><a href="#cb56-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-9"><a href="#cb56-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Create boundary condition</span></span>
<span id="cb56-10"><a href="#cb56-10" aria-hidden="true" tabindex="-1"></a>fdim <span class="op">=</span> tdim <span class="op">-</span><span class="dv">1</span></span>
<span id="cb56-11"><a href="#cb56-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-12"><a href="#cb56-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Select all boundary facets</span></span>
<span id="cb56-13"><a href="#cb56-13" aria-hidden="true" tabindex="-1"></a>boundary_facets <span class="op">=</span> mesh.locate_entities_boundary(</span>
<span id="cb56-14"><a href="#cb56-14" aria-hidden="true" tabindex="-1"></a>  domain, </span>
<span id="cb56-15"><a href="#cb56-15" aria-hidden="true" tabindex="-1"></a>  fdim, </span>
<span id="cb56-16"><a href="#cb56-16" aria-hidden="true" tabindex="-1"></a>  <span class="kw">lambda</span> x: np.full(x.shape[<span class="dv">1</span>], <span class="va">True</span>, dtype<span class="op">=</span><span class="bu">bool</span>)</span>
<span id="cb56-17"><a href="#cb56-17" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb56-18"><a href="#cb56-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-19"><a href="#cb56-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract boundary DOFs</span></span>
<span id="cb56-20"><a href="#cb56-20" aria-hidden="true" tabindex="-1"></a>boundary_dofs <span class="op">=</span> fem.locate_dofs_topological(</span>
<span id="cb56-21"><a href="#cb56-21" aria-hidden="true" tabindex="-1"></a>  V, </span>
<span id="cb56-22"><a href="#cb56-22" aria-hidden="true" tabindex="-1"></a>  fdim, </span>
<span id="cb56-23"><a href="#cb56-23" aria-hidden="true" tabindex="-1"></a>  boundary_facets</span>
<span id="cb56-24"><a href="#cb56-24" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb56-25"><a href="#cb56-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb56-26"><a href="#cb56-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Define boundary condition (u = 0 on the entire boundary)</span></span>
<span id="cb56-27"><a href="#cb56-27" aria-hidden="true" tabindex="-1"></a><span class="co"># For scalar constants, </span></span>
<span id="cb56-28"><a href="#cb56-28" aria-hidden="true" tabindex="-1"></a><span class="co">#   also pass V to specify the function space</span></span>
<span id="cb56-29"><a href="#cb56-29" aria-hidden="true" tabindex="-1"></a>bc <span class="op">=</span> fem.dirichletbc(</span>
<span id="cb56-30"><a href="#cb56-30" aria-hidden="true" tabindex="-1"></a>  PETSc.ScalarType(<span class="dv">0</span>), </span>
<span id="cb56-31"><a href="#cb56-31" aria-hidden="true" tabindex="-1"></a>  boundary_dofs, </span>
<span id="cb56-32"><a href="#cb56-32" aria-hidden="true" tabindex="-1"></a>  V</span>
<span id="cb56-33"><a href="#cb56-33" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
<p><strong>Variational formulation</strong></p>
<p>As in the previous example, we set up the necessary objects for the time-dependent problem so that we do not need to recreate the data structures</p>
<div id="3466d351" class="cell" data-execution_count="50">
<div class="sourceCode" id="cb57"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb57-1"><a href="#cb57-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> ufl.TrialFunction(V)</span>
<span id="cb57-2"><a href="#cb57-2" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> ufl.TestFunction(V)</span>
<span id="cb57-3"><a href="#cb57-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-4"><a href="#cb57-4" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> fem.Constant(domain, PETSc.ScalarType(<span class="dv">0</span>))</span>
<span id="cb57-5"><a href="#cb57-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb57-6"><a href="#cb57-6" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> (u <span class="op">*</span>v <span class="op">+</span>dt <span class="op">*</span>ufl.dot(ufl.grad(u), ufl.grad(v))) <span class="op">*</span>ufl.dx</span>
<span id="cb57-7"><a href="#cb57-7" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> (u_n <span class="op">+</span>dt <span class="op">*</span>f) <span class="op">*</span>v <span class="op">*</span>ufl.dx</span></code></pre></div>
</div>
<p><strong>Preparing linear algebra structures for time dependent problems</strong></p>
<p>Even though <code>u_n</code> depends on time, we use the same function for both <code>f</code> and <code>u_n</code> at each time step. We then call <code>dolfinx.fem.form</code> to create the assembly kernels for the matrix and vector</p>
<div id="6146856e" class="cell" data-execution_count="51">
<div class="sourceCode" id="cb58"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb58-1"><a href="#cb58-1" aria-hidden="true" tabindex="-1"></a>bilinear_form <span class="op">=</span> fem.form(a)</span>
<span id="cb58-2"><a href="#cb58-2" aria-hidden="true" tabindex="-1"></a>linear_form <span class="op">=</span> fem.form(L)</span></code></pre></div>
</div>
<p>The left-hand side of the system, the matrix <code>A</code>, does not change between time steps, so it only needs to be assembled once. The right-hand side, however, depends on the previous solution <code>u_n</code> and must be assembled at every time step. For this reason, we create the vector <code>b</code> from <code>L</code> and reuse it at each step</p>
<div id="1d4bb43f" class="cell" data-execution_count="52">
<div class="sourceCode" id="cb59"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb59-1"><a href="#cb59-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> assemble_matrix(bilinear_form, bcs<span class="op">=</span>[bc])</span>
<span id="cb59-2"><a href="#cb59-2" aria-hidden="true" tabindex="-1"></a>A.assemble()</span>
<span id="cb59-3"><a href="#cb59-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> create_vector(linear_form)</span></code></pre></div>
</div>
<p><strong>Using <code>petsc4py</code> to create a linear solver</strong></p>
<p>Since we have already assembled <code>a</code> into the matrix <code>A</code>, we cannot use the <code>dolfinx.fem.petsc.LinearProblem</code> class. Instead, we create a <code>PETSc</code> linear solver, assign the matrix <code>A</code> to it, and select a solution strategy</p>
<div id="6ad2cfd4" class="cell" data-execution_count="53">
<div class="sourceCode" id="cb60"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb60-1"><a href="#cb60-1" aria-hidden="true" tabindex="-1"></a>solver <span class="op">=</span> PETSc.KSP().create(domain.comm)</span>
<span id="cb60-2"><a href="#cb60-2" aria-hidden="true" tabindex="-1"></a>solver.setOperators(A)</span>
<span id="cb60-3"><a href="#cb60-3" aria-hidden="true" tabindex="-1"></a>solver.setType(PETSc.KSP.Type.PREONLY)</span>
<span id="cb60-4"><a href="#cb60-4" aria-hidden="true" tabindex="-1"></a>solver.getPC().setType(PETSc.PC.Type.LU)</span></code></pre></div>
</div>
<p><strong>Saving time-dependent solutions with XDMFFile</strong></p>
<p>To visualize the solution in an external program such as <code>Paraview</code>, we create an <code>XDMFFile</code>, which can store multiple solutions. The main advantage of using an XDMFFile is that the mesh only needs to be stored once, and multiple solutions can be appended to the same grid, thereby reducing the storage requirements</p>
<p>The first argument to <code>XDMFFile</code> specifies the communicator used to store the data. Since we want a single output file regardless of the number of processors, we use the <code>COMM_WORLD</code>. The second argument is the name of the output file, and the third argument specifies the file mode, which can be read (<code>"r"</code>), write (<code>"w"</code>) or append (<code>"a"</code>)</p>
<div id="1c2915c0" class="cell" data-execution_count="54">
<div class="sourceCode" id="cb61"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb61-1"><a href="#cb61-1" aria-hidden="true" tabindex="-1"></a>xdmf <span class="op">=</span> io.XDMFFile(</span>
<span id="cb61-2"><a href="#cb61-2" aria-hidden="true" tabindex="-1"></a>  domain.comm, </span>
<span id="cb61-3"><a href="#cb61-3" aria-hidden="true" tabindex="-1"></a>  results_folder<span class="op">/</span><span class="st">&quot;heat.xdmf&quot;</span>, </span>
<span id="cb61-4"><a href="#cb61-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;w&quot;</span></span>
<span id="cb61-5"><a href="#cb61-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb61-6"><a href="#cb61-6" aria-hidden="true" tabindex="-1"></a>xdmf.write_mesh(domain)</span>
<span id="cb61-7"><a href="#cb61-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-8"><a href="#cb61-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Define solution variable, </span></span>
<span id="cb61-9"><a href="#cb61-9" aria-hidden="true" tabindex="-1"></a><span class="co">#  and interpolate initial solution for visualization</span></span>
<span id="cb61-10"><a href="#cb61-10" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> fem.Function(V)</span>
<span id="cb61-11"><a href="#cb61-11" aria-hidden="true" tabindex="-1"></a>uh.name <span class="op">=</span> <span class="st">&quot;uh&quot;</span></span>
<span id="cb61-12"><a href="#cb61-12" aria-hidden="true" tabindex="-1"></a>uh.interpolate(initial_condition)</span>
<span id="cb61-13"><a href="#cb61-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb61-14"><a href="#cb61-14" aria-hidden="true" tabindex="-1"></a>xdmf.write_function(uh, t)</span></code></pre></div>
</div>
<p><strong>Visualizing time-dependent solutions with PyVista</strong></p>
<p>We use the <code>DOLFINx</code> plotting tools, based on <code>PyVista</code>, to plot the solution at every time step. We also display a colorbar showing the initial maximum values of <code>u</code>. For this, we use the convenience function <code>renderer</code>:</p>
<div id="48fa4be6" class="cell" data-execution_count="55">
<div class="sourceCode" id="cb62"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb62-1"><a href="#cb62-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> functools <span class="im">import</span> partial</span>
<span id="cb62-2"><a href="#cb62-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-3"><a href="#cb62-3" aria-hidden="true" tabindex="-1"></a>viridis <span class="op">=</span> mpl.colormaps.get_cmap(<span class="st">&quot;viridis&quot;</span>).resampled(<span class="dv">25</span>)</span>
<span id="cb62-4"><a href="#cb62-4" aria-hidden="true" tabindex="-1"></a>sargs <span class="op">=</span> <span class="bu">dict</span>(</span>
<span id="cb62-5"><a href="#cb62-5" aria-hidden="true" tabindex="-1"></a>  title_font_size<span class="op">=</span><span class="dv">25</span>, </span>
<span id="cb62-6"><a href="#cb62-6" aria-hidden="true" tabindex="-1"></a>  label_font_size<span class="op">=</span><span class="dv">20</span>, </span>
<span id="cb62-7"><a href="#cb62-7" aria-hidden="true" tabindex="-1"></a>  fmt<span class="op">=</span><span class="st">&quot;</span><span class="sc">%.2f</span><span class="st">&quot;</span>, </span>
<span id="cb62-8"><a href="#cb62-8" aria-hidden="true" tabindex="-1"></a>  color<span class="op">=</span><span class="st">&quot;black&quot;</span>,</span>
<span id="cb62-9"><a href="#cb62-9" aria-hidden="true" tabindex="-1"></a>  position_x<span class="op">=</span><span class="fl">0.1</span>, </span>
<span id="cb62-10"><a href="#cb62-10" aria-hidden="true" tabindex="-1"></a>  position_y<span class="op">=</span><span class="fl">0.8</span>, </span>
<span id="cb62-11"><a href="#cb62-11" aria-hidden="true" tabindex="-1"></a>  width<span class="op">=</span><span class="fl">0.8</span>, </span>
<span id="cb62-12"><a href="#cb62-12" aria-hidden="true" tabindex="-1"></a>  height<span class="op">=</span><span class="fl">0.1</span></span>
<span id="cb62-13"><a href="#cb62-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb62-14"><a href="#cb62-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-15"><a href="#cb62-15" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter()</span>
<span id="cb62-16"><a href="#cb62-16" aria-hidden="true" tabindex="-1"></a><span class="co"># conda install -c conda-forge imageio</span></span>
<span id="cb62-17"><a href="#cb62-17" aria-hidden="true" tabindex="-1"></a>plotter.open_gif(results_folder<span class="op">/</span><span class="st">&quot;heat_animation.gif&quot;</span>, fps<span class="op">=</span><span class="dv">10</span>) </span>
<span id="cb62-18"><a href="#cb62-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb62-19"><a href="#cb62-19" aria-hidden="true" tabindex="-1"></a>renderer <span class="op">=</span> partial(</span>
<span id="cb62-20"><a href="#cb62-20" aria-hidden="true" tabindex="-1"></a>  plotter.add_mesh,</span>
<span id="cb62-21"><a href="#cb62-21" aria-hidden="true" tabindex="-1"></a>  show_edges<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb62-22"><a href="#cb62-22" aria-hidden="true" tabindex="-1"></a>  lighting<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb62-23"><a href="#cb62-23" aria-hidden="true" tabindex="-1"></a>  cmap<span class="op">=</span>viridis, </span>
<span id="cb62-24"><a href="#cb62-24" aria-hidden="true" tabindex="-1"></a>  scalar_bar_args<span class="op">=</span>sargs,</span>
<span id="cb62-25"><a href="#cb62-25" aria-hidden="true" tabindex="-1"></a>  clim<span class="op">=</span>[<span class="dv">0</span>, <span class="bu">max</span>(uh.x.array)]</span>
<span id="cb62-26"><a href="#cb62-26" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
<div id="d3dfae10" class="cell" data-execution_count="56">
<div class="sourceCode" id="cb63"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb63-1"><a href="#cb63-1" aria-hidden="true" tabindex="-1"></a>grid.point_data[<span class="st">&quot;uh&quot;</span>] <span class="op">=</span> uh.x.array</span>
<span id="cb63-2"><a href="#cb63-2" aria-hidden="true" tabindex="-1"></a>warped <span class="op">=</span> grid.warp_by_scalar(<span class="st">&quot;uh&quot;</span>, factor<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb63-3"><a href="#cb63-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb63-4"><a href="#cb63-4" aria-hidden="true" tabindex="-1"></a>renderer(warped)<span class="op">;</span></span></code></pre></div>
</div>
<p><strong>Updating the right hand side and solution per time step</strong></p>
<p>To solve the variational problem at each time step, we must assemble the right-hand side and apply the boundary conditions before calling <code>solver.solve(b, uh.x.petsc_vec)</code>. We begin by resetting the values in <code>b</code>, since the vector is reused at every step. Next, we assemble the vector with <code>dolfinx.fem.petsc.assemble_vector(b, L)</code>, which inserts the linear form <code>L(v)</code> into <code>b</code></p>
<p>Note that boundary conditions are not supplied during this assembly, unlike for the left-hand side. Instead, we apply them later using lifting, which preserves the symmetry of the matrix in the bilinear form without Dirichlet conditions. After applying the boundary conditions, we solve the linear system and update any values that may be shared across processors. Finally, before advancing to the next step, we update the previous solution with the current one</p>
<div id="ecf3eb74" class="cell" data-execution_count="57">
<div class="sourceCode" id="cb64"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb64-1"><a href="#cb64-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_steps):</span>
<span id="cb64-2"><a href="#cb64-2" aria-hidden="true" tabindex="-1"></a>    t <span class="op">+=</span> dt</span>
<span id="cb64-3"><a href="#cb64-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-4"><a href="#cb64-4" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Update the right hand side reusing the initial vector</span></span>
<span id="cb64-5"><a href="#cb64-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> b.localForm() <span class="im">as</span> loc_b:</span>
<span id="cb64-6"><a href="#cb64-6" aria-hidden="true" tabindex="-1"></a>        loc_b.<span class="bu">set</span>(<span class="dv">0</span>)</span>
<span id="cb64-7"><a href="#cb64-7" aria-hidden="true" tabindex="-1"></a>    assemble_vector(b, linear_form)</span>
<span id="cb64-8"><a href="#cb64-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-9"><a href="#cb64-9" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply Dirichlet boundary condition to the vector</span></span>
<span id="cb64-10"><a href="#cb64-10" aria-hidden="true" tabindex="-1"></a>    apply_lifting(b, [bilinear_form], [[bc]])</span>
<span id="cb64-11"><a href="#cb64-11" aria-hidden="true" tabindex="-1"></a>    b.ghostUpdate(</span>
<span id="cb64-12"><a href="#cb64-12" aria-hidden="true" tabindex="-1"></a>      addv<span class="op">=</span>PETSc.InsertMode.ADD_VALUES, </span>
<span id="cb64-13"><a href="#cb64-13" aria-hidden="true" tabindex="-1"></a>      mode<span class="op">=</span>PETSc.ScatterMode.REVERSE</span>
<span id="cb64-14"><a href="#cb64-14" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb64-15"><a href="#cb64-15" aria-hidden="true" tabindex="-1"></a>    set_bc(b, [bc])</span>
<span id="cb64-16"><a href="#cb64-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-17"><a href="#cb64-17" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Solve linear problem</span></span>
<span id="cb64-18"><a href="#cb64-18" aria-hidden="true" tabindex="-1"></a>    solver.solve(b, uh.x.petsc_vec)</span>
<span id="cb64-19"><a href="#cb64-19" aria-hidden="true" tabindex="-1"></a>    uh.x.scatter_forward()</span>
<span id="cb64-20"><a href="#cb64-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-21"><a href="#cb64-21" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Update solution at previous time step (u_n)</span></span>
<span id="cb64-22"><a href="#cb64-22" aria-hidden="true" tabindex="-1"></a>    u_n.x.array[:] <span class="op">=</span> uh.x.array</span>
<span id="cb64-23"><a href="#cb64-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-24"><a href="#cb64-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Write solution to file</span></span>
<span id="cb64-25"><a href="#cb64-25" aria-hidden="true" tabindex="-1"></a>    xdmf.write_function(uh, t)</span>
<span id="cb64-26"><a href="#cb64-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-27"><a href="#cb64-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Update plot</span></span>
<span id="cb64-28"><a href="#cb64-28" aria-hidden="true" tabindex="-1"></a>    new_warped <span class="op">=</span> grid.warp_by_scalar(<span class="st">&quot;uh&quot;</span>, factor<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb64-29"><a href="#cb64-29" aria-hidden="true" tabindex="-1"></a>    warped.points[:, :] <span class="op">=</span> new_warped.points</span>
<span id="cb64-30"><a href="#cb64-30" aria-hidden="true" tabindex="-1"></a>    warped.point_data[<span class="st">&quot;uh&quot;</span>][:] <span class="op">=</span> uh.x.array</span>
<span id="cb64-31"><a href="#cb64-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb64-32"><a href="#cb64-32" aria-hidden="true" tabindex="-1"></a>    renderer(warped)</span>
<span id="cb64-33"><a href="#cb64-33" aria-hidden="true" tabindex="-1"></a>    plotter.write_frame()</span>
<span id="cb64-34"><a href="#cb64-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb64-35"><a href="#cb64-35" aria-hidden="true" tabindex="-1"></a>plotter.close()</span>
<span id="cb64-36"><a href="#cb64-36" aria-hidden="true" tabindex="-1"></a>xdmf.close()</span></code></pre></div>
</div>
<p><img src="fenicsx/heat/heat_animation.gif" class="img-fluid" /></p>
</section>
<section id="method-of-manufactured-solutions" class="level4" data-number="K.7.1.2">
<h4 data-number="K.7.1.2"><span class="header-section-number">K.7.1.2</span> Method of Manufactured Solutions</h4>
<p>Author: Jørgen S. Dokken</p>
<p>Just as in the Poisson problem, we construct a test case that makes it straightforward to verify the correctness of the computations</p>
<p>Since our first-order time-stepping scheme is exact for linear functions in time, we design a problem with linear temporal variation combined with quadratic spatial variation. Accordingly, we choose the analytical solution</p>
<p><span class="math display">\[\begin{aligned}
u = 1 + x^2+\alpha y^2 + \beta t
\end{aligned}\]</span></p>
<p>which ensures that the computed values at the degrees of freedom are exact, regardless of the mesh size or time step <span class="math inline">\(\Delta t\)</span>, provided that the mesh is uniformly partitioned</p>
<p>Substituting this expression into the original PDE yields the right hand side <span class="math inline">\(f = \beta -2 -2\alpha\)</span>. The corresponding boundary condition is <span class="math inline">\(u_D(x,y,t)= 1 +x^2 +\alpha y^2 +\beta t\)</span> and the initial condition is <span class="math inline">\(u_0(x,y)=1+x^2+\alpha y^2\)</span></p>
<p>We start by defining the temporal discretization parameters, along with the parameters for <span class="math inline">\(\alpha\)</span> and <span class="math inline">\(\beta\)</span></p>
<div id="901093e9" class="cell" data-execution_count="58">
<div class="sourceCode" id="cb65"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb65-1"><a href="#cb65-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb65-2"><a href="#cb65-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb65-3"><a href="#cb65-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> petsc4py <span class="im">import</span> PETSc</span>
<span id="cb65-4"><a href="#cb65-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-5"><a href="#cb65-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> mesh, fem</span>
<span id="cb65-6"><a href="#cb65-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> (</span>
<span id="cb65-7"><a href="#cb65-7" aria-hidden="true" tabindex="-1"></a>  assemble_matrix, assemble_vector, </span>
<span id="cb65-8"><a href="#cb65-8" aria-hidden="true" tabindex="-1"></a>  apply_lifting, create_vector, set_bc</span>
<span id="cb65-9"><a href="#cb65-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb65-10"><a href="#cb65-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-11"><a href="#cb65-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ufl</span>
<span id="cb65-12"><a href="#cb65-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-13"><a href="#cb65-13" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="dv">0</span>  <span class="co"># Start time</span></span>
<span id="cb65-14"><a href="#cb65-14" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">2</span>  <span class="co"># End time</span></span>
<span id="cb65-15"><a href="#cb65-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-16"><a href="#cb65-16" aria-hidden="true" tabindex="-1"></a>num_steps <span class="op">=</span> <span class="dv">20</span>          <span class="co"># Number of time steps</span></span>
<span id="cb65-17"><a href="#cb65-17" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> (T <span class="op">-</span>t) <span class="op">/</span>num_steps  <span class="co"># Time step size</span></span>
<span id="cb65-18"><a href="#cb65-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb65-19"><a href="#cb65-19" aria-hidden="true" tabindex="-1"></a>alpha <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb65-20"><a href="#cb65-20" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> <span class="fl">1.2</span></span></code></pre></div>
</div>
<p>As in the previous problem, we define the mesh and the appropriate function spaces</p>
<div id="7253e3ec" class="cell" data-execution_count="59">
<div class="sourceCode" id="cb66"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb66-1"><a href="#cb66-1" aria-hidden="true" tabindex="-1"></a>nx, ny <span class="op">=</span> <span class="dv">5</span>, <span class="dv">5</span></span>
<span id="cb66-2"><a href="#cb66-2" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> mesh.create_unit_square(</span>
<span id="cb66-3"><a href="#cb66-3" aria-hidden="true" tabindex="-1"></a>  MPI.COMM_WORLD, </span>
<span id="cb66-4"><a href="#cb66-4" aria-hidden="true" tabindex="-1"></a>  nx, ny, </span>
<span id="cb66-5"><a href="#cb66-5" aria-hidden="true" tabindex="-1"></a>  mesh.CellType.triangle</span>
<span id="cb66-6"><a href="#cb66-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb66-7"><a href="#cb66-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb66-8"><a href="#cb66-8" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span></code></pre></div>
</div>
<p><strong>Defining the exact solution</strong></p>
<p>We implement a Python class to represent the exact solution</p>
<div id="0daae525" class="cell" data-execution_count="60">
<div class="sourceCode" id="cb67"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb67-1"><a href="#cb67-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> exact_solution():</span>
<span id="cb67-2"><a href="#cb67-2" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, alpha, beta, t):</span>
<span id="cb67-3"><a href="#cb67-3" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.alpha <span class="op">=</span> alpha</span>
<span id="cb67-4"><a href="#cb67-4" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.beta <span class="op">=</span> beta</span>
<span id="cb67-5"><a href="#cb67-5" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.t <span class="op">=</span> t</span>
<span id="cb67-6"><a href="#cb67-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-7"><a href="#cb67-7" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb67-8"><a href="#cb67-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span>x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span><span class="va">self</span>.alpha <span class="op">*</span>x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span><span class="va">self</span>.beta <span class="op">*</span><span class="va">self</span>.t</span>
<span id="cb67-9"><a href="#cb67-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb67-10"><a href="#cb67-10" aria-hidden="true" tabindex="-1"></a>u_exact <span class="op">=</span> exact_solution(alpha, beta, t)</span></code></pre></div>
</div>
<p><strong>Defining the boundary condition</strong></p>
<p>As in the previous sections, we define a Dirichlet boundary condition over the whole boundary</p>
<div id="0b00b475" class="cell" data-execution_count="61">
<div class="sourceCode" id="cb68"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb68-1"><a href="#cb68-1" aria-hidden="true" tabindex="-1"></a>u_D <span class="op">=</span> fem.Function(V)</span>
<span id="cb68-2"><a href="#cb68-2" aria-hidden="true" tabindex="-1"></a>u_D.interpolate(u_exact)</span>
<span id="cb68-3"><a href="#cb68-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-4"><a href="#cb68-4" aria-hidden="true" tabindex="-1"></a>tdim <span class="op">=</span> domain.topology.dim</span>
<span id="cb68-5"><a href="#cb68-5" aria-hidden="true" tabindex="-1"></a>fdim <span class="op">=</span> tdim <span class="op">-</span><span class="dv">1</span></span>
<span id="cb68-6"><a href="#cb68-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-7"><a href="#cb68-7" aria-hidden="true" tabindex="-1"></a>domain.topology.create_connectivity(fdim, tdim)</span>
<span id="cb68-8"><a href="#cb68-8" aria-hidden="true" tabindex="-1"></a>boundary_facets <span class="op">=</span> mesh.exterior_facet_indices(domain.topology)</span>
<span id="cb68-9"><a href="#cb68-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb68-10"><a href="#cb68-10" aria-hidden="true" tabindex="-1"></a>bc <span class="op">=</span> fem.dirichletbc(</span>
<span id="cb68-11"><a href="#cb68-11" aria-hidden="true" tabindex="-1"></a>  u_D, </span>
<span id="cb68-12"><a href="#cb68-12" aria-hidden="true" tabindex="-1"></a>  fem.locate_dofs_topological(V, fdim, boundary_facets)</span>
<span id="cb68-13"><a href="#cb68-13" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img src="figures/fenicsx_mesh_conectivity.png" class="img-fluid" style="width:70.0%" /></p>
<figcaption>FEniCSx mesh connectivity</figcaption>
</figure>
</div>
<p><strong>Defining the variational formualation</strong></p>
<p>Since we set <span class="math inline">\(t=0\)</span> in <code>u_exact</code>, we can reuse this variable to obtain <span class="math inline">\(u_n\)</span> for the first time step</p>
<div id="d5a9061c" class="cell" data-execution_count="62">
<div class="sourceCode" id="cb69"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb69-1"><a href="#cb69-1" aria-hidden="true" tabindex="-1"></a>u_n <span class="op">=</span> fem.Function(V)</span>
<span id="cb69-2"><a href="#cb69-2" aria-hidden="true" tabindex="-1"></a>u_n.interpolate(u_exact)</span></code></pre></div>
</div>
<p>Because <span class="math inline">\(f\)</span> is time-independent, we can treat it as a constant</p>
<div id="319c0a9b" class="cell" data-execution_count="63">
<div class="sourceCode" id="cb70"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb70-1"><a href="#cb70-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> fem.Constant(domain, beta <span class="op">-</span><span class="dv">2</span> <span class="op">-</span><span class="dv">2</span> <span class="op">*</span>alpha)</span></code></pre></div>
</div>
<p>We can now create our variational formulation, with the bilinear form <code>a</code> and linear form <code>L</code></p>
<div id="6f74a32e" class="cell" data-execution_count="64">
<div class="sourceCode" id="cb71"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb71-1"><a href="#cb71-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> ufl.TrialFunction(V)</span>
<span id="cb71-2"><a href="#cb71-2" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> ufl.TestFunction(V)</span>
<span id="cb71-3"><a href="#cb71-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-4"><a href="#cb71-4" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> u <span class="op">*</span>v <span class="op">*</span>ufl.dx <span class="op">+</span>dt <span class="op">*</span>ufl.dot(ufl.grad(u), ufl.grad(v)) <span class="op">*</span>ufl.dx <span class="op">-</span>(u_n <span class="op">+</span>dt <span class="op">*</span>f) <span class="op">*</span>v <span class="op">*</span>ufl.dx</span>
<span id="cb71-5"><a href="#cb71-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb71-6"><a href="#cb71-6" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> fem.form(ufl.lhs(F))</span>
<span id="cb71-7"><a href="#cb71-7" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> fem.form(ufl.rhs(F))</span></code></pre></div>
</div>
<p><strong>Create the matrix and vector for the linear problem</strong></p>
<p>To ensure that the variational problem is solved efficiently, we construct several structures that allow data reuse, such as matrix sparisty patterns. In particular, since the bilinear form <code>a</code> is independent of time, the matrix only needs to be assembled once</p>
<div id="94285b56" class="cell" data-execution_count="65">
<div class="sourceCode" id="cb72"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb72-1"><a href="#cb72-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> assemble_matrix(a, bcs<span class="op">=</span>[bc])</span>
<span id="cb72-2"><a href="#cb72-2" aria-hidden="true" tabindex="-1"></a>A.assemble()</span>
<span id="cb72-3"><a href="#cb72-3" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> create_vector(L)</span>
<span id="cb72-4"><a href="#cb72-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb72-5"><a href="#cb72-5" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> fem.Function(V)</span></code></pre></div>
</div>
<p><strong>Define a linear variational solver</strong></p>
<p>The resulting linear algebra problem is solved with <a href="https://www.mcs.anl.gov/petsc/">PETSc</a>, using the Python API <code>petsc4py</code> to define a linear solver</p>
<div id="71f34caa" class="cell" data-execution_count="66">
<div class="sourceCode" id="cb73"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb73-1"><a href="#cb73-1" aria-hidden="true" tabindex="-1"></a>solver <span class="op">=</span> PETSc.KSP().create(domain.comm)</span>
<span id="cb73-2"><a href="#cb73-2" aria-hidden="true" tabindex="-1"></a>solver.setOperators(A)</span>
<span id="cb73-3"><a href="#cb73-3" aria-hidden="true" tabindex="-1"></a>solver.setType(PETSc.KSP.Type.PREONLY)</span>
<span id="cb73-4"><a href="#cb73-4" aria-hidden="true" tabindex="-1"></a>solver.getPC().setType(PETSc.PC.Type.LU)</span></code></pre></div>
</div>
<p><strong>Solving the time-dependent problem</strong></p>
<p>With these structures in place, we construct our time-stepping loop. Within this loop, we first update the Dirichlet boundary condition by interpolating the updated expression <code>u_exact</code> into <code>V</code>. Next, we reassemble the vector <code>b</code> using the current solution <code>u_n</code>. The boundary condition is then applied to this vector via a lifting operation, which preserves the symmetry of the matrix. Finally, we solve the problem using <code>PETSc</code> and update <code>u_n</code> with the values from <code>uh</code></p>
<div id="d664d2e0" class="cell" data-execution_count="67">
<div class="sourceCode" id="cb74"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb74-1"><a href="#cb74-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(num_steps):</span>
<span id="cb74-2"><a href="#cb74-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-3"><a href="#cb74-3" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Update Diriclet boundary condition</span></span>
<span id="cb74-4"><a href="#cb74-4" aria-hidden="true" tabindex="-1"></a>    u_exact.t <span class="op">+=</span> dt</span>
<span id="cb74-5"><a href="#cb74-5" aria-hidden="true" tabindex="-1"></a>    u_D.interpolate(u_exact)</span>
<span id="cb74-6"><a href="#cb74-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-7"><a href="#cb74-7" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Update the right hand side reusing the initial vector</span></span>
<span id="cb74-8"><a href="#cb74-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> b.localForm() <span class="im">as</span> loc_b:</span>
<span id="cb74-9"><a href="#cb74-9" aria-hidden="true" tabindex="-1"></a>        loc_b.<span class="bu">set</span>(<span class="dv">0</span>)</span>
<span id="cb74-10"><a href="#cb74-10" aria-hidden="true" tabindex="-1"></a>    assemble_vector(b, L)</span>
<span id="cb74-11"><a href="#cb74-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-12"><a href="#cb74-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply Dirichlet boundary condition to the vector</span></span>
<span id="cb74-13"><a href="#cb74-13" aria-hidden="true" tabindex="-1"></a>    apply_lifting(b, [a], [[bc]])</span>
<span id="cb74-14"><a href="#cb74-14" aria-hidden="true" tabindex="-1"></a>    b.ghostUpdate(</span>
<span id="cb74-15"><a href="#cb74-15" aria-hidden="true" tabindex="-1"></a>      addv<span class="op">=</span>PETSc.InsertMode.ADD_VALUES, </span>
<span id="cb74-16"><a href="#cb74-16" aria-hidden="true" tabindex="-1"></a>      mode<span class="op">=</span>PETSc.ScatterMode.REVERSE</span>
<span id="cb74-17"><a href="#cb74-17" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb74-18"><a href="#cb74-18" aria-hidden="true" tabindex="-1"></a>    set_bc(b, [bc])</span>
<span id="cb74-19"><a href="#cb74-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-20"><a href="#cb74-20" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Solve linear problem</span></span>
<span id="cb74-21"><a href="#cb74-21" aria-hidden="true" tabindex="-1"></a>    solver.solve(b, uh.x.petsc_vec)</span>
<span id="cb74-22"><a href="#cb74-22" aria-hidden="true" tabindex="-1"></a>    uh.x.scatter_forward()</span>
<span id="cb74-23"><a href="#cb74-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb74-24"><a href="#cb74-24" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Update solution at previous time step (u_n)</span></span>
<span id="cb74-25"><a href="#cb74-25" aria-hidden="true" tabindex="-1"></a>    u_n.x.array[:] <span class="op">=</span> uh.x.array</span></code></pre></div>
</div>
<p><strong>Verifying the numerical solution</strong></p>
<p>We compute the <span class="math inline">\(L^2\)</span>-error and the maximum error at the mesh vertices for the final time step. This allows us to verify the correctness of our implementation</p>
<div id="d5b33ad9" class="cell" data-execution_count="68">
<div class="sourceCode" id="cb75"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb75-1"><a href="#cb75-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute L2 error and error at nodes</span></span>
<span id="cb75-2"><a href="#cb75-2" aria-hidden="true" tabindex="-1"></a>V_ex <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">2</span>))</span>
<span id="cb75-3"><a href="#cb75-3" aria-hidden="true" tabindex="-1"></a>u_ex <span class="op">=</span> fem.Function(V_ex)</span>
<span id="cb75-4"><a href="#cb75-4" aria-hidden="true" tabindex="-1"></a>u_ex.interpolate(u_exact)</span>
<span id="cb75-5"><a href="#cb75-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-6"><a href="#cb75-6" aria-hidden="true" tabindex="-1"></a>error_L2 <span class="op">=</span> np.sqrt(</span>
<span id="cb75-7"><a href="#cb75-7" aria-hidden="true" tabindex="-1"></a>  domain.comm.allreduce(</span>
<span id="cb75-8"><a href="#cb75-8" aria-hidden="true" tabindex="-1"></a>    fem.assemble_scalar(fem.form((uh <span class="op">-</span>u_ex)<span class="op">**</span><span class="dv">2</span> <span class="op">*</span>ufl.dx)), </span>
<span id="cb75-9"><a href="#cb75-9" aria-hidden="true" tabindex="-1"></a>      op<span class="op">=</span>MPI.SUM)</span>
<span id="cb75-10"><a href="#cb75-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb75-11"><a href="#cb75-11" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> domain.comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb75-12"><a href="#cb75-12" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Error_L2: </span><span class="sc">{</span>error_L2<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span>
<span id="cb75-13"><a href="#cb75-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb75-14"><a href="#cb75-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute values at mesh vertices</span></span>
<span id="cb75-15"><a href="#cb75-15" aria-hidden="true" tabindex="-1"></a>error_max <span class="op">=</span> domain.comm.allreduce(</span>
<span id="cb75-16"><a href="#cb75-16" aria-hidden="true" tabindex="-1"></a>  np.<span class="bu">max</span>(np.<span class="bu">abs</span>(uh.x.array <span class="op">-</span>u_D.x.array)), op<span class="op">=</span>MPI.MAX</span>
<span id="cb75-17"><a href="#cb75-17" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb75-18"><a href="#cb75-18" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> domain.comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb75-19"><a href="#cb75-19" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Error_max: </span><span class="sc">{</span>error_max<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Error_L2: 2.83e-02
Error_max: 1.78e-15</code></pre>
</div>
</div>
</section>
</section>
<section id="singular-poisson-problem" class="level3" data-number="K.7.2">
<h3 data-number="K.7.2"><span class="header-section-number">K.7.2</span> Singular Poisson problem</h3>
<p>Author: Jørgen S. Dokken</p>
<p>In this example, we solve the singular Poisson problem by incorporating information about the nullspace of the discretized system into the matrix formulation</p>
<p>The problem is defined as</p>
<p><span class="math display">\[\begin{aligned}
   -\Delta u &amp;= f &amp;&amp;\text{in } \Omega\\
   -\nabla u \cdot \mathbf{n} &amp;= g &amp;&amp;\text{on } \partial\Omega
\end{aligned}\]</span></p>
<p>This problem possesses a nullspace: if <span class="math inline">\(\tilde u\)</span> is a solution, then for any constant <span class="math inline">\(c\)</span>, <span class="math inline">\(u_c = \tilde u + c\)</span> is also a solution</p>
<p>To investigate this problem, we consider a manufactured solution on the unit square, given by</p>
<p><span class="math display">\[\begin{aligned}
u(x, y) &amp;= \sin(2\pi x)\\
f(x, y) &amp;= -4\pi^2\sin(2\pi x)\\
g(x, y) &amp;=
\begin{cases}
   -2\pi  &amp; \text{if } x=0,\\
   \phantom{-}2\pi &amp; \text{if } x=1,\\
   \phantom{-}0 &amp; \text{otherwise}
\end{cases}
\end{aligned}\]</span></p>
<p>Here we define a simple wrapper function to set up the variational problem for a given manufactured solution</p>
<div id="174dd32b" class="cell" data-execution_count="69">
<div class="sourceCode" id="cb77"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb77-1"><a href="#cb77-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> typing</span>
<span id="cb77-2"><a href="#cb77-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb77-3"><a href="#cb77-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-4"><a href="#cb77-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb77-5"><a href="#cb77-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-6"><a href="#cb77-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> fem, mesh</span>
<span id="cb77-7"><a href="#cb77-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dolfinx.fem.petsc</span>
<span id="cb77-8"><a href="#cb77-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ufl</span>
<span id="cb77-9"><a href="#cb77-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-10"><a href="#cb77-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> u_ex(mod, x):</span>
<span id="cb77-11"><a href="#cb77-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> mod.sin(<span class="dv">2</span> <span class="op">*</span>mod.pi <span class="op">*</span>x[<span class="dv">0</span>])</span>
<span id="cb77-12"><a href="#cb77-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-13"><a href="#cb77-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> setup_problem(N: <span class="bu">int</span>) <span class="op">\</span></span>
<span id="cb77-14"><a href="#cb77-14" aria-hidden="true" tabindex="-1"></a>  <span class="op">-&gt;</span> typing.Tuple[fem.FunctionSpace, fem.Form, fem.Form]:</span>
<span id="cb77-15"><a href="#cb77-15" aria-hidden="true" tabindex="-1"></a>  <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb77-16"><a href="#cb77-16" aria-hidden="true" tabindex="-1"></a><span class="co">  Set up bilinear and linear form of </span></span>
<span id="cb77-17"><a href="#cb77-17" aria-hidden="true" tabindex="-1"></a><span class="co">    the singular Poisson problem</span></span>
<span id="cb77-18"><a href="#cb77-18" aria-hidden="true" tabindex="-1"></a><span class="co">  Args: </span></span>
<span id="cb77-19"><a href="#cb77-19" aria-hidden="true" tabindex="-1"></a><span class="co">    N, number of elements in each direction of the mesh   </span></span>
<span id="cb77-20"><a href="#cb77-20" aria-hidden="true" tabindex="-1"></a><span class="co">  Returns:</span></span>
<span id="cb77-21"><a href="#cb77-21" aria-hidden="true" tabindex="-1"></a><span class="co">    The function space, the bilinear form </span></span>
<span id="cb77-22"><a href="#cb77-22" aria-hidden="true" tabindex="-1"></a><span class="co">      and the linear form of the problem</span></span>
<span id="cb77-23"><a href="#cb77-23" aria-hidden="true" tabindex="-1"></a><span class="co">  &quot;&quot;&quot;</span></span>
<span id="cb77-24"><a href="#cb77-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-25"><a href="#cb77-25" aria-hidden="true" tabindex="-1"></a>  domain <span class="op">=</span> dolfinx.mesh.create_unit_square(</span>
<span id="cb77-26"><a href="#cb77-26" aria-hidden="true" tabindex="-1"></a>    MPI.COMM_WORLD, </span>
<span id="cb77-27"><a href="#cb77-27" aria-hidden="true" tabindex="-1"></a>    N, N, </span>
<span id="cb77-28"><a href="#cb77-28" aria-hidden="true" tabindex="-1"></a>    cell_type<span class="op">=</span>mesh.CellType.quadrilateral</span>
<span id="cb77-29"><a href="#cb77-29" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb77-30"><a href="#cb77-30" aria-hidden="true" tabindex="-1"></a>  V <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span>
<span id="cb77-31"><a href="#cb77-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb77-32"><a href="#cb77-32" aria-hidden="true" tabindex="-1"></a>  u <span class="op">=</span> ufl.TrialFunction(V)</span>
<span id="cb77-33"><a href="#cb77-33" aria-hidden="true" tabindex="-1"></a>  v <span class="op">=</span> ufl.TestFunction(V)</span>
<span id="cb77-34"><a href="#cb77-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-35"><a href="#cb77-35" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> ufl.SpatialCoordinate(domain)</span>
<span id="cb77-36"><a href="#cb77-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-37"><a href="#cb77-37" aria-hidden="true" tabindex="-1"></a>  u_exact <span class="op">=</span> u_ex(ufl, x)</span>
<span id="cb77-38"><a href="#cb77-38" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb77-39"><a href="#cb77-39" aria-hidden="true" tabindex="-1"></a>  f <span class="op">=</span> <span class="op">-</span>ufl.div(ufl.grad(u_exact))</span>
<span id="cb77-40"><a href="#cb77-40" aria-hidden="true" tabindex="-1"></a>  n <span class="op">=</span> ufl.FacetNormal(domain)</span>
<span id="cb77-41"><a href="#cb77-41" aria-hidden="true" tabindex="-1"></a>  g <span class="op">=</span> <span class="op">-</span>ufl.dot(ufl.grad(u_exact), n)</span>
<span id="cb77-42"><a href="#cb77-42" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-43"><a href="#cb77-43" aria-hidden="true" tabindex="-1"></a>  F <span class="op">=</span> ufl.dot(ufl.grad(u), ufl.grad(v)) <span class="op">*</span>ufl.dx</span>
<span id="cb77-44"><a href="#cb77-44" aria-hidden="true" tabindex="-1"></a>  F <span class="op">+=</span> ufl.inner(g, v) <span class="op">*</span>ufl.ds</span>
<span id="cb77-45"><a href="#cb77-45" aria-hidden="true" tabindex="-1"></a>  F <span class="op">-=</span> f <span class="op">*</span>v <span class="op">*</span>ufl.dx</span>
<span id="cb77-46"><a href="#cb77-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb77-47"><a href="#cb77-47" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> V, <span class="op">*</span>fem.form(ufl.system(F))</span></code></pre></div>
</div>
<p>Using the convenience function defined above, we can now handle the nullspace. To do this, we employ <code>PETSc</code>, attaching additional information to the assembled matrices. Here, we make use of <code>PETSc</code>’s built-in function for creating constant nullspaces</p>
<div id="0062cb8d" class="cell" data-execution_count="70">
<div class="sourceCode" id="cb78"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb78-1"><a href="#cb78-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> petsc4py <span class="im">import</span> PETSc</span>
<span id="cb78-2"><a href="#cb78-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb78-3"><a href="#cb78-3" aria-hidden="true" tabindex="-1"></a>nullspace <span class="op">=</span> PETSc.NullSpace().create(</span>
<span id="cb78-4"><a href="#cb78-4" aria-hidden="true" tabindex="-1"></a>  constant<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb78-5"><a href="#cb78-5" aria-hidden="true" tabindex="-1"></a>  comm<span class="op">=</span>MPI.COMM_WORLD</span>
<span id="cb78-6"><a href="#cb78-6" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
<p><strong>Direct solver</strong></p>
<p>We begin by solving the singular problem using a direct solver (<code>MUMPS</code>). <code>MUMPS</code> provides additional options to handle singular matrices, which we utilize here</p>
<div id="143be3e6" class="cell" data-execution_count="71">
<div class="sourceCode" id="cb79"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb79-1"><a href="#cb79-1" aria-hidden="true" tabindex="-1"></a>petsc_options <span class="op">=</span> {</span>
<span id="cb79-2"><a href="#cb79-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;ksp_error_if_not_converged&quot;</span>: <span class="va">True</span>,</span>
<span id="cb79-3"><a href="#cb79-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;preonly&quot;</span>,</span>
<span id="cb79-4"><a href="#cb79-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;lu&quot;</span>,</span>
<span id="cb79-5"><a href="#cb79-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;pc_factor_mat_solver_type&quot;</span>: <span class="st">&quot;mumps&quot;</span>,</span>
<span id="cb79-6"><a href="#cb79-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;ksp_monitor&quot;</span>: <span class="va">None</span>,</span>
<span id="cb79-7"><a href="#cb79-7" aria-hidden="true" tabindex="-1"></a>}</span></code></pre></div>
</div>
<p>Next, we configure the KSP solver</p>
<div id="e29deb78" class="cell" data-execution_count="72">
<div class="sourceCode" id="cb80"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb80-1"><a href="#cb80-1" aria-hidden="true" tabindex="-1"></a>ksp <span class="op">=</span> PETSc.KSP().create(MPI.COMM_WORLD)</span>
<span id="cb80-2"><a href="#cb80-2" aria-hidden="true" tabindex="-1"></a>ksp.setOptionsPrefix(<span class="st">&quot;singular_direct&quot;</span>)</span>
<span id="cb80-3"><a href="#cb80-3" aria-hidden="true" tabindex="-1"></a>opts <span class="op">=</span> PETSc.Options()</span>
<span id="cb80-4"><a href="#cb80-4" aria-hidden="true" tabindex="-1"></a>opts.prefixPush(ksp.getOptionsPrefix())</span>
<span id="cb80-5"><a href="#cb80-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-6"><a href="#cb80-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key, value <span class="kw">in</span> petsc_options.items():</span>
<span id="cb80-7"><a href="#cb80-7" aria-hidden="true" tabindex="-1"></a>  opts[key] <span class="op">=</span> value</span>
<span id="cb80-8"><a href="#cb80-8" aria-hidden="true" tabindex="-1"></a>ksp.setFromOptions()</span>
<span id="cb80-9"><a href="#cb80-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb80-10"><a href="#cb80-10" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key, value <span class="kw">in</span> petsc_options.items():</span>
<span id="cb80-11"><a href="#cb80-11" aria-hidden="true" tabindex="-1"></a>  <span class="kw">del</span> opts[key]</span>
<span id="cb80-12"><a href="#cb80-12" aria-hidden="true" tabindex="-1"></a>opts.prefixPop()</span></code></pre></div>
</div>
<p>We then assemble the bilinear and linear forms and construct the matrix <code>A</code> and the right-hand side vector <code>b</code></p>
<div id="c5a8d185" class="cell" data-execution_count="73">
<div class="sourceCode" id="cb81"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb81-1"><a href="#cb81-1" aria-hidden="true" tabindex="-1"></a>V, a, L <span class="op">=</span> setup_problem(<span class="dv">40</span>)</span>
<span id="cb81-2"><a href="#cb81-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb81-3"><a href="#cb81-3" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> fem.petsc.assemble_matrix(a)</span>
<span id="cb81-4"><a href="#cb81-4" aria-hidden="true" tabindex="-1"></a>A.assemble()</span>
<span id="cb81-5"><a href="#cb81-5" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> fem.petsc.assemble_vector(L)</span>
<span id="cb81-6"><a href="#cb81-6" aria-hidden="true" tabindex="-1"></a>b.ghostUpdate(</span>
<span id="cb81-7"><a href="#cb81-7" aria-hidden="true" tabindex="-1"></a>  addv<span class="op">=</span>PETSc.InsertMode.ADD_VALUES, </span>
<span id="cb81-8"><a href="#cb81-8" aria-hidden="true" tabindex="-1"></a>  mode<span class="op">=</span>PETSc.ScatterMode.REVERSE</span>
<span id="cb81-9"><a href="#cb81-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb81-10"><a href="#cb81-10" aria-hidden="true" tabindex="-1"></a>ksp.setOperators(A)</span></code></pre></div>
</div>
<p>We begin by verifying that this is indeed the nullspace of <code>A</code>, after which we attach it to the matrix</p>
<div id="e6806195" class="cell" data-execution_count="74">
<div class="sourceCode" id="cb82"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb82-1"><a href="#cb82-1" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> nullspace.test(A)</span>
<span id="cb82-2"><a href="#cb82-2" aria-hidden="true" tabindex="-1"></a>A.setNullSpace(nullspace)</span></code></pre></div>
</div>
<p>We can then solve the linear system of equations</p>
<div id="9b86646e" class="cell" data-execution_count="75">
<div class="sourceCode" id="cb83"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb83-1"><a href="#cb83-1" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> fem.Function(V)</span>
<span id="cb83-2"><a href="#cb83-2" aria-hidden="true" tabindex="-1"></a>ksp.solve(b, uh.x.petsc_vec)</span>
<span id="cb83-3"><a href="#cb83-3" aria-hidden="true" tabindex="-1"></a>uh.x.scatter_forward()</span>
<span id="cb83-4"><a href="#cb83-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb83-5"><a href="#cb83-5" aria-hidden="true" tabindex="-1"></a>ksp.destroy()</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  Residual norms for singular_direct solve.
  0 KSP Residual norm 1.553142231547e+00
  1 KSP Residual norm 1.561504727766e-14</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="75">
<pre><code>&lt;petsc4py.PETSc.KSP at 0x30e5be160&gt;</code></pre>
</div>
</div>
<p>The <span class="math inline">\(L^2\)</span>-error can now be evaluated against the analytical solution</p>
<div id="ca73663c" class="cell" data-execution_count="76">
<div class="sourceCode" id="cb86"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb86-1"><a href="#cb86-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compute_L2_error(uh: fem.Function) <span class="op">-&gt;</span> <span class="bu">float</span>:</span>
<span id="cb86-2"><a href="#cb86-2" aria-hidden="true" tabindex="-1"></a>  mesh <span class="op">=</span> uh.function_space.mesh</span>
<span id="cb86-3"><a href="#cb86-3" aria-hidden="true" tabindex="-1"></a>  u_exact <span class="op">=</span> u_ex(ufl, ufl.SpatialCoordinate(mesh))</span>
<span id="cb86-4"><a href="#cb86-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb86-5"><a href="#cb86-5" aria-hidden="true" tabindex="-1"></a>  error_L2 <span class="op">=</span> fem.form(</span>
<span id="cb86-6"><a href="#cb86-6" aria-hidden="true" tabindex="-1"></a>    ufl.inner(uh <span class="op">-</span>u_exact, uh <span class="op">-</span>u_exact) <span class="op">*</span>ufl.dx</span>
<span id="cb86-7"><a href="#cb86-7" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb86-8"><a href="#cb86-8" aria-hidden="true" tabindex="-1"></a>  error_local <span class="op">=</span> fem.assemble_scalar(error_L2)</span>
<span id="cb86-9"><a href="#cb86-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> np.sqrt(</span>
<span id="cb86-10"><a href="#cb86-10" aria-hidden="true" tabindex="-1"></a>    mesh.comm.allreduce(error_local, op<span class="op">=</span>MPI.SUM)</span>
<span id="cb86-11"><a href="#cb86-11" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb86-12"><a href="#cb86-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb86-13"><a href="#cb86-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Direct solver L2 error: &quot;</span></span>
<span id="cb86-14"><a href="#cb86-14" aria-hidden="true" tabindex="-1"></a>     <span class="ss">f&quot;</span><span class="sc">{</span>compute_L2_error(uh)<span class="sc">:.5e}</span><span class="ss">&quot;</span>)    </span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Direct solver L2 error: 1.59184e-03</code></pre>
</div>
</div>
<p>We additionally confirm that the solution’s mean value coincides with that of the manufactured solution</p>
<div id="a301e728" class="cell" data-execution_count="77">
<div class="sourceCode" id="cb88"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb88-1"><a href="#cb88-1" aria-hidden="true" tabindex="-1"></a>u_exact <span class="op">=</span> u_ex(ufl, ufl.SpatialCoordinate(V.mesh))</span>
<span id="cb88-2"><a href="#cb88-2" aria-hidden="true" tabindex="-1"></a>ex_mean <span class="op">=</span> V.mesh.comm.allreduce(</span>
<span id="cb88-3"><a href="#cb88-3" aria-hidden="true" tabindex="-1"></a>  fem.assemble_scalar(fem.form(u_exact <span class="op">*</span>ufl.dx)), </span>
<span id="cb88-4"><a href="#cb88-4" aria-hidden="true" tabindex="-1"></a>  op<span class="op">=</span>MPI.SUM</span>
<span id="cb88-5"><a href="#cb88-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb88-6"><a href="#cb88-6" aria-hidden="true" tabindex="-1"></a>approx_mean <span class="op">=</span> V.mesh.comm.allreduce(</span>
<span id="cb88-7"><a href="#cb88-7" aria-hidden="true" tabindex="-1"></a>  fem.assemble_scalar(fem.form(uh <span class="op">*</span>ufl.dx)), </span>
<span id="cb88-8"><a href="#cb88-8" aria-hidden="true" tabindex="-1"></a>  op<span class="op">=</span>MPI.SUM</span>
<span id="cb88-9"><a href="#cb88-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb88-10"><a href="#cb88-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-11"><a href="#cb88-11" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Mean value of manufactured solution: &quot;</span></span>
<span id="cb88-12"><a href="#cb88-12" aria-hidden="true" tabindex="-1"></a>     <span class="ss">f&quot;</span><span class="sc">{</span>ex_mean<span class="sc">:.5e}</span><span class="ss">&quot;</span>)</span>
<span id="cb88-13"><a href="#cb88-13" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Mean value of computed solution (direct solver): &quot;</span></span>
<span id="cb88-14"><a href="#cb88-14" aria-hidden="true" tabindex="-1"></a>     <span class="ss">f&quot;</span><span class="sc">{</span>approx_mean<span class="sc">:.5e}</span><span class="ss">&quot;</span>)</span>
<span id="cb88-15"><a href="#cb88-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb88-16"><a href="#cb88-16" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> np.isclose(ex_mean, approx_mean), <span class="st">&quot;Mean values do not match!&quot;</span></span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Mean value of manufactured solution: -1.17019e-15
Mean value of computed solution (direct solver): 1.53906e-15</code></pre>
</div>
</div>
<p><strong>Iterative solver</strong></p>
<p>We can also solve the problem using an iterative solver, such as <code>GMRES</code> with <code>AMG</code> preconditioning. To do this, we select a new set of <code>PETSc</code> options and create a new <code>KSP</code> solver</p>
<div id="409449e4" class="cell" data-execution_count="78">
<div class="sourceCode" id="cb90"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb90-1"><a href="#cb90-1" aria-hidden="true" tabindex="-1"></a>ksp_iterative <span class="op">=</span> PETSc.KSP().create(MPI.COMM_WORLD)</span>
<span id="cb90-2"><a href="#cb90-2" aria-hidden="true" tabindex="-1"></a>ksp_iterative.setOptionsPrefix(<span class="st">&quot;singular_iterative&quot;</span>)</span>
<span id="cb90-3"><a href="#cb90-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-4"><a href="#cb90-4" aria-hidden="true" tabindex="-1"></a>petsc_options_iterative <span class="op">=</span> {</span>
<span id="cb90-5"><a href="#cb90-5" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;ksp_error_if_not_converged&quot;</span>: <span class="va">True</span>,</span>
<span id="cb90-6"><a href="#cb90-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;ksp_monitor&quot;</span>: <span class="va">None</span>,</span>
<span id="cb90-7"><a href="#cb90-7" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;gmres&quot;</span>,</span>
<span id="cb90-8"><a href="#cb90-8" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;hypre&quot;</span>,</span>
<span id="cb90-9"><a href="#cb90-9" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;pc_hypre_type&quot;</span>: <span class="st">&quot;boomeramg&quot;</span>,</span>
<span id="cb90-10"><a href="#cb90-10" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;pc_hypre_boomeramg_max_iter&quot;</span>: <span class="dv">1</span>,</span>
<span id="cb90-11"><a href="#cb90-11" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;pc_hypre_boomeramg_cycle_type&quot;</span>: <span class="st">&quot;v&quot;</span>,</span>
<span id="cb90-12"><a href="#cb90-12" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;ksp_rtol&quot;</span>: <span class="fl">1.0e-13</span>,</span>
<span id="cb90-13"><a href="#cb90-13" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb90-14"><a href="#cb90-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-15"><a href="#cb90-15" aria-hidden="true" tabindex="-1"></a>opts.prefixPush(ksp_iterative.getOptionsPrefix())</span>
<span id="cb90-16"><a href="#cb90-16" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key, value <span class="kw">in</span> petsc_options_iterative.items():</span>
<span id="cb90-17"><a href="#cb90-17" aria-hidden="true" tabindex="-1"></a>  opts[key] <span class="op">=</span> value</span>
<span id="cb90-18"><a href="#cb90-18" aria-hidden="true" tabindex="-1"></a>ksp_iterative.setFromOptions()</span>
<span id="cb90-19"><a href="#cb90-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb90-20"><a href="#cb90-20" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> key, value <span class="kw">in</span> petsc_options_iterative.items():</span>
<span id="cb90-21"><a href="#cb90-21" aria-hidden="true" tabindex="-1"></a>  <span class="kw">del</span> opts[key]</span>
<span id="cb90-22"><a href="#cb90-22" aria-hidden="true" tabindex="-1"></a>opts.prefixPop()</span></code></pre></div>
</div>
<p>Rather than defining the nullspace explicitly, we provide it as a near-nullspace to the multigrid preconditioner</p>
<div id="6be47b21" class="cell" data-execution_count="79">
<div class="sourceCode" id="cb91"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb91-1"><a href="#cb91-1" aria-hidden="true" tabindex="-1"></a>A_iterative <span class="op">=</span> fem.petsc.assemble_matrix(a)</span>
<span id="cb91-2"><a href="#cb91-2" aria-hidden="true" tabindex="-1"></a>A_iterative.assemble()</span>
<span id="cb91-3"><a href="#cb91-3" aria-hidden="true" tabindex="-1"></a>A_iterative.setNearNullSpace(nullspace)</span>
<span id="cb91-4"><a href="#cb91-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb91-5"><a href="#cb91-5" aria-hidden="true" tabindex="-1"></a>ksp_iterative.setOperators(A_iterative)</span></code></pre></div>
</div>
<div id="7e01e9f4" class="cell" data-execution_count="80">
<div class="sourceCode" id="cb92"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb92-1"><a href="#cb92-1" aria-hidden="true" tabindex="-1"></a>uh_iterative <span class="op">=</span> fem.Function(V)</span></code></pre></div>
</div>
<div id="0c21e671" class="cell" data-execution_count="81">
<div class="sourceCode" id="cb93"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb93-1"><a href="#cb93-1" aria-hidden="true" tabindex="-1"></a>ksp_iterative.solve(b, uh_iterative.x.petsc_vec)</span>
<span id="cb93-2"><a href="#cb93-2" aria-hidden="true" tabindex="-1"></a>uh_iterative.x.scatter_forward()</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>  Residual norms for singular_iterative solve.
  0 KSP Residual norm 2.661001756726e+01
  1 KSP Residual norm 6.492588815947e-01
  2 KSP Residual norm 1.847006602521e-02
  3 KSP Residual norm 4.324476514095e-04
  4 KSP Residual norm 1.023834897254e-05
  5 KSP Residual norm 1.698517274164e-07
  6 KSP Residual norm 5.001124493771e-09
  7 KSP Residual norm 9.716088243127e-11
  8 KSP Residual norm 2.097703665509e-12</code></pre>
</div>
</div>
<p>When using the iterative solver, we correct the solution by subtracting its mean value and adding the mean value of the manufactured solution before evaluating the error</p>
<div id="bded9ff2" class="cell" data-execution_count="82">
<div class="sourceCode" id="cb95"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb95-1"><a href="#cb95-1" aria-hidden="true" tabindex="-1"></a>approx_mean <span class="op">=</span> V.mesh.comm.allreduce(</span>
<span id="cb95-2"><a href="#cb95-2" aria-hidden="true" tabindex="-1"></a>  fem.assemble_scalar(fem.form(uh_iterative <span class="op">*</span>ufl.dx)), </span>
<span id="cb95-3"><a href="#cb95-3" aria-hidden="true" tabindex="-1"></a>  op<span class="op">=</span>MPI.SUM</span>
<span id="cb95-4"><a href="#cb95-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb95-5"><a href="#cb95-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb95-6"><a href="#cb95-6" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;Mean value of computed solution (iterative solver):&quot;</span>, </span>
<span id="cb95-7"><a href="#cb95-7" aria-hidden="true" tabindex="-1"></a>  approx_mean</span>
<span id="cb95-8"><a href="#cb95-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb95-9"><a href="#cb95-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-10"><a href="#cb95-10" aria-hidden="true" tabindex="-1"></a>uh_iterative.x.array[:] <span class="op">+=</span> ex_mean <span class="op">-</span>approx_mean</span>
<span id="cb95-11"><a href="#cb95-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-12"><a href="#cb95-12" aria-hidden="true" tabindex="-1"></a>approx_mean <span class="op">=</span> V.mesh.comm.allreduce(</span>
<span id="cb95-13"><a href="#cb95-13" aria-hidden="true" tabindex="-1"></a>  fem.assemble_scalar(fem.form(uh_iterative <span class="op">*</span>ufl.dx)), </span>
<span id="cb95-14"><a href="#cb95-14" aria-hidden="true" tabindex="-1"></a>  op<span class="op">=</span>MPI.SUM</span>
<span id="cb95-15"><a href="#cb95-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb95-16"><a href="#cb95-16" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(</span>
<span id="cb95-17"><a href="#cb95-17" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;Mean value of computed solution (iterative solver) post normalization:&quot;</span>,</span>
<span id="cb95-18"><a href="#cb95-18" aria-hidden="true" tabindex="-1"></a>  approx_mean</span>
<span id="cb95-19"><a href="#cb95-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb95-20"><a href="#cb95-20" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">&quot;Iterative solver L2 error: &quot;</span></span>
<span id="cb95-21"><a href="#cb95-21" aria-hidden="true" tabindex="-1"></a>     <span class="ss">f&quot;</span><span class="sc">{</span>compute_L2_error(uh_iterative)<span class="sc">:.5e}</span><span class="ss">&quot;</span>)</span>
<span id="cb95-22"><a href="#cb95-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb95-23"><a href="#cb95-23" aria-hidden="true" tabindex="-1"></a>np.testing.assert_allclose(</span>
<span id="cb95-24"><a href="#cb95-24" aria-hidden="true" tabindex="-1"></a>  uh.x.array, </span>
<span id="cb95-25"><a href="#cb95-25" aria-hidden="true" tabindex="-1"></a>  uh_iterative.x.array, </span>
<span id="cb95-26"><a href="#cb95-26" aria-hidden="true" tabindex="-1"></a>  rtol<span class="op">=</span><span class="fl">1e-10</span>, atol<span class="op">=</span><span class="fl">1e-12</span></span>
<span id="cb95-27"><a href="#cb95-27" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Mean value of computed solution (iterative solver): -0.1310082077545258
Mean value of computed solution (iterative solver) post normalization: -1.0586522706645257e-15
Iterative solver L2 error: 1.59184e-03</code></pre>
</div>
</div>
</section>
<section id="a-nonlinear-poisson-equation" class="level3" data-number="K.7.3">
<h3 data-number="K.7.3"><span class="header-section-number">K.7.3</span> A nonlinear Poisson equation</h3>
<p>Authors: Anders Logg and Hans Petter Langtangen</p>
<p>We next address the solution of nonlinear PDEs. In contrast to linear problems, nonlinear equations lead to subtle but important differences in the definition of the variational form</p>
<p><strong>PDE problem</strong></p>
<p>To illustrate, we consider the nonlinear Poisson equation</p>
<p><span class="math display">\[\begin{aligned}
-\nabla \cdot (q(u) \nabla u) &amp;=f &amp;&amp;\text{in } \Omega \\
  u&amp;=u_D  &amp;&amp;\text{on } \partial \Omega
  \end{aligned}\]</span></p>
<p>The nonlinearity arises from the coefficient <span class="math inline">\(q(u)\)</span>, which depends on the solution <span class="math inline">\(u\)</span> itself (the problem reduces to the linear case when <span class="math inline">\(q(u)\)</span> is constant)</p>
<p><strong>Variational formulation</strong></p>
<p>As usual, we multiply the PDE by a test function <span class="math inline">\(v \in \hat{V}\)</span>, integrate over the domain, and apply integration by parts to reduce the order of derivatives. The boundary terms vanish under the Dirichlet conditions. The variational formulation of our model problem then takes the form</p>
<p>Find <span class="math inline">\(u\in V\)</span> such that</p>
<p><span class="math display">\[\begin{aligned}
    F(u; v)&amp;=0 &amp;&amp; \forall v \in \hat{V}
\end{aligned}\]</span> where <span class="math display">\[\begin{aligned}
    F(u; v)&amp;=\int_{\Omega}(q(u)\nabla u \cdot \nabla v - fv)\,\mathrm{d}x
\end{aligned}\]</span> and <span class="math display">\[\begin{aligned}
    V&amp;=\left\{v\in H^1(\Omega)\,\vert\, v=u_D \text{ on } \partial \Omega \right\}\\
    \hat{V}&amp;=\left\{v\in H^1(\Omega)\,\vert\, v=0 \text{ on } \partial \Omega \right\}
\end{aligned}\]</span></p>
<p>As usual, the discrete problem is obtained by restricting <span class="math inline">\(V\)</span> and <span class="math inline">\(\hat{V}\)</span> to corresponding finite-dimensional spaces. The resulting discrete nonlinear problem can then be written as:</p>
<p>Find <span class="math inline">\(u_h \in V_h\)</span> such that</p>
<p><span class="math display">\[F(u_h; v) = 0 \quad \forall v \in \hat{V}_h\]</span> with <span class="math display">\[u_h = \sum_{j=1}^N U_j \phi_j\]</span></p>
<p>Since <span class="math inline">\(F\)</span> is nonlinear in <span class="math inline">\(u_h\)</span>, this variational formulation leads to a system of nonlinear algebraic equations for the unknown coefficients <span class="math inline">\(U_1, \dots, U_N\)</span></p>
<p><strong>Test problem</strong></p>
<p>To set up a test problem, it is necessary to prescribe the right-hand side <span class="math inline">\(f\)</span>, the coefficient <span class="math inline">\(q(u)\)</span>, and the boundary condition <span class="math inline">\(u_D\)</span>. In earlier cases, we employed manufactured solutions that can be exactly reproduced, thereby avoiding approximation errors. For nonlinear problems this construction is more difficult, as the algebra becomes significantly more tedious. To address this, we employ the differentiation capabilities of <code>UFL</code> to derive a manufactured solution</p>
<p>Specifically, we select <span class="math inline">\(q(u) = 1 + u^2\)</span> and define a two-dimensional manufactured solution that is linear in both <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span></p>
<div id="b029fa13" class="cell" data-execution_count="83">
<div class="sourceCode" id="cb97"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb97-1"><a href="#cb97-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb97-2"><a href="#cb97-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-3"><a href="#cb97-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb97-4"><a href="#cb97-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> petsc4py <span class="im">import</span> PETSc</span>
<span id="cb97-5"><a href="#cb97-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-6"><a href="#cb97-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> mesh, fem, io, nls, log</span>
<span id="cb97-7"><a href="#cb97-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> NonlinearProblem</span>
<span id="cb97-8"><a href="#cb97-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.nls.petsc <span class="im">import</span> NewtonSolver</span>
<span id="cb97-9"><a href="#cb97-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ufl</span>
<span id="cb97-10"><a href="#cb97-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-11"><a href="#cb97-11" aria-hidden="true" tabindex="-1"></a>log.set_log_level(log.LogLevel.WARNING)</span>
<span id="cb97-12"><a href="#cb97-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-13"><a href="#cb97-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> q(u):</span>
<span id="cb97-14"><a href="#cb97-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span>u<span class="op">**</span><span class="dv">2</span></span>
<span id="cb97-15"><a href="#cb97-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-16"><a href="#cb97-16" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> mesh.create_unit_square(MPI.COMM_WORLD, <span class="dv">10</span>, <span class="dv">10</span>)</span>
<span id="cb97-17"><a href="#cb97-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-18"><a href="#cb97-18" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> ufl.SpatialCoordinate(domain)</span>
<span id="cb97-19"><a href="#cb97-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb97-20"><a href="#cb97-20" aria-hidden="true" tabindex="-1"></a><span class="co"># manufactured solution and the source term</span></span>
<span id="cb97-21"><a href="#cb97-21" aria-hidden="true" tabindex="-1"></a>u_ufl <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span>x[<span class="dv">0</span>] <span class="op">+</span><span class="dv">2</span> <span class="op">*</span>x[<span class="dv">1</span>]</span>
<span id="cb97-22"><a href="#cb97-22" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="op">-</span> ufl.div(q(u_ufl) <span class="op">*</span>ufl.grad(u_ufl))</span></code></pre></div>
</div>
<p>Note that since <code>x</code> is a 2D vector, the first component (index 0) represents the <span class="math inline">\(x\)</span>-coordinate, while the second component (index 1) represents the <span class="math inline">\(y\)</span>-coordinate. The resulting function <code>f</code> can be directly used in variational formulations in <code>DOLFINx</code></p>
<p>Having defined both the source term and an exact solution, we can now construct the corresponding function space and boundary conditions. Since the exact solution is already specified, we only need to convert it into a Python function that can be evaluated for interpolation. This is accomplished using Python’s <code>eval</code> function</p>
<div id="fc3c0b6a" class="cell" data-execution_count="84">
<div class="sourceCode" id="cb98"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb98-1"><a href="#cb98-1" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span>
<span id="cb98-2"><a href="#cb98-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> u_exact(x): <span class="cf">return</span> <span class="bu">eval</span>(<span class="bu">str</span>(u_ufl))</span></code></pre></div>
</div>
<div id="dcac2f81" class="cell" data-execution_count="85">
<div class="sourceCode" id="cb99"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb99-1"><a href="#cb99-1" aria-hidden="true" tabindex="-1"></a>u_D <span class="op">=</span> fem.Function(V)</span>
<span id="cb99-2"><a href="#cb99-2" aria-hidden="true" tabindex="-1"></a>u_D.interpolate(u_exact)</span>
<span id="cb99-3"><a href="#cb99-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb99-4"><a href="#cb99-4" aria-hidden="true" tabindex="-1"></a>fdim <span class="op">=</span> domain.topology.dim <span class="op">-</span><span class="dv">1</span></span>
<span id="cb99-5"><a href="#cb99-5" aria-hidden="true" tabindex="-1"></a>boundary_facets <span class="op">=</span> mesh.locate_entities_boundary(</span>
<span id="cb99-6"><a href="#cb99-6" aria-hidden="true" tabindex="-1"></a>  domain, </span>
<span id="cb99-7"><a href="#cb99-7" aria-hidden="true" tabindex="-1"></a>  fdim, </span>
<span id="cb99-8"><a href="#cb99-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">lambda</span> x: np.full(x.shape[<span class="dv">1</span>], <span class="va">True</span>, dtype<span class="op">=</span><span class="bu">bool</span>)</span>
<span id="cb99-9"><a href="#cb99-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb99-10"><a href="#cb99-10" aria-hidden="true" tabindex="-1"></a>bc <span class="op">=</span> fem.dirichletbc(</span>
<span id="cb99-11"><a href="#cb99-11" aria-hidden="true" tabindex="-1"></a>  u_D, </span>
<span id="cb99-12"><a href="#cb99-12" aria-hidden="true" tabindex="-1"></a>  fem.locate_dofs_topological(V, fdim, boundary_facets)</span>
<span id="cb99-13"><a href="#cb99-13" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
<p>We are now ready to define the variational formulation. Since the problem is nonlinear, we replace the <code>TrialFunction</code> with a <code>Function</code>, which acts as the unknown of the problem</p>
<div id="96ffe0ed" class="cell" data-execution_count="86">
<div class="sourceCode" id="cb100"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb100-1"><a href="#cb100-1" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> fem.Function(V)</span>
<span id="cb100-2"><a href="#cb100-2" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> ufl.TestFunction(V)</span>
<span id="cb100-3"><a href="#cb100-3" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> q(uh) <span class="op">*</span>ufl.dot(ufl.grad(uh), ufl.grad(v)) <span class="op">*</span>ufl.dx <span class="op">-</span>f <span class="op">*</span>v <span class="op">*</span>ufl.dx</span></code></pre></div>
</div>
<p><strong>Newton’s method</strong></p>
<p>The next step is to define the nonlinear problem. Since the problem is nonlinear, we will use Newton’s method. Newton’s method requires routines for evaluating the residual <code>F</code> (including the enforcement of boundary conditions), as well as for computing the Jacobian matrix. <code>DOLFINx</code> provides the <code>NonlinearProblem</code> class, which implements these routines. In addition to the boundary conditions, you can specify the variational form of the Jacobian (automatically computed if not provided), along with form and JIT parameters</p>
<div id="00802c74" class="cell" data-execution_count="87">
<div class="sourceCode" id="cb101"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb101-1"><a href="#cb101-1" aria-hidden="true" tabindex="-1"></a>problem <span class="op">=</span> NonlinearProblem(F, uh, bcs<span class="op">=</span>[bc])</span></code></pre></div>
</div>
<p>Next, we use the <code>DOLFINx</code> Newton solver. The convergence criteria can be adjusted by setting the absolute tolerance (<code>atol</code>), the relative tolerance (<code>rtol</code>), or the convergence criterion type (<code>residual</code> or <code>incremental</code>)</p>
<div id="2b4a6aab" class="cell" data-execution_count="88">
<div class="sourceCode" id="cb102"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb102-1"><a href="#cb102-1" aria-hidden="true" tabindex="-1"></a>solver <span class="op">=</span> NewtonSolver(MPI.COMM_WORLD, problem)</span>
<span id="cb102-2"><a href="#cb102-2" aria-hidden="true" tabindex="-1"></a>solver.convergence_criterion <span class="op">=</span> <span class="st">&quot;incremental&quot;</span></span>
<span id="cb102-3"><a href="#cb102-3" aria-hidden="true" tabindex="-1"></a>solver.rtol <span class="op">=</span> <span class="fl">1e-6</span></span>
<span id="cb102-4"><a href="#cb102-4" aria-hidden="true" tabindex="-1"></a>solver.report <span class="op">=</span> <span class="va">True</span></span></code></pre></div>
</div>
<p>We can adjust the linear solver used in each Newton iteration by accessing the underlying <code>PETSc</code> object</p>
<div id="600787d4" class="cell" data-execution_count="89">
<div class="sourceCode" id="cb103"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb103-1"><a href="#cb103-1" aria-hidden="true" tabindex="-1"></a>ksp <span class="op">=</span> solver.krylov_solver</span>
<span id="cb103-2"><a href="#cb103-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-3"><a href="#cb103-3" aria-hidden="true" tabindex="-1"></a>opts <span class="op">=</span> PETSc.Options()</span>
<span id="cb103-4"><a href="#cb103-4" aria-hidden="true" tabindex="-1"></a>option_prefix <span class="op">=</span> ksp.getOptionsPrefix()</span>
<span id="cb103-5"><a href="#cb103-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-6"><a href="#cb103-6" aria-hidden="true" tabindex="-1"></a>opts[<span class="ss">f&quot;</span><span class="sc">{</span>option_prefix<span class="sc">}</span><span class="ss">ksp_type&quot;</span>] <span class="op">=</span> <span class="st">&quot;gmres&quot;</span></span>
<span id="cb103-7"><a href="#cb103-7" aria-hidden="true" tabindex="-1"></a>opts[<span class="ss">f&quot;</span><span class="sc">{</span>option_prefix<span class="sc">}</span><span class="ss">ksp_rtol&quot;</span>] <span class="op">=</span> <span class="fl">1.0e-8</span></span>
<span id="cb103-8"><a href="#cb103-8" aria-hidden="true" tabindex="-1"></a>opts[<span class="ss">f&quot;</span><span class="sc">{</span>option_prefix<span class="sc">}</span><span class="ss">pc_type&quot;</span>] <span class="op">=</span> <span class="st">&quot;hypre&quot;</span></span>
<span id="cb103-9"><a href="#cb103-9" aria-hidden="true" tabindex="-1"></a>opts[<span class="ss">f&quot;</span><span class="sc">{</span>option_prefix<span class="sc">}</span><span class="ss">pc_hypre_type&quot;</span>] <span class="op">=</span> <span class="st">&quot;boomeramg&quot;</span></span>
<span id="cb103-10"><a href="#cb103-10" aria-hidden="true" tabindex="-1"></a>opts[<span class="ss">f&quot;</span><span class="sc">{</span>option_prefix<span class="sc">}</span><span class="ss">pc_hypre_boomeramg_max_iter&quot;</span>] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb103-11"><a href="#cb103-11" aria-hidden="true" tabindex="-1"></a>opts[<span class="ss">f&quot;</span><span class="sc">{</span>option_prefix<span class="sc">}</span><span class="ss">pc_hypre_boomeramg_cycle_type&quot;</span>] <span class="op">=</span> <span class="st">&quot;v&quot;</span></span>
<span id="cb103-12"><a href="#cb103-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb103-13"><a href="#cb103-13" aria-hidden="true" tabindex="-1"></a>ksp.setFromOptions()</span></code></pre></div>
</div>
<p>We are now ready to solve the nonlinear problem. After solving, we verify that the solver has converged and print the number of iterations</p>
<div id="fda6228a" class="cell" data-execution_count="90">
<div class="sourceCode" id="cb104"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb104-1"><a href="#cb104-1" aria-hidden="true" tabindex="-1"></a>log.set_log_level(log.LogLevel.INFO)</span>
<span id="cb104-2"><a href="#cb104-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb104-3"><a href="#cb104-3" aria-hidden="true" tabindex="-1"></a>n, converged <span class="op">=</span> solver.solve(uh)</span>
<span id="cb104-4"><a href="#cb104-4" aria-hidden="true" tabindex="-1"></a><span class="cf">assert</span> (converged)</span>
<span id="cb104-5"><a href="#cb104-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Number of interations: </span><span class="sc">{</span>n<span class="sc">:d}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Number of interations: 8[2025-11-19 17:23:00.236] [info] PETSc Krylov solver starting to solve system.

[2025-11-19 17:23:00.236] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:23:00.237] [info] Newton iteration 2: r (abs) = 20.37916572634954 (tol = 1e-10), r (rel) = 0.9225323398510277 (tol = 1e-06)
[2025-11-19 17:23:00.237] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:23:00.237] [info] Newton iteration 3: r (abs) = 6.952713011092111 (tol = 1e-10), r (rel) = 0.31473823259321565 (tol = 1e-06)
[2025-11-19 17:23:00.237] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:23:00.237] [info] Newton iteration 4: r (abs) = 2.935703719836487 (tol = 1e-10), r (rel) = 0.13289462670537136 (tol = 1e-06)
[2025-11-19 17:23:00.237] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:23:00.237] [info] Newton iteration 5: r (abs) = 0.7005897377755923 (tol = 1e-10), r (rel) = 0.031714580407483046 (tol = 1e-06)
[2025-11-19 17:23:00.237] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:23:00.238] [info] Newton iteration 6: r (abs) = 0.04908059170012947 (tol = 1e-10), r (rel) = 0.0022218001320755713 (tol = 1e-06)
[2025-11-19 17:23:00.238] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:23:00.238] [info] Newton iteration 7: r (abs) = 0.00029947987676681893 (tol = 1e-10), r (rel) = 1.3556976529945522e-05 (tol = 1e-06)
[2025-11-19 17:23:00.238] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:23:00.238] [info] Newton iteration 8: r (abs) = 1.52769046025878e-08 (tol = 1e-10), r (rel) = 6.915611138332291e-10 (tol = 1e-06)
[2025-11-19 17:23:00.238] [info] Newton solver finished in 8 iterations and 33 linear solver iterations.</code></pre>
</div>
</div>
<p>We observe that the solver converges after <span class="math inline">\(8\)</span> iterations. If we view the problem in terms of finite differences on a uniform mesh, <span class="math inline">\(\mathcal{P}_1\)</span> elements mimic standard second-order finite differences, which compute derivatives of linear or quadratic functions exactly. In this case, <span class="math inline">\(\nabla u\)</span> is a constant vector, multiplied by <span class="math inline">\(1+u^2\)</span>, resulting in a second-order polynomial in <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>. Such terms would also be computed exactly by the finite difference operator. Therefore, even with <span class="math inline">\(\mathcal{P}_1\)</span> elements, we can expect the manufactured solution to be reproduced by the numerical method. However, if we had chosen a different nonlinearity, such as <span class="math inline">\(1+u^4\)</span>, this would no longer hold, and we would need to verify convergence rates</p>
<div id="a68b07dc" class="cell" data-execution_count="91">
<div class="sourceCode" id="cb106"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb106-1"><a href="#cb106-1" aria-hidden="true" tabindex="-1"></a>log.set_log_level(log.LogLevel.WARNING)</span>
<span id="cb106-2"><a href="#cb106-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-3"><a href="#cb106-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute L2 error and error at nodes</span></span>
<span id="cb106-4"><a href="#cb106-4" aria-hidden="true" tabindex="-1"></a>V_ex <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">2</span>))</span>
<span id="cb106-5"><a href="#cb106-5" aria-hidden="true" tabindex="-1"></a>u_ex <span class="op">=</span> fem.Function(V_ex)</span>
<span id="cb106-6"><a href="#cb106-6" aria-hidden="true" tabindex="-1"></a>u_ex.interpolate(u_exact)</span>
<span id="cb106-7"><a href="#cb106-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-8"><a href="#cb106-8" aria-hidden="true" tabindex="-1"></a>error_local <span class="op">=</span> fem.assemble_scalar(</span>
<span id="cb106-9"><a href="#cb106-9" aria-hidden="true" tabindex="-1"></a>  fem.form((uh <span class="op">-</span>u_ex)<span class="op">**</span><span class="dv">2</span> <span class="op">*</span>ufl.dx)</span>
<span id="cb106-10"><a href="#cb106-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb106-11"><a href="#cb106-11" aria-hidden="true" tabindex="-1"></a>error_L2 <span class="op">=</span> np.sqrt(</span>
<span id="cb106-12"><a href="#cb106-12" aria-hidden="true" tabindex="-1"></a>  domain.comm.allreduce(error_local, op<span class="op">=</span>MPI.SUM)</span>
<span id="cb106-13"><a href="#cb106-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb106-14"><a href="#cb106-14" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> domain.comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb106-15"><a href="#cb106-15" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;L2-error: </span><span class="sc">{</span>error_L2<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span>
<span id="cb106-16"><a href="#cb106-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb106-17"><a href="#cb106-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute values at mesh vertices</span></span>
<span id="cb106-18"><a href="#cb106-18" aria-hidden="true" tabindex="-1"></a>error_max <span class="op">=</span> domain.comm.allreduce(</span>
<span id="cb106-19"><a href="#cb106-19" aria-hidden="true" tabindex="-1"></a>  np.<span class="bu">max</span>(np.<span class="bu">abs</span>(uh.x.array <span class="op">-</span>u_D.x.array)), </span>
<span id="cb106-20"><a href="#cb106-20" aria-hidden="true" tabindex="-1"></a>  op<span class="op">=</span>MPI.MAX</span>
<span id="cb106-21"><a href="#cb106-21" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb106-22"><a href="#cb106-22" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> domain.comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb106-23"><a href="#cb106-23" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Error_max: </span><span class="sc">{</span>error_max<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>L2-error: 4.65e-16
Error_max: 8.88e-16</code></pre>
</div>
</div>
</section>
<section id="the-equations-of-linear-elasticity" class="level3" data-number="K.7.4">
<h3 data-number="K.7.4"><span class="header-section-number">K.7.4</span> The equations of linear elasticity</h3>
<p>Authors: Anders Logg and Hans Petter Langtangen</p>
<p>Analysis of structures is one of the central tasks in modern engineering, which likely makes the PDE governing the deformation of elastic bodies the most widely used PDE in practice. With <code>DOLFINx</code>, the equations of 2D or 3D elasticity can be solved in just a single page of code, as demonstrated in this section</p>
<p><strong>The PDE problem</strong></p>
<p>The equations governing small elastic deformations of a body <span class="math inline">\(\Omega\)</span> can be written as</p>
<p><span class="math display">\[\begin{aligned}
    -\nabla \cdot \sigma (u) &amp;= f &amp;&amp; \text{in } \Omega\\
    \sigma(u)&amp;= \lambda \mathrm{tr}(\epsilon(u))I + 2 \mu \epsilon(u)\\
    \epsilon(u) &amp;= \frac{1}{2}\left(\nabla u + (\nabla u )^T\right)
\end{aligned}\]</span></p>
<p>where <span class="math inline">\(\sigma\)</span> is the stress tensor, <span class="math inline">\(f\)</span> is the body force per unit volume, <span class="math inline">\(\lambda\)</span> and <span class="math inline">\(\mu\)</span> are Lamé’s elasticity parameters for the material in <span class="math inline">\(\Omega\)</span>, <span class="math inline">\(I\)</span> is the identity tensor, <span class="math inline">\(\mathrm{tr}\)</span> denotes the trace operator on a tensor, <span class="math inline">\(\epsilon\)</span> is the symmetric strain tensor (the symmetric gradient of <span class="math inline">\(u\)</span>), and <span class="math inline">\(u\)</span> is the displacement vector field. Here, we assume isotropic elastic conditions</p>
<p>Substituting <span class="math inline">\(\epsilon(u)\)</span> into the expression for <span class="math inline">\(\sigma\)</span>, we obtain</p>
<p><span class="math display">\[\begin{aligned}
\sigma(u) &amp;= \lambda(\nabla \cdot u)I + \mu\big(\nabla u + (\nabla u)^T\big)
\end{aligned}\]</span></p>
<p>Note that the PDE above could alternatively be written as a single vector equation for <span class="math inline">\(u\)</span>, known as Navier’s equation, which governs the displacement field. However, it is often more convenient to keep the present representation when deriving the variational formulation</p>
<p><strong>The variational formulation</strong></p>
<p>The variational formulation is obtained by taking the inner product of the elasticity PDE with a <em>vector-valued</em> test function <span class="math inline">\(v\in\hat{V}\)</span>, where <span class="math inline">\(\hat{V}\)</span> denotes the corresponding test function space, and integrating over the domain <span class="math inline">\(\Omega\)</span>:</p>
<p><span class="math display">\[ -\int_{\Omega}(\nabla \cdot \sigma)\cdot v ~\mathrm{d} x = \int_{\Omega} f\cdot v \,\mathrm{d}x \]</span></p>
<p>Since <span class="math inline">\(\nabla \cdot \sigma\)</span> contains second-order derivatives of the unknown <span class="math inline">\(u\)</span>, we integrate this term by parts:</p>
<p><span class="math display">\[-\int_{\Omega} (\nabla \cdot \sigma)\cdot v \,\mathrm{d}x
= \int_{\Omega} \sigma : \nabla v \,\mathrm{d}x
    -   \int_{\partial \Omega} (\sigma \cdot n)\cdot v \,\mathrm{d}s\]</span></p>
<p>where the colon operator denotes the inner product between tensors (the sum of pairwise products of all components), and <span class="math inline">\(n\)</span> is the outward unit normal to the boundary. The quantity <span class="math inline">\(\sigma \cdot n\)</span> is known as the traction or stress vector at the boundary, and it is often prescribed as a boundary condition. Here, we assume that the traction is prescribed on a portion <span class="math inline">\(\partial \Omega_T\)</span> of the boundary as <span class="math inline">\(\sigma \cdot n = T\)</span>. On the remaining part of the boundary, we impose Dirichlet conditions on the displacement, which eliminates the corresponding boundary integral. Thus we obtain</p>
<p><span class="math display">\[\int_{\Omega} \sigma : \nabla v \,\mathrm{d}x
= \int_{\Omega} f \cdot v \,\mathrm{d}x
    +   \int_{\partial \Omega_T} T \cdot v \,\mathrm{d}s\]</span></p>
<p>If we now substitute the expression for <span class="math inline">\(\sigma\)</span> in terms of the unknown <span class="math inline">\(u\)</span>, the variational formulation can be stated as:</p>
<p>Find <span class="math inline">\(u \in V\)</span> such that</p>
<p><span class="math display">\[a(u, v) = L(v) \qquad \forall v \in \hat{V}\]</span></p>
<p>where</p>
<p><span class="math display">\[\begin{aligned}
a(u, v) &amp;= \int_{\Omega} \sigma(u) : \nabla v \,\mathrm{d}x \\
\sigma(u) &amp;= \lambda (\nabla \cdot u) I + \mu \big(\nabla u + (\nabla u)^T\big)\\
L(v) &amp;= \int_{\Omega} f \cdot v \,\mathrm{d}x
    +   \int_{\partial \Omega_T} T \cdot v \,\mathrm{d}s
\end{aligned}\]</span></p>
<p>It can be shown that the inner product of a symmetric tensor <span class="math inline">\(A\)</span> and an antisymmetric tensor <span class="math inline">\(B\)</span> vanishes. Decomposing <span class="math inline">\(\nabla v\)</span> into its symmetric and antisymmetric parts therefore implies that only the symmetric part contributes to the product <span class="math inline">\(\sigma : \nabla v\)</span>, since <span class="math inline">\(\sigma\)</span> is symmetric. Replacing <span class="math inline">\(\nabla v\)</span> by the symmetric gradient <span class="math inline">\(\epsilon(v)\)</span> leads to a slightly different, but equivalent, variational formulation:</p>
<p><span class="math display">\[a(u, v) = \int_{\Omega} \sigma(u) : \epsilon(v) \,\mathrm{d}x\]</span></p>
<p>where the symmetric gradient of <span class="math inline">\(v\)</span> is defined as</p>
<p><span class="math display">\[\epsilon(v) = \tfrac{1}{2}\big(\nabla v + (\nabla v)^T\big)\]</span></p>
<p>This formulation naturally arises from the minimization of elastic potential energy and is more commonly used than the earlier form based on <span class="math inline">\(\sigma : \nabla v\)</span></p>
<p><strong>Scaling</strong></p>
<p>It is often advantageous to scale a problem, as this reduces the need to specify physical parameters and produces dimensionless numbers that capture the relative influence of different parameters and physical effects. We first develop the code for the original dimensional model and then run the scaled problem by appropriately adjusting the parameters. For the present application, scaling reduces the number of active parameters from six to two</p>
<p>In Navier’s equation for <span class="math inline">\(u\)</span>, obtained by substituting <span class="math inline">\(\sigma(u)\)</span> into elasticity PDE, we have:</p>
<p><span class="math display">\[ -(\lambda + \mu)\nabla (\nabla \cdot u) - \mu \nabla^2 u = f \]</span></p>
<p>We introduce dimensionless coordinates by scaling with <span class="math inline">\(L\)</span>, and define <span class="math inline">\(\bar{u} = \frac{u}{U}\)</span>. This leads to the dimensionless governing equations:</p>
<p><span class="math display">\[-\beta\,\bar{\nabla}(\bar{\nabla}\cdot \bar{u}) -\bar{\nabla}^2 \bar{u} = \bar{f}, \quad \bar{f} = (0,0,\gamma)\]</span></p>
<p>where <span class="math inline">\(\beta = 1 +\frac{\lambda}{\mu}\)</span> is a dimensionless elasticity parameter and</p>
<p><span class="math display">\[ \gamma = \frac{\rho g L^2}{\mu U} \]</span></p>
<p>is a dimensionless number representing the ratio of the applied load <span class="math inline">\(\rho g\)</span> to the shear stress term <span class="math inline">\(\mu \nabla^2 u \sim \mu \frac{U}{L^2}\)</span> in the PDE</p>
<p>One option for scaling is to choose <span class="math inline">\(U\)</span> such that <span class="math inline">\(\gamma\)</span> is of order one, i.e., <span class="math inline">\(U = \frac{\rho g L^2}{\mu}\)</span>. However, in elasticity, this choice leads to displacements comparable to the size of the geometry. A more practical approach is to set <span class="math inline">\(U\)</span> equal to the maximum deflection of a clamped beam, for which a formula exists:</p>
<p><span class="math display">\[U = \frac{3}{2} \, \rho g L^2 \frac{\delta^2}{E}\]</span></p>
<p>where <span class="math inline">\(\delta = \frac{L}{W}\)</span> reflects the beam’s slenderness, and <span class="math inline">\(E\)</span> is the modulus of elasticity. The dimensionless parameter <span class="math inline">\(\delta\)</span> is therefore very important in this problem (as expected, <span class="math inline">\(\delta \gg 1\)</span> is what justifies beam theory). Taking <span class="math inline">\(E\)</span> to be of the same order as <span class="math inline">\(\mu\)</span>, which is typical for many materials, we find that <span class="math inline">\(\gamma \sim \delta^{-2}\)</span> is an appropriate choice. By experimenting with the code to obtain displacements that “look right” in plots of the deformed geometry, we select <span class="math inline">\(\gamma = 0.4 \, \delta^{-2}\)</span> as our final value</p>
<p>The simulation code handles the dimensional problem with parameters <span class="math inline">\(\lambda,\)</span> <span class="math inline">\(\mu,\)</span> <span class="math inline">\(\rho,\)</span> <span class="math inline">\(g,\)</span> <span class="math inline">\(L,\)</span> <span class="math inline">\(W\)</span>. For the scaled problem, we simply set <span class="math inline">\(\mu = \rho = L = 1,\)</span> <span class="math inline">\(W = \delta^{-1},\)</span> <span class="math inline">\(g = \gamma,\)</span> and <span class="math inline">\(\lambda = \beta\)</span></p>
<section id="implementation-2" class="level4" data-number="K.7.4.1">
<h4 data-number="K.7.4.1"><span class="header-section-number">K.7.4.1</span> Implementation</h4>
<p>Author: Jørgen S. Dokken</p>
<p>In this section, you will learn how to:</p>
<ul>
<li>Work with vector function spaces</li>
<li>Define constant boundary conditions on vector spaces</li>
<li>Visualize cell wise constant functions</li>
<li>Compute Von Mises stresses</li>
</ul>
<p><strong>Test problem</strong></p>
<p>As a test case, we consider a clamped beam in 3D that deforms under its own weight. This is modeled by prescribing the body force per unit volume as <span class="math inline">\(f = (0, 0, -\rho g)\)</span>, where <span class="math inline">\(\rho\)</span> is the density of the beam and <span class="math inline">\(g\)</span> is the gravitational acceleration</p>
<p>The beam has a box shape with length <span class="math inline">\(L\)</span> and a square cross-section of width <span class="math inline">\(W\)</span>. At the clamped end (<span class="math inline">\(x = 0\)</span>), we impose the displacement condition <span class="math inline">\(u = u_D = (0,0,0)\)</span>. The remaining boundaries are traction-free, i.e., we set <span class="math inline">\(T = 0\)</span></p>
<p>We begin by defining the physical variables that will be used in the program</p>
<div id="8c5eae1b" class="cell" data-execution_count="92">
<div class="sourceCode" id="cb108"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb108-1"><a href="#cb108-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb108-2"><a href="#cb108-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb108-3"><a href="#cb108-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb108-4"><a href="#cb108-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-5"><a href="#cb108-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> mesh, fem, plot, io, default_scalar_type</span>
<span id="cb108-6"><a href="#cb108-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> LinearProblem</span>
<span id="cb108-7"><a href="#cb108-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-8"><a href="#cb108-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ufl</span>
<span id="cb108-9"><a href="#cb108-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-10"><a href="#cb108-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Scaled variable</span></span>
<span id="cb108-11"><a href="#cb108-11" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb108-12"><a href="#cb108-12" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb108-13"><a href="#cb108-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-14"><a href="#cb108-14" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb108-15"><a href="#cb108-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-16"><a href="#cb108-16" aria-hidden="true" tabindex="-1"></a>delta <span class="op">=</span> W <span class="op">/</span>L</span>
<span id="cb108-17"><a href="#cb108-17" aria-hidden="true" tabindex="-1"></a>gamma <span class="op">=</span> <span class="fl">0.4</span> <span class="op">*</span>delta<span class="op">**</span><span class="dv">2</span></span>
<span id="cb108-18"><a href="#cb108-18" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> gamma</span>
<span id="cb108-19"><a href="#cb108-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-20"><a href="#cb108-20" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb108-21"><a href="#cb108-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb108-22"><a href="#cb108-22" aria-hidden="true" tabindex="-1"></a>beta <span class="op">=</span> <span class="fl">1.25</span></span>
<span id="cb108-23"><a href="#cb108-23" aria-hidden="true" tabindex="-1"></a>lambda_ <span class="op">=</span> beta</span></code></pre></div>
</div>
<p>We next create the mesh, which will be composed of hexahedral elements, together with the assoicated function space. Since we require a vector element with three components, we add <code>(3, )</code> or (or more generally <code>(domain.geometry.dim, )</code>) to the element tuple to obtain a triplet</p>
<div id="5341832f" class="cell" data-execution_count="93">
<div class="sourceCode" id="cb109"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb109-1"><a href="#cb109-1" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> mesh.create_box(</span>
<span id="cb109-2"><a href="#cb109-2" aria-hidden="true" tabindex="-1"></a>  MPI.COMM_WORLD, </span>
<span id="cb109-3"><a href="#cb109-3" aria-hidden="true" tabindex="-1"></a>  [np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>]), np.array([L, W, W])],</span>
<span id="cb109-4"><a href="#cb109-4" aria-hidden="true" tabindex="-1"></a>  [<span class="dv">20</span>, <span class="dv">6</span>, <span class="dv">6</span>], </span>
<span id="cb109-5"><a href="#cb109-5" aria-hidden="true" tabindex="-1"></a>  cell_type<span class="op">=</span>mesh.CellType.hexahedron</span>
<span id="cb109-6"><a href="#cb109-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb109-7"><a href="#cb109-7" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>, (domain.geometry.dim, )))</span></code></pre></div>
</div>
<p>Alternatively, we can take advantage of <code>basix.ufl</code> to construct the vector element directly:</p>
<div id="edaf51c2" class="cell" data-execution_count="94">
<div class="sourceCode" id="cb110"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb110-1"><a href="#cb110-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> basix</span>
<span id="cb110-2"><a href="#cb110-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb110-3"><a href="#cb110-3" aria-hidden="true" tabindex="-1"></a>element <span class="op">=</span> basix.ufl.element(</span>
<span id="cb110-4"><a href="#cb110-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;Lagrange&quot;</span>, </span>
<span id="cb110-5"><a href="#cb110-5" aria-hidden="true" tabindex="-1"></a>  domain.topology.cell_name(), </span>
<span id="cb110-6"><a href="#cb110-6" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1</span>,</span>
<span id="cb110-7"><a href="#cb110-7" aria-hidden="true" tabindex="-1"></a>  shape<span class="op">=</span>(domain.geometry.dim,)</span>
<span id="cb110-8"><a href="#cb110-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb110-9"><a href="#cb110-9" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> fem.functionspace(domain, element)</span></code></pre></div>
</div>
<p><strong>Boundary conditions</strong></p>
<p>Since we want to clamp the boundary at <span class="math inline">\(x = 0\)</span>, we achieve this by using a marker function, which identifies the facets where <span class="math inline">\(x\)</span> is (within machine precision) close to zero</p>
<div id="0dd4f529" class="cell" data-execution_count="95">
<div class="sourceCode" id="cb111"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb111-1"><a href="#cb111-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> clamped_boundary(x):</span>
<span id="cb111-2"><a href="#cb111-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> np.isclose(x[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb111-3"><a href="#cb111-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-4"><a href="#cb111-4" aria-hidden="true" tabindex="-1"></a>fdim <span class="op">=</span> domain.topology.dim <span class="op">-</span><span class="dv">1</span></span>
<span id="cb111-5"><a href="#cb111-5" aria-hidden="true" tabindex="-1"></a>boundary_facets <span class="op">=</span> mesh.locate_entities_boundary(</span>
<span id="cb111-6"><a href="#cb111-6" aria-hidden="true" tabindex="-1"></a>  domain, </span>
<span id="cb111-7"><a href="#cb111-7" aria-hidden="true" tabindex="-1"></a>  fdim, </span>
<span id="cb111-8"><a href="#cb111-8" aria-hidden="true" tabindex="-1"></a>  clamped_boundary</span>
<span id="cb111-9"><a href="#cb111-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb111-10"><a href="#cb111-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb111-11"><a href="#cb111-11" aria-hidden="true" tabindex="-1"></a>u_D <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>], dtype<span class="op">=</span>default_scalar_type)</span>
<span id="cb111-12"><a href="#cb111-12" aria-hidden="true" tabindex="-1"></a>bc <span class="op">=</span> fem.dirichletbc(</span>
<span id="cb111-13"><a href="#cb111-13" aria-hidden="true" tabindex="-1"></a>  u_D, </span>
<span id="cb111-14"><a href="#cb111-14" aria-hidden="true" tabindex="-1"></a>  fem.locate_dofs_topological(V, fdim, boundary_facets), </span>
<span id="cb111-15"><a href="#cb111-15" aria-hidden="true" tabindex="-1"></a>  V</span>
<span id="cb111-16"><a href="#cb111-16" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
<p>Since the traction <span class="math inline">\(T\)</span> should vanish on the remaining boundary, we introduce a <code>dolfinx.Constant</code></p>
<div id="0f7c6fe0" class="cell" data-execution_count="96">
<div class="sourceCode" id="cb112"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb112-1"><a href="#cb112-1" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> fem.Constant(domain, default_scalar_type((<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)))</span></code></pre></div>
</div>
<p>We specify the integration measure <span class="math inline">\(\mathrm{d}s\)</span>, corresponding to integration over the domain boundary, using <code>ufl</code>’s built-in measures</p>
<div id="860e03e4" class="cell" data-execution_count="97">
<div class="sourceCode" id="cb113"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb113-1"><a href="#cb113-1" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> ufl.Measure(<span class="st">&quot;ds&quot;</span>, domain<span class="op">=</span>domain)</span></code></pre></div>
</div>
<p><strong>Variational formulation</strong></p>
<p>We are now ready to formulate the variational problem in a syntax that closely resembles the mathematical notation, as in the previous examples</p>
<div id="7824924f" class="cell" data-execution_count="98">
<div class="sourceCode" id="cb114"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb114-1"><a href="#cb114-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> epsilon(u):</span>
<span id="cb114-2"><a href="#cb114-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Equivalent to 0.5 *(ufl.nabla_grad(u) +ufl.nabla_grad(u).T)  </span></span>
<span id="cb114-3"><a href="#cb114-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> ufl.sym(ufl.grad(u))  </span>
<span id="cb114-4"><a href="#cb114-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-5"><a href="#cb114-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sigma(u):</span>
<span id="cb114-6"><a href="#cb114-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> (lambda_ <span class="op">*</span>ufl.nabla_div(u) <span class="op">*</span>ufl.Identity(<span class="bu">len</span>(u)) </span>
<span id="cb114-7"><a href="#cb114-7" aria-hidden="true" tabindex="-1"></a>    <span class="op">+</span><span class="dv">2</span> <span class="op">*</span>mu <span class="op">*</span>epsilon(u))</span>
<span id="cb114-8"><a href="#cb114-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-9"><a href="#cb114-9" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> ufl.TrialFunction(V)</span>
<span id="cb114-10"><a href="#cb114-10" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> ufl.TestFunction(V)</span>
<span id="cb114-11"><a href="#cb114-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb114-12"><a href="#cb114-12" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> fem.Constant(domain, default_scalar_type((<span class="dv">0</span>, <span class="dv">0</span>, <span class="op">-</span>rho <span class="op">*</span> g)))</span>
<span id="cb114-13"><a href="#cb114-13" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> ufl.inner(sigma(u), epsilon(v)) <span class="op">*</span>ufl.dx</span>
<span id="cb114-14"><a href="#cb114-14" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> ufl.dot(f, v) <span class="op">*</span>ufl.dx <span class="op">+</span>ufl.dot(T, v) <span class="op">*</span>ds</span></code></pre></div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class='callout-icon'></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>In <code>DOLFINx</code>, <code>grad(u)</code> uses the <span class="math inline">\(\partial u_i / \partial x_j\)</span> convention, but since continuum mechanics often prefers the opposite, <code>ufl</code> offers <code>nabla_grad</code> to support that usage</p>
</div>
</div>
<p><strong>Solve the linear variational problem</strong></p>
<p>As in the previous examples, we assemble the system matrix and right-hand side vector, and solve the variational problem using <code>PETSc</code></p>
<div id="f5d12878" class="cell" data-execution_count="99">
<div class="sourceCode" id="cb115"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb115-1"><a href="#cb115-1" aria-hidden="true" tabindex="-1"></a>problem <span class="op">=</span> LinearProblem(</span>
<span id="cb115-2"><a href="#cb115-2" aria-hidden="true" tabindex="-1"></a>  a, </span>
<span id="cb115-3"><a href="#cb115-3" aria-hidden="true" tabindex="-1"></a>  L, </span>
<span id="cb115-4"><a href="#cb115-4" aria-hidden="true" tabindex="-1"></a>  bcs<span class="op">=</span>[bc], </span>
<span id="cb115-5"><a href="#cb115-5" aria-hidden="true" tabindex="-1"></a>  petsc_options<span class="op">=</span>{<span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;preonly&quot;</span>, <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;lu&quot;</span>}</span>
<span id="cb115-6"><a href="#cb115-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb115-7"><a href="#cb115-7" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> problem.solve()</span></code></pre></div>
</div>
<p><strong>Visualization</strong></p>
<p>As in earlier demos, visualization can be done with <code>PyVista</code> or <code>ParaView</code>. We first use <code>PyVista</code>, adding vectors to the grid rather than scalars</p>
<div id="b962366f" class="cell" data-execution_count="100">
<div class="sourceCode" id="cb116"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb116-1"><a href="#cb116-1" aria-hidden="true" tabindex="-1"></a>results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/linear_elasticity&quot;</span>)</span>
<span id="cb116-2"><a href="#cb116-2" aria-hidden="true" tabindex="-1"></a>results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb116-3"><a href="#cb116-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-4"><a href="#cb116-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create plotter and pyvista grid</span></span>
<span id="cb116-5"><a href="#cb116-5" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb116-6"><a href="#cb116-6" aria-hidden="true" tabindex="-1"></a>topology, cell_types, geometry <span class="op">=</span> plot.vtk_mesh(V)</span>
<span id="cb116-7"><a href="#cb116-7" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> pyvista.UnstructuredGrid(topology, cell_types, geometry)</span>
<span id="cb116-8"><a href="#cb116-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-9"><a href="#cb116-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Attach vector values to grid and warp grid by vector</span></span>
<span id="cb116-10"><a href="#cb116-10" aria-hidden="true" tabindex="-1"></a>grid[<span class="st">&quot;u&quot;</span>] <span class="op">=</span> uh.x.array.reshape((geometry.shape[<span class="dv">0</span>], <span class="dv">3</span>))</span>
<span id="cb116-11"><a href="#cb116-11" aria-hidden="true" tabindex="-1"></a>actor_0 <span class="op">=</span> p.add_mesh(grid, style<span class="op">=</span><span class="st">&quot;wireframe&quot;</span>, color<span class="op">=</span><span class="st">&quot;k&quot;</span>)</span>
<span id="cb116-12"><a href="#cb116-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-13"><a href="#cb116-13" aria-hidden="true" tabindex="-1"></a>warped <span class="op">=</span> grid.warp_by_vector(<span class="st">&quot;u&quot;</span>, factor<span class="op">=</span><span class="fl">1.5</span>)</span>
<span id="cb116-14"><a href="#cb116-14" aria-hidden="true" tabindex="-1"></a>actor_1 <span class="op">=</span> p.add_mesh(warped, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb116-15"><a href="#cb116-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-16"><a href="#cb116-16" aria-hidden="true" tabindex="-1"></a>p.show_axes()</span>
<span id="cb116-17"><a href="#cb116-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-18"><a href="#cb116-18" aria-hidden="true" tabindex="-1"></a><span class="co"># if not pyvista.OFF_SCREEN:</span></span>
<span id="cb116-19"><a href="#cb116-19" aria-hidden="true" tabindex="-1"></a><span class="co">#   p.show()</span></span>
<span id="cb116-20"><a href="#cb116-20" aria-hidden="true" tabindex="-1"></a><span class="co"># else:</span></span>
<span id="cb116-21"><a href="#cb116-21" aria-hidden="true" tabindex="-1"></a><span class="co">#   p.screenshot(results_folder/&quot;deflection.png&quot;)</span></span>
<span id="cb116-22"><a href="#cb116-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb116-23"><a href="#cb116-23" aria-hidden="true" tabindex="-1"></a><span class="co"># HTML 저장</span></span>
<span id="cb116-24"><a href="#cb116-24" aria-hidden="true" tabindex="-1"></a>p.export_html(results_folder<span class="op">/</span><span class="st">&quot;deflection.html&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/linear_elasticity/deflection.html"
        width="100%" height="400px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
<p>We can also use <code>ParaView</code> for visualization. As explained in previous sections, the solution is saved using <code>XDMFFile</code></p>
<div id="c70f03e1" class="cell" data-execution_count="101">
<div class="sourceCode" id="cb117"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb117-1"><a href="#cb117-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> io.XDMFFile(</span>
<span id="cb117-2"><a href="#cb117-2" aria-hidden="true" tabindex="-1"></a>  domain.comm, </span>
<span id="cb117-3"><a href="#cb117-3" aria-hidden="true" tabindex="-1"></a>  results_folder<span class="op">/</span><span class="st">&quot;deformation.xdmf&quot;</span>, </span>
<span id="cb117-4"><a href="#cb117-4" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;w&quot;</span></span>
<span id="cb117-5"><a href="#cb117-5" aria-hidden="true" tabindex="-1"></a>) <span class="im">as</span> xdmf:</span>
<span id="cb117-6"><a href="#cb117-6" aria-hidden="true" tabindex="-1"></a>  xdmf.write_mesh(domain)</span>
<span id="cb117-7"><a href="#cb117-7" aria-hidden="true" tabindex="-1"></a>  uh.name <span class="op">=</span> <span class="st">&quot;Deformation&quot;</span></span>
<span id="cb117-8"><a href="#cb117-8" aria-hidden="true" tabindex="-1"></a>  xdmf.write_function(uh)</span></code></pre></div>
</div>
<p><strong>Stress computation</strong></p>
<p>Once the displacement has been computed, we can evaluate various stress measures. In particular, we compute the von Mises stress, defined as</p>
<p><span class="math display">\[\sigma_m = \sqrt{\tfrac{3}{2}\, s : s}\]</span></p>
<p>where <span class="math inline">\(s\)</span> is the deviatoric stress tensor, given by</p>
<p><span class="math display">\[s(u) = \sigma(u) - \tfrac{1}{3}\,\mathrm{tr}(\sigma(u))\, I\]</span></p>
<div id="b945ea53" class="cell" data-execution_count="102">
<div class="sourceCode" id="cb118"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb118-1"><a href="#cb118-1" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> sigma(uh) <span class="op">-</span><span class="fl">1.</span> <span class="op">/</span><span class="dv">3</span> <span class="op">*</span>ufl.tr(sigma(uh)) <span class="op">*</span>ufl.Identity(<span class="bu">len</span>(uh))</span>
<span id="cb118-2"><a href="#cb118-2" aria-hidden="true" tabindex="-1"></a>von_Mises <span class="op">=</span> ufl.sqrt(<span class="fl">3.</span> <span class="op">/</span><span class="dv">2</span> <span class="op">*</span>ufl.inner(s, s))</span></code></pre></div>
</div>
<p><code>von_Mises</code> is an expression that needs to be projected onto a suitable function space for visualization. Because <code>uh</code> consists of first-order piecewise continuous functions, the resulting von Mises stress is cell-wise constant</p>
<div id="a21ff9d9" class="cell" data-execution_count="103">
<div class="sourceCode" id="cb119"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb119-1"><a href="#cb119-1" aria-hidden="true" tabindex="-1"></a><span class="co"># This is suitable for representing </span></span>
<span id="cb119-2"><a href="#cb119-2" aria-hidden="true" tabindex="-1"></a><span class="co">#  cell-wise constant quantities like the von Mises stress</span></span>
<span id="cb119-3"><a href="#cb119-3" aria-hidden="true" tabindex="-1"></a><span class="co"># DG = Discontinuous Galerkin, 0 = cell-wise constant</span></span>
<span id="cb119-4"><a href="#cb119-4" aria-hidden="true" tabindex="-1"></a>V_von_mises <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;DG&quot;</span>, <span class="dv">0</span>))</span>
<span id="cb119-5"><a href="#cb119-5" aria-hidden="true" tabindex="-1"></a>stress_expr <span class="op">=</span> fem.Expression(</span>
<span id="cb119-6"><a href="#cb119-6" aria-hidden="true" tabindex="-1"></a>  von_Mises, </span>
<span id="cb119-7"><a href="#cb119-7" aria-hidden="true" tabindex="-1"></a>  V_von_mises.element.interpolation_points()</span>
<span id="cb119-8"><a href="#cb119-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb119-9"><a href="#cb119-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb119-10"><a href="#cb119-10" aria-hidden="true" tabindex="-1"></a>stresses <span class="op">=</span> fem.Function(V_von_mises)</span>
<span id="cb119-11"><a href="#cb119-11" aria-hidden="true" tabindex="-1"></a>stresses.interpolate(stress_expr)</span></code></pre></div>
</div>
<p>Previously, we visualized only first-order Lagrange functions. Since the von Mises stress is piecewise constant per cell, we slightly adjust the plotting routine, setting values for each cell, which corresponds directly to the degrees of freedom in the function space</p>
<div id="c811dde8" class="cell" data-execution_count="104">
<div class="sourceCode" id="cb120"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb120-1"><a href="#cb120-1" aria-hidden="true" tabindex="-1"></a>warped.cell_data[<span class="st">&quot;VonMises&quot;</span>] <span class="op">=</span> stresses.x.petsc_vec.array</span>
<span id="cb120-2"><a href="#cb120-2" aria-hidden="true" tabindex="-1"></a>warped.set_active_scalars(<span class="st">&quot;VonMises&quot;</span>)</span>
<span id="cb120-3"><a href="#cb120-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-4"><a href="#cb120-4" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb120-5"><a href="#cb120-5" aria-hidden="true" tabindex="-1"></a>p.add_mesh(warped)</span>
<span id="cb120-6"><a href="#cb120-6" aria-hidden="true" tabindex="-1"></a>p.show_axes()</span>
<span id="cb120-7"><a href="#cb120-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-8"><a href="#cb120-8" aria-hidden="true" tabindex="-1"></a><span class="co"># if not pyvista.OFF_SCREEN:</span></span>
<span id="cb120-9"><a href="#cb120-9" aria-hidden="true" tabindex="-1"></a><span class="co">#   p.show()</span></span>
<span id="cb120-10"><a href="#cb120-10" aria-hidden="true" tabindex="-1"></a><span class="co"># else:</span></span>
<span id="cb120-11"><a href="#cb120-11" aria-hidden="true" tabindex="-1"></a><span class="co">#   p.screenshot(results_folder/&quot;stresses.png&quot;)</span></span>
<span id="cb120-12"><a href="#cb120-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb120-13"><a href="#cb120-13" aria-hidden="true" tabindex="-1"></a><span class="co"># HTML 저장</span></span>
<span id="cb120-14"><a href="#cb120-14" aria-hidden="true" tabindex="-1"></a>p.export_html(results_folder<span class="op">/</span><span class="st">&quot;stresses.html&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/linear_elasticity/stresses.html"
        width="100%" height="400px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
</section>
</section>
<section id="the-navier-stokes-equations" class="level3" data-number="K.7.5">
<h3 data-number="K.7.5"><span class="header-section-number">K.7.5</span> The Navier-Stokes equations</h3>
<p>In this section, we address the incompressible Navier–Stokes equations, which combine time dependence, nonlinearity, and vector-valued variables—challenges seen in earlier problems</p>
<p><strong>The PDE problem</strong></p>
<p>The incompressible Navier–Stokes equations form a system of equations governing the velocity <span class="math inline">\(u\)</span> and pressure <span class="math inline">\(p\)</span> of an incompressible fluid:</p>
<p><span class="math display">\[\begin{aligned}
\rho \left( \frac{\partial u }{\partial t} + u \cdot \nabla u \right) &amp;= \nabla \cdot \sigma (u, p) + f\\
\nabla \cdot u &amp;= 0
\end{aligned}\tag{NS}\label{eq:NS}\]</span></p>
<p>The right-hand side <span class="math inline">\(f\)</span> represents a given force per unit volume. As in the equations of linear elasticity, <span class="math inline">\(\sigma(u,p)\)</span> denotes the stress tensor, which for a Newtonian fluid is given by:</p>
<p><span class="math display">\[\sigma(u, p) = 2 \mu \epsilon(u) - p I\]</span></p>
<p>where <span class="math inline">\(\epsilon(u)\)</span> is the strain-rate tensor:</p>
<p><span class="math display">\[\epsilon(u) = \frac{1}{2}\left(\nabla u + (\nabla u)^T\right)\]</span></p>
<p>The parameter <span class="math inline">\(\mu\)</span> is the dynamic viscosity. Note that the momentum equation is very similar to the elasticity equation . The difference lies in the two additional terms, <span class="math inline">\(\rho\left(\frac{\partial u}{\partial t} + u \cdot \nabla u\right)\)</span>, and in the different form of the stress tensor. These extra terms represent the acceleration of the fluid, balanced by the force <span class="math inline">\(F = \nabla \cdot \sigma + f\)</span> per unit volume according to Newton’s second law of motion</p>
<p><strong>Variational formulation</strong></p>
<p>The Navier–Stokes equations are more challenging than the time-dependent heat equation because they form a system of equations, rather than a single equation, and the system has a special structure</p>
<p>If we use the same approach as for the heat equation—replacing the time derivative with a simple difference quotient—we end up with a nonlinear system. Nonlinearity itself is not a problem, as we have already seen in the nonlinear Poisson equation</p>
<p>The main difficulty comes from the saddle point structure of the system. Intuitively, a saddle point system has competing constraints: in this case, the velocity and pressure fields are linked through the incompressibility condition <span class="math inline">\(\nabla \cdot u = 0\)</span>. This coupling makes standard solvers inefficient or unstable. To handle this efficiently, we need specialized iterative methods and preconditioners that respect the saddle point structure</p>
<p>Instead, we will apply a simpler and often highly efficient approach known as a <em>splitting method</em>. The idea is to treat the two equations in <span class="math inline">\(\eqref{eq:NS}\)</span> separately. There are many splitting strategies for the incompressible Navier-Stokes equations. One of the earliest is Chorin’s method. Here, we will use a modified version of Chorin’s method, the so-called incremental pressure correction scheme (IPCS), which provides improved accuracy compared to the original scheme at little additional cost</p>
<p>The IPCS scheme involves three steps. First, we compute a tentative velocity <span class="math inline">\(u^*\)</span> by advancing the momentum equation using a midpoint finite difference scheme in time, but with the pressure <span class="math inline">\(p^n\)</span> from the previous time step. The nonlinear convective term is linearized by using the known velocity <span class="math inline">\(u^n\)</span> from the previous step: <span class="math inline">\(u^n \cdot \nabla u^n\)</span>. Note that several alternative methods exist to linearize this term, such as the Adams-Bashforth method. The variational problem for the first step reads: for the <span class="math inline">\((n+1)\)</span>-th step, find <span class="math inline">\(u^*\)</span> such that</p>
<p><span class="math display">\[\begin{aligned}
\left\langle \rho \frac{u^*-u^n}{\Delta t}, v\right\rangle
    &amp;+ \left\langle \rho u^n\cdot \nabla u^n, v \right\rangle
    +\left\langle \sigma(u^{n+\frac{1}{2}}, p^n), \epsilon(v)\right\rangle\\
    &amp;+ \left\langle p^n n, v \right\rangle_{\partial\Omega}
    -\left\langle \mu \nabla u^{n+\frac{1}{2}}\cdot n, v \right \rangle_{\partial\Omega}=
    \left\langle f^{n+1}, v \right\rangle
\end{aligned}\tag{V1}\label{eq:NS-v1}\]</span></p>
<p>This notation, which is particularly useful for problems involving many terms in the variational formulation, requires some explanation. First, we introduce the shorthand notation</p>
<p><span class="math display">\[\begin{aligned}
\langle v, w \rangle = \int_{\Omega} v w \, \mathrm{d}x, \quad
\langle v, w \rangle_{\partial\Omega} = \int_{\partial\Omega} v w \, \mathrm{d}s
\end{aligned}\]</span></p>
<p>This allows us to express the variational problem in a more compact form. Second, we introduce the notation <span class="math inline">\(u^{n+\frac{1}{2}}\)</span>, which refers to the value of <span class="math inline">\(u\)</span> at the midpoint of the time interval. This is usually approximated by the arithmetic mean:</p>
<p><span class="math display">\[u^{n+\frac{1}{2}} \approx \frac{u^{n} + u^{n+1}}{2}\]</span></p>
<p>Third, we note that the variational problem <span class="math inline">\(\eqref{eq:NS-v1}\)</span> arises from the integration by parts of the term <span class="math inline">\(\langle -\nabla \cdot \sigma, v\rangle\)</span>. As in the linear elasticity problem, this yields</p>
<p><span class="math display">\[\langle -\nabla \cdot \sigma, v\rangle =
    \langle \sigma, \epsilon(v) \rangle
    - \langle T, v\rangle_{\partial \Omega}\]</span></p>
<p>where <span class="math inline">\(T = \sigma \cdot n\)</span> denotes the boundary traction. If we solve a problem with a free boundary, we may set <span class="math inline">\(T=0\)</span> on the boundary. However, in the case of flow through a channel or pipe, where we wish to model the continuation of the flow into an “imaginary channel” at the outflow, this term requires more careful treatment</p>
<p>In such situations, a common assumption is that the derivative of the velocity in the streamwise direction vanishes at the outflow. This corresponds to the flow being fully developed, meaning it does not change significantly downstream. Under this assumption, the remaining boundary term at the outflow becomes</p>
<p><span class="math display">\[pn - \mu \nabla u \cdot n\]</span></p>
<p>which is precisely the term appearing in the variational problem <span class="math inline">\(\eqref{eq:NS-v1}\)</span></p>
<p>It is important to note that both this argument and its implementation depend on the exact definition of <span class="math inline">\(\nabla u\)</span>: whether it is taken as the matrix with components <span class="math inline">\(\frac{\partial u_i}{\partial x_j}\)</span> or with components <span class="math inline">\(\frac{\partial u_j}{\partial x_i}\)</span>. In this work, we adopt the latter convention, <span class="math inline">\(\frac{\partial u_j}{\partial x_i}\)</span>, which corresponds to using the <code>UFL</code> operator <code>nabla_grad</code>. If, instead, we use the operator <code>grad</code> (with the definition <span class="math inline">\(\frac{\partial u_i}{\partial x_j}\)</span>), then the boundary term must be written as</p>
<p><span class="math display">\[pn - \mu (\nabla u)^T \cdot n\]</span></p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class='callout-icon'></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>As noted in Linear elasticity implementation, the use of <code>nabla_grad</code> and <code>grad</code> must be interpreted with care. For the Navier–Stokes equations, it is particularly important to consider the convective term <span class="math inline">\(u \cdot \nabla u\)</span>, which should be understood as the vector <span class="math inline">\(w\)</span> with components</p>
<p><span class="math display">\[w_i = \sum_{j} \left(u_j \frac{\partial}{\partial x_j}\right) u_i = \sum_j u_j \frac{\partial u_i}{\partial x_j}\]</span></p>
<p>In <code>FEniCSx</code>, this term can be implemented either as <code>grad(u) *u</code>, which corresponds to <span class="math inline">\(\sum_j \frac{\partial u_i}{\partial x_j} u_j\)</span>, or as <code>dot(u, nabla_grad(u))</code>, which corresponds to <span class="math inline">\(\sum_i u_i \frac{\partial u_j}{\partial x_i}\)</span></p>
<p>In what follows, we adopt the notation <code>dot(u, nabla_grad(u))</code>, since it most closely matches the standard mathematical form <span class="math inline">\(u \cdot \nabla u\)</span></p>
</div>
</div>
<p>We now proceed to the second step of our splitting scheme for the incompressible Navier–Stokes equations. In the first step, we computed the tentative velocity <span class="math inline">\(u^*\)</span> using the pressure from the previous time step. We now use this tentative velocity to compute the updated pressure <span class="math inline">\(p^{n+1}\)</span>:</p>
<p><span class="math display">\[\langle \nabla p^{n+1}, \nabla q \rangle
    = \langle \nabla p^n, \nabla q \rangle
    - \frac{\rho}{\Delta t} \langle \nabla \cdot u^*, q \rangle
    \tag{V2}\label{eq:NS-v2}\]</span></p>
<p>Here, <span class="math inline">\(q\)</span> denotes a scalar-valued test function from the pressure space, whereas the test function <span class="math inline">\(v\)</span> in <span class="math inline">\(\eqref{eq:NS-v1}\)</span> is vector-valued and belongs to the velocity space</p>
<p>One way to interpret this step is as follows: subtract the Navier–Stokes momentum equation <span class="math inline">\(\eqref{eq:NS}\)</span> expressed in terms of the tentative velocity <span class="math inline">\(u^*\)</span> and the pressure <span class="math inline">\(p^n\)</span> from the same equation expressed in terms of the updated velocity <span class="math inline">\(u^{n+1}\)</span> and pressure <span class="math inline">\(p^{n+1}\)</span>. This yields</p>
<p><span class="math display">\[\frac{\rho (u^{n+1}-u^*)}{\Delta t} + \nabla p^{n+1} - \nabla p^n = 0
\tag{VT}\label{eq:NS-vT}
\]</span></p>
<p>Taking the divergence and imposing the incompressibility condition <span class="math inline">\(\nabla \cdot u^{n+1} = 0\)</span> from the Navier–Stokes continuity equation, we obtain</p>
<p><span class="math display">\[
- \frac{\rho \nabla \cdot u^*}{\Delta t} + \nabla^2 p^{n+1} - \nabla^2 p^n = 0
\]</span></p>
<p>which is a Poisson problem for the pressure <span class="math inline">\(p^{n+1}\)</span> and leads directly to the variational formulation <span class="math inline">\(\eqref{eq:NS-v2}\)</span></p>
<p>Finally, the corrected velocity <span class="math inline">\(u^{n+1}\)</span> is computed from <span class="math inline">\(\eqref{eq:NS-vT}\)</span>. Multiplying this equation by a test function <span class="math inline">\(v\)</span>, we obtain</p>
<p><span class="math display">\[\rho \langle (u^{n+1} - u^*), v \rangle
    = - \Delta t \langle \nabla(p^{n+1} - p^n), v \rangle
     \tag{V3}\label{eq:NS-v3}\]</span></p>
<p>In summary, the incompressible Navier–Stokes equations can be solved efficiently by computing, at each time step, a sequence of three linear variational problems</p>
<section id="channel-flow-poiseuille-flow" class="level4" data-number="K.7.5.1">
<h4 data-number="K.7.5.1"><span class="header-section-number">K.7.5.1</span> Channel flow (Poiseuille flow)</h4>
<p>In this section, you will learn how to:</p>
<ul>
<li>Solve the Navier–Stokes problem using a splitting scheme</li>
<li>Visualize functions from higher-order Lagrangian spaces</li>
</ul>
<p>We will consider the flow between two infinite parallel plates, known as channel flow or Poiseuille flow. As we shall see, this problem admits an analytical solution. Let <span class="math inline">\(H\)</span> denote the distance between the plates and <span class="math inline">\(L\)</span> the length of the channel. We assume that no body forces are present</p>
<p>We first scale the problem to eliminate seemingly independent physical parameters. Since the physics of this flow is governed solely by viscous effects in the direction perpendicular to the flow, the natural time scale is based on diffusion across the channel: <span class="math inline">\(t_v = H^2 / \nu\)</span>. We choose <span class="math inline">\(U\)</span> (a characteristic inflow velocity) as the velocity scale and <span class="math inline">\(H\)</span> as the spatial scale. For the pressure scale, we take the characteristic shear stress, <span class="math inline">\(\mu U / H\)</span>, since this problem is a canonical example of shear-driven flow</p>
<p>Introducing the nondimensional variables</p>
<p><span class="math display">\[\begin{aligned}
  \bar{t} &amp;= \frac{t}{t_v} = \frac{\nu t}{H^2} \\
  \bar{x} &amp;= \frac{x}{H}, \;
  \bar{y} = \frac{y}{H}, \;
  \bar{z} = \frac{z}{H} \\
  \bar{u} &amp;= \frac{u}{U}, \;
  \bar{p} = \frac{H p}{\mu U}
\end{aligned}\]</span></p>
<p>and substituting into the governing equations, we obtain the nondimensional Navier–Stokes equations (where we drop the bars for simplicity):</p>
<p><span class="math display">\[\begin{aligned}
\frac{\partial u}{\partial t} + \mathrm{Re}\, u \cdot \nabla u
&amp;= -\nabla p + \nabla^2 u\\
\nabla \cdot u &amp;= 0
\end{aligned}\]</span></p>
<p>Here, <span class="math inline">\(\mathrm{Re} = \rho U H / \mu\)</span> is the Reynolds number. Because the time and pressure scales differ from those in convection-dominated flows, the Reynolds number appears in association with the convective term rather than the viscous term</p>
<p>The exact solution can be derived by assuming <span class="math inline">\(u = (u_x(x,y,z), 0, 0)\)</span>, with the <span class="math inline">\(x\)</span>-axis aligned with the channel. Since <span class="math inline">\(\nabla \cdot u = 0\)</span>, the velocity cannot depend on <span class="math inline">\(x\)</span> (<span class="math inline">\(u=(u_x(y, z), 0, 0)\)</span>)</p>
<p>The physics of channel flow is two-dimensional, so we may omit the <span class="math inline">\(z\)</span>-coordinate (more precisely, we set <span class="math inline">\(\partial/\partial z = 0\)</span>). Substituting <span class="math inline">\(u = (u_x, 0, 0)\)</span> into the scaled governing equations gives</p>
<p><span class="math display">\[\frac{\partial^2 u_x}{\partial y^2 } = \frac{\partial p}{\partial x}\]</span></p>
<p>Differentiating this equation with respect to <span class="math inline">\(x\)</span> yields</p>
<p><span class="math display">\[\frac{\partial^2 p}{\partial x^2} = 0\]</span></p>
<p>so <span class="math inline">\(\partial p / \partial x\)</span> is constant. We denote this constant by <span class="math inline">\(-\beta\)</span>, which represents the driving force of the flow and can be specified as a parameter in the problem</p>
<p>Integrating <span class="math inline">\(\partial^2 u_x(y) / \partial y^2 = -\beta\)</span> across the channel width <span class="math inline">\([0,1]\)</span> and imposing the no-slip condition <span class="math inline">\(u = (0,0,0)\)</span> at the channel walls gives</p>
<p><span class="math display">\[u_x(y) = \tfrac{1}{2} \beta y(1-y)\]</span></p>
<p>The characteristic velocity <span class="math inline">\(U\)</span> can be defined as the maximum inflow at <span class="math inline">\(y = 0.5\)</span>, which implies <span class="math inline">\(\beta = 8\)</span>. The channel length, <span class="math inline">\(L/H\)</span> in the scaled model, does not affect the solution, so for simplicity we restrict the computation to the unit square</p>
<p>From a mathematical perspective, the pressure must be prescribed at a point for uniqueness. However, since <span class="math inline">\(p\)</span> is independent of <span class="math inline">\(y\)</span>, we can set it to a known value (e.g., zero) along the outlet boundary <span class="math inline">\(x = 1\)</span>. The resulting solution is</p>
<p><span class="math display">\[p(x) = 8(1-x), \quad u_x(y) = 4y(1-y)\]</span></p>
<p>The boundary conditions can be prescribed as <span class="math inline">\(p = 8\)</span> at <span class="math inline">\(x = 0\)</span>, <span class="math inline">\(p = 0\)</span> at <span class="math inline">\(x = 1\)</span>, and <span class="math inline">\(u = (0,0,0)\)</span> on the walls <span class="math inline">\(y = 0,1\)</span>. This setup defines the pressure drop and yields a unit maximum velocity at both the inlet and outlet, along with a parabolic velocity profile, without requiring any further specifications</p>
<p>It is worth noting that the Navier–Stokes equations are only meaningful to solve in two- or three-dimensional geometries, even though in this case the underlying mathematical problem reduces to two one-dimensional problems: one for <span class="math inline">\(u_x(y)\)</span> and one for <span class="math inline">\(p(x)\)</span></p>
<p>The scaled model is not straightforward to simulate using a standard dimensional Navier–Stokes solver. However, since the convection term vanishes, the Reynolds number coefficient in front of this term in the scaled PDEs is irrelevant and can be set to unity. In that case, setting <span class="math inline">\(\rho=\mu=1\)</span> in the original Navier–Stokes equations reproduces the scaled model</p>
<p>For a specific engineering problem, one typically wants to simulate a particular fluid with its corresponding physical parameters. A general-purpose solver is therefore most naturally implemented in dimensional form, using the original physical parameters. However, nondimensionalization can greatly simplify numerical simulations. First, it reveals that all fluids behave in the same way: it does not matter whether oil, gas, or water flows between two plates, nor does the absolute flow speed matter—at least up to a critical Reynolds number beyond which the flow becomes unstable and transitions to turbulence of an entirely different nature. This means that a single simulation can effectively represent all types of channel flow. In other applications, nondimensionalization shows that it may be sufficient to prescribe only certain parameter ratios (dimensionless numbers) rather than the parameters themselves. This approach simplifies exploration of the input parameter space, which is often the main purpose of simulation. In practice, the nondimensional problem is frequently solved by fixing some dimensional input parameters to convenient values (often unity)</p>
<p><strong>Implementation</strong></p>
<p>As in the previous example, we load the <code>DOLFINx</code> module together with the <code>mpi4py</code> module, create the unit square mesh, and specify the simulation time and temporal discretization</p>
<div id="ef56940b" class="cell" data-execution_count="105">
<div class="sourceCode" id="cb121"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb121-1"><a href="#cb121-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb121-2"><a href="#cb121-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb121-3"><a href="#cb121-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-4"><a href="#cb121-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb121-5"><a href="#cb121-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> petsc4py <span class="im">import</span> PETSc</span>
<span id="cb121-6"><a href="#cb121-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-7"><a href="#cb121-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem <span class="im">import</span> (Constant, Function, functionspace,</span>
<span id="cb121-8"><a href="#cb121-8" aria-hidden="true" tabindex="-1"></a>  assemble_scalar, dirichletbc, form, locate_dofs_geometrical)</span>
<span id="cb121-9"><a href="#cb121-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> (assemble_matrix, assemble_vector, </span>
<span id="cb121-10"><a href="#cb121-10" aria-hidden="true" tabindex="-1"></a>  apply_lifting, create_vector, set_bc)</span>
<span id="cb121-11"><a href="#cb121-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.io <span class="im">import</span> VTXWriter</span>
<span id="cb121-12"><a href="#cb121-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.mesh <span class="im">import</span> create_unit_square</span>
<span id="cb121-13"><a href="#cb121-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.plot <span class="im">import</span> vtk_mesh</span>
<span id="cb121-14"><a href="#cb121-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> basix.ufl <span class="im">import</span> element</span>
<span id="cb121-15"><a href="#cb121-15" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ufl <span class="im">import</span> (FacetNormal, Identity, TestFunction, TrialFunction,</span>
<span id="cb121-16"><a href="#cb121-16" aria-hidden="true" tabindex="-1"></a>  div, dot, ds, dx, inner, lhs, nabla_grad, rhs, sym)</span>
<span id="cb121-17"><a href="#cb121-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-18"><a href="#cb121-18" aria-hidden="true" tabindex="-1"></a>mesh <span class="op">=</span> create_unit_square(MPI.COMM_WORLD, <span class="dv">10</span>, <span class="dv">10</span>)</span>
<span id="cb121-19"><a href="#cb121-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb121-20"><a href="#cb121-20" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb121-21"><a href="#cb121-21" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb121-22"><a href="#cb121-22" aria-hidden="true" tabindex="-1"></a>num_steps <span class="op">=</span> <span class="dv">500</span></span>
<span id="cb121-23"><a href="#cb121-23" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> T <span class="op">/</span>num_steps</span></code></pre></div>
</div>
<p>Unlike in the previous demos, we will define our two function spaces using <code>ufl</code> element definitions as input</p>
<div id="8f9ebe8b" class="cell" data-execution_count="106">
<div class="sourceCode" id="cb122"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb122-1"><a href="#cb122-1" aria-hidden="true" tabindex="-1"></a>v_cg2 <span class="op">=</span> element(</span>
<span id="cb122-2"><a href="#cb122-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;Lagrange&quot;</span>, </span>
<span id="cb122-3"><a href="#cb122-3" aria-hidden="true" tabindex="-1"></a>  mesh.topology.cell_name(), </span>
<span id="cb122-4"><a href="#cb122-4" aria-hidden="true" tabindex="-1"></a>  <span class="dv">2</span>, </span>
<span id="cb122-5"><a href="#cb122-5" aria-hidden="true" tabindex="-1"></a>  shape<span class="op">=</span>(mesh.geometry.dim, )</span>
<span id="cb122-6"><a href="#cb122-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb122-7"><a href="#cb122-7" aria-hidden="true" tabindex="-1"></a>s_cg1 <span class="op">=</span> element(</span>
<span id="cb122-8"><a href="#cb122-8" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;Lagrange&quot;</span>, </span>
<span id="cb122-9"><a href="#cb122-9" aria-hidden="true" tabindex="-1"></a>  mesh.topology.cell_name(), </span>
<span id="cb122-10"><a href="#cb122-10" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1</span></span>
<span id="cb122-11"><a href="#cb122-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb122-12"><a href="#cb122-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb122-13"><a href="#cb122-13" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> functionspace(mesh, v_cg2)</span>
<span id="cb122-14"><a href="#cb122-14" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> functionspace(mesh, s_cg1)</span></code></pre></div>
</div>
<p>The first space, <code>V</code>, is a vector-valued function space for the velocity, while <code>Q</code> is a scalar-valued function space for the pressure. We use piecewise quadratic elements for the velocity and piecewise linear elements for the pressure. When creating the vector finite element, the dimension of the vector is set to the geometric dimension of the mesh</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class='callout-icon'></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>It is well known that certain finite element spaces are unstable for the Navier–Stokes equations, and even for the simpler Stokes equation. A prime example of an unstable pair is the use of continuous piecewise linear polynomials (first-order) for both velocity and pressure. Such an unstable choice typically produces solutions with spurious, non-physical oscillations in the pressure field. A simple remedy is to use continuous piecewise quadratic elements for the velocity and continuous piecewise linear elements for the pressure. This combination is known as the Taylor–Hood element. Note that spurious oscillations may also arise when using splitting methods with an unstable element pair</p>
</div>
</div>
<p>Since we are working with two different function spaces, we need to define two corresponding sets of trial and test functions:</p>
<div id="d7cabca2" class="cell" data-execution_count="107">
<div class="sourceCode" id="cb123"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb123-1"><a href="#cb123-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> TrialFunction(V)</span>
<span id="cb123-2"><a href="#cb123-2" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> TestFunction(V)</span>
<span id="cb123-3"><a href="#cb123-3" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> TrialFunction(Q)</span>
<span id="cb123-4"><a href="#cb123-4" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> TestFunction(Q)</span></code></pre></div>
</div>
<p>As we saw in the Linear Elasticity Problem, we can use Python functions to define the different Dirichlet boundary conditions. For this problem, we impose three Dirichlet conditions. First, we set <span class="math inline">\(u=0\)</span> at the channel walls, i.e., at <span class="math inline">\(y=0\)</span> and <span class="math inline">\(y=1\)</span>. In this case, we use <code>dolfinx.fem.locate_dofs_geometrical</code></p>
<div id="cd0db97a" class="cell" data-execution_count="108">
<div class="sourceCode" id="cb124"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb124-1"><a href="#cb124-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> walls(x):</span>
<span id="cb124-2"><a href="#cb124-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> np.logical_or(</span>
<span id="cb124-3"><a href="#cb124-3" aria-hidden="true" tabindex="-1"></a>    np.isclose(x[<span class="dv">1</span>], <span class="dv">0</span>), </span>
<span id="cb124-4"><a href="#cb124-4" aria-hidden="true" tabindex="-1"></a>    np.isclose(x[<span class="dv">1</span>], <span class="dv">1</span>)</span>
<span id="cb124-5"><a href="#cb124-5" aria-hidden="true" tabindex="-1"></a>  )</span></code></pre></div>
</div>
<div id="bdfe9571" class="cell" data-execution_count="109">
<div class="sourceCode" id="cb125"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb125-1"><a href="#cb125-1" aria-hidden="true" tabindex="-1"></a>wall_dofs <span class="op">=</span> locate_dofs_geometrical(V, walls)</span>
<span id="cb125-2"><a href="#cb125-2" aria-hidden="true" tabindex="-1"></a>u_noslip <span class="op">=</span> np.array((<span class="dv">0</span>,) <span class="op">*</span>mesh.geometry.dim, dtype<span class="op">=</span>PETSc.ScalarType)</span>
<span id="cb125-3"><a href="#cb125-3" aria-hidden="true" tabindex="-1"></a>bc_noslip <span class="op">=</span> dirichletbc(u_noslip, wall_dofs, V)</span></code></pre></div>
</div>
<p>Second, we will impose <span class="math inline">\(p=8\)</span> at the inflow boundary (<span class="math inline">\(x=0\)</span>)</p>
<div id="68e633fd" class="cell" data-execution_count="110">
<div class="sourceCode" id="cb126"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb126-1"><a href="#cb126-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> inflow(x):</span>
<span id="cb126-2"><a href="#cb126-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> np.isclose(x[<span class="dv">0</span>], <span class="dv">0</span>)</span></code></pre></div>
</div>
<div id="85d10ab3" class="cell" data-execution_count="111">
<div class="sourceCode" id="cb127"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb127-1"><a href="#cb127-1" aria-hidden="true" tabindex="-1"></a>inflow_dofs <span class="op">=</span> locate_dofs_geometrical(Q, inflow)</span>
<span id="cb127-2"><a href="#cb127-2" aria-hidden="true" tabindex="-1"></a>bc_inflow <span class="op">=</span> dirichletbc(PETSc.ScalarType(<span class="dv">8</span>), inflow_dofs, Q)</span></code></pre></div>
</div>
<p>Finally, we set <span class="math inline">\(p=0\)</span> at the outflow (<span class="math inline">\(x=1\)</span>). This creates a pressure gradient that accelerates the flow from the initial state of zero velocity. We then collect the velocity and pressure boundary conditions in Python lists, so they can be easily accessed in the subsequent computations</p>
<div id="3c5f3cae" class="cell" data-execution_count="112">
<div class="sourceCode" id="cb128"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb128-1"><a href="#cb128-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> outflow(x):</span>
<span id="cb128-2"><a href="#cb128-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> np.isclose(x[<span class="dv">0</span>], <span class="dv">1</span>)</span></code></pre></div>
</div>
<div id="949df53b" class="cell" data-execution_count="113">
<div class="sourceCode" id="cb129"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb129-1"><a href="#cb129-1" aria-hidden="true" tabindex="-1"></a>outflow_dofs <span class="op">=</span> locate_dofs_geometrical(Q, outflow)</span>
<span id="cb129-2"><a href="#cb129-2" aria-hidden="true" tabindex="-1"></a>bc_outflow <span class="op">=</span> dirichletbc(PETSc.ScalarType(<span class="dv">0</span>), outflow_dofs, Q)</span>
<span id="cb129-3"><a href="#cb129-3" aria-hidden="true" tabindex="-1"></a>bcu <span class="op">=</span> [bc_noslip]</span>
<span id="cb129-4"><a href="#cb129-4" aria-hidden="true" tabindex="-1"></a>bcp <span class="op">=</span> [bc_inflow, bc_outflow]</span></code></pre></div>
</div>
<p>We now turn to the definition of the three variational forms, one for each step in the IPCS scheme. Let us first consider the formulation of the initial variational problem and the associated parameters</p>
<div id="5a571124" class="cell" data-execution_count="114">
<div class="sourceCode" id="cb130"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb130-1"><a href="#cb130-1" aria-hidden="true" tabindex="-1"></a>u_n <span class="op">=</span> Function(V)</span>
<span id="cb130-2"><a href="#cb130-2" aria-hidden="true" tabindex="-1"></a>u_n.name <span class="op">=</span> <span class="st">&quot;u_n&quot;</span></span>
<span id="cb130-3"><a href="#cb130-3" aria-hidden="true" tabindex="-1"></a>U <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span>(u_n <span class="op">+</span>u)</span>
<span id="cb130-4"><a href="#cb130-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-5"><a href="#cb130-5" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> Constant(mesh, PETSc.ScalarType(dt))</span>
<span id="cb130-6"><a href="#cb130-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-7"><a href="#cb130-7" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> Constant(mesh, PETSc.ScalarType(<span class="dv">1</span>))</span>
<span id="cb130-8"><a href="#cb130-8" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> Constant(mesh, PETSc.ScalarType(<span class="dv">1</span>))</span>
<span id="cb130-9"><a href="#cb130-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb130-10"><a href="#cb130-10" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> FacetNormal(mesh)</span>
<span id="cb130-11"><a href="#cb130-11" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> Constant(mesh, PETSc.ScalarType((<span class="dv">0</span>, <span class="dv">0</span>)))</span></code></pre></div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class='callout-icon'></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Note that we have wrapped several parameters as constants. This reduces the compilation time of the variational formulations. By wrapping them as constants, we can later modify their values without requiring recompilation</p>
</div>
</div>
<p>The next step is to set up the variational form for the first stage. Since the variational problem contains a mix of known and unknown quantities, we adopt the following naming convention:</p>
<ul>
<li><code>u</code> (mathematically <span class="math inline">\(u^{n+1}\)</span>) denotes the trial function in the variational form</li>
<li><code>u_</code> represents the most recently computed approximation (<span class="math inline">\(u^{n+1}\)</span> available as a Function object)</li>
<li><code>u_n</code> corresponds to <span class="math inline">\(u^n\)</span></li>
<li>The same convention applies to <code>p</code>, <code>p_</code> (<span class="math inline">\(p^{n+1}\)</span>), and <code>p_n</code> (<span class="math inline">\(p^n\)</span>)</li>
</ul>
<div id="bef956b6" class="cell" data-execution_count="115">
<div class="sourceCode" id="cb131"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb131-1"><a href="#cb131-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define strain-rate tensor</span></span>
<span id="cb131-2"><a href="#cb131-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> epsilon(u):</span>
<span id="cb131-3"><a href="#cb131-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sym(nabla_grad(u))</span>
<span id="cb131-4"><a href="#cb131-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-5"><a href="#cb131-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Define stress tensor</span></span>
<span id="cb131-6"><a href="#cb131-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sigma(u, p):</span>
<span id="cb131-7"><a href="#cb131-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">2</span> <span class="op">*</span>mu <span class="op">*</span>epsilon(u) <span class="op">-</span>p <span class="op">*</span>Identity(<span class="bu">len</span>(u))</span>
<span id="cb131-8"><a href="#cb131-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-9"><a href="#cb131-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the variational problem for the first step</span></span>
<span id="cb131-10"><a href="#cb131-10" aria-hidden="true" tabindex="-1"></a>p_n <span class="op">=</span> Function(Q)</span>
<span id="cb131-11"><a href="#cb131-11" aria-hidden="true" tabindex="-1"></a>p_n.name <span class="op">=</span> <span class="st">&quot;p_n&quot;</span></span>
<span id="cb131-12"><a href="#cb131-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-13"><a href="#cb131-13" aria-hidden="true" tabindex="-1"></a>F1 <span class="op">=</span> rho <span class="op">*</span>dot((u <span class="op">-</span>u_n) <span class="op">/</span>k, v) <span class="op">*</span>dx</span>
<span id="cb131-14"><a href="#cb131-14" aria-hidden="true" tabindex="-1"></a>F1 <span class="op">+=</span> rho <span class="op">*</span>dot(dot(u_n, nabla_grad(u_n)), v) <span class="op">*</span>dx</span>
<span id="cb131-15"><a href="#cb131-15" aria-hidden="true" tabindex="-1"></a>F1 <span class="op">+=</span> inner(sigma(U, p_n), epsilon(v)) <span class="op">*</span>dx</span>
<span id="cb131-16"><a href="#cb131-16" aria-hidden="true" tabindex="-1"></a>F1 <span class="op">+=</span> dot(p_n <span class="op">*</span>n, v) <span class="op">*</span>ds <span class="op">-</span>dot(mu <span class="op">*</span>nabla_grad(U) <span class="op">*</span>n, v) <span class="op">*</span>ds</span>
<span id="cb131-17"><a href="#cb131-17" aria-hidden="true" tabindex="-1"></a>F1 <span class="op">-=</span> dot(f, v) <span class="op">*</span>dx</span>
<span id="cb131-18"><a href="#cb131-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb131-19"><a href="#cb131-19" aria-hidden="true" tabindex="-1"></a>a1 <span class="op">=</span> form(lhs(F1))</span>
<span id="cb131-20"><a href="#cb131-20" aria-hidden="true" tabindex="-1"></a>L1 <span class="op">=</span> form(rhs(F1))</span></code></pre></div>
</div>
<p>Note that we have used the <code>ufl</code> functions <code>lhs</code> and <code>rhs</code> to extract the bilinear form <span class="math inline">\(a(u,v)\)</span> and the linear form <span class="math inline">\(L(v)\)</span>. This is particularly convenient for longer and more complex variational formulations. With our chosen discretization, <span class="math inline">\(a(u,v)\)</span> (<code>a1</code>) is not time-dependent and therefore needs to be assembled only once, whereas the right-hand side depends on the solution from the previous time step (<code>u_n</code>). Consequently, as in the heat equation example, we create the matrix outside the time loop</p>
<div id="aa014c7f" class="cell" data-execution_count="116">
<div class="sourceCode" id="cb132"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb132-1"><a href="#cb132-1" aria-hidden="true" tabindex="-1"></a>A1 <span class="op">=</span> assemble_matrix(a1, bcs<span class="op">=</span>bcu)</span>
<span id="cb132-2"><a href="#cb132-2" aria-hidden="true" tabindex="-1"></a>A1.assemble()</span>
<span id="cb132-3"><a href="#cb132-3" aria-hidden="true" tabindex="-1"></a>b1 <span class="op">=</span> create_vector(L1)</span></code></pre></div>
</div>
<p>Next, we set up the variational formulations and data structures for the second and third steps of the IPCS scheme, following the same approach as in the first step</p>
<div id="51ada250" class="cell" data-execution_count="117">
<div class="sourceCode" id="cb133"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb133-1"><a href="#cb133-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define variational problem for step 2</span></span>
<span id="cb133-2"><a href="#cb133-2" aria-hidden="true" tabindex="-1"></a>u_ <span class="op">=</span> Function(V)</span>
<span id="cb133-3"><a href="#cb133-3" aria-hidden="true" tabindex="-1"></a>a2 <span class="op">=</span> form(dot(nabla_grad(p), nabla_grad(q)) <span class="op">*</span>dx)</span>
<span id="cb133-4"><a href="#cb133-4" aria-hidden="true" tabindex="-1"></a>L2 <span class="op">=</span> form(dot(nabla_grad(p_n), nabla_grad(q)) <span class="op">*</span>dx <span class="op">-</span>(rho <span class="op">/</span>k) <span class="op">*</span>div(u_) <span class="op">*</span>q <span class="op">*</span>dx)</span>
<span id="cb133-5"><a href="#cb133-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-6"><a href="#cb133-6" aria-hidden="true" tabindex="-1"></a>A2 <span class="op">=</span> assemble_matrix(a2, bcs<span class="op">=</span>bcp)</span>
<span id="cb133-7"><a href="#cb133-7" aria-hidden="true" tabindex="-1"></a>A2.assemble()</span>
<span id="cb133-8"><a href="#cb133-8" aria-hidden="true" tabindex="-1"></a>b2 <span class="op">=</span> create_vector(L2)</span>
<span id="cb133-9"><a href="#cb133-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-10"><a href="#cb133-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Define variational problem for step 3</span></span>
<span id="cb133-11"><a href="#cb133-11" aria-hidden="true" tabindex="-1"></a>p_ <span class="op">=</span> Function(Q)</span>
<span id="cb133-12"><a href="#cb133-12" aria-hidden="true" tabindex="-1"></a>a3 <span class="op">=</span> form(rho <span class="op">*</span>dot(u, v) <span class="op">*</span>dx)</span>
<span id="cb133-13"><a href="#cb133-13" aria-hidden="true" tabindex="-1"></a>L3 <span class="op">=</span> form(rho <span class="op">*</span>dot(u_, v) <span class="op">*</span>dx <span class="op">-</span>k <span class="op">*</span>dot(nabla_grad(p_ <span class="op">-</span>p_n), v) <span class="op">*</span>dx)</span>
<span id="cb133-14"><a href="#cb133-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb133-15"><a href="#cb133-15" aria-hidden="true" tabindex="-1"></a>A3 <span class="op">=</span> assemble_matrix(a3)</span>
<span id="cb133-16"><a href="#cb133-16" aria-hidden="true" tabindex="-1"></a>A3.assemble()</span>
<span id="cb133-17"><a href="#cb133-17" aria-hidden="true" tabindex="-1"></a>b3 <span class="op">=</span> create_vector(L3)</span></code></pre></div>
</div>
<p>Now that the linear systems are ready, we can attach solvers to them using <code>PETSc</code>. Each step can have its own solution strategy. For the tentative velocity and pressure correction steps, we’ll go with the <code>BiCGStab</code> method and algebraic multigrid as a preconditioner. For the velocity update step, we’ll switch to the <code>CG</code>method with <code>SOR</code> (Gauss–Seidel) preconditioning</p>
<div id="e0c04552" class="cell" data-execution_count="118">
<div class="sourceCode" id="cb134"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb134-1"><a href="#cb134-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Solver for step 1</span></span>
<span id="cb134-2"><a href="#cb134-2" aria-hidden="true" tabindex="-1"></a>solver1 <span class="op">=</span> PETSc.KSP().create(mesh.comm)</span>
<span id="cb134-3"><a href="#cb134-3" aria-hidden="true" tabindex="-1"></a>solver1.setOperators(A1)</span>
<span id="cb134-4"><a href="#cb134-4" aria-hidden="true" tabindex="-1"></a>solver1.setType(PETSc.KSP.Type.BCGS)</span>
<span id="cb134-5"><a href="#cb134-5" aria-hidden="true" tabindex="-1"></a>pc1 <span class="op">=</span> solver1.getPC()</span>
<span id="cb134-6"><a href="#cb134-6" aria-hidden="true" tabindex="-1"></a>pc1.setType(PETSc.PC.Type.HYPRE)</span>
<span id="cb134-7"><a href="#cb134-7" aria-hidden="true" tabindex="-1"></a>pc1.setHYPREType(<span class="st">&quot;boomeramg&quot;</span>)</span>
<span id="cb134-8"><a href="#cb134-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-9"><a href="#cb134-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Solver for step 2</span></span>
<span id="cb134-10"><a href="#cb134-10" aria-hidden="true" tabindex="-1"></a>solver2 <span class="op">=</span> PETSc.KSP().create(mesh.comm)</span>
<span id="cb134-11"><a href="#cb134-11" aria-hidden="true" tabindex="-1"></a>solver2.setOperators(A2)</span>
<span id="cb134-12"><a href="#cb134-12" aria-hidden="true" tabindex="-1"></a>solver2.setType(PETSc.KSP.Type.BCGS)</span>
<span id="cb134-13"><a href="#cb134-13" aria-hidden="true" tabindex="-1"></a>pc2 <span class="op">=</span> solver2.getPC()</span>
<span id="cb134-14"><a href="#cb134-14" aria-hidden="true" tabindex="-1"></a>pc2.setType(PETSc.PC.Type.HYPRE)</span>
<span id="cb134-15"><a href="#cb134-15" aria-hidden="true" tabindex="-1"></a>pc2.setHYPREType(<span class="st">&quot;boomeramg&quot;</span>)</span>
<span id="cb134-16"><a href="#cb134-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb134-17"><a href="#cb134-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Solver for step 3</span></span>
<span id="cb134-18"><a href="#cb134-18" aria-hidden="true" tabindex="-1"></a>solver3 <span class="op">=</span> PETSc.KSP().create(mesh.comm)</span>
<span id="cb134-19"><a href="#cb134-19" aria-hidden="true" tabindex="-1"></a>solver3.setOperators(A3)</span>
<span id="cb134-20"><a href="#cb134-20" aria-hidden="true" tabindex="-1"></a>solver3.setType(PETSc.KSP.Type.CG)</span>
<span id="cb134-21"><a href="#cb134-21" aria-hidden="true" tabindex="-1"></a>pc3 <span class="op">=</span> solver3.getPC()</span>
<span id="cb134-22"><a href="#cb134-22" aria-hidden="true" tabindex="-1"></a>pc3.setType(PETSc.PC.Type.SOR)</span></code></pre></div>
</div>
<p>We prepare output files for the velocity and pressure and write the mesh along with the initial conditions to file</p>
<div id="5b41acf5" class="cell" data-execution_count="119">
<div class="sourceCode" id="cb135"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb135-1"><a href="#cb135-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb135-2"><a href="#cb135-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-3"><a href="#cb135-3" aria-hidden="true" tabindex="-1"></a>folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/ns&quot;</span>)</span>
<span id="cb135-4"><a href="#cb135-4" aria-hidden="true" tabindex="-1"></a>folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb135-5"><a href="#cb135-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb135-6"><a href="#cb135-6" aria-hidden="true" tabindex="-1"></a>vtx_u <span class="op">=</span> VTXWriter(mesh.comm, folder<span class="op">/</span><span class="st">&quot;poiseuille_u.bp&quot;</span>, u_n, engine<span class="op">=</span><span class="st">&quot;BP4&quot;</span>)</span>
<span id="cb135-7"><a href="#cb135-7" aria-hidden="true" tabindex="-1"></a>vtx_p <span class="op">=</span> VTXWriter(mesh.comm, folder<span class="op">/</span><span class="st">&quot;poiseuille_p.bp&quot;</span>, p_n, engine<span class="op">=</span><span class="st">&quot;BP4&quot;</span>)</span>
<span id="cb135-8"><a href="#cb135-8" aria-hidden="true" tabindex="-1"></a>vtx_u.write(t)</span>
<span id="cb135-9"><a href="#cb135-9" aria-hidden="true" tabindex="-1"></a>vtx_p.write(t)</span></code></pre></div>
</div>
<p>We also interpolate the analytical solution into our function space and set up a variational formulation to compute the <span class="math inline">\(L^2\)</span> error</p>
<div id="1bd456e2" class="cell" data-execution_count="120">
<div class="sourceCode" id="cb136"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb136-1"><a href="#cb136-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> u_exact(x):</span>
<span id="cb136-2"><a href="#cb136-2" aria-hidden="true" tabindex="-1"></a>  values <span class="op">=</span> np.zeros((<span class="dv">2</span>, x.shape[<span class="dv">1</span>]), dtype<span class="op">=</span>PETSc.ScalarType)</span>
<span id="cb136-3"><a href="#cb136-3" aria-hidden="true" tabindex="-1"></a>  values[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">4</span> <span class="op">*</span>x[<span class="dv">1</span>] <span class="op">*</span>(<span class="fl">1.0</span> <span class="op">-</span>x[<span class="dv">1</span>])</span>
<span id="cb136-4"><a href="#cb136-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> values</span>
<span id="cb136-5"><a href="#cb136-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-6"><a href="#cb136-6" aria-hidden="true" tabindex="-1"></a>u_ex <span class="op">=</span> Function(V)</span>
<span id="cb136-7"><a href="#cb136-7" aria-hidden="true" tabindex="-1"></a>u_ex.interpolate(u_exact)</span>
<span id="cb136-8"><a href="#cb136-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb136-9"><a href="#cb136-9" aria-hidden="true" tabindex="-1"></a>L2_error <span class="op">=</span> form(dot(u_ <span class="op">-</span>u_ex, u_ <span class="op">-</span>u_ex) <span class="op">*</span>dx)</span></code></pre></div>
</div>
<p>The next step is to set up the time-stepping loop. For all three steps, we only need to assemble the right-hand side and apply the boundary conditions using lifting, so that the solvers can use them at each time step</p>
<div id="56c0c602" class="cell" data-execution_count="121">
<div class="sourceCode" id="cb137"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb137-1"><a href="#cb137-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(num_steps):</span>
<span id="cb137-2"><a href="#cb137-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Update current time step</span></span>
<span id="cb137-3"><a href="#cb137-3" aria-hidden="true" tabindex="-1"></a>  t <span class="op">+=</span> dt</span>
<span id="cb137-4"><a href="#cb137-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-5"><a href="#cb137-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Step 1: Tentative veolcity step</span></span>
<span id="cb137-6"><a href="#cb137-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">with</span> b1.localForm() <span class="im">as</span> loc_1:</span>
<span id="cb137-7"><a href="#cb137-7" aria-hidden="true" tabindex="-1"></a>    loc_1.<span class="bu">set</span>(<span class="dv">0</span>)</span>
<span id="cb137-8"><a href="#cb137-8" aria-hidden="true" tabindex="-1"></a>  assemble_vector(b1, L1)</span>
<span id="cb137-9"><a href="#cb137-9" aria-hidden="true" tabindex="-1"></a>  apply_lifting(b1, [a1], [bcu])</span>
<span id="cb137-10"><a href="#cb137-10" aria-hidden="true" tabindex="-1"></a>  b1.ghostUpdate(</span>
<span id="cb137-11"><a href="#cb137-11" aria-hidden="true" tabindex="-1"></a>    addv<span class="op">=</span>PETSc.InsertMode.ADD_VALUES, </span>
<span id="cb137-12"><a href="#cb137-12" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">=</span>PETSc.ScatterMode.REVERSE</span>
<span id="cb137-13"><a href="#cb137-13" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb137-14"><a href="#cb137-14" aria-hidden="true" tabindex="-1"></a>  set_bc(b1, bcu)</span>
<span id="cb137-15"><a href="#cb137-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb137-16"><a href="#cb137-16" aria-hidden="true" tabindex="-1"></a>  solver1.solve(b1, u_.x.petsc_vec)</span>
<span id="cb137-17"><a href="#cb137-17" aria-hidden="true" tabindex="-1"></a>  u_.x.scatter_forward()</span>
<span id="cb137-18"><a href="#cb137-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-19"><a href="#cb137-19" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Step 2: Pressure corrrection step</span></span>
<span id="cb137-20"><a href="#cb137-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">with</span> b2.localForm() <span class="im">as</span> loc_2:</span>
<span id="cb137-21"><a href="#cb137-21" aria-hidden="true" tabindex="-1"></a>    loc_2.<span class="bu">set</span>(<span class="dv">0</span>)</span>
<span id="cb137-22"><a href="#cb137-22" aria-hidden="true" tabindex="-1"></a>  assemble_vector(b2, L2)</span>
<span id="cb137-23"><a href="#cb137-23" aria-hidden="true" tabindex="-1"></a>  apply_lifting(b2, [a2], [bcp])</span>
<span id="cb137-24"><a href="#cb137-24" aria-hidden="true" tabindex="-1"></a>  b2.ghostUpdate(</span>
<span id="cb137-25"><a href="#cb137-25" aria-hidden="true" tabindex="-1"></a>    addv<span class="op">=</span>PETSc.InsertMode.ADD_VALUES, </span>
<span id="cb137-26"><a href="#cb137-26" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">=</span>PETSc.ScatterMode.REVERSE</span>
<span id="cb137-27"><a href="#cb137-27" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb137-28"><a href="#cb137-28" aria-hidden="true" tabindex="-1"></a>  set_bc(b2, bcp)</span>
<span id="cb137-29"><a href="#cb137-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-30"><a href="#cb137-30" aria-hidden="true" tabindex="-1"></a>  solver2.solve(b2, p_.x.petsc_vec)</span>
<span id="cb137-31"><a href="#cb137-31" aria-hidden="true" tabindex="-1"></a>  p_.x.scatter_forward()</span>
<span id="cb137-32"><a href="#cb137-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-33"><a href="#cb137-33" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Step 3: Velocity correction step</span></span>
<span id="cb137-34"><a href="#cb137-34" aria-hidden="true" tabindex="-1"></a>  <span class="cf">with</span> b3.localForm() <span class="im">as</span> loc_3:</span>
<span id="cb137-35"><a href="#cb137-35" aria-hidden="true" tabindex="-1"></a>    loc_3.<span class="bu">set</span>(<span class="dv">0</span>)</span>
<span id="cb137-36"><a href="#cb137-36" aria-hidden="true" tabindex="-1"></a>  assemble_vector(b3, L3)</span>
<span id="cb137-37"><a href="#cb137-37" aria-hidden="true" tabindex="-1"></a>  b3.ghostUpdate(</span>
<span id="cb137-38"><a href="#cb137-38" aria-hidden="true" tabindex="-1"></a>    addv<span class="op">=</span>PETSc.InsertMode.ADD_VALUES, </span>
<span id="cb137-39"><a href="#cb137-39" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">=</span>PETSc.ScatterMode.REVERSE</span>
<span id="cb137-40"><a href="#cb137-40" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb137-41"><a href="#cb137-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-42"><a href="#cb137-42" aria-hidden="true" tabindex="-1"></a>  solver3.solve(b3, u_.x.petsc_vec)</span>
<span id="cb137-43"><a href="#cb137-43" aria-hidden="true" tabindex="-1"></a>  u_.x.scatter_forward()</span>
<span id="cb137-44"><a href="#cb137-44" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb137-45"><a href="#cb137-45" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Update variable with solution form this time step</span></span>
<span id="cb137-46"><a href="#cb137-46" aria-hidden="true" tabindex="-1"></a>  u_n.x.array[:] <span class="op">=</span> u_.x.array[:]</span>
<span id="cb137-47"><a href="#cb137-47" aria-hidden="true" tabindex="-1"></a>  p_n.x.array[:] <span class="op">=</span> p_.x.array[:]</span>
<span id="cb137-48"><a href="#cb137-48" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-49"><a href="#cb137-49" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Write solutions to file</span></span>
<span id="cb137-50"><a href="#cb137-50" aria-hidden="true" tabindex="-1"></a>  vtx_u.write(t)</span>
<span id="cb137-51"><a href="#cb137-51" aria-hidden="true" tabindex="-1"></a>  vtx_p.write(t)</span>
<span id="cb137-52"><a href="#cb137-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-53"><a href="#cb137-53" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Compute error at current time-step</span></span>
<span id="cb137-54"><a href="#cb137-54" aria-hidden="true" tabindex="-1"></a>  error_L2 <span class="op">=</span> np.sqrt(</span>
<span id="cb137-55"><a href="#cb137-55" aria-hidden="true" tabindex="-1"></a>    mesh.comm.allreduce(assemble_scalar(L2_error), </span>
<span id="cb137-56"><a href="#cb137-56" aria-hidden="true" tabindex="-1"></a>    op<span class="op">=</span>MPI.SUM)</span>
<span id="cb137-57"><a href="#cb137-57" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb137-58"><a href="#cb137-58" aria-hidden="true" tabindex="-1"></a>  error_max <span class="op">=</span> mesh.comm.allreduce(</span>
<span id="cb137-59"><a href="#cb137-59" aria-hidden="true" tabindex="-1"></a>    np.<span class="bu">max</span>(u_.x.petsc_vec.array <span class="op">-</span>u_ex.x.petsc_vec.array), </span>
<span id="cb137-60"><a href="#cb137-60" aria-hidden="true" tabindex="-1"></a>    op<span class="op">=</span>MPI.MAX</span>
<span id="cb137-61"><a href="#cb137-61" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb137-62"><a href="#cb137-62" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb137-63"><a href="#cb137-63" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Print error only every 20th step and at the last step</span></span>
<span id="cb137-64"><a href="#cb137-64" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> (i <span class="op">%</span> <span class="dv">20</span> <span class="op">==</span> <span class="dv">0</span>) <span class="kw">or</span> (i <span class="op">==</span> num_steps <span class="op">-</span><span class="dv">1</span>):</span>
<span id="cb137-65"><a href="#cb137-65" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Time </span><span class="sc">{</span>t<span class="sc">:.2f}</span><span class="ss">, L2-error </span><span class="sc">{</span>error_L2<span class="sc">:.2e}</span><span class="ss">, Max error </span><span class="sc">{</span>error_max<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span>
<span id="cb137-66"><a href="#cb137-66" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-67"><a href="#cb137-67" aria-hidden="true" tabindex="-1"></a><span class="co"># Close xmdf file</span></span>
<span id="cb137-68"><a href="#cb137-68" aria-hidden="true" tabindex="-1"></a>vtx_u.close()</span>
<span id="cb137-69"><a href="#cb137-69" aria-hidden="true" tabindex="-1"></a>vtx_p.close()</span>
<span id="cb137-70"><a href="#cb137-70" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-71"><a href="#cb137-71" aria-hidden="true" tabindex="-1"></a>b1.destroy()</span>
<span id="cb137-72"><a href="#cb137-72" aria-hidden="true" tabindex="-1"></a>b2.destroy()</span>
<span id="cb137-73"><a href="#cb137-73" aria-hidden="true" tabindex="-1"></a>b3.destroy()</span>
<span id="cb137-74"><a href="#cb137-74" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb137-75"><a href="#cb137-75" aria-hidden="true" tabindex="-1"></a>solver1.destroy()</span>
<span id="cb137-76"><a href="#cb137-76" aria-hidden="true" tabindex="-1"></a>solver2.destroy()</span>
<span id="cb137-77"><a href="#cb137-77" aria-hidden="true" tabindex="-1"></a>solver3.destroy()</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Time 0.02, L2-error 5.88e-01, Max error 1.60e-01
Time 0.42, L2-error 1.09e-02, Max error 1.28e-04
Time 0.82, L2-error 2.11e-04, Max error 2.65e-04
Time 1.22, L2-error 1.98e-05, Max error 1.56e-04
Time 1.62, L2-error 9.53e-06, Max error 8.46e-05
Time 2.02, L2-error 5.89e-06, Max error 5.24e-05
Time 2.42, L2-error 4.55e-06, Max error 3.62e-05
Time 2.82, L2-error 3.99e-06, Max error 2.70e-05
Time 3.22, L2-error 3.71e-06, Max error 2.13e-05
Time 3.62, L2-error 3.55e-06, Max error 1.75e-05
Time 4.02, L2-error 3.46e-06, Max error 1.49e-05
Time 4.42, L2-error 3.41e-06, Max error 1.30e-05
Time 4.82, L2-error 3.37e-06, Max error 1.16e-05
Time 5.22, L2-error 3.35e-06, Max error 1.06e-05
Time 5.62, L2-error 3.34e-06, Max error 9.75e-06
Time 6.02, L2-error 3.33e-06, Max error 9.11e-06
Time 6.42, L2-error 3.32e-06, Max error 8.92e-06
Time 6.82, L2-error 3.32e-06, Max error 8.92e-06
Time 7.22, L2-error 3.32e-06, Max error 9.05e-06
Time 7.62, L2-error 3.31e-06, Max error 9.26e-06
Time 8.02, L2-error 3.31e-06, Max error 9.44e-06
Time 8.42, L2-error 3.31e-06, Max error 9.58e-06
Time 8.82, L2-error 3.31e-06, Max error 9.69e-06
Time 9.22, L2-error 3.31e-06, Max error 9.79e-06
Time 9.62, L2-error 3.31e-06, Max error 9.86e-06
Time 10.00, L2-error 3.31e-06, Max error 1.05e-05</code></pre>
</div>
<div class="cell-output cell-output-display" data-execution_count="120">
<pre><code>&lt;petsc4py.PETSc.KSP at 0x322fd7b00&gt;</code></pre>
</div>
</div>
<p><strong>Verification</strong></p>
<p>As in the previous problems, we compute the error at each degree of freedom as well as the <span class="math inline">\(L^2(\Omega)\)</span> error. We start from the initial condition <span class="math inline">\(u=(0,0)\)</span>. Although we have not explicitly specified the initial condition, <code>FEniCSx</code> initializes all Functions—including <code>u_n</code> and <code>u_</code>—to zero. Since the exact solution is quadratic, we expect the error to reach machine precision in a finite time. In our implementation, we observe that the error quickly approaches zero and is around <span class="math inline">\(10^{-6}\)</span> at <span class="math inline">\(T=10\)</span>, which means the solution is basically exact by this time</p>
<p><strong>Visualization of vectors</strong></p>
<p>We have already seen how to plot higher-order functions and vector functions. In this section, we’ll focus on visualizing vector functions using glyphs, rather than by warping the mesh</p>
<div id="888b3860" class="cell" data-execution_count="122">
<div class="sourceCode" id="cb140"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb140-1"><a href="#cb140-1" aria-hidden="true" tabindex="-1"></a>topology, cell_types, geometry <span class="op">=</span> vtk_mesh(V)</span>
<span id="cb140-2"><a href="#cb140-2" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> np.zeros((geometry.shape[<span class="dv">0</span>], <span class="dv">3</span>), dtype<span class="op">=</span>np.float64)</span>
<span id="cb140-3"><a href="#cb140-3" aria-hidden="true" tabindex="-1"></a>values[:, :<span class="bu">len</span>(u_n)] <span class="op">=</span> u_n.x.array.real.reshape((geometry.shape[<span class="dv">0</span>], <span class="bu">len</span>(u_n)))</span>
<span id="cb140-4"><a href="#cb140-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-5"><a href="#cb140-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a point cloud of glyphs</span></span>
<span id="cb140-6"><a href="#cb140-6" aria-hidden="true" tabindex="-1"></a>function_grid <span class="op">=</span> pyvista.UnstructuredGrid(topology, cell_types, geometry)</span>
<span id="cb140-7"><a href="#cb140-7" aria-hidden="true" tabindex="-1"></a>function_grid[<span class="st">&quot;u&quot;</span>] <span class="op">=</span> values</span>
<span id="cb140-8"><a href="#cb140-8" aria-hidden="true" tabindex="-1"></a>glyphs <span class="op">=</span> function_grid.glyph(orient<span class="op">=</span><span class="st">&quot;u&quot;</span>, factor<span class="op">=</span><span class="fl">0.2</span>)</span>
<span id="cb140-9"><a href="#cb140-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-10"><a href="#cb140-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a pyvista-grid for the mesh</span></span>
<span id="cb140-11"><a href="#cb140-11" aria-hidden="true" tabindex="-1"></a>mesh.topology.create_connectivity(mesh.topology.dim, mesh.topology.dim)</span>
<span id="cb140-12"><a href="#cb140-12" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> pyvista.UnstructuredGrid(<span class="op">*</span>vtk_mesh(mesh, mesh.topology.dim))</span>
<span id="cb140-13"><a href="#cb140-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-14"><a href="#cb140-14" aria-hidden="true" tabindex="-1"></a><span class="co"># Create plotter</span></span>
<span id="cb140-15"><a href="#cb140-15" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb140-16"><a href="#cb140-16" aria-hidden="true" tabindex="-1"></a>plotter.add_mesh(grid, style<span class="op">=</span><span class="st">&quot;wireframe&quot;</span>, color<span class="op">=</span><span class="st">&quot;k&quot;</span>)</span>
<span id="cb140-17"><a href="#cb140-17" aria-hidden="true" tabindex="-1"></a>plotter.add_mesh(glyphs, scalar_bar_args<span class="op">=</span>{<span class="st">&quot;title&quot;</span>: <span class="st">&quot;u_x&quot;</span>})</span>
<span id="cb140-18"><a href="#cb140-18" aria-hidden="true" tabindex="-1"></a>plotter.view_xy()</span>
<span id="cb140-19"><a href="#cb140-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-20"><a href="#cb140-20" aria-hidden="true" tabindex="-1"></a><span class="co"># if not pyvista.OFF_SCREEN:</span></span>
<span id="cb140-21"><a href="#cb140-21" aria-hidden="true" tabindex="-1"></a><span class="co">#   plotter.show()</span></span>
<span id="cb140-22"><a href="#cb140-22" aria-hidden="true" tabindex="-1"></a><span class="co"># else:</span></span>
<span id="cb140-23"><a href="#cb140-23" aria-hidden="true" tabindex="-1"></a><span class="co">#   plotter.screenshot(folder/&quot;glyphs.png&quot;)</span></span>
<span id="cb140-24"><a href="#cb140-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb140-25"><a href="#cb140-25" aria-hidden="true" tabindex="-1"></a><span class="co"># HTML 저장</span></span>
<span id="cb140-26"><a href="#cb140-26" aria-hidden="true" tabindex="-1"></a>plotter.export_html(folder<span class="op">/</span><span class="st">&quot;glyphs.html&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/ns/glyphs.html"
        width="100%" height="400px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
<!-- #### Flow past a cylinder (@sec-fenicsx-flow-past-a-cylinder) -->
</section>
<section id="sec-fenicsx-flow-past-a-cylinder" class="level4" data-number="K.7.5.2">
<h4 data-number="K.7.5.2"><span class="header-section-number">K.7.5.2</span> Flow past a cylinder</h4>
<p>Author: Jørgen S. Dokken — Modifications by Kee-Youn Yoo</p>
<p>In this section, we consider a slightly more challenging problem: flow past a cylinder. The geometry and parameters are taken from the <a href="https://wwwold.mathematik.tu-dortmund.de/~featflow/en/benchmarks/cfdbenchmarking/flow/dfg_benchmark3_re100.html">DFG 2D-3 benchmark</a> in FeatFlow</p>
<p>To solve this problem efficiently and ensure numerical stability, we replace the first-order backward difference scheme with a Crank–Nicolson time discretization, combined with a semi-implicit Adams–Bashforth approximation of the nonlinear term</p>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class='callout-icon'></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>This demo is computationally demanding, with a run time of up to 15 minutes, as it uses parameters from the DFG 2D-3 benchmark, which consists of 12,800 time steps. It is advised to download this demo rather than running it in a browser. The run time can be reduced by using 2 or 3 MPI processes</p>
</div>
</div>
<p>The computational geometry chosen for this example is <img src="figures/turek.png" class="img-fluid" alt="Fluid channel with a circular obstacle" /></p>
<p>The kinematic viscosity is given by <span class="math inline">\(\nu = 0.001 = \frac{\mu}{\rho}\)</span>, and the inflow velocity profile is specified as</p>
<p><span class="math display">\[
u(x,y,t) = \left( \frac{4U(t)y(0.41-y)}{0.41^2}, 0 \right)
\]</span></p>
<p>where <span class="math display">\[
U(t) = 1.5 \sin\left(\tfrac{\pi t}{8}\right)
\]</span></p>
<p>This profile attains a maximum value of <span class="math inline">\(1.5\)</span> at <span class="math inline">\(y = 0.41/2\)</span>. No scaling is applied in this problem, since all parameters are given explicitly</p>
<p><strong>Mesh generation</strong></p>
<p>As in the Deflection of a Membrane example, we use <code>GMSH</code> to generate the mesh. We first create the rectangle and the obstacle</p>
<div id="40c6664f" class="cell" data-execution_count="123">
<div class="sourceCode" id="cb141"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb141-1"><a href="#cb141-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> sys</span>
<span id="cb141-2"><a href="#cb141-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-3"><a href="#cb141-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb141-4"><a href="#cb141-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb141-5"><a href="#cb141-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> tqdm.notebook <span class="im">import</span> tqdm</span>
<span id="cb141-6"><a href="#cb141-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-7"><a href="#cb141-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb141-8"><a href="#cb141-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> petsc4py <span class="im">import</span> PETSc</span>
<span id="cb141-9"><a href="#cb141-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> gmsh</span>
<span id="cb141-10"><a href="#cb141-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-11"><a href="#cb141-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.cpp.mesh <span class="im">import</span> to_type, cell_entity_type</span>
<span id="cb141-12"><a href="#cb141-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem <span class="im">import</span> (Constant, Function, functionspace,</span>
<span id="cb141-13"><a href="#cb141-13" aria-hidden="true" tabindex="-1"></a>  assemble_scalar, dirichletbc, form, locate_dofs_topological, set_bc)</span>
<span id="cb141-14"><a href="#cb141-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> (apply_lifting, assemble_matrix, </span>
<span id="cb141-15"><a href="#cb141-15" aria-hidden="true" tabindex="-1"></a>  assemble_vector, create_vector, create_matrix, set_bc)</span>
<span id="cb141-16"><a href="#cb141-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.mesh <span class="im">import</span> create_mesh, meshtags_from_entities</span>
<span id="cb141-17"><a href="#cb141-17" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.graph <span class="im">import</span> adjacencylist</span>
<span id="cb141-18"><a href="#cb141-18" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.geometry <span class="im">import</span> (bb_tree, compute_collisions_points, </span>
<span id="cb141-19"><a href="#cb141-19" aria-hidden="true" tabindex="-1"></a>  compute_colliding_cells)</span>
<span id="cb141-20"><a href="#cb141-20" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.io <span class="im">import</span> VTXWriter, distribute_entity_data, gmshio</span>
<span id="cb141-21"><a href="#cb141-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-22"><a href="#cb141-22" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> basix.ufl <span class="im">import</span> element</span>
<span id="cb141-23"><a href="#cb141-23" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ufl <span class="im">import</span> (FacetNormal, Identity, Measure, </span>
<span id="cb141-24"><a href="#cb141-24" aria-hidden="true" tabindex="-1"></a>  TestFunction, TrialFunction, as_vector, </span>
<span id="cb141-25"><a href="#cb141-25" aria-hidden="true" tabindex="-1"></a>  div, dot, ds, dx, inner, lhs, grad, nabla_grad, rhs, sym, system)</span>
<span id="cb141-26"><a href="#cb141-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-27"><a href="#cb141-27" aria-hidden="true" tabindex="-1"></a>mesh_comm <span class="op">=</span> MPI.COMM_WORLD</span>
<span id="cb141-28"><a href="#cb141-28" aria-hidden="true" tabindex="-1"></a>model_rank <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb141-29"><a href="#cb141-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-30"><a href="#cb141-30" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> gmsh.isInitialized():</span>
<span id="cb141-31"><a href="#cb141-31" aria-hidden="true" tabindex="-1"></a>    gmsh.initialize()</span>
<span id="cb141-32"><a href="#cb141-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-33"><a href="#cb141-33" aria-hidden="true" tabindex="-1"></a>gdim <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb141-34"><a href="#cb141-34" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="fl">2.2</span></span>
<span id="cb141-35"><a href="#cb141-35" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> <span class="fl">0.41</span></span>
<span id="cb141-36"><a href="#cb141-36" aria-hidden="true" tabindex="-1"></a>c_x <span class="op">=</span> c_y <span class="op">=</span> <span class="fl">0.2</span></span>
<span id="cb141-37"><a href="#cb141-37" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.05</span></span>
<span id="cb141-38"><a href="#cb141-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-39"><a href="#cb141-39" aria-hidden="true" tabindex="-1"></a><span class="co"># Ensure that mesh generation is performed only on</span></span>
<span id="cb141-40"><a href="#cb141-40" aria-hidden="true" tabindex="-1"></a><span class="co">#  the specified process (model_rank) in parallel runs,</span></span>
<span id="cb141-41"><a href="#cb141-41" aria-hidden="true" tabindex="-1"></a><span class="co">#  since Gmsh is not parallel-safe</span></span>
<span id="cb141-42"><a href="#cb141-42" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> mesh_comm.rank <span class="op">==</span> model_rank:</span>
<span id="cb141-43"><a href="#cb141-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-44"><a href="#cb141-44" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> dim, tag <span class="kw">in</span> gmsh.model.occ.getEntities(gdim):</span>
<span id="cb141-45"><a href="#cb141-45" aria-hidden="true" tabindex="-1"></a>    gmsh.model.occ.remove([(dim, tag)])</span>
<span id="cb141-46"><a href="#cb141-46" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb141-47"><a href="#cb141-47" aria-hidden="true" tabindex="-1"></a>  rectangle <span class="op">=</span> gmsh.model.occ.addRectangle(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, L, H, tag<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb141-48"><a href="#cb141-48" aria-hidden="true" tabindex="-1"></a>  obstacle <span class="op">=</span> gmsh.model.occ.addDisk(c_x, c_y, <span class="dv">0</span>, r, r)</span></code></pre></div>
</div>
<p>The next step is to subtract the obstacle from the channel, so that the interior of the circle is not meshed</p>
<div id="6c5fd38c" class="cell" data-execution_count="124">
<div class="sourceCode" id="cb142"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb142-1"><a href="#cb142-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> mesh_comm.rank <span class="op">==</span> model_rank:</span>
<span id="cb142-2"><a href="#cb142-2" aria-hidden="true" tabindex="-1"></a>  fluid <span class="op">=</span> gmsh.model.occ.cut([(gdim, rectangle)], [(gdim, obstacle)])</span>
<span id="cb142-3"><a href="#cb142-3" aria-hidden="true" tabindex="-1"></a>  gmsh.model.occ.synchronize()</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Info    : [  0%] Difference                                                                                  Info    : [ 10%] Difference                                                                                  Info    : [ 20%] Difference                                                                                  Info    : [ 30%] Difference - Performing Face-Face intersection                                                                                Info    : [ 70%] Difference - Performing intersection of shapes                                                                                Info    : [ 80%] Difference - Making faces                                                                                Info    : [ 90%] Difference - Adding holes                                                                                                                                                                </code></pre>
</div>
</div>
<p>To make <code>Gmsh</code> mesh the fluid domain, we add a physical volume marker</p>
<div id="6469130e" class="cell" data-execution_count="125">
<div class="sourceCode" id="cb144"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb144-1"><a href="#cb144-1" aria-hidden="true" tabindex="-1"></a><span class="co"># ID for the fluid domain</span></span>
<span id="cb144-2"><a href="#cb144-2" aria-hidden="true" tabindex="-1"></a>fluid_marker <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb144-3"><a href="#cb144-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-4"><a href="#cb144-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove any existing physical groups with the same (dim, tag)</span></span>
<span id="cb144-5"><a href="#cb144-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> dim, tag <span class="kw">in</span> gmsh.model.getPhysicalGroups():</span>
<span id="cb144-6"><a href="#cb144-6" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> dim <span class="op">==</span> gdim <span class="kw">and</span> tag <span class="op">==</span> fluid_marker:</span>
<span id="cb144-7"><a href="#cb144-7" aria-hidden="true" tabindex="-1"></a>        gmsh.model.removePhysicalGroups([(dim, tag)])</span>
<span id="cb144-8"><a href="#cb144-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-9"><a href="#cb144-9" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> mesh_comm.rank <span class="op">==</span> model_rank:</span>
<span id="cb144-10"><a href="#cb144-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># get all volume entities (2D: surfaces, 3D: volumes)</span></span>
<span id="cb144-11"><a href="#cb144-11" aria-hidden="true" tabindex="-1"></a>  volumes <span class="op">=</span> gmsh.model.getEntities(dim<span class="op">=</span>gdim)</span>
<span id="cb144-12"><a href="#cb144-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-13"><a href="#cb144-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ensure there is exactly one fluid region</span></span>
<span id="cb144-14"><a href="#cb144-14" aria-hidden="true" tabindex="-1"></a>  <span class="cf">assert</span> (<span class="bu">len</span>(volumes) <span class="op">==</span> <span class="dv">1</span>)</span>
<span id="cb144-15"><a href="#cb144-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-16"><a href="#cb144-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Register the volume as a physical group with marker = fluid_marker</span></span>
<span id="cb144-17"><a href="#cb144-17" aria-hidden="true" tabindex="-1"></a>  gmsh.model.addPhysicalGroup(</span>
<span id="cb144-18"><a href="#cb144-18" aria-hidden="true" tabindex="-1"></a>    volumes[<span class="dv">0</span>][<span class="dv">0</span>], </span>
<span id="cb144-19"><a href="#cb144-19" aria-hidden="true" tabindex="-1"></a>    [volumes[<span class="dv">0</span>][<span class="dv">1</span>]], </span>
<span id="cb144-20"><a href="#cb144-20" aria-hidden="true" tabindex="-1"></a>    fluid_marker</span>
<span id="cb144-21"><a href="#cb144-21" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb144-22"><a href="#cb144-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb144-23"><a href="#cb144-23" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Assign a human-readable name (&quot;Fluid&quot;) to this physical group</span></span>
<span id="cb144-24"><a href="#cb144-24" aria-hidden="true" tabindex="-1"></a>  gmsh.model.setPhysicalName(</span>
<span id="cb144-25"><a href="#cb144-25" aria-hidden="true" tabindex="-1"></a>    volumes[<span class="dv">0</span>][<span class="dv">0</span>], </span>
<span id="cb144-26"><a href="#cb144-26" aria-hidden="true" tabindex="-1"></a>    fluid_marker, </span>
<span id="cb144-27"><a href="#cb144-27" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;Fluid&quot;</span></span>
<span id="cb144-28"><a href="#cb144-28" aria-hidden="true" tabindex="-1"></a>  )</span></code></pre></div>
</div>
<p>To label the different surfaces of the mesh, we proceed as follows:</p>
<ol type="1">
<li>Assign marker 2 to the inflow (left-hand side)</li>
<li>Assign marker 3 to the outflow (right-hand side)</li>
<li>Assign marker 4 to the fluid walls</li>
<li>Assign marker 5 to the obstacle</li>
</ol>
<p>We determine the correct marker for each surface by computing the center of mass of each geometric entity. This way, we can automatically identify and label each boundary in the mesh</p>
<div id="5f6bf83f" class="cell" data-execution_count="126">
<div class="sourceCode" id="cb145"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb145-1"><a href="#cb145-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define boundary markers (unique IDs)</span></span>
<span id="cb145-2"><a href="#cb145-2" aria-hidden="true" tabindex="-1"></a>inlet_marker, outlet_marker, wall_marker, obstacle_marker <span class="op">=</span> <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>, <span class="dv">5</span></span>
<span id="cb145-3"><a href="#cb145-3" aria-hidden="true" tabindex="-1"></a>inflow, outflow, walls, obstacle <span class="op">=</span> [], [], [], []</span>
<span id="cb145-4"><a href="#cb145-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb145-5"><a href="#cb145-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> mesh_comm.rank <span class="op">==</span> model_rank:</span>
<span id="cb145-6"><a href="#cb145-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Extract all 1D boundary entities of the fluid volume</span></span>
<span id="cb145-7"><a href="#cb145-7" aria-hidden="true" tabindex="-1"></a>  boundaries <span class="op">=</span> gmsh.model.getBoundary(volumes, oriented<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb145-8"><a href="#cb145-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb145-9"><a href="#cb145-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Identify each boundary by its center of mass</span></span>
<span id="cb145-10"><a href="#cb145-10" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> boundary <span class="kw">in</span> boundaries:</span>
<span id="cb145-11"><a href="#cb145-11" aria-hidden="true" tabindex="-1"></a>    center_of_mass <span class="op">=</span> gmsh.model.occ.getCenterOfMass(</span>
<span id="cb145-12"><a href="#cb145-12" aria-hidden="true" tabindex="-1"></a>      boundary[<span class="dv">0</span>], </span>
<span id="cb145-13"><a href="#cb145-13" aria-hidden="true" tabindex="-1"></a>      boundary[<span class="dv">1</span>]</span>
<span id="cb145-14"><a href="#cb145-14" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb145-15"><a href="#cb145-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb145-16"><a href="#cb145-16" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Left boundary → Inlet</span></span>
<span id="cb145-17"><a href="#cb145-17" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.allclose(center_of_mass, [<span class="dv">0</span>, H <span class="op">/</span><span class="dv">2</span>, <span class="dv">0</span>]):</span>
<span id="cb145-18"><a href="#cb145-18" aria-hidden="true" tabindex="-1"></a>      inflow.append(boundary[<span class="dv">1</span>])</span>
<span id="cb145-19"><a href="#cb145-19" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Right boundary → Outlet</span></span>
<span id="cb145-20"><a href="#cb145-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> np.allclose(center_of_mass, [L, H <span class="op">/</span><span class="dv">2</span>, <span class="dv">0</span>]):</span>
<span id="cb145-21"><a href="#cb145-21" aria-hidden="true" tabindex="-1"></a>      outflow.append(boundary[<span class="dv">1</span>])</span>
<span id="cb145-22"><a href="#cb145-22" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Top/bottom → Walls</span></span>
<span id="cb145-23"><a href="#cb145-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> np.allclose(center_of_mass, [L <span class="op">/</span><span class="dv">2</span>, H, <span class="dv">0</span>]) <span class="kw">or</span> <span class="op">\</span></span>
<span id="cb145-24"><a href="#cb145-24" aria-hidden="true" tabindex="-1"></a>         np.allclose(center_of_mass, [L <span class="op">/</span><span class="dv">2</span>, <span class="dv">0</span>, <span class="dv">0</span>]):</span>
<span id="cb145-25"><a href="#cb145-25" aria-hidden="true" tabindex="-1"></a>      walls.append(boundary[<span class="dv">1</span>])</span>
<span id="cb145-26"><a href="#cb145-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Remaining boundary → Obstacle</span></span>
<span id="cb145-27"><a href="#cb145-27" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb145-28"><a href="#cb145-28" aria-hidden="true" tabindex="-1"></a>      obstacle.append(boundary[<span class="dv">1</span>])</span>
<span id="cb145-29"><a href="#cb145-29" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb145-30"><a href="#cb145-30" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Register boundaries as physical groups with human-readable names</span></span>
<span id="cb145-31"><a href="#cb145-31" aria-hidden="true" tabindex="-1"></a>  gmsh.model.addPhysicalGroup(<span class="dv">1</span>, walls, wall_marker)</span>
<span id="cb145-32"><a href="#cb145-32" aria-hidden="true" tabindex="-1"></a>  gmsh.model.setPhysicalName(<span class="dv">1</span>, wall_marker, <span class="st">&quot;Walls&quot;</span>)</span>
<span id="cb145-33"><a href="#cb145-33" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb145-34"><a href="#cb145-34" aria-hidden="true" tabindex="-1"></a>  gmsh.model.addPhysicalGroup(<span class="dv">1</span>, inflow, inlet_marker)</span>
<span id="cb145-35"><a href="#cb145-35" aria-hidden="true" tabindex="-1"></a>  gmsh.model.setPhysicalName(<span class="dv">1</span>, inlet_marker, <span class="st">&quot;Inlet&quot;</span>)</span>
<span id="cb145-36"><a href="#cb145-36" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb145-37"><a href="#cb145-37" aria-hidden="true" tabindex="-1"></a>  gmsh.model.addPhysicalGroup(<span class="dv">1</span>, outflow, outlet_marker)</span>
<span id="cb145-38"><a href="#cb145-38" aria-hidden="true" tabindex="-1"></a>  gmsh.model.setPhysicalName(<span class="dv">1</span>, outlet_marker, <span class="st">&quot;Outlet&quot;</span>)</span>
<span id="cb145-39"><a href="#cb145-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb145-40"><a href="#cb145-40" aria-hidden="true" tabindex="-1"></a>  gmsh.model.addPhysicalGroup(<span class="dv">1</span>, obstacle, obstacle_marker)</span>
<span id="cb145-41"><a href="#cb145-41" aria-hidden="true" tabindex="-1"></a>  gmsh.model.setPhysicalName(<span class="dv">1</span>, obstacle_marker, <span class="st">&quot;Obstacle&quot;</span>)</span></code></pre></div>
</div>
<p>In previous meshes, uniform element sizes were employed. In this example, variable mesh sizes are used to better capture the flow in the region of interest, particularly around the circular obstacle. This is accomplished using <code>Gmsh</code> fields</p>
<div id="aab59685" class="cell" data-execution_count="127">
<div class="sourceCode" id="cb146"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb146-1"><a href="#cb146-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define minimum element size near obstacle (1/3 of radius)</span></span>
<span id="cb146-2"><a href="#cb146-2" aria-hidden="true" tabindex="-1"></a>res_min <span class="op">=</span> r <span class="op">/</span><span class="dv">3</span></span>
<span id="cb146-3"><a href="#cb146-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-4"><a href="#cb146-4" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> mesh_comm.rank <span class="op">==</span> model_rank:</span>
<span id="cb146-5"><a href="#cb146-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Distance field: measure distance from obstacle edges</span></span>
<span id="cb146-6"><a href="#cb146-6" aria-hidden="true" tabindex="-1"></a>  distance_field <span class="op">=</span> gmsh.model.mesh.field.add(<span class="st">&quot;Distance&quot;</span>)</span>
<span id="cb146-7"><a href="#cb146-7" aria-hidden="true" tabindex="-1"></a>  gmsh.model.mesh.field.setNumbers(distance_field, <span class="st">&quot;EdgesList&quot;</span>, obstacle)</span>
<span id="cb146-8"><a href="#cb146-8" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb146-9"><a href="#cb146-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Threshold field: refine mesh based on distance</span></span>
<span id="cb146-10"><a href="#cb146-10" aria-hidden="true" tabindex="-1"></a>  threshold_field <span class="op">=</span> gmsh.model.mesh.field.add(<span class="st">&quot;Threshold&quot;</span>)</span>
<span id="cb146-11"><a href="#cb146-11" aria-hidden="true" tabindex="-1"></a>  gmsh.model.mesh.field.setNumber(threshold_field, <span class="st">&quot;IField&quot;</span>, distance_field)</span>
<span id="cb146-12"><a href="#cb146-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># fine near obstacle</span></span>
<span id="cb146-13"><a href="#cb146-13" aria-hidden="true" tabindex="-1"></a>  gmsh.model.mesh.field.setNumber(threshold_field, <span class="st">&quot;LcMin&quot;</span>, res_min)</span>
<span id="cb146-14"><a href="#cb146-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># coarse far away</span></span>
<span id="cb146-15"><a href="#cb146-15" aria-hidden="true" tabindex="-1"></a>  gmsh.model.mesh.field.setNumber(threshold_field, <span class="st">&quot;LcMax&quot;</span>, <span class="fl">0.25</span> <span class="op">*</span>H)</span>
<span id="cb146-16"><a href="#cb146-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># within radius → LcMin</span></span>
<span id="cb146-17"><a href="#cb146-17" aria-hidden="true" tabindex="-1"></a>  gmsh.model.mesh.field.setNumber(threshold_field, <span class="st">&quot;DistMin&quot;</span>, r)</span>
<span id="cb146-18"><a href="#cb146-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># beyond 2H → LcMax</span></span>
<span id="cb146-19"><a href="#cb146-19" aria-hidden="true" tabindex="-1"></a>  gmsh.model.mesh.field.setNumber(threshold_field, <span class="st">&quot;DistMax&quot;</span>, <span class="dv">2</span> <span class="op">*</span>H)</span>
<span id="cb146-20"><a href="#cb146-20" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb146-21"><a href="#cb146-21" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Min field: apply the smallest size rule if multiple fields exist</span></span>
<span id="cb146-22"><a href="#cb146-22" aria-hidden="true" tabindex="-1"></a>  min_field <span class="op">=</span> gmsh.model.mesh.field.add(<span class="st">&quot;Min&quot;</span>)</span>
<span id="cb146-23"><a href="#cb146-23" aria-hidden="true" tabindex="-1"></a>  gmsh.model.mesh.field.setNumbers(min_field, <span class="st">&quot;FieldsList&quot;</span>, [threshold_field])</span>
<span id="cb146-24"><a href="#cb146-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb146-25"><a href="#cb146-25" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Set background mesh: controls final mesh refinement</span></span>
<span id="cb146-26"><a href="#cb146-26" aria-hidden="true" tabindex="-1"></a>  gmsh.model.mesh.field.setAsBackgroundMesh(min_field)</span></code></pre></div>
</div>
<p><strong>Generating mesh</strong></p>
<p>We are now ready to generate the mesh. At this stage, we need to decide whether the mesh should consist of triangles or quadrilaterals. In this demo, to match the DFG 2D-3 benchmark, we use second-order quadrilateral elements</p>
<div id="82087ed0" class="cell" data-execution_count="128">
<div class="sourceCode" id="cb147"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb147-1"><a href="#cb147-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> mesh_comm.rank <span class="op">==</span> model_rank:</span>
<span id="cb147-2"><a href="#cb147-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Set mesh algorithm for quadrilaterals (Delquad/Delaunay)</span></span>
<span id="cb147-3"><a href="#cb147-3" aria-hidden="true" tabindex="-1"></a>  gmsh.option.setNumber(<span class="st">&quot;Mesh.Algorithm&quot;</span>, <span class="dv">8</span>)</span>
<span id="cb147-4"><a href="#cb147-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-5"><a href="#cb147-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Choose recombination algorithm (Blossom)</span></span>
<span id="cb147-6"><a href="#cb147-6" aria-hidden="true" tabindex="-1"></a>  gmsh.option.setNumber(<span class="st">&quot;Mesh.RecombinationAlgorithm&quot;</span>, <span class="dv">2</span>)</span>
<span id="cb147-7"><a href="#cb147-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-8"><a href="#cb147-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Apply recombination to all elements (triangles → quads)</span></span>
<span id="cb147-9"><a href="#cb147-9" aria-hidden="true" tabindex="-1"></a>  gmsh.option.setNumber(<span class="st">&quot;Mesh.RecombineAll&quot;</span>, <span class="dv">1</span>)</span>
<span id="cb147-10"><a href="#cb147-10" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb147-11"><a href="#cb147-11" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Set subdivision algorithm for recombined quads</span></span>
<span id="cb147-12"><a href="#cb147-12" aria-hidden="true" tabindex="-1"></a>  gmsh.option.setNumber(<span class="st">&quot;Mesh.SubdivisionAlgorithm&quot;</span>, <span class="dv">1</span>)</span>
<span id="cb147-13"><a href="#cb147-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-14"><a href="#cb147-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Generate the mesh for the given dimension</span></span>
<span id="cb147-15"><a href="#cb147-15" aria-hidden="true" tabindex="-1"></a>  gmsh.model.mesh.generate(gdim)</span>
<span id="cb147-16"><a href="#cb147-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-17"><a href="#cb147-17" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Upgrade mesh to second-order (quadratic) elements</span></span>
<span id="cb147-18"><a href="#cb147-18" aria-hidden="true" tabindex="-1"></a>  gmsh.model.mesh.setOrder(<span class="dv">2</span>)</span>
<span id="cb147-19"><a href="#cb147-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb147-20"><a href="#cb147-20" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Optimize mesh quality using Netgen optimizer</span></span>
<span id="cb147-21"><a href="#cb147-21" aria-hidden="true" tabindex="-1"></a>  gmsh.model.mesh.optimize(<span class="st">&quot;Netgen&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Info    : Meshing 1D...
Info    : [  0%] Meshing curve 5 (Ellipse)
Info    : [ 30%] Meshing curve 6 (Line)
Info    : [ 50%] Meshing curve 7 (Line)
Info    : [ 70%] Meshing curve 8 (Line)
Info    : [ 90%] Meshing curve 9 (Line)
Info    : Done meshing 1D (Wall 0.00672012s, CPU 0.011078s)
Info    : Meshing 2D...
Info    : Meshing surface 1 (Plane, Frontal-Delaunay for Quads)
Info    : Simple recombination completed (Wall 0.00162879s, CPU 0.002608s): 101 quads, 24 triangles, 0 invalid quads, 0 quads with Q &lt; 0.1, avg Q = 0.813901, min Q = 0.470126
Info    : Simple recombination completed (Wall 0.00268696s, CPU 0.004374s): 476 quads, 0 triangles, 0 invalid quads, 0 quads with Q &lt; 0.1, avg Q = 0.848887, min Q = 0.511467
Info    : Done meshing 2D (Wall 0.00837917s, CPU 0.013356s)
Info    : Refining mesh...
Info    : Meshing order 2 (curvilinear on)...
Info    : [  0%] Meshing curve 5 order 2
Info    : [ 20%] Meshing curve 6 order 2
Info    : [ 40%] Meshing curve 7 order 2
Info    : [ 60%] Meshing curve 8 order 2
Info    : [ 70%] Meshing curve 9 order 2
Info    : [ 90%] Meshing surface 1 order 2
Info    : Done meshing order 2 (Wall 0.00278633s, CPU 0.004618s)
Info    : Done refining mesh (Wall 0.00314025s, CPU 0.00521s)
Info    : 2016 nodes 2133 elements
Info    : Meshing order 2 (curvilinear on)...
Info    : [  0%] Meshing curve 5 order 2
Info    : [ 20%] Meshing curve 6 order 2
Info    : [ 40%] Meshing curve 7 order 2
Info    : [ 60%] Meshing curve 8 order 2
Info    : [ 70%] Meshing curve 9 order 2
Info    : [ 90%] Meshing surface 1 order 2
Info    : Done meshing order 2 (Wall 0.00956333s, CPU 0.015247s)
Info    : Optimizing mesh (Netgen)...
Info    : Done optimizing mesh (Wall 1.291e-06s, CPU 1e-06s)</code></pre>
</div>
</div>
<p><strong>Loading mesh and boundary markers</strong></p>
<p>Having generated the mesh, we now need to load it together with the corresponding facet markers into <code>DOLFINx</code>. We follow the same structure as in Deflection of a membrane, with the difference that facet markers are also loaded. For more details about the function used below, see <a href="https://jsdokken.com/src/tutorial_gmsh.html">A GMSH tutorial for DOLFINx</a></p>
<div id="ce4f7175" class="cell" data-execution_count="129">
<div class="sourceCode" id="cb149"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb149-1"><a href="#cb149-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Convert GMSH model to DOLFINx mesh and facet markers</span></span>
<span id="cb149-2"><a href="#cb149-2" aria-hidden="true" tabindex="-1"></a>mesh, _, ft <span class="op">=</span> gmshio.model_to_mesh(</span>
<span id="cb149-3"><a href="#cb149-3" aria-hidden="true" tabindex="-1"></a>  gmsh.model, </span>
<span id="cb149-4"><a href="#cb149-4" aria-hidden="true" tabindex="-1"></a>  mesh_comm, </span>
<span id="cb149-5"><a href="#cb149-5" aria-hidden="true" tabindex="-1"></a>  model_rank, </span>
<span id="cb149-6"><a href="#cb149-6" aria-hidden="true" tabindex="-1"></a>  gdim<span class="op">=</span>gdim</span>
<span id="cb149-7"><a href="#cb149-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb149-8"><a href="#cb149-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-9"><a href="#cb149-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Assign a human-readable name to the facet markers</span></span>
<span id="cb149-10"><a href="#cb149-10" aria-hidden="true" tabindex="-1"></a>ft.name <span class="op">=</span> <span class="st">&quot;Facet markers&quot;</span></span>
<span id="cb149-11"><a href="#cb149-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb149-12"><a href="#cb149-12" aria-hidden="true" tabindex="-1"></a>gmsh.finalize()</span></code></pre></div>
</div>
<div id="2e724991" class="cell" data-execution_count="130">
<div class="sourceCode" id="cb150"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb150-1"><a href="#cb150-1" aria-hidden="true" tabindex="-1"></a><span class="co"># For notebook only</span></span>
<span id="cb150-2"><a href="#cb150-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="st">&quot;ipykernel&quot;</span> <span class="kw">in</span> sys.modules:</span>
<span id="cb150-3"><a href="#cb150-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-4"><a href="#cb150-4" aria-hidden="true" tabindex="-1"></a>  <span class="im">import</span> pyvista</span>
<span id="cb150-5"><a href="#cb150-5" aria-hidden="true" tabindex="-1"></a>  <span class="im">from</span> dolfinx <span class="im">import</span> plot</span>
<span id="cb150-6"><a href="#cb150-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-7"><a href="#cb150-7" aria-hidden="true" tabindex="-1"></a>  V <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">2</span>))</span>
<span id="cb150-8"><a href="#cb150-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-9"><a href="#cb150-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Extract topology from mesh and create pyvista mesh</span></span>
<span id="cb150-10"><a href="#cb150-10" aria-hidden="true" tabindex="-1"></a>  topology, cell_types, x <span class="op">=</span> plot.vtk_mesh(V)</span>
<span id="cb150-11"><a href="#cb150-11" aria-hidden="true" tabindex="-1"></a>  grid <span class="op">=</span> pyvista.UnstructuredGrid(topology, cell_types, x)</span>
<span id="cb150-12"><a href="#cb150-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-13"><a href="#cb150-13" aria-hidden="true" tabindex="-1"></a>  plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb150-14"><a href="#cb150-14" aria-hidden="true" tabindex="-1"></a>  plotter.add_mesh(grid, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb150-15"><a href="#cb150-15" aria-hidden="true" tabindex="-1"></a>  plotter.add_axes()</span>
<span id="cb150-16"><a href="#cb150-16" aria-hidden="true" tabindex="-1"></a>  plotter.view_xy()</span>
<span id="cb150-17"><a href="#cb150-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-18"><a href="#cb150-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># if not pyvista.OFF_SCREEN:</span></span>
<span id="cb150-19"><a href="#cb150-19" aria-hidden="true" tabindex="-1"></a>  <span class="co">#   plotter.show()</span></span>
<span id="cb150-20"><a href="#cb150-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb150-21"><a href="#cb150-21" aria-hidden="true" tabindex="-1"></a>  <span class="co"># HTML 저장</span></span>
<span id="cb150-22"><a href="#cb150-22" aria-hidden="true" tabindex="-1"></a>  plotter.export_html(<span class="st">&quot;fenicsx/ns/flow_past_a_cylinder_mesh.html&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/ns/flow_past_a_cylinder_mesh.html"
        width="100%" height="350px"
        style="border:none;">
</iframe>
<p><strong>Physical and discretization parameters</strong></p>
<p>In accordance with the DGF-2 benchmark, the problem-specific parameters are defined</p>
<div id="ba29b180" class="cell" data-execution_count="131">
<div class="sourceCode" id="cb151"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb151-1"><a href="#cb151-1" aria-hidden="true" tabindex="-1"></a>t <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb151-2"><a href="#cb151-2" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> <span class="dv">8</span>                        <span class="co"># Final time</span></span>
<span id="cb151-3"><a href="#cb151-3" aria-hidden="true" tabindex="-1"></a>dt <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span><span class="dv">1600</span>                 <span class="co"># Time step size</span></span>
<span id="cb151-4"><a href="#cb151-4" aria-hidden="true" tabindex="-1"></a>num_steps <span class="op">=</span> <span class="bu">int</span>(T <span class="op">/</span>dt)</span>
<span id="cb151-5"><a href="#cb151-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb151-6"><a href="#cb151-6" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> Constant(mesh, PETSc.ScalarType(dt))</span>
<span id="cb151-7"><a href="#cb151-7" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> Constant(mesh, PETSc.ScalarType(<span class="fl">0.001</span>))  <span class="co"># Dynamic viscosity</span></span>
<span id="cb151-8"><a href="#cb151-8" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> Constant(mesh, PETSc.ScalarType(<span class="dv">1</span>))     <span class="co"># Density</span></span></code></pre></div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class='callout-icon'></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>Converting the notebook to a Python script and running it with <code>mpirun</code> considerably decreases the runtime</p>
</div>
</div>
<p><strong>Boundary conditions</strong></p>
<p>After creating the mesh and the corresponding mesh tags, we can define the function spaces <code>V</code> and <code>Q</code> together with the boundary conditions. Since <code>ft</code> contains the facet markers, we use it to identify the facets corresponding to the inlet and the walls</p>
<div id="21bd5029" class="cell" data-execution_count="132">
<div class="sourceCode" id="cb152"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb152-1"><a href="#cb152-1" aria-hidden="true" tabindex="-1"></a>v_cg2 <span class="op">=</span> element(</span>
<span id="cb152-2"><a href="#cb152-2" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;Lagrange&quot;</span>, </span>
<span id="cb152-3"><a href="#cb152-3" aria-hidden="true" tabindex="-1"></a>  mesh.topology.cell_name(), </span>
<span id="cb152-4"><a href="#cb152-4" aria-hidden="true" tabindex="-1"></a>  <span class="dv">2</span>, </span>
<span id="cb152-5"><a href="#cb152-5" aria-hidden="true" tabindex="-1"></a>  shape<span class="op">=</span>(mesh.geometry.dim, )</span>
<span id="cb152-6"><a href="#cb152-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb152-7"><a href="#cb152-7" aria-hidden="true" tabindex="-1"></a>s_cg1 <span class="op">=</span> element(</span>
<span id="cb152-8"><a href="#cb152-8" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;Lagrange&quot;</span>, </span>
<span id="cb152-9"><a href="#cb152-9" aria-hidden="true" tabindex="-1"></a>  mesh.topology.cell_name(), </span>
<span id="cb152-10"><a href="#cb152-10" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1</span></span>
<span id="cb152-11"><a href="#cb152-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb152-12"><a href="#cb152-12" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> functionspace(mesh, v_cg2)</span>
<span id="cb152-13"><a href="#cb152-13" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> functionspace(mesh, s_cg1)</span>
<span id="cb152-14"><a href="#cb152-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-15"><a href="#cb152-15" aria-hidden="true" tabindex="-1"></a>fdim <span class="op">=</span> mesh.topology.dim <span class="op">-</span><span class="dv">1</span></span>
<span id="cb152-16"><a href="#cb152-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-17"><a href="#cb152-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Define boundary conditions</span></span>
<span id="cb152-18"><a href="#cb152-18" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> InletVelocity():</span>
<span id="cb152-19"><a href="#cb152-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, t):</span>
<span id="cb152-20"><a href="#cb152-20" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>.t <span class="op">=</span> t</span>
<span id="cb152-21"><a href="#cb152-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-22"><a href="#cb152-22" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">__call__</span>(<span class="va">self</span>, x):</span>
<span id="cb152-23"><a href="#cb152-23" aria-hidden="true" tabindex="-1"></a>    values <span class="op">=</span> np.zeros((gdim, x.shape[<span class="dv">1</span>]), dtype<span class="op">=</span>PETSc.ScalarType)</span>
<span id="cb152-24"><a href="#cb152-24" aria-hidden="true" tabindex="-1"></a>    values[<span class="dv">0</span>] <span class="op">=</span> <span class="dv">4</span> <span class="op">*</span><span class="fl">1.5</span> <span class="op">*</span>np.sin(<span class="va">self</span>.t <span class="op">*</span>np.pi <span class="op">/</span><span class="dv">8</span>) <span class="op">*</span>x[<span class="dv">1</span>] <span class="op">*</span>(<span class="fl">0.41</span> <span class="op">-</span>x[<span class="dv">1</span>]) <span class="op">/</span>(<span class="fl">0.41</span><span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb152-25"><a href="#cb152-25" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> values</span>
<span id="cb152-26"><a href="#cb152-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-27"><a href="#cb152-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Inlet</span></span>
<span id="cb152-28"><a href="#cb152-28" aria-hidden="true" tabindex="-1"></a>u_inlet <span class="op">=</span> Function(V)</span>
<span id="cb152-29"><a href="#cb152-29" aria-hidden="true" tabindex="-1"></a>inlet_velocity <span class="op">=</span> InletVelocity(t)</span>
<span id="cb152-30"><a href="#cb152-30" aria-hidden="true" tabindex="-1"></a>u_inlet.interpolate(inlet_velocity)</span>
<span id="cb152-31"><a href="#cb152-31" aria-hidden="true" tabindex="-1"></a>bcu_inflow <span class="op">=</span> dirichletbc(</span>
<span id="cb152-32"><a href="#cb152-32" aria-hidden="true" tabindex="-1"></a>  u_inlet, </span>
<span id="cb152-33"><a href="#cb152-33" aria-hidden="true" tabindex="-1"></a>  locate_dofs_topological(V, fdim, ft.find(inlet_marker))</span>
<span id="cb152-34"><a href="#cb152-34" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb152-35"><a href="#cb152-35" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-36"><a href="#cb152-36" aria-hidden="true" tabindex="-1"></a><span class="co"># Walls</span></span>
<span id="cb152-37"><a href="#cb152-37" aria-hidden="true" tabindex="-1"></a>u_nonslip <span class="op">=</span> np.array((<span class="dv">0</span>,) <span class="op">*</span>mesh.geometry.dim, dtype<span class="op">=</span>PETSc.ScalarType)</span>
<span id="cb152-38"><a href="#cb152-38" aria-hidden="true" tabindex="-1"></a>bcu_walls <span class="op">=</span> dirichletbc(</span>
<span id="cb152-39"><a href="#cb152-39" aria-hidden="true" tabindex="-1"></a>  u_nonslip, </span>
<span id="cb152-40"><a href="#cb152-40" aria-hidden="true" tabindex="-1"></a>  locate_dofs_topological(V, fdim, ft.find(wall_marker)), </span>
<span id="cb152-41"><a href="#cb152-41" aria-hidden="true" tabindex="-1"></a>  V</span>
<span id="cb152-42"><a href="#cb152-42" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb152-43"><a href="#cb152-43" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-44"><a href="#cb152-44" aria-hidden="true" tabindex="-1"></a><span class="co"># Obstacle</span></span>
<span id="cb152-45"><a href="#cb152-45" aria-hidden="true" tabindex="-1"></a>bcu_obstacle <span class="op">=</span> dirichletbc(</span>
<span id="cb152-46"><a href="#cb152-46" aria-hidden="true" tabindex="-1"></a>  u_nonslip, </span>
<span id="cb152-47"><a href="#cb152-47" aria-hidden="true" tabindex="-1"></a>  locate_dofs_topological(V, fdim, ft.find(obstacle_marker)), </span>
<span id="cb152-48"><a href="#cb152-48" aria-hidden="true" tabindex="-1"></a>  V</span>
<span id="cb152-49"><a href="#cb152-49" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb152-50"><a href="#cb152-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-51"><a href="#cb152-51" aria-hidden="true" tabindex="-1"></a>bcu <span class="op">=</span> [bcu_inflow, bcu_obstacle, bcu_walls]</span>
<span id="cb152-52"><a href="#cb152-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb152-53"><a href="#cb152-53" aria-hidden="true" tabindex="-1"></a><span class="co"># Outlet</span></span>
<span id="cb152-54"><a href="#cb152-54" aria-hidden="true" tabindex="-1"></a>bcp_outlet <span class="op">=</span> dirichletbc(</span>
<span id="cb152-55"><a href="#cb152-55" aria-hidden="true" tabindex="-1"></a>  PETSc.ScalarType(<span class="dv">0</span>), </span>
<span id="cb152-56"><a href="#cb152-56" aria-hidden="true" tabindex="-1"></a>  locate_dofs_topological(Q, fdim, ft.find(outlet_marker)), </span>
<span id="cb152-57"><a href="#cb152-57" aria-hidden="true" tabindex="-1"></a>  Q</span>
<span id="cb152-58"><a href="#cb152-58" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb152-59"><a href="#cb152-59" aria-hidden="true" tabindex="-1"></a>bcp <span class="op">=</span> [bcp_outlet]</span></code></pre></div>
</div>
<p><strong>Variational form</strong></p>
<p>In contrast to Poiseuille flow, we employ a Crank–Nicolson discretization together with a semi-implicit Adams–Bashforth approximation</p>
<p>The first step can be written as</p>
<p><span class="math display">\[
\rho\left(\frac{u^* -u^n}{\delta t} +\left(\frac{3}{2}u^{n} -\frac{1}{2} u^{n-1}\right)\cdot \frac{1}{2}\nabla (u^* +u^n) \right) - \frac{1}{2}\mu \Delta( u^* + u^n )+ \nabla p^{n-\tfrac{1}{2}} = f^{n+\tfrac{1}{2}} \;\, \text{ in } \Omega
\]</span></p>
<p><span class="math display">\[
u^{*}=g(\cdot, t^{n+1}) \;\, \text{ on } \partial \Omega_{D}
\]</span></p>
<p><span class="math display">\[
\tfrac{1}{2}\nu \nabla (u^*+u^n) \cdot n = p^{n-\tfrac{1}{2}} \;\, \text{ on } \partial \Omega_{N}
\]</span></p>
<p>where the temporal derivative of the velocity uses the two previous time steps, and the pressure is computed in a staggered manner, at the midpoint between the previous and the current solution</p>
<p>The second step is</p>
<p><span class="math display">\[
\nabla^2 \phi = \frac{\rho}{\delta t} \nabla \cdot u^* \;\,\text{in } \Omega
\]</span></p>
<p><span class="math display">\[
\nabla \phi \cdot n = 0 \;\, \text{on } \partial \Omega_D
\]</span></p>
<p><span class="math display">\[
\phi = 0 \;\,\text{on } \partial\Omega_N
\]</span></p>
<p>where <span class="math inline">\(p^{n+\tfrac{1}{2}}=p^{n-\tfrac{1}{2}} + \phi\)</span></p>
<p>Finally, the third step is</p>
<p><span class="math display">\[
\rho (u^{n+1}-u^{*}) = -\delta t \nabla\phi
\]</span></p>
<p>We begin by defining all the variables required in the variational formulations</p>
<div id="13b58725" class="cell" data-execution_count="133">
<div class="sourceCode" id="cb153"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb153-1"><a href="#cb153-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> TrialFunction(V)</span>
<span id="cb153-2"><a href="#cb153-2" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> TestFunction(V)</span>
<span id="cb153-3"><a href="#cb153-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-4"><a href="#cb153-4" aria-hidden="true" tabindex="-1"></a>u_ <span class="op">=</span> Function(V)</span>
<span id="cb153-5"><a href="#cb153-5" aria-hidden="true" tabindex="-1"></a>u_.name <span class="op">=</span> <span class="st">&quot;u&quot;</span></span>
<span id="cb153-6"><a href="#cb153-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-7"><a href="#cb153-7" aria-hidden="true" tabindex="-1"></a>u_s <span class="op">=</span> Function(V)</span>
<span id="cb153-8"><a href="#cb153-8" aria-hidden="true" tabindex="-1"></a>u_n <span class="op">=</span> Function(V)</span>
<span id="cb153-9"><a href="#cb153-9" aria-hidden="true" tabindex="-1"></a>u_n1 <span class="op">=</span> Function(V)</span>
<span id="cb153-10"><a href="#cb153-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-11"><a href="#cb153-11" aria-hidden="true" tabindex="-1"></a>p <span class="op">=</span> TrialFunction(Q)</span>
<span id="cb153-12"><a href="#cb153-12" aria-hidden="true" tabindex="-1"></a>q <span class="op">=</span> TestFunction(Q)</span>
<span id="cb153-13"><a href="#cb153-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-14"><a href="#cb153-14" aria-hidden="true" tabindex="-1"></a>p_ <span class="op">=</span> Function(Q)</span>
<span id="cb153-15"><a href="#cb153-15" aria-hidden="true" tabindex="-1"></a>p_.name <span class="op">=</span> <span class="st">&quot;p&quot;</span></span>
<span id="cb153-16"><a href="#cb153-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb153-17"><a href="#cb153-17" aria-hidden="true" tabindex="-1"></a>phi <span class="op">=</span> Function(Q)</span></code></pre></div>
</div>
<p>Next, we define the variational formulation for the first step, where the diffusion and pressure terms are integrated by parts</p>
<div id="7410e7d8" class="cell" data-execution_count="134">
<div class="sourceCode" id="cb154"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb154-1"><a href="#cb154-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> Constant(mesh, PETSc.ScalarType((<span class="dv">0</span>, <span class="dv">0</span>)))</span>
<span id="cb154-2"><a href="#cb154-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-3"><a href="#cb154-3" aria-hidden="true" tabindex="-1"></a>F1 <span class="op">=</span> rho <span class="op">/</span>k <span class="op">*</span>dot(u <span class="op">-</span>u_n, v) <span class="op">*</span>dx</span>
<span id="cb154-4"><a href="#cb154-4" aria-hidden="true" tabindex="-1"></a>F1 <span class="op">+=</span> inner(dot(<span class="fl">1.5</span> <span class="op">*</span>u_n <span class="op">-</span><span class="fl">0.5</span> <span class="op">*</span>u_n1, <span class="fl">0.5</span> <span class="op">*</span>nabla_grad(u <span class="op">+</span>u_n)), v) <span class="op">*</span>dx</span>
<span id="cb154-5"><a href="#cb154-5" aria-hidden="true" tabindex="-1"></a>F1 <span class="op">+=</span> <span class="fl">0.5</span> <span class="op">*</span>mu <span class="op">*</span>inner(grad(u <span class="op">+</span>u_n), grad(v)) <span class="op">*</span>dx <span class="op">-</span>dot(p_, div(v)) <span class="op">*</span>dx</span>
<span id="cb154-6"><a href="#cb154-6" aria-hidden="true" tabindex="-1"></a>F1 <span class="op">+=</span> dot(f, v) <span class="op">*</span>dx</span>
<span id="cb154-7"><a href="#cb154-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-8"><a href="#cb154-8" aria-hidden="true" tabindex="-1"></a>a1 <span class="op">=</span> form(lhs(F1))</span>
<span id="cb154-9"><a href="#cb154-9" aria-hidden="true" tabindex="-1"></a>L1 <span class="op">=</span> form(rhs(F1))</span>
<span id="cb154-10"><a href="#cb154-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb154-11"><a href="#cb154-11" aria-hidden="true" tabindex="-1"></a>A1 <span class="op">=</span> create_matrix(a1)</span>
<span id="cb154-12"><a href="#cb154-12" aria-hidden="true" tabindex="-1"></a>b1 <span class="op">=</span> create_vector(L1)</span></code></pre></div>
</div>
<p>Next, we set up the second step</p>
<div id="eb4bc8c0" class="cell" data-execution_count="135">
<div class="sourceCode" id="cb155"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb155-1"><a href="#cb155-1" aria-hidden="true" tabindex="-1"></a>a2 <span class="op">=</span> form(dot(grad(p), grad(q)) <span class="op">*</span>dx)</span>
<span id="cb155-2"><a href="#cb155-2" aria-hidden="true" tabindex="-1"></a>L2 <span class="op">=</span> form(<span class="op">-</span>rho <span class="op">/</span>k <span class="op">*</span>dot(div(u_s), q) <span class="op">*</span>dx)</span>
<span id="cb155-3"><a href="#cb155-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb155-4"><a href="#cb155-4" aria-hidden="true" tabindex="-1"></a>A2 <span class="op">=</span> assemble_matrix(a2, bcs<span class="op">=</span>bcp)</span>
<span id="cb155-5"><a href="#cb155-5" aria-hidden="true" tabindex="-1"></a>A2.assemble()</span>
<span id="cb155-6"><a href="#cb155-6" aria-hidden="true" tabindex="-1"></a>b2 <span class="op">=</span> create_vector(L2)</span></code></pre></div>
</div>
<p>We finally complete the last step</p>
<div id="d04db12c" class="cell" data-execution_count="136">
<div class="sourceCode" id="cb156"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb156-1"><a href="#cb156-1" aria-hidden="true" tabindex="-1"></a>a3 <span class="op">=</span> form(rho <span class="op">*</span>dot(u, v) <span class="op">*</span>dx)</span>
<span id="cb156-2"><a href="#cb156-2" aria-hidden="true" tabindex="-1"></a>L3 <span class="op">=</span> form(rho <span class="op">*</span>dot(u_s, v) <span class="op">*</span>dx <span class="op">-</span>k <span class="op">*</span>dot(nabla_grad(phi), v) <span class="op">*</span>dx)</span>
<span id="cb156-3"><a href="#cb156-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb156-4"><a href="#cb156-4" aria-hidden="true" tabindex="-1"></a>A3 <span class="op">=</span> assemble_matrix(a3)</span>
<span id="cb156-5"><a href="#cb156-5" aria-hidden="true" tabindex="-1"></a>A3.assemble()</span>
<span id="cb156-6"><a href="#cb156-6" aria-hidden="true" tabindex="-1"></a>b3 <span class="op">=</span> create_vector(L3)</span></code></pre></div>
</div>
<p>As in the previous tutorials, we use PETSc as the linear algebra backend</p>
<div id="29d37143" class="cell" data-execution_count="137">
<div class="sourceCode" id="cb157"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb157-1"><a href="#cb157-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Solver for step 1</span></span>
<span id="cb157-2"><a href="#cb157-2" aria-hidden="true" tabindex="-1"></a>solver1 <span class="op">=</span> PETSc.KSP().create(mesh.comm)</span>
<span id="cb157-3"><a href="#cb157-3" aria-hidden="true" tabindex="-1"></a>solver1.setOperators(A1)</span>
<span id="cb157-4"><a href="#cb157-4" aria-hidden="true" tabindex="-1"></a>solver1.setType(PETSc.KSP.Type.BCGS)</span>
<span id="cb157-5"><a href="#cb157-5" aria-hidden="true" tabindex="-1"></a>pc1 <span class="op">=</span> solver1.getPC()</span>
<span id="cb157-6"><a href="#cb157-6" aria-hidden="true" tabindex="-1"></a>pc1.setType(PETSc.PC.Type.JACOBI)</span>
<span id="cb157-7"><a href="#cb157-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-8"><a href="#cb157-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Solver for step 2</span></span>
<span id="cb157-9"><a href="#cb157-9" aria-hidden="true" tabindex="-1"></a>solver2 <span class="op">=</span> PETSc.KSP().create(mesh.comm)</span>
<span id="cb157-10"><a href="#cb157-10" aria-hidden="true" tabindex="-1"></a>solver2.setOperators(A2)</span>
<span id="cb157-11"><a href="#cb157-11" aria-hidden="true" tabindex="-1"></a>solver2.setType(PETSc.KSP.Type.MINRES)</span>
<span id="cb157-12"><a href="#cb157-12" aria-hidden="true" tabindex="-1"></a>pc2 <span class="op">=</span> solver2.getPC()</span>
<span id="cb157-13"><a href="#cb157-13" aria-hidden="true" tabindex="-1"></a>pc2.setType(PETSc.PC.Type.HYPRE)</span>
<span id="cb157-14"><a href="#cb157-14" aria-hidden="true" tabindex="-1"></a>pc2.setHYPREType(<span class="st">&quot;boomeramg&quot;</span>)</span>
<span id="cb157-15"><a href="#cb157-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb157-16"><a href="#cb157-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Solver for step 3</span></span>
<span id="cb157-17"><a href="#cb157-17" aria-hidden="true" tabindex="-1"></a>solver3 <span class="op">=</span> PETSc.KSP().create(mesh.comm)</span>
<span id="cb157-18"><a href="#cb157-18" aria-hidden="true" tabindex="-1"></a>solver3.setOperators(A3)</span>
<span id="cb157-19"><a href="#cb157-19" aria-hidden="true" tabindex="-1"></a>solver3.setType(PETSc.KSP.Type.CG)</span>
<span id="cb157-20"><a href="#cb157-20" aria-hidden="true" tabindex="-1"></a>pc3 <span class="op">=</span> solver3.getPC()</span>
<span id="cb157-21"><a href="#cb157-21" aria-hidden="true" tabindex="-1"></a>pc3.setType(PETSc.PC.Type.SOR)</span></code></pre></div>
</div>
<p><strong>Verification of the implementation by computing known physical quantities</strong></p>
<p>As a further verification of our implementation, we compute the drag and lift coefficients over the obstacle, defined as</p>
<p><span class="math display">\[
C_{\text{D}}(u,p,t,\partial\Omega_S) = \frac{2}{\rho L U_{\text{mean}}^2}\int_{\partial\Omega_S}\rho \nu \left(n \cdot \nabla u_{t_S}(t)\right)n_y - p(t)n_x\,\mathrm{d} s
\]</span></p>
<p><span class="math display">\[
C_{\text{L}}(u,p,t,\partial\Omega_S) = -\frac{2}{\rho L U_{\text{mean}}^2}\int_{\partial\Omega_S}\rho \nu \left(n \cdot \nabla u_{t_S}(t)\right)n_x + p(t)n_y\,\mathrm{d} s
\]</span></p>
<p>where <span class="math inline">\(u_{t_S}\)</span> is the tangential velocity component at the obstacle interface <span class="math inline">\(\partial\Omega_S\)</span>, defined as <span class="math inline">\(u_{t_S}=u\cdot (n_y,-n_x)\)</span>, <span class="math inline">\(U_{\text{mean}}=1\)</span> is the average inflow velocity, and <span class="math inline">\(L\)</span> is the channel length. We use <code>UFL</code> to define the relevant integrals and assemble them at each time step</p>
<div id="81fad77d" class="cell" data-execution_count="138">
<div class="sourceCode" id="cb158"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb158-1"><a href="#cb158-1" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> <span class="op">-</span>FacetNormal(mesh)  <span class="co"># Normal pointing out of obstacle</span></span>
<span id="cb158-2"><a href="#cb158-2" aria-hidden="true" tabindex="-1"></a>dObs <span class="op">=</span> Measure(</span>
<span id="cb158-3"><a href="#cb158-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;ds&quot;</span>, </span>
<span id="cb158-4"><a href="#cb158-4" aria-hidden="true" tabindex="-1"></a>  domain<span class="op">=</span>mesh, </span>
<span id="cb158-5"><a href="#cb158-5" aria-hidden="true" tabindex="-1"></a>  subdomain_data<span class="op">=</span>ft, </span>
<span id="cb158-6"><a href="#cb158-6" aria-hidden="true" tabindex="-1"></a>  subdomain_id<span class="op">=</span>obstacle_marker</span>
<span id="cb158-7"><a href="#cb158-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb158-8"><a href="#cb158-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-9"><a href="#cb158-9" aria-hidden="true" tabindex="-1"></a>u_t <span class="op">=</span> inner(as_vector((n[<span class="dv">1</span>], <span class="op">-</span>n[<span class="dv">0</span>])), u_)</span>
<span id="cb158-10"><a href="#cb158-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-11"><a href="#cb158-11" aria-hidden="true" tabindex="-1"></a>drag <span class="op">=</span> form(<span class="dv">2</span> <span class="op">/</span><span class="fl">0.1</span> <span class="op">*</span>(mu <span class="op">/</span>rho <span class="op">*</span>inner(grad(u_t), n) <span class="op">*</span>n[<span class="dv">1</span>] <span class="op">-</span>p_ <span class="op">*</span>n[<span class="dv">0</span>]) <span class="op">*</span>dObs)</span>
<span id="cb158-12"><a href="#cb158-12" aria-hidden="true" tabindex="-1"></a>lift <span class="op">=</span> form(<span class="op">-</span><span class="dv">2</span> <span class="op">/</span><span class="fl">0.1</span> <span class="op">*</span>(mu <span class="op">/</span>rho <span class="op">*</span>inner(grad(u_t), n) <span class="op">*</span>n[<span class="dv">0</span>] <span class="op">+</span>p_ <span class="op">*</span>n[<span class="dv">1</span>]) <span class="op">*</span>dObs)</span>
<span id="cb158-13"><a href="#cb158-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb158-14"><a href="#cb158-14" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> mesh.comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb158-15"><a href="#cb158-15" aria-hidden="true" tabindex="-1"></a>  C_D <span class="op">=</span> np.zeros(num_steps, dtype<span class="op">=</span>PETSc.ScalarType)</span>
<span id="cb158-16"><a href="#cb158-16" aria-hidden="true" tabindex="-1"></a>  C_L <span class="op">=</span> np.zeros(num_steps, dtype<span class="op">=</span>PETSc.ScalarType)</span>
<span id="cb158-17"><a href="#cb158-17" aria-hidden="true" tabindex="-1"></a>  t_u <span class="op">=</span> np.zeros(num_steps, dtype<span class="op">=</span>np.float64)</span>
<span id="cb158-18"><a href="#cb158-18" aria-hidden="true" tabindex="-1"></a>  t_p <span class="op">=</span> np.zeros(num_steps, dtype<span class="op">=</span>np.float64)</span></code></pre></div>
</div>
<p>We will also evaluate the pressure at two points: one in front of the obstacle, <span class="math inline">\((0.15, 0.2)\)</span>, and one behind it, <span class="math inline">\((0.25, 0.2)\)</span>. To do this, we first need to determine which cell contains each point, so that we can construct a linear combination of the local basis functions and their coefficients</p>
<div id="8a4b02d8" class="cell" data-execution_count="139">
<div class="sourceCode" id="cb159"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb159-1"><a href="#cb159-1" aria-hidden="true" tabindex="-1"></a>tree <span class="op">=</span> bb_tree(mesh, mesh.geometry.dim)</span>
<span id="cb159-2"><a href="#cb159-2" aria-hidden="true" tabindex="-1"></a>points <span class="op">=</span> np.array([[<span class="fl">0.15</span>, <span class="fl">0.2</span>, <span class="dv">0</span>], [<span class="fl">0.25</span>, <span class="fl">0.2</span>, <span class="dv">0</span>]])</span>
<span id="cb159-3"><a href="#cb159-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-4"><a href="#cb159-4" aria-hidden="true" tabindex="-1"></a>cell_candidates <span class="op">=</span> compute_collisions_points(tree, points)</span>
<span id="cb159-5"><a href="#cb159-5" aria-hidden="true" tabindex="-1"></a>colliding_cells <span class="op">=</span> compute_colliding_cells(mesh, cell_candidates, points)</span>
<span id="cb159-6"><a href="#cb159-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-7"><a href="#cb159-7" aria-hidden="true" tabindex="-1"></a>front_cells <span class="op">=</span> colliding_cells.links(<span class="dv">0</span>)</span>
<span id="cb159-8"><a href="#cb159-8" aria-hidden="true" tabindex="-1"></a>back_cells <span class="op">=</span> colliding_cells.links(<span class="dv">1</span>)</span>
<span id="cb159-9"><a href="#cb159-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb159-10"><a href="#cb159-10" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> mesh.comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb159-11"><a href="#cb159-11" aria-hidden="true" tabindex="-1"></a>  p_diff <span class="op">=</span> np.zeros(num_steps, dtype<span class="op">=</span>PETSc.ScalarType)</span></code></pre></div>
</div>
<p><strong>Solving the time-dependent problem</strong></p>
<p>As in the previous example, we create output files for the velocity and pressure and solve the time-dependent problem. Since the problem involves many time steps, we use the tqdm package to visualize the progress</p>
<div id="c70d8cf4" class="cell" data-execution_count="140">
<div class="sourceCode" id="cb160"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb160-1"><a href="#cb160-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb160-2"><a href="#cb160-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-3"><a href="#cb160-3" aria-hidden="true" tabindex="-1"></a>folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/ns&quot;</span>)</span>
<span id="cb160-4"><a href="#cb160-4" aria-hidden="true" tabindex="-1"></a>folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb160-5"><a href="#cb160-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-6"><a href="#cb160-6" aria-hidden="true" tabindex="-1"></a>vtx_u <span class="op">=</span> VTXWriter(mesh.comm, folder<span class="op">/</span><span class="st">&quot;dfg2D-3-u.bp&quot;</span>, [u_], engine<span class="op">=</span><span class="st">&quot;BP4&quot;</span>)</span>
<span id="cb160-7"><a href="#cb160-7" aria-hidden="true" tabindex="-1"></a>vtx_p <span class="op">=</span> VTXWriter(mesh.comm, folder<span class="op">/</span><span class="st">&quot;dfg2D-3-p.bp&quot;</span>, [p_], engine<span class="op">=</span><span class="st">&quot;BP4&quot;</span>)</span>
<span id="cb160-8"><a href="#cb160-8" aria-hidden="true" tabindex="-1"></a>vtx_u.write(t)</span>
<span id="cb160-9"><a href="#cb160-9" aria-hidden="true" tabindex="-1"></a>vtx_p.write(t)</span>
<span id="cb160-10"><a href="#cb160-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-11"><a href="#cb160-11" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i <span class="kw">in</span> tqdm(<span class="bu">range</span>(num_steps), desc<span class="op">=</span><span class="st">&quot;Time Stepping&quot;</span>, unit<span class="op">=</span><span class="st">&#39;step&#39;</span>):</span>
<span id="cb160-12"><a href="#cb160-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-13"><a href="#cb160-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Update current time step</span></span>
<span id="cb160-14"><a href="#cb160-14" aria-hidden="true" tabindex="-1"></a>  t <span class="op">+=</span> dt</span>
<span id="cb160-15"><a href="#cb160-15" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb160-16"><a href="#cb160-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Update inlet velocity</span></span>
<span id="cb160-17"><a href="#cb160-17" aria-hidden="true" tabindex="-1"></a>  inlet_velocity.t <span class="op">=</span> t</span>
<span id="cb160-18"><a href="#cb160-18" aria-hidden="true" tabindex="-1"></a>  u_inlet.interpolate(inlet_velocity)</span>
<span id="cb160-19"><a href="#cb160-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-20"><a href="#cb160-20" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Step 1: Tentative velocity step</span></span>
<span id="cb160-21"><a href="#cb160-21" aria-hidden="true" tabindex="-1"></a>  A1.zeroEntries()</span>
<span id="cb160-22"><a href="#cb160-22" aria-hidden="true" tabindex="-1"></a>  assemble_matrix(A1, a1, bcs<span class="op">=</span>bcu)</span>
<span id="cb160-23"><a href="#cb160-23" aria-hidden="true" tabindex="-1"></a>  A1.assemble()</span>
<span id="cb160-24"><a href="#cb160-24" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb160-25"><a href="#cb160-25" aria-hidden="true" tabindex="-1"></a>  <span class="cf">with</span> b1.localForm() <span class="im">as</span> loc:</span>
<span id="cb160-26"><a href="#cb160-26" aria-hidden="true" tabindex="-1"></a>    loc.<span class="bu">set</span>(<span class="dv">0</span>)</span>
<span id="cb160-27"><a href="#cb160-27" aria-hidden="true" tabindex="-1"></a>  assemble_vector(b1, L1)</span>
<span id="cb160-28"><a href="#cb160-28" aria-hidden="true" tabindex="-1"></a>  apply_lifting(b1, [a1], [bcu])</span>
<span id="cb160-29"><a href="#cb160-29" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb160-30"><a href="#cb160-30" aria-hidden="true" tabindex="-1"></a>  b1.ghostUpdate(</span>
<span id="cb160-31"><a href="#cb160-31" aria-hidden="true" tabindex="-1"></a>    addv<span class="op">=</span>PETSc.InsertMode.ADD_VALUES, </span>
<span id="cb160-32"><a href="#cb160-32" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">=</span>PETSc.ScatterMode.REVERSE</span>
<span id="cb160-33"><a href="#cb160-33" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb160-34"><a href="#cb160-34" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb160-35"><a href="#cb160-35" aria-hidden="true" tabindex="-1"></a>  set_bc(b1, bcu)</span>
<span id="cb160-36"><a href="#cb160-36" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb160-37"><a href="#cb160-37" aria-hidden="true" tabindex="-1"></a>  solver1.solve(b1, u_s.x.petsc_vec)</span>
<span id="cb160-38"><a href="#cb160-38" aria-hidden="true" tabindex="-1"></a>  u_s.x.scatter_forward()</span>
<span id="cb160-39"><a href="#cb160-39" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-40"><a href="#cb160-40" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Step 2: Pressure corrrection step</span></span>
<span id="cb160-41"><a href="#cb160-41" aria-hidden="true" tabindex="-1"></a>  <span class="cf">with</span> b2.localForm() <span class="im">as</span> loc:</span>
<span id="cb160-42"><a href="#cb160-42" aria-hidden="true" tabindex="-1"></a>    loc.<span class="bu">set</span>(<span class="dv">0</span>)</span>
<span id="cb160-43"><a href="#cb160-43" aria-hidden="true" tabindex="-1"></a>  assemble_vector(b2, L2)</span>
<span id="cb160-44"><a href="#cb160-44" aria-hidden="true" tabindex="-1"></a>  apply_lifting(b2, [a2], [bcp])</span>
<span id="cb160-45"><a href="#cb160-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-46"><a href="#cb160-46" aria-hidden="true" tabindex="-1"></a>  b2.ghostUpdate(</span>
<span id="cb160-47"><a href="#cb160-47" aria-hidden="true" tabindex="-1"></a>    addv<span class="op">=</span>PETSc.InsertMode.ADD_VALUES, </span>
<span id="cb160-48"><a href="#cb160-48" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">=</span>PETSc.ScatterMode.REVERSE</span>
<span id="cb160-49"><a href="#cb160-49" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb160-50"><a href="#cb160-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-51"><a href="#cb160-51" aria-hidden="true" tabindex="-1"></a>  set_bc(b2, bcp)</span>
<span id="cb160-52"><a href="#cb160-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-53"><a href="#cb160-53" aria-hidden="true" tabindex="-1"></a>  solver2.solve(b2, phi.x.petsc_vec)</span>
<span id="cb160-54"><a href="#cb160-54" aria-hidden="true" tabindex="-1"></a>  phi.x.scatter_forward()</span>
<span id="cb160-55"><a href="#cb160-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-56"><a href="#cb160-56" aria-hidden="true" tabindex="-1"></a>  p_.x.petsc_vec.axpy(<span class="dv">1</span>, phi.x.petsc_vec)</span>
<span id="cb160-57"><a href="#cb160-57" aria-hidden="true" tabindex="-1"></a>  p_.x.scatter_forward()</span>
<span id="cb160-58"><a href="#cb160-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-59"><a href="#cb160-59" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Step 3: Velocity correction step</span></span>
<span id="cb160-60"><a href="#cb160-60" aria-hidden="true" tabindex="-1"></a>  <span class="cf">with</span> b3.localForm() <span class="im">as</span> loc:</span>
<span id="cb160-61"><a href="#cb160-61" aria-hidden="true" tabindex="-1"></a>    loc.<span class="bu">set</span>(<span class="dv">0</span>)</span>
<span id="cb160-62"><a href="#cb160-62" aria-hidden="true" tabindex="-1"></a>  assemble_vector(b3, L3)</span>
<span id="cb160-63"><a href="#cb160-63" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-64"><a href="#cb160-64" aria-hidden="true" tabindex="-1"></a>  b3.ghostUpdate(</span>
<span id="cb160-65"><a href="#cb160-65" aria-hidden="true" tabindex="-1"></a>    addv<span class="op">=</span>PETSc.InsertMode.ADD_VALUES, </span>
<span id="cb160-66"><a href="#cb160-66" aria-hidden="true" tabindex="-1"></a>    mode<span class="op">=</span>PETSc.ScatterMode.REVERSE</span>
<span id="cb160-67"><a href="#cb160-67" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb160-68"><a href="#cb160-68" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb160-69"><a href="#cb160-69" aria-hidden="true" tabindex="-1"></a>  solver3.solve(b3, u_.x.petsc_vec)</span>
<span id="cb160-70"><a href="#cb160-70" aria-hidden="true" tabindex="-1"></a>  u_.x.scatter_forward()</span>
<span id="cb160-71"><a href="#cb160-71" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-72"><a href="#cb160-72" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Write solutions to file</span></span>
<span id="cb160-73"><a href="#cb160-73" aria-hidden="true" tabindex="-1"></a>  vtx_u.write(t)</span>
<span id="cb160-74"><a href="#cb160-74" aria-hidden="true" tabindex="-1"></a>  vtx_p.write(t)</span>
<span id="cb160-75"><a href="#cb160-75" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-76"><a href="#cb160-76" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Update variable with solution form this time step</span></span>
<span id="cb160-77"><a href="#cb160-77" aria-hidden="true" tabindex="-1"></a>  <span class="cf">with</span> (</span>
<span id="cb160-78"><a href="#cb160-78" aria-hidden="true" tabindex="-1"></a>    u_.x.petsc_vec.localForm() <span class="im">as</span> loc_, </span>
<span id="cb160-79"><a href="#cb160-79" aria-hidden="true" tabindex="-1"></a>    u_n.x.petsc_vec.localForm() <span class="im">as</span> loc_n, </span>
<span id="cb160-80"><a href="#cb160-80" aria-hidden="true" tabindex="-1"></a>    u_n1.x.petsc_vec.localForm() <span class="im">as</span> loc_n1</span>
<span id="cb160-81"><a href="#cb160-81" aria-hidden="true" tabindex="-1"></a>  ):</span>
<span id="cb160-82"><a href="#cb160-82" aria-hidden="true" tabindex="-1"></a>    loc_n.copy(loc_n1)</span>
<span id="cb160-83"><a href="#cb160-83" aria-hidden="true" tabindex="-1"></a>    loc_.copy(loc_n)</span>
<span id="cb160-84"><a href="#cb160-84" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-85"><a href="#cb160-85" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Compute physical quantities</span></span>
<span id="cb160-86"><a href="#cb160-86" aria-hidden="true" tabindex="-1"></a>  <span class="co"># For this to work in paralell, we gather contributions from all processors</span></span>
<span id="cb160-87"><a href="#cb160-87" aria-hidden="true" tabindex="-1"></a>  <span class="co"># to processor zero and sum the contributions</span></span>
<span id="cb160-88"><a href="#cb160-88" aria-hidden="true" tabindex="-1"></a>  drag_coeff <span class="op">=</span> mesh.comm.gather(assemble_scalar(drag), root<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb160-89"><a href="#cb160-89" aria-hidden="true" tabindex="-1"></a>  lift_coeff <span class="op">=</span> mesh.comm.gather(assemble_scalar(lift), root<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb160-90"><a href="#cb160-90" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb160-91"><a href="#cb160-91" aria-hidden="true" tabindex="-1"></a>  p_front <span class="op">=</span> <span class="va">None</span></span>
<span id="cb160-92"><a href="#cb160-92" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="bu">len</span>(front_cells) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb160-93"><a href="#cb160-93" aria-hidden="true" tabindex="-1"></a>    p_front <span class="op">=</span> p_.<span class="bu">eval</span>(points[<span class="dv">0</span>], front_cells[:<span class="dv">1</span>])</span>
<span id="cb160-94"><a href="#cb160-94" aria-hidden="true" tabindex="-1"></a>  p_front <span class="op">=</span> mesh.comm.gather(p_front, root<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb160-95"><a href="#cb160-95" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb160-96"><a href="#cb160-96" aria-hidden="true" tabindex="-1"></a>  p_back <span class="op">=</span> <span class="va">None</span></span>
<span id="cb160-97"><a href="#cb160-97" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="bu">len</span>(back_cells) <span class="op">&gt;</span> <span class="dv">0</span>:</span>
<span id="cb160-98"><a href="#cb160-98" aria-hidden="true" tabindex="-1"></a>    p_back <span class="op">=</span> p_.<span class="bu">eval</span>(points[<span class="dv">1</span>], back_cells[:<span class="dv">1</span>])</span>
<span id="cb160-99"><a href="#cb160-99" aria-hidden="true" tabindex="-1"></a>  p_back <span class="op">=</span> mesh.comm.gather(p_back, root<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb160-100"><a href="#cb160-100" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb160-101"><a href="#cb160-101" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> mesh.comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb160-102"><a href="#cb160-102" aria-hidden="true" tabindex="-1"></a>    t_u[i] <span class="op">=</span> t</span>
<span id="cb160-103"><a href="#cb160-103" aria-hidden="true" tabindex="-1"></a>    t_p[i] <span class="op">=</span> t <span class="op">-</span>dt <span class="op">/</span><span class="dv">2</span></span>
<span id="cb160-104"><a href="#cb160-104" aria-hidden="true" tabindex="-1"></a>    C_D[i] <span class="op">=</span> <span class="bu">sum</span>(drag_coeff)</span>
<span id="cb160-105"><a href="#cb160-105" aria-hidden="true" tabindex="-1"></a>    C_L[i] <span class="op">=</span> <span class="bu">sum</span>(lift_coeff)</span>
<span id="cb160-106"><a href="#cb160-106" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb160-107"><a href="#cb160-107" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Choose first pressure that is found from the different processors</span></span>
<span id="cb160-108"><a href="#cb160-108" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> pressure <span class="kw">in</span> p_front:</span>
<span id="cb160-109"><a href="#cb160-109" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> pressure <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb160-110"><a href="#cb160-110" aria-hidden="true" tabindex="-1"></a>        p_diff[i] <span class="op">=</span> pressure[<span class="dv">0</span>]</span>
<span id="cb160-111"><a href="#cb160-111" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb160-112"><a href="#cb160-112" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> pressure <span class="kw">in</span> p_back:</span>
<span id="cb160-113"><a href="#cb160-113" aria-hidden="true" tabindex="-1"></a>      <span class="cf">if</span> pressure <span class="kw">is</span> <span class="kw">not</span> <span class="va">None</span>:</span>
<span id="cb160-114"><a href="#cb160-114" aria-hidden="true" tabindex="-1"></a>        p_diff[i] <span class="op">-=</span> pressure[<span class="dv">0</span>]</span>
<span id="cb160-115"><a href="#cb160-115" aria-hidden="true" tabindex="-1"></a>        <span class="cf">break</span></span>
<span id="cb160-116"><a href="#cb160-116" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb160-117"><a href="#cb160-117" aria-hidden="true" tabindex="-1"></a>vtx_u.close()</span>
<span id="cb160-118"><a href="#cb160-118" aria-hidden="true" tabindex="-1"></a>vtx_p.close()</span></code></pre></div>
<div class="cell-output cell-output-display">
<script type="application/vnd.jupyter.widget-view+json">
{"model_id":"6628550280254c928c4281c4a3ca4482","version_major":2,"version_minor":0,"quarto_mimetype":"application/vnd.jupyter.widget-view+json"}
</script>
</div>
</div>
<div class="video">
<p><video src="fenicsx/ns/dfg2D-3-u.mp4" class="img-fluid" controls=""><a href="fenicsx/ns/dfg2D-3-u.mp4">Video</a></video></p>
</div>
<div class="video">
<p><video src="fenicsx/ns/dfg2D-3-p.mp4" class="img-fluid" controls=""><a href="fenicsx/ns/dfg2D-3-p.mp4">Video</a></video></p>
</div>
<p><strong>Verification using data from <code>FEATFLOW</code></strong></p>
<p>We use <code>matplotlib</code> to compare our numerical results with the reference data provided by <code>FEATFLOW</code> for different discretization levels</p>
<div id="eaed2e66" class="cell" data-execution_count="141">
<div class="sourceCode" id="cb161"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb161-1"><a href="#cb161-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> mesh.comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb161-2"><a href="#cb161-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Compute the total number of velocity degrees of freedom (DOFs)</span></span>
<span id="cb161-3"><a href="#cb161-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># - V.dofmap.index_map.size_global : global number of scalar DOFs</span></span>
<span id="cb161-4"><a href="#cb161-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># - V.dofmap.index_map_bs          : block size (e.g., 2 in 2D, 3 in 3D for vector spaces)</span></span>
<span id="cb161-5"><a href="#cb161-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">#   → Total number of velocity DOFs = block size × scalar DOFs  </span></span>
<span id="cb161-6"><a href="#cb161-6" aria-hidden="true" tabindex="-1"></a>  num_velocity_dofs <span class="op">=</span> V.dofmap.index_map_bs <span class="op">*</span>V.dofmap.index_map.size_global</span>
<span id="cb161-7"><a href="#cb161-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-8"><a href="#cb161-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Compute the total number of pressure degrees of freedom (DOFs)</span></span>
<span id="cb161-9"><a href="#cb161-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># - Typically: Q.dofmap.index_map.size_global × Q.dofmap.index_map_bs</span></span>
<span id="cb161-10"><a href="#cb161-10" aria-hidden="true" tabindex="-1"></a>  <span class="co">#   (for scalar pressure spaces, block size = 1)</span></span>
<span id="cb161-11"><a href="#cb161-11" aria-hidden="true" tabindex="-1"></a>  num_pressure_dofs <span class="op">=</span> Q.dofmap.index_map_bs <span class="op">*</span>Q.dofmap.index_map.size_global</span>
<span id="cb161-12"><a href="#cb161-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-13"><a href="#cb161-13" aria-hidden="true" tabindex="-1"></a>  turek <span class="op">=</span> np.loadtxt(folder<span class="op">/</span><span class="st">&quot;bdforces_lv4&quot;</span>)</span>
<span id="cb161-14"><a href="#cb161-14" aria-hidden="true" tabindex="-1"></a>  turek_p <span class="op">=</span> np.loadtxt(folder<span class="op">/</span><span class="st">&quot;pointvalues_lv4&quot;</span>)</span>
<span id="cb161-15"><a href="#cb161-15" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb161-16"><a href="#cb161-16" aria-hidden="true" tabindex="-1"></a>  fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">25</span>, <span class="dv">8</span>))</span>
<span id="cb161-17"><a href="#cb161-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-18"><a href="#cb161-18" aria-hidden="true" tabindex="-1"></a>  l1 <span class="op">=</span> plt.plot(</span>
<span id="cb161-19"><a href="#cb161-19" aria-hidden="true" tabindex="-1"></a>    t_u, C_D, </span>
<span id="cb161-20"><a href="#cb161-20" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="ss">f&quot;FEniCSx (</span><span class="sc">{</span>num_velocity_dofs <span class="op">+</span>num_pressure_dofs<span class="sc">:d}</span><span class="ss"> dofs)&quot;</span>, linewidth<span class="op">=</span><span class="dv">2</span></span>
<span id="cb161-21"><a href="#cb161-21" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb161-22"><a href="#cb161-22" aria-hidden="true" tabindex="-1"></a>  l2 <span class="op">=</span> plt.plot(</span>
<span id="cb161-23"><a href="#cb161-23" aria-hidden="true" tabindex="-1"></a>    turek[<span class="dv">1</span>:, <span class="dv">1</span>], turek[<span class="dv">1</span>:, <span class="dv">3</span>], </span>
<span id="cb161-24"><a href="#cb161-24" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span><span class="st">&quot;x&quot;</span>, markevery<span class="op">=</span><span class="dv">50</span>, linestyle<span class="op">=</span><span class="st">&quot;&quot;</span>, markersize<span class="op">=</span><span class="dv">4</span>, </span>
<span id="cb161-25"><a href="#cb161-25" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">&quot;FEATFLOW (42016 dofs)&quot;</span>)</span>
<span id="cb161-26"><a href="#cb161-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-27"><a href="#cb161-27" aria-hidden="true" tabindex="-1"></a>  plt.title(<span class="st">&quot;Drag Coefficient&quot;</span>)</span>
<span id="cb161-28"><a href="#cb161-28" aria-hidden="true" tabindex="-1"></a>  plt.grid()</span>
<span id="cb161-29"><a href="#cb161-29" aria-hidden="true" tabindex="-1"></a>  plt.legend()</span>
<span id="cb161-30"><a href="#cb161-30" aria-hidden="true" tabindex="-1"></a>  plt.savefig(folder<span class="op">/</span><span class="st">&quot;drag_comparison.png&quot;</span>)</span>
<span id="cb161-31"><a href="#cb161-31" aria-hidden="true" tabindex="-1"></a>  plt.show()</span>
<span id="cb161-32"><a href="#cb161-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-33"><a href="#cb161-33" aria-hidden="true" tabindex="-1"></a>  fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">25</span>, <span class="dv">8</span>))</span>
<span id="cb161-34"><a href="#cb161-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-35"><a href="#cb161-35" aria-hidden="true" tabindex="-1"></a>  l1 <span class="op">=</span> plt.plot(</span>
<span id="cb161-36"><a href="#cb161-36" aria-hidden="true" tabindex="-1"></a>    t_u, C_L, </span>
<span id="cb161-37"><a href="#cb161-37" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="ss">f&quot;FEniCSx (</span><span class="sc">{</span>num_velocity_dofs <span class="op">+</span>num_pressure_dofs<span class="sc">:d}</span><span class="ss"> dofs)&quot;</span>, linewidth<span class="op">=</span><span class="dv">2</span></span>
<span id="cb161-38"><a href="#cb161-38" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb161-39"><a href="#cb161-39" aria-hidden="true" tabindex="-1"></a>  l2 <span class="op">=</span> plt.plot(</span>
<span id="cb161-40"><a href="#cb161-40" aria-hidden="true" tabindex="-1"></a>    turek[<span class="dv">1</span>:, <span class="dv">1</span>], turek[<span class="dv">1</span>:, <span class="dv">4</span>], </span>
<span id="cb161-41"><a href="#cb161-41" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span><span class="st">&quot;x&quot;</span>, markevery<span class="op">=</span><span class="dv">50</span>, linestyle<span class="op">=</span><span class="st">&quot;&quot;</span>, markersize<span class="op">=</span><span class="dv">4</span>, </span>
<span id="cb161-42"><a href="#cb161-42" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">&quot;FEATFLOW (42016 dofs)&quot;</span></span>
<span id="cb161-43"><a href="#cb161-43" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb161-44"><a href="#cb161-44" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb161-45"><a href="#cb161-45" aria-hidden="true" tabindex="-1"></a>  plt.title(<span class="st">&quot;Lift Coefficient&quot;</span>)</span>
<span id="cb161-46"><a href="#cb161-46" aria-hidden="true" tabindex="-1"></a>  plt.grid()</span>
<span id="cb161-47"><a href="#cb161-47" aria-hidden="true" tabindex="-1"></a>  plt.legend()</span>
<span id="cb161-48"><a href="#cb161-48" aria-hidden="true" tabindex="-1"></a>  plt.savefig(folder<span class="op">/</span><span class="st">&quot;lift_comparison.png&quot;</span>)</span>
<span id="cb161-49"><a href="#cb161-49" aria-hidden="true" tabindex="-1"></a>  plt.show()  </span>
<span id="cb161-50"><a href="#cb161-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-51"><a href="#cb161-51" aria-hidden="true" tabindex="-1"></a>  fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">25</span>, <span class="dv">8</span>))</span>
<span id="cb161-52"><a href="#cb161-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb161-53"><a href="#cb161-53" aria-hidden="true" tabindex="-1"></a>  l1 <span class="op">=</span> plt.plot(</span>
<span id="cb161-54"><a href="#cb161-54" aria-hidden="true" tabindex="-1"></a>    t_p, p_diff, </span>
<span id="cb161-55"><a href="#cb161-55" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="ss">f&quot;FEniCSx (</span><span class="sc">{</span>num_velocity_dofs <span class="op">+</span> num_pressure_dofs<span class="sc">:d}</span><span class="ss"> dofs)&quot;</span>, linewidth<span class="op">=</span><span class="dv">2</span></span>
<span id="cb161-56"><a href="#cb161-56" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb161-57"><a href="#cb161-57" aria-hidden="true" tabindex="-1"></a>  l2 <span class="op">=</span> plt.plot(</span>
<span id="cb161-58"><a href="#cb161-58" aria-hidden="true" tabindex="-1"></a>    turek[<span class="dv">1</span>:, <span class="dv">1</span>], turek_p[<span class="dv">1</span>:, <span class="dv">6</span>] <span class="op">-</span>turek_p[<span class="dv">1</span>:, <span class="op">-</span><span class="dv">1</span>], </span>
<span id="cb161-59"><a href="#cb161-59" aria-hidden="true" tabindex="-1"></a>    marker<span class="op">=</span><span class="st">&quot;x&quot;</span>, markevery<span class="op">=</span><span class="dv">50</span>, linestyle<span class="op">=</span><span class="st">&quot;&quot;</span>, markersize<span class="op">=</span><span class="dv">4</span>, </span>
<span id="cb161-60"><a href="#cb161-60" aria-hidden="true" tabindex="-1"></a>    label<span class="op">=</span><span class="st">&quot;FEATFLOW (42016 dofs)&quot;</span></span>
<span id="cb161-61"><a href="#cb161-61" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb161-62"><a href="#cb161-62" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb161-63"><a href="#cb161-63" aria-hidden="true" tabindex="-1"></a>  plt.title(<span class="st">&quot;Pressure difference&quot;</span>)</span>
<span id="cb161-64"><a href="#cb161-64" aria-hidden="true" tabindex="-1"></a>  plt.grid()</span>
<span id="cb161-65"><a href="#cb161-65" aria-hidden="true" tabindex="-1"></a>  plt.legend()</span>
<span id="cb161-66"><a href="#cb161-66" aria-hidden="true" tabindex="-1"></a>  plt.savefig(folder<span class="op">/</span><span class="st">&quot;pressure_comparison.png&quot;</span>)</span>
<span id="cb161-67"><a href="#cb161-67" aria-hidden="true" tabindex="-1"></a>  plt.show()</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img src="x_PDE_FEniCS_files/figure-html/cell-142-output-1.png" width="1910" height="653" /></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img src="x_PDE_FEniCS_files/figure-html/cell-142-output-2.png" width="1921" height="653" /></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img src="x_PDE_FEniCS_files/figure-html/cell-142-output-3.png" width="1910" height="653" /></p>
</figure>
</div>
</div>
</div>
</section>
</section>
<section id="hyperelasticity" class="level3" data-number="K.7.6">
<h3 data-number="K.7.6"><span class="header-section-number">K.7.6</span> Hyperelasticity</h3>
<p>Author: Jørgen S. Dokken and Garth N. Wells</p>
<p>This section demonstrates how to solve the hyperelasticity problem for the deformation of a beam. We also illustrate how to define a constant boundary condition for a vector function space</p>
<p>We begin by importing <code>DOLFINx</code> along with additional dependencies. Next, we construct a slender cantilever composed of hexahedral elements and define the function space <code>V</code> for the unknown field</p>
<div id="5d8fbbb1" class="cell" data-execution_count="142">
<div class="sourceCode" id="cb162"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb162-1"><a href="#cb162-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb162-2"><a href="#cb162-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-3"><a href="#cb162-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb162-4"><a href="#cb162-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb162-5"><a href="#cb162-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-6"><a href="#cb162-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> fem, mesh, plot</span>
<span id="cb162-7"><a href="#cb162-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> log, default_scalar_type</span>
<span id="cb162-8"><a href="#cb162-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> NonlinearProblem</span>
<span id="cb162-9"><a href="#cb162-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.nls.petsc <span class="im">import</span> NewtonSolver</span>
<span id="cb162-10"><a href="#cb162-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-11"><a href="#cb162-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ufl</span>
<span id="cb162-12"><a href="#cb162-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb162-13"><a href="#cb162-13" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="fl">20.0</span></span>
<span id="cb162-14"><a href="#cb162-14" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> mesh.create_box(</span>
<span id="cb162-15"><a href="#cb162-15" aria-hidden="true" tabindex="-1"></a>  MPI.COMM_WORLD, </span>
<span id="cb162-16"><a href="#cb162-16" aria-hidden="true" tabindex="-1"></a>  [[<span class="fl">0.0</span>, <span class="fl">0.0</span>, <span class="fl">0.0</span>], [L, <span class="dv">1</span>, <span class="dv">1</span>]], </span>
<span id="cb162-17"><a href="#cb162-17" aria-hidden="true" tabindex="-1"></a>  [<span class="dv">20</span>, <span class="dv">5</span>, <span class="dv">5</span>], </span>
<span id="cb162-18"><a href="#cb162-18" aria-hidden="true" tabindex="-1"></a>  mesh.CellType.hexahedron</span>
<span id="cb162-19"><a href="#cb162-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb162-20"><a href="#cb162-20" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">2</span>, (domain.geometry.dim, )))</span></code></pre></div>
</div>
<p>We define two Python functions to identify the facets where boundary conditions should be applied</p>
<div id="139efb5b" class="cell" data-execution_count="143">
<div class="sourceCode" id="cb163"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb163-1"><a href="#cb163-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> left(x):</span>
<span id="cb163-2"><a href="#cb163-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> np.isclose(x[<span class="dv">0</span>], <span class="dv">0</span>)</span>
<span id="cb163-3"><a href="#cb163-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-4"><a href="#cb163-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> right(x):</span>
<span id="cb163-5"><a href="#cb163-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> np.isclose(x[<span class="dv">0</span>], L)</span>
<span id="cb163-6"><a href="#cb163-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb163-7"><a href="#cb163-7" aria-hidden="true" tabindex="-1"></a>fdim <span class="op">=</span> domain.topology.dim <span class="op">-</span><span class="dv">1</span></span>
<span id="cb163-8"><a href="#cb163-8" aria-hidden="true" tabindex="-1"></a>left_facets <span class="op">=</span> mesh.locate_entities_boundary(domain, fdim, left)</span>
<span id="cb163-9"><a href="#cb163-9" aria-hidden="true" tabindex="-1"></a>right_facets <span class="op">=</span> mesh.locate_entities_boundary(domain, fdim, right)</span></code></pre></div>
</div>
<p>Next, we create a marker using these two functions</p>
<div id="236e43ff" class="cell" data-execution_count="144">
<div class="sourceCode" id="cb164"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb164-1"><a href="#cb164-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Concatenate and sort the arrays based on facet indices</span></span>
<span id="cb164-2"><a href="#cb164-2" aria-hidden="true" tabindex="-1"></a><span class="co"># Left facets are marked with ID 1, right facets with ID 2</span></span>
<span id="cb164-3"><a href="#cb164-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-4"><a href="#cb164-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Combine the facet indices from the left and right boundary</span></span>
<span id="cb164-5"><a href="#cb164-5" aria-hidden="true" tabindex="-1"></a>marked_facets <span class="op">=</span> np.hstack([left_facets, right_facets])</span>
<span id="cb164-6"><a href="#cb164-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-7"><a href="#cb164-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Assign marker values: 1 for left facets, 2 for right facets</span></span>
<span id="cb164-8"><a href="#cb164-8" aria-hidden="true" tabindex="-1"></a>marked_values <span class="op">=</span> np.hstack([</span>
<span id="cb164-9"><a href="#cb164-9" aria-hidden="true" tabindex="-1"></a>    np.full_like(left_facets, <span class="dv">1</span>), </span>
<span id="cb164-10"><a href="#cb164-10" aria-hidden="true" tabindex="-1"></a>    np.full_like(right_facets, <span class="dv">2</span>)</span>
<span id="cb164-11"><a href="#cb164-11" aria-hidden="true" tabindex="-1"></a>])</span>
<span id="cb164-12"><a href="#cb164-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-13"><a href="#cb164-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Sort facets (and corresponding marker values) by facet index</span></span>
<span id="cb164-14"><a href="#cb164-14" aria-hidden="true" tabindex="-1"></a>sorted_facets <span class="op">=</span> np.argsort(marked_facets)</span>
<span id="cb164-15"><a href="#cb164-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb164-16"><a href="#cb164-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Create a MeshTags object that stores the facet markers</span></span>
<span id="cb164-17"><a href="#cb164-17" aria-hidden="true" tabindex="-1"></a><span class="co"># This will allow us to apply different boundary conditions</span></span>
<span id="cb164-18"><a href="#cb164-18" aria-hidden="true" tabindex="-1"></a><span class="co"># depending on whether the facet belongs to the left or right boundary</span></span>
<span id="cb164-19"><a href="#cb164-19" aria-hidden="true" tabindex="-1"></a>facet_tag <span class="op">=</span> mesh.meshtags(</span>
<span id="cb164-20"><a href="#cb164-20" aria-hidden="true" tabindex="-1"></a>    domain, fdim, </span>
<span id="cb164-21"><a href="#cb164-21" aria-hidden="true" tabindex="-1"></a>    marked_facets[sorted_facets], </span>
<span id="cb164-22"><a href="#cb164-22" aria-hidden="true" tabindex="-1"></a>    marked_values[sorted_facets]</span>
<span id="cb164-23"><a href="#cb164-23" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
<p>We then create a function to prescribe the fixed boundary condition on the left side</p>
<div id="d3d4e70e" class="cell" data-execution_count="145">
<div class="sourceCode" id="cb165"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb165-1"><a href="#cb165-1" aria-hidden="true" tabindex="-1"></a>u_bc <span class="op">=</span> np.array((<span class="dv">0</span>,) <span class="op">*</span>domain.geometry.dim, dtype<span class="op">=</span>default_scalar_type)</span></code></pre></div>
</div>
<p>To apply the boundary condition, we identify the degrees of freedom (dofs) associated with the facets marked by the <code>MeshTag</code></p>
<div id="aabaf333" class="cell" data-execution_count="146">
<div class="sourceCode" id="cb166"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb166-1"><a href="#cb166-1" aria-hidden="true" tabindex="-1"></a>left_dofs <span class="op">=</span> fem.locate_dofs_topological(</span>
<span id="cb166-2"><a href="#cb166-2" aria-hidden="true" tabindex="-1"></a>  V, </span>
<span id="cb166-3"><a href="#cb166-3" aria-hidden="true" tabindex="-1"></a>  facet_tag.dim, </span>
<span id="cb166-4"><a href="#cb166-4" aria-hidden="true" tabindex="-1"></a>  facet_tag.find(<span class="dv">1</span>)</span>
<span id="cb166-5"><a href="#cb166-5" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb166-6"><a href="#cb166-6" aria-hidden="true" tabindex="-1"></a>bcs <span class="op">=</span> [fem.dirichletbc(u_bc, left_dofs, V)]</span></code></pre></div>
</div>
<p>Next, we define the body force <code>B</code> on the reference configuration and the nominal (first Piola-Kirchhoff) traction <code>T</code></p>
<div id="0683b86a" class="cell" data-execution_count="147">
<div class="sourceCode" id="cb167"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb167-1"><a href="#cb167-1" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> fem.Constant(domain, default_scalar_type((<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)))</span>
<span id="cb167-2"><a href="#cb167-2" aria-hidden="true" tabindex="-1"></a>T <span class="op">=</span> fem.Constant(domain, default_scalar_type((<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)))</span></code></pre></div>
</div>
<p>We define the test and solution functions in the space <span class="math inline">\(V\)</span></p>
<div id="cbd18c27" class="cell" data-execution_count="148">
<div class="sourceCode" id="cb168"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb168-1"><a href="#cb168-1" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> ufl.TestFunction(V)</span>
<span id="cb168-2"><a href="#cb168-2" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> fem.Function(V)</span></code></pre></div>
</div>
<p>We define the kinematic quantities relevant to the problem</p>
<div id="1db61f3c" class="cell" data-execution_count="149">
<div class="sourceCode" id="cb169"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb169-1"><a href="#cb169-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Spatial dimension</span></span>
<span id="cb169-2"><a href="#cb169-2" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> <span class="bu">len</span>(u)</span>
<span id="cb169-3"><a href="#cb169-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-4"><a href="#cb169-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Identity tensor</span></span>
<span id="cb169-5"><a href="#cb169-5" aria-hidden="true" tabindex="-1"></a>I <span class="op">=</span> ufl.variable(ufl.Identity(d))</span>
<span id="cb169-6"><a href="#cb169-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-7"><a href="#cb169-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Deformation gradient</span></span>
<span id="cb169-8"><a href="#cb169-8" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> ufl.variable(I <span class="op">+</span>ufl.grad(u))</span>
<span id="cb169-9"><a href="#cb169-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-10"><a href="#cb169-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Right Cauchy-Green tensor</span></span>
<span id="cb169-11"><a href="#cb169-11" aria-hidden="true" tabindex="-1"></a>C <span class="op">=</span> ufl.variable(F.T <span class="op">*</span>F)</span>
<span id="cb169-12"><a href="#cb169-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb169-13"><a href="#cb169-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Invariants of deformation tensors</span></span>
<span id="cb169-14"><a href="#cb169-14" aria-hidden="true" tabindex="-1"></a>Ic <span class="op">=</span> ufl.variable(ufl.tr(C))</span>
<span id="cb169-15"><a href="#cb169-15" aria-hidden="true" tabindex="-1"></a>J <span class="op">=</span> ufl.variable(ufl.det(F))</span></code></pre></div>
</div>
<p>We define the elasticity model using the stored strain energy density function <span class="math inline">\(\psi\)</span>, and derive the corresponding first Piola-Kirchhoff stress expression:</p>
<div id="f4aa313f" class="cell" data-execution_count="150">
<div class="sourceCode" id="cb170"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb170-1"><a href="#cb170-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Elasticity parameters</span></span>
<span id="cb170-2"><a href="#cb170-2" aria-hidden="true" tabindex="-1"></a>E <span class="op">=</span> default_scalar_type(<span class="fl">1.0e4</span>)</span>
<span id="cb170-3"><a href="#cb170-3" aria-hidden="true" tabindex="-1"></a>nu <span class="op">=</span> default_scalar_type(<span class="fl">0.3</span>)</span>
<span id="cb170-4"><a href="#cb170-4" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> fem.Constant(domain, E <span class="op">/</span>(<span class="dv">2</span> <span class="op">*</span>(<span class="dv">1</span> <span class="op">+</span>nu)))</span>
<span id="cb170-5"><a href="#cb170-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-6"><a href="#cb170-6" aria-hidden="true" tabindex="-1"></a>lmbda <span class="op">=</span> fem.Constant(domain, E <span class="op">*</span>nu <span class="op">/</span>((<span class="dv">1</span> <span class="op">+</span>nu) <span class="op">*</span>(<span class="dv">1</span> <span class="op">-</span><span class="dv">2</span> <span class="op">*</span>nu)))</span>
<span id="cb170-7"><a href="#cb170-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-8"><a href="#cb170-8" aria-hidden="true" tabindex="-1"></a><span class="co"># Stored strain energy density (compressible neo-Hookean model)</span></span>
<span id="cb170-9"><a href="#cb170-9" aria-hidden="true" tabindex="-1"></a>psi <span class="op">=</span> (mu <span class="op">/</span><span class="dv">2</span>) <span class="op">*</span>(Ic <span class="op">-</span><span class="dv">3</span>) <span class="op">-</span>mu <span class="op">*</span>ufl.ln(J) <span class="op">+</span>(lmbda <span class="op">/</span><span class="dv">2</span>) <span class="op">*</span>(ufl.ln(J))<span class="op">**</span><span class="dv">2</span></span>
<span id="cb170-10"><a href="#cb170-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb170-11"><a href="#cb170-11" aria-hidden="true" tabindex="-1"></a><span class="co"># Stress - Hyper-elasticity</span></span>
<span id="cb170-12"><a href="#cb170-12" aria-hidden="true" tabindex="-1"></a>P <span class="op">=</span> ufl.diff(psi, F)</span></code></pre></div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class='callout-icon'></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>To illustrate the difference between linear elasticity and hyperelasticity, the following lines can be uncommented to solve the linear elasticity problem</p>
</div>
</div>
<div id="e8de40ce" class="cell" data-execution_count="151">
<div class="sourceCode" id="cb171"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb171-1"><a href="#cb171-1" aria-hidden="true" tabindex="-1"></a><span class="co"># P = 2.0 *mu *ufl.sym(ufl.grad(u)) +lmbda *ufl.tr(ufl.sym(ufl.grad(u))) *I</span></span></code></pre></div>
</div>
<p>Define the variational form, including the traction integral over all facets marked with value 2. The quadrature degree for the integrals is set to 4</p>
<div id="dbde8fec" class="cell" data-execution_count="152">
<div class="sourceCode" id="cb172"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb172-1"><a href="#cb172-1" aria-hidden="true" tabindex="-1"></a>metadata <span class="op">=</span> {<span class="st">&quot;quadrature_degree&quot;</span>: <span class="dv">4</span>}</span>
<span id="cb172-2"><a href="#cb172-2" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> ufl.Measure(</span>
<span id="cb172-3"><a href="#cb172-3" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;ds&quot;</span>, </span>
<span id="cb172-4"><a href="#cb172-4" aria-hidden="true" tabindex="-1"></a>  domain<span class="op">=</span>domain, </span>
<span id="cb172-5"><a href="#cb172-5" aria-hidden="true" tabindex="-1"></a>  subdomain_data<span class="op">=</span>facet_tag, </span>
<span id="cb172-6"><a href="#cb172-6" aria-hidden="true" tabindex="-1"></a>  metadata<span class="op">=</span>metadata</span>
<span id="cb172-7"><a href="#cb172-7" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb172-8"><a href="#cb172-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-9"><a href="#cb172-9" aria-hidden="true" tabindex="-1"></a>dx <span class="op">=</span> ufl.Measure(</span>
<span id="cb172-10"><a href="#cb172-10" aria-hidden="true" tabindex="-1"></a>  <span class="st">&quot;dx&quot;</span>, </span>
<span id="cb172-11"><a href="#cb172-11" aria-hidden="true" tabindex="-1"></a>  domain<span class="op">=</span>domain, </span>
<span id="cb172-12"><a href="#cb172-12" aria-hidden="true" tabindex="-1"></a>  metadata<span class="op">=</span>metadata</span>
<span id="cb172-13"><a href="#cb172-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb172-14"><a href="#cb172-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb172-15"><a href="#cb172-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Define form F (we want to find u such that F(u) = 0)</span></span>
<span id="cb172-16"><a href="#cb172-16" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> ufl.inner(ufl.grad(v), P) <span class="op">*</span>dx <span class="op">-</span>ufl.inner(v, B) <span class="op">*</span>dx <span class="op">-</span>ufl.inner(v, T) <span class="op">*</span>ds(<span class="dv">2</span>)</span></code></pre></div>
</div>
<p>As the variational form is nonlinear and written in residual form, we use the nonlinear problem class from <code>DOLFINx</code> to set up the structures required for a Newton solver</p>
<div id="512522cc" class="cell" data-execution_count="153">
<div class="sourceCode" id="cb173"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb173-1"><a href="#cb173-1" aria-hidden="true" tabindex="-1"></a>problem <span class="op">=</span> NonlinearProblem(F, u, bcs)</span></code></pre></div>
</div>
<p>and then create and configure the Newton solver</p>
<div id="794f5e23" class="cell" data-execution_count="154">
<div class="sourceCode" id="cb174"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb174-1"><a href="#cb174-1" aria-hidden="true" tabindex="-1"></a>solver <span class="op">=</span> NewtonSolver(domain.comm, problem)</span>
<span id="cb174-2"><a href="#cb174-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb174-3"><a href="#cb174-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Set Newton solver options</span></span>
<span id="cb174-4"><a href="#cb174-4" aria-hidden="true" tabindex="-1"></a>solver.atol <span class="op">=</span> <span class="fl">1e-8</span></span>
<span id="cb174-5"><a href="#cb174-5" aria-hidden="true" tabindex="-1"></a>solver.rtol <span class="op">=</span> <span class="fl">1e-8</span></span>
<span id="cb174-6"><a href="#cb174-6" aria-hidden="true" tabindex="-1"></a>solver.convergence_criterion <span class="op">=</span> <span class="st">&quot;incremental&quot;</span></span></code></pre></div>
</div>
<p>We define a function to plot the solution at each time step</p>
<div id="22f405b0" class="cell" data-execution_count="155">
<div class="sourceCode" id="cb175"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb175-1"><a href="#cb175-1" aria-hidden="true" tabindex="-1"></a>results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/hyperelasticity&quot;</span>)</span>
<span id="cb175-2"><a href="#cb175-2" aria-hidden="true" tabindex="-1"></a>results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb175-3"><a href="#cb175-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-4"><a href="#cb175-4" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb175-5"><a href="#cb175-5" aria-hidden="true" tabindex="-1"></a>plotter.open_gif(results_folder<span class="op">/</span><span class="st">&quot;deformation.gif&quot;</span>, fps<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb175-6"><a href="#cb175-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-7"><a href="#cb175-7" aria-hidden="true" tabindex="-1"></a>topology, cells, geometry <span class="op">=</span> plot.vtk_mesh(u.function_space)</span>
<span id="cb175-8"><a href="#cb175-8" aria-hidden="true" tabindex="-1"></a>function_grid <span class="op">=</span> pyvista.UnstructuredGrid(topology, cells, geometry)</span>
<span id="cb175-9"><a href="#cb175-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-10"><a href="#cb175-10" aria-hidden="true" tabindex="-1"></a>values <span class="op">=</span> np.zeros((geometry.shape[<span class="dv">0</span>], <span class="dv">3</span>))</span>
<span id="cb175-11"><a href="#cb175-11" aria-hidden="true" tabindex="-1"></a>values[:, :<span class="bu">len</span>(u)] <span class="op">=</span> u.x.array.reshape(geometry.shape[<span class="dv">0</span>], <span class="bu">len</span>(u))</span>
<span id="cb175-12"><a href="#cb175-12" aria-hidden="true" tabindex="-1"></a>function_grid[<span class="st">&quot;u&quot;</span>] <span class="op">=</span> values</span>
<span id="cb175-13"><a href="#cb175-13" aria-hidden="true" tabindex="-1"></a>function_grid.set_active_vectors(<span class="st">&quot;u&quot;</span>)</span>
<span id="cb175-14"><a href="#cb175-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-15"><a href="#cb175-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Warp mesh by deformation</span></span>
<span id="cb175-16"><a href="#cb175-16" aria-hidden="true" tabindex="-1"></a>warped <span class="op">=</span> function_grid.warp_by_vector(<span class="st">&quot;u&quot;</span>, factor<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb175-17"><a href="#cb175-17" aria-hidden="true" tabindex="-1"></a>warped.set_active_vectors(<span class="st">&quot;u&quot;</span>)</span>
<span id="cb175-18"><a href="#cb175-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-19"><a href="#cb175-19" aria-hidden="true" tabindex="-1"></a><span class="co"># Add mesh to plotter and visualize</span></span>
<span id="cb175-20"><a href="#cb175-20" aria-hidden="true" tabindex="-1"></a>actor <span class="op">=</span> plotter.add_mesh(</span>
<span id="cb175-21"><a href="#cb175-21" aria-hidden="true" tabindex="-1"></a>  warped, </span>
<span id="cb175-22"><a href="#cb175-22" aria-hidden="true" tabindex="-1"></a>  show_edges<span class="op">=</span><span class="va">True</span>, </span>
<span id="cb175-23"><a href="#cb175-23" aria-hidden="true" tabindex="-1"></a>  lighting<span class="op">=</span><span class="va">False</span>, </span>
<span id="cb175-24"><a href="#cb175-24" aria-hidden="true" tabindex="-1"></a>  clim<span class="op">=</span>[<span class="dv">0</span>, <span class="dv">10</span>],</span>
<span id="cb175-25"><a href="#cb175-25" aria-hidden="true" tabindex="-1"></a>  scalar_bar_args<span class="op">=</span>{<span class="st">&quot;vertical&quot;</span>: <span class="va">True</span>},</span>
<span id="cb175-26"><a href="#cb175-26" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb175-27"><a href="#cb175-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-28"><a href="#cb175-28" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute magnitude of displacement to visualize in GIF</span></span>
<span id="cb175-29"><a href="#cb175-29" aria-hidden="true" tabindex="-1"></a>Vs <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">2</span>))</span>
<span id="cb175-30"><a href="#cb175-30" aria-hidden="true" tabindex="-1"></a>magnitude <span class="op">=</span> fem.Function(Vs)</span>
<span id="cb175-31"><a href="#cb175-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb175-32"><a href="#cb175-32" aria-hidden="true" tabindex="-1"></a>us <span class="op">=</span> fem.Expression(</span>
<span id="cb175-33"><a href="#cb175-33" aria-hidden="true" tabindex="-1"></a>  ufl.sqrt(<span class="bu">sum</span>([u[i]<span class="op">**</span><span class="dv">2</span> <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">len</span>(u))])), </span>
<span id="cb175-34"><a href="#cb175-34" aria-hidden="true" tabindex="-1"></a>  Vs.element.interpolation_points()</span>
<span id="cb175-35"><a href="#cb175-35" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb175-36"><a href="#cb175-36" aria-hidden="true" tabindex="-1"></a>magnitude.interpolate(us)</span>
<span id="cb175-37"><a href="#cb175-37" aria-hidden="true" tabindex="-1"></a>warped[<span class="st">&quot;mag&quot;</span>] <span class="op">=</span> magnitude.x.array</span></code></pre></div>
</div>
<p>Finally, we solve the problem over multiple time steps, updating the traction in the z-direction</p>
<div id="189b964b" class="cell" data-execution_count="156">
<div class="sourceCode" id="cb176"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb176-1"><a href="#cb176-1" aria-hidden="true" tabindex="-1"></a>log.set_log_level(log.LogLevel.INFO)</span>
<span id="cb176-2"><a href="#cb176-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-3"><a href="#cb176-3" aria-hidden="true" tabindex="-1"></a>tval0 <span class="op">=</span> <span class="op">-</span><span class="fl">1.5</span></span>
<span id="cb176-4"><a href="#cb176-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> n <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">1</span>, <span class="dv">10</span>):</span>
<span id="cb176-5"><a href="#cb176-5" aria-hidden="true" tabindex="-1"></a>    T.value[<span class="dv">2</span>] <span class="op">=</span> n <span class="op">*</span>tval0</span>
<span id="cb176-6"><a href="#cb176-6" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb176-7"><a href="#cb176-7" aria-hidden="true" tabindex="-1"></a>    num_its, converged <span class="op">=</span> solver.solve(u)</span>
<span id="cb176-8"><a href="#cb176-8" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> (converged)</span>
<span id="cb176-9"><a href="#cb176-9" aria-hidden="true" tabindex="-1"></a>    u.x.scatter_forward()</span>
<span id="cb176-10"><a href="#cb176-10" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Time step </span><span class="sc">{</span>n<span class="sc">}</span><span class="ss">, Number of iterations </span><span class="sc">{</span>num_its<span class="sc">}</span><span class="ss">, Load </span><span class="sc">{</span>T<span class="sc">.</span>value<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb176-11"><a href="#cb176-11" aria-hidden="true" tabindex="-1"></a>    function_grid[<span class="st">&quot;u&quot;</span>][:, :<span class="bu">len</span>(u)] <span class="op">=</span> u.x.array.reshape(geometry.shape[<span class="dv">0</span>], <span class="bu">len</span>(u))</span>
<span id="cb176-12"><a href="#cb176-12" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb176-13"><a href="#cb176-13" aria-hidden="true" tabindex="-1"></a>    magnitude.interpolate(us)</span>
<span id="cb176-14"><a href="#cb176-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb176-15"><a href="#cb176-15" aria-hidden="true" tabindex="-1"></a>    warped.set_active_scalars(<span class="st">&quot;mag&quot;</span>)</span>
<span id="cb176-16"><a href="#cb176-16" aria-hidden="true" tabindex="-1"></a>    warped_n <span class="op">=</span> function_grid.warp_by_vector(factor<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb176-17"><a href="#cb176-17" aria-hidden="true" tabindex="-1"></a>    warped.points[:, :] <span class="op">=</span> warped_n.points</span>
<span id="cb176-18"><a href="#cb176-18" aria-hidden="true" tabindex="-1"></a>    warped.point_data[<span class="st">&quot;mag&quot;</span>][:] <span class="op">=</span> magnitude.x.array</span>
<span id="cb176-19"><a href="#cb176-19" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb176-20"><a href="#cb176-20" aria-hidden="true" tabindex="-1"></a>    plotter.update_scalar_bar_range([<span class="dv">0</span>, <span class="dv">10</span>])</span>
<span id="cb176-21"><a href="#cb176-21" aria-hidden="true" tabindex="-1"></a>    plotter.write_frame()</span>
<span id="cb176-22"><a href="#cb176-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-23"><a href="#cb176-23" aria-hidden="true" tabindex="-1"></a>plotter.close()</span>
<span id="cb176-24"><a href="#cb176-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb176-25"><a href="#cb176-25" aria-hidden="true" tabindex="-1"></a>log.set_log_level(log.LogLevel.WARNING)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[2025-11-19 17:31:55.749] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:31:58.440] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:00.732] [info] Newton iteration 2: r (abs) = 22.245488847569664 (tol = 1e-08), r (rel) = 0.1342779422433199 (tol = 1e-08)
[2025-11-19 17:32:00.949] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:03.089] [info] Newton iteration 3: r (abs) = 2.432613380788242 (tol = 1e-08), r (rel) = 0.01468371053942908 (tol = 1e-08)
[2025-11-19 17:32:03.302] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:05.568] [info] Newton iteration 4: r (abs) = 4.431578720802735 (tol = 1e-08), r (rel) = 0.026749840185403984 (tol = 1e-08)
[2025-11-19 17:32:05.782] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:08.012] [info] Newton iteration 5: r (abs) = 0.14418915583061978 (tol = 1e-08), r (rel) = 0.0008703527834971478 (tol = 1e-08)
[2025-11-19 17:32:08.224] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:10.320] [info] Newton iteration 6: r (abs) = 0.02142394652831032 (tol = 1e-08), r (rel) = 0.00012931895874550384 (tol = 1e-08)
[2025-11-19 17:32:10.533] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:12.646] [info] Newton iteration 7: r (abs) = 4.80066955935609e-06 (tol = 1e-08), r (rel) = 2.8977741700241697e-08 (tol = 1e-08)
Time step 1, Number of iterations 8, Load [ 0.   0.  -1.5]
[2025-11-19 17:32:12.861] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:14.949] [info] Newton iteration 8: r (abs) = 2.6593315879693925e-11 (tol = 1e-08), r (rel) = 1.6052224153042273e-13 (tol = 1e-08)
[2025-11-19 17:32:14.949] [info] Newton solver finished in 8 iterations and 8 linear solver iterations.
[2025-11-19 17:32:15.281] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:17.597] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:19.796] [info] Newton iteration 2: r (abs) = 17.325417842770662 (tol = 1e-08), r (rel) = 0.11784222264969324 (tol = 1e-08)
[2025-11-19 17:32:20.009] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:22.162] [info] Newton iteration 3: r (abs) = 5.148824037029388 (tol = 1e-08), r (rel) = 0.03502073508771889 (tol = 1e-08)
[2025-11-19 17:32:22.376] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:24.494] [info] Newton iteration 4: r (abs) = 7.240032569659952 (tol = 1e-08), r (rel) = 0.0492444994866836 (tol = 1e-08)
[2025-11-19 17:32:24.705] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:26.818] [info] Newton iteration 5: r (abs) = 0.7778888011215269 (tol = 1e-08), r (rel) = 0.0052909630307540366 (tol = 1e-08)
[2025-11-19 17:32:27.024] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:29.084] [info] Newton iteration 6: r (abs) = 1.2552533144730293 (tol = 1e-08), r (rel) = 0.008537851260402308 (tol = 1e-08)
[2025-11-19 17:32:29.290] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:31.434] [info] Newton iteration 7: r (abs) = 0.008495122949791085 (tol = 1e-08), r (rel) = 5.778124251724872e-05 (tol = 1e-08)
[2025-11-19 17:32:31.645] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:33.784] [info] Newton iteration 8: r (abs) = 0.00019210705108344808 (tol = 1e-08), r (rel) = 1.3066537322098655e-06 (tol = 1e-08)
[2025-11-19 17:32:34.005] [info] PETSc Krylov solver starting to solve system.
Time step 2, Number of iterations 9, Load [ 0.  0. -3.]
[2025-11-19 17:32:36.088] [info] Newton iteration 9: r (abs) = 1.7065882144463082e-10 (tol = 1e-08), r (rel) = 1.1607693976745285e-12 (tol = 1e-08)
[2025-11-19 17:32:36.088] [info] Newton solver finished in 9 iterations and 9 linear solver iterations.
[2025-11-19 17:32:36.334] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:38.605] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:40.869] [info] Newton iteration 2: r (abs) = 10.001117239450483 (tol = 1e-08), r (rel) = 0.08874707904158333 (tol = 1e-08)
[2025-11-19 17:32:41.079] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:43.190] [info] Newton iteration 3: r (abs) = 5.330258434852234 (tol = 1e-08), r (rel) = 0.04729920220952126 (tol = 1e-08)
[2025-11-19 17:32:43.405] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:45.499] [info] Newton iteration 4: r (abs) = 11.990116721075117 (tol = 1e-08), r (rel) = 0.10639689655528227 (tol = 1e-08)
[2025-11-19 17:32:45.716] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:47.779] [info] Newton iteration 5: r (abs) = 2.2970192412283055 (tol = 1e-08), r (rel) = 0.020383097536063585 (tol = 1e-08)
[2025-11-19 17:32:47.991] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:50.122] [info] Newton iteration 6: r (abs) = 3.9023388069967275 (tol = 1e-08), r (rel) = 0.03462824825065298 (tol = 1e-08)
[2025-11-19 17:32:50.335] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:52.453] [info] Newton iteration 7: r (abs) = 0.23653543302398086 (tol = 1e-08), r (rel) = 0.0020989483742786096 (tol = 1e-08)
[2025-11-19 17:32:52.658] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:55.145] [info] Newton iteration 8: r (abs) = 0.04271420922498156 (tol = 1e-08), r (rel) = 0.0003790337830792644 (tol = 1e-08)
[2025-11-19 17:32:55.396] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:32:57.636] [info] Newton iteration 9: r (abs) = 2.8779784817306148e-05 (tol = 1e-08), r (rel) = 2.553836513290955e-07 (tol = 1e-08)
[2025-11-19 17:32:57.854] [info] PETSc Krylov solver starting to solve system.
Time step 3, Number of iterations 10, Load [ 0.   0.  -4.5]
[2025-11-19 17:33:00.120] [info] Newton iteration 10: r (abs) = 6.077785953131127e-10 (tol = 1e-08), r (rel) = 5.393254948084079e-12 (tol = 1e-08)
[2025-11-19 17:33:00.120] [info] Newton solver finished in 10 iterations and 10 linear solver iterations.
[2025-11-19 17:33:00.366] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:02.733] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:04.918] [info] Newton iteration 2: r (abs) = 5.506929934734036 (tol = 1e-08), r (rel) = 0.06539183682426397 (tol = 1e-08)
[2025-11-19 17:33:05.139] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:07.246] [info] Newton iteration 3: r (abs) = 26.248919589460577 (tol = 1e-08), r (rel) = 0.3116918295584109 (tol = 1e-08)
[2025-11-19 17:33:07.460] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:09.549] [info] Newton iteration 4: r (abs) = 2.309270521316821 (tol = 1e-08), r (rel) = 0.027421347811341937 (tol = 1e-08)
[2025-11-19 17:33:09.761] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:11.910] [info] Newton iteration 5: r (abs) = 14.056244490622522 (tol = 1e-08), r (rel) = 0.16691035785570413 (tol = 1e-08)
[2025-11-19 17:33:12.127] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:14.318] [info] Newton iteration 6: r (abs) = 0.22277413322257641 (tol = 1e-08), r (rel) = 0.0026453232456209053 (tol = 1e-08)
[2025-11-19 17:33:14.533] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:16.690] [info] Newton iteration 7: r (abs) = 0.28667052510539687 (tol = 1e-08), r (rel) = 0.0034040585992898666 (tol = 1e-08)
[2025-11-19 17:33:16.901] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:18.985] [info] Newton iteration 8: r (abs) = 0.00032186938773632337 (tol = 1e-08), r (rel) = 3.822026198086344e-06 (tol = 1e-08)
[2025-11-19 17:33:19.194] [info] PETSc Krylov solver starting to solve system.
Time step 4, Number of iterations 9, Load [ 0.  0. -6.]
[2025-11-19 17:33:21.385] [info] Newton iteration 9: r (abs) = 2.637964780929628e-07 (tol = 1e-08), r (rel) = 3.132441569933224e-09 (tol = 1e-08)
[2025-11-19 17:33:21.385] [info] Newton solver finished in 9 iterations and 9 linear solver iterations.
[2025-11-19 17:33:21.632] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:24.004] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:26.182] [info] Newton iteration 2: r (abs) = 3.194619708234956 (tol = 1e-08), r (rel) = 0.04964789514888014 (tol = 1e-08)
[2025-11-19 17:33:26.397] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:28.439] [info] Newton iteration 3: r (abs) = 7.714285832925293 (tol = 1e-08), r (rel) = 0.1198884653451208 (tol = 1e-08)
[2025-11-19 17:33:28.652] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:30.785] [info] Newton iteration 4: r (abs) = 0.8508731194677975 (tol = 1e-08), r (rel) = 0.013223501786908416 (tol = 1e-08)
[2025-11-19 17:33:30.991] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:33.109] [info] Newton iteration 5: r (abs) = 0.3714343524134822 (tol = 1e-08), r (rel) = 0.005772497344763917 (tol = 1e-08)
[2025-11-19 17:33:33.321] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:35.509] [info] Newton iteration 6: r (abs) = 0.002150656410572117 (tol = 1e-08), r (rel) = 3.342356014961964e-05 (tol = 1e-08)
[2025-11-19 17:33:35.720] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:37.887] [info] Newton iteration 7: r (abs) = 2.546067480793498e-06 (tol = 1e-08), r (rel) = 3.956868199446797e-08 (tol = 1e-08)
Time step 5, Number of iterations 8, Load [ 0.   0.  -7.5]
[2025-11-19 17:33:38.099] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:40.173] [info] Newton iteration 8: r (abs) = 1.6857449626793708e-13 (tol = 1e-08), r (rel) = 2.619832618546621e-15 (tol = 1e-08)
[2025-11-19 17:33:40.173] [info] Newton solver finished in 8 iterations and 8 linear solver iterations.
[2025-11-19 17:33:40.415] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:42.762] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:44.879] [info] Newton iteration 2: r (abs) = 2.006488301405612 (tol = 1e-08), r (rel) = 0.0395622031385681 (tol = 1e-08)
[2025-11-19 17:33:45.088] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:47.184] [info] Newton iteration 3: r (abs) = 4.609768229355378 (tol = 1e-08), r (rel) = 0.09089142806549969 (tol = 1e-08)
[2025-11-19 17:33:47.399] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:49.544] [info] Newton iteration 4: r (abs) = 0.18537214300427624 (tol = 1e-08), r (rel) = 0.0036550077927837146 (tol = 1e-08)
[2025-11-19 17:33:49.756] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:51.796] [info] Newton iteration 5: r (abs) = 0.02468800140561847 (tol = 1e-08), r (rel) = 0.00048677668641781437 (tol = 1e-08)
[2025-11-19 17:33:52.003] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:54.167] [info] Newton iteration 6: r (abs) = 5.6925390491283854e-06 (tol = 1e-08), r (rel) = 1.1224056780100924e-07 (tol = 1e-08)
[2025-11-19 17:33:54.376] [info] PETSc Krylov solver starting to solve system.
Time step 6, Number of iterations 7, Load [ 0.  0. -9.]
[2025-11-19 17:33:56.492] [info] Newton iteration 7: r (abs) = 2.6204561860805414e-11 (tol = 1e-08), r (rel) = 5.166789154803981e-13 (tol = 1e-08)
[2025-11-19 17:33:56.493] [info] Newton solver finished in 7 iterations and 7 linear solver iterations.
[2025-11-19 17:33:56.728] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:33:58.952] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:34:01.103] [info] Newton iteration 2: r (abs) = 1.3850621350551318 (tol = 1e-08), r (rel) = 0.033662175723783674 (tol = 1e-08)
[2025-11-19 17:34:01.329] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:34:03.408] [info] Newton iteration 3: r (abs) = 3.0373936052903123 (tol = 1e-08), r (rel) = 0.07381999312219266 (tol = 1e-08)
[2025-11-19 17:34:03.627] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:34:05.792] [info] Newton iteration 4: r (abs) = 0.04123861973234785 (tol = 1e-08), r (rel) = 0.00100225226645253 (tol = 1e-08)
[2025-11-19 17:34:06.002] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:34:08.139] [info] Newton iteration 5: r (abs) = 0.00205056641006533 (tol = 1e-08), r (rel) = 4.983641172614961e-05 (tol = 1e-08)
[2025-11-19 17:34:08.369] [info] PETSc Krylov solver starting to solve system.
Time step 7, Number of iterations 6, Load [  0.    0.  -10.5]
[2025-11-19 17:34:10.591] [info] Newton iteration 6: r (abs) = 1.7885886176830885e-08 (tol = 1e-08), r (rel) = 4.346937427728534e-10 (tol = 1e-08)
[2025-11-19 17:34:10.591] [info] Newton solver finished in 6 iterations and 6 linear solver iterations.
[2025-11-19 17:34:10.849] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:34:13.183] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:34:15.230] [info] Newton iteration 2: r (abs) = 1.0633648528364101 (tol = 1e-08), r (rel) = 0.031085002034186824 (tol = 1e-08)
[2025-11-19 17:34:15.439] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:34:17.500] [info] Newton iteration 3: r (abs) = 2.0477031306171987 (tol = 1e-08), r (rel) = 0.05985984566901875 (tol = 1e-08)
[2025-11-19 17:34:17.707] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:34:19.759] [info] Newton iteration 4: r (abs) = 0.008977192522240718 (tol = 1e-08), r (rel) = 0.0002624273757692741 (tol = 1e-08)
[2025-11-19 17:34:19.970] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:34:22.167] [info] Newton iteration 5: r (abs) = 0.00016742178144130685 (tol = 1e-08), r (rel) = 4.894186978992472e-06 (tol = 1e-08)
[2025-11-19 17:34:22.381] [info] PETSc Krylov solver starting to solve system.
Time step 8, Number of iterations 6, Load [  0.   0. -12.]
[2025-11-19 17:34:24.434] [info] Newton iteration 6: r (abs) = 3.241819305822145e-11 (tol = 1e-08), r (rel) = 9.476705897053983e-13 (tol = 1e-08)
[2025-11-19 17:34:24.434] [info] Newton solver finished in 6 iterations and 6 linear solver iterations.
[2025-11-19 17:34:24.680] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:34:27.001] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:34:29.082] [info] Newton iteration 2: r (abs) = 0.898788614589174 (tol = 1e-08), r (rel) = 0.030966555717676078 (tol = 1e-08)
[2025-11-19 17:34:29.290] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:34:31.458] [info] Newton iteration 3: r (abs) = 1.3835366517792282 (tol = 1e-08), r (rel) = 0.04766789890229271 (tol = 1e-08)
[2025-11-19 17:34:31.681] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:34:33.897] [info] Newton iteration 4: r (abs) = 0.001850960693256602 (tol = 1e-08), r (rel) = 6.377236706003253e-05 (tol = 1e-08)
[2025-11-19 17:34:34.147] [info] PETSc Krylov solver starting to solve system.
[2025-11-19 17:34:36.312] [info] Newton iteration 5: r (abs) = 7.871830666129107e-06 (tol = 1e-08), r (rel) = 2.712133631490422e-07 (tol = 1e-08)
[2025-11-19 17:34:36.532] [info] PETSc Krylov solver starting to solve system.
Time step 9, Number of iterations 6, Load [  0.    0.  -13.5]
[2025-11-19 17:34:38.612] [info] Newton iteration 6: r (abs) = 4.498496771177386e-13 (tol = 1e-08), r (rel) = 1.549896701507776e-14 (tol = 1e-08)
[2025-11-19 17:34:38.612] [info] Newton solver finished in 6 iterations and 6 linear solver iterations.</code></pre>
</div>
</div>
<p><img src="fenicsx/hyperelasticity/deformation.gif" class="img-fluid" /></p>
</section>
<section id="sec-fenicsx-helmholtz" class="level3" data-number="K.7.7">
<h3 data-number="K.7.7"><span class="header-section-number">K.7.7</span> The Helmholtz equation</h3>
<p>Author: Antonio Baiano Svizzero</p>
<p>The study of computational acoustics is essential in fields such as noise, vibration, and harshness (NVH), noise control, and acoustic design. In this section, we focus on the theoretical foundations of the Helmholtz equation—which is valid for noise problems with harmonic time dependence—and its implementation in <code>FEniCSx</code> to compute the sound pressure in arbitrary acoustic systems</p>
<p><strong>The PDE problem</strong></p>
<p>The acoustic Helmholtz equation in its general form reads</p>
<p><span class="math display">\[
\begin{aligned}
\nabla^2 p + k^2 p = -j \omega \rho_0 q \quad\text{in } \Omega
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(p\)</span> is the complex acoustic pressure, <span class="math inline">\(k\)</span> the wavenumber, <span class="math inline">\(\omega\)</span> the angular frequency, <span class="math inline">\(j\)</span> the imaginary unit, and <span class="math inline">\(q\)</span> the volume velocity (<span class="math inline">\(\mathrm{m^3/s}\)</span>) of a generic source field. In the case of a monopole source, <span class="math inline">\(q\)</span> can be written as</p>
<p><span class="math display">\[q = Q \, \delta(x_s, y_s, z_s)\]</span></p>
<p>where <span class="math inline">\(\delta(x_s, y_s, z_s)\)</span> is the three-dimensional Dirac delta function centered at the monopole location. This formulation allows the computation of the sound pressure field generated by any generic source distribution, while the monopole source provides a simple yet fundamental example for analytical and numerical studies in computational acoustics</p>
<p>In order to solve this problem with real-valued solvers in <code>FEniCSx</code>, we split the complex pressure into its real and imaginary parts:</p>
<p><span class="math display">\[p = p_r + j \, p_i\]</span></p>
<p>with <span class="math inline">\(p_r\)</span> and <span class="math inline">\(p_i\)</span> real-valued functions representing the real and imaginary components, respectively. Substituting this into the original equation and separating real and imaginary parts leads to two coupled real-valued PDEs:</p>
<p><span class="math display">\[\begin{aligned}
\nabla^2 p_r + k^2 p_r &amp;= 0, \\
\nabla^2 p_i + k^2 p_i &amp;= - \omega \, \rho_0 \, q,
\end{aligned}
\quad \text{in } \Omega\]</span></p>
<p>After splitting the complex pressure <span class="math inline">\(p = p_r + j\, p_i\)</span> into its real and imaginary parts, the boundary conditions are applied separately to <span class="math inline">\(p_r\)</span> and <span class="math inline">\(p_i\)</span>:</p>
<ul>
<li><p>Dirichlet BC:</p>
<p><span class="math display">\[p_r = \Re(\bar{p}), \quad p_i = \Im(\bar{p}) \quad \text{on } \partial\Omega_p\]</span></p></li>
<li><p>Neumann BC:</p>
<p><span class="math display">\[\frac{\partial p_r}{\partial n} = 0, \quad
  \frac{\partial p_i}{\partial n} = - \omega \, \rho_0 \, \bar{v}_n \quad \text{on } \partial\Omega_v\]</span></p></li>
<li><p>Robin BC:</p>
<p><span class="math display">\[\frac{\partial p_r}{\partial n} =
    \frac{\omega \, \rho_0}{\bar{Z}} \, p_i, \quad
  \frac{\partial p_i}{\partial n} = -\frac{\omega \, \rho_0}{\bar{Z}} \, p_r \quad \text{on } \partial\Omega_Z\]</span></p></li>
</ul>
<p>where <span class="math inline">\(\bar{p}\)</span> is the complex prescribed acoustic pressure at <span class="math inline">\(\partial\Omega_p\)</span>, <span class="math inline">\(\bar{v}_n\)</span> is the prescribed normal sound particle velocity at <span class="math inline">\(\partial\Omega_v\)</span>, and <span class="math inline">\(\bar{Z}\)</span> is the prescribed acoustic impedance at <span class="math inline">\(\partial\Omega_Z\)</span>, with <span class="math inline">\(n\)</span> denoting the outward unit normal. In this context, the overbar notation is used to denote prescribed boundary quantities (known data) in order to distinguish them from the unknown fields. It should be emphasized that the overbar does not indicate a complex conjugate</p>
<p>This formulation allows the use of real-valued solvers while fully accounting for the effect of complex-valued boundary conditions in the Helmholtz problem</p>
<p><strong>Weak formulation in terms of real and imaginary parts</strong></p>
<p>Let the complex source be</p>
<p><span class="math display">\[
q = q_r + j\,q_i,
\]</span></p>
<p>and let the (possibly complex) surface impedance and the prescribed normal velocity be</p>
<p><span class="math display">\[
\bar Z = Z_r + j\,Z_i,\qquad \bar v_n = v_{n,r} + j\,v_{n,i},
\]</span></p>
<p>with <span class="math inline">\(Z_r,Z_i,v_{n,r},v_{n,i}\in\mathbb{R}\)</span>. Define <span class="math inline">\(\Delta_Z = Z_r^2+Z_i^2\)</span>. Then</p>
<p><span class="math display">\[
\frac{j\,\omega\rho_0}{\bar Z}
= \frac{\omega\rho_0}{\Delta_Z}\bigl(Z_i + j\,Z_r\bigr)
\]</span></p>
<p>Multiplying the complex Helmholtz equation by a real test function <span class="math inline">\(v \in \hat V\)</span> and separating real and imaginary parts yields the following two real variational problems.</p>
<ul>
<li>Real part (for <span class="math inline">\(p_r\)</span>):</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\int_{\Omega} \nabla p_r \cdot \nabla v \,\mathrm{d}x
&amp;- k^2 \int_{\Omega} p_r\,v\,\mathrm{d}x
+ \frac{\omega\rho_0}{\Delta_Z}\int_{\partial\Omega_Z} \bigl(Z_i p_r - Z_r p_i\bigr)\,v\,\mathrm{d}s \\
=&amp; -\,\omega\rho_0\int_{\Omega} q_i\,v\,\mathrm{d}x
\;+\; \omega\rho_0\int_{\partial\Omega_v} v_{n,i}\,v\,\mathrm{d}s
\end{aligned}\]</span></p>
<ul>
<li>Imaginary part (for <span class="math inline">\(p_i\)</span>):</li>
</ul>
<p><span class="math display">\[
\begin{aligned}
\int_{\Omega} \nabla p_i \cdot \nabla v \,\mathrm{d}x
&amp;- k^2 \int_{\Omega} p_i\,v\,\mathrm{d}x
+ \frac{\omega\rho_0}{\Delta_Z}\int_{\partial\Omega_Z} \bigl(Z_r p_r + Z_i p_i\bigr)\,v\,\mathrm{d}s \\
=&amp; \;\omega\rho_0\int_{\Omega} q_r\,v\,\mathrm{d}x
\;-\; \omega\rho_0\int_{\partial\Omega_v} v_{n,r}\,v\,\mathrm{d}s
\end{aligned}\]</span></p>
<p>After solving these two coupled real systems for <span class="math inline">\(p_r\)</span> and <span class="math inline">\(p_i\)</span>, the complex pressure is reconstructed as <span class="math inline">\(p = p_r + \mathrm{i}\,p_i\)</span>, from which amplitude <span class="math inline">\(|p|\)</span>, phase and derived quantities such as the Sound Pressure Level (SPL) can be computed</p>
<p>In this section, you will learn how to:</p>
<ul>
<li>Define acoustic velocity and impedance boundary conditions</li>
<li>Compute the acoustic sound pressure for multiple frequencies</li>
<li>Evaluate the SPL at a given microphone position</li>
</ul>
<p><strong>Test problem</strong></p>
<p>As an example, we model a plane wave propagating through a tube. Although this is a basic test case, the code can be extended to more complex problems requiring velocity and impedance boundary conditions</p>
<p>Finally, we create the mesh with <code>GMSH</code>, defining the physical groups for the velocity and impedance boundary conditions along with their respective tags</p>
<div id="1ac545df" class="cell" data-execution_count="157">
<div class="sourceCode" id="cb178"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb178-1"><a href="#cb178-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> gmsh</span>
<span id="cb178-2"><a href="#cb178-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-3"><a href="#cb178-3" aria-hidden="true" tabindex="-1"></a><span class="co"># ---------------------------------</span></span>
<span id="cb178-4"><a href="#cb178-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Create gmsh box and tag facets</span></span>
<span id="cb178-5"><a href="#cb178-5" aria-hidden="true" tabindex="-1"></a><span class="co"># ---------------------------------</span></span>
<span id="cb178-6"><a href="#cb178-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-7"><a href="#cb178-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> gmsh.isInitialized():</span>
<span id="cb178-8"><a href="#cb178-8" aria-hidden="true" tabindex="-1"></a>  gmsh.initialize()</span>
<span id="cb178-9"><a href="#cb178-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-10"><a href="#cb178-10" aria-hidden="true" tabindex="-1"></a><span class="co"># meshsize settings</span></span>
<span id="cb178-11"><a href="#cb178-11" aria-hidden="true" tabindex="-1"></a>meshsize <span class="op">=</span> <span class="fl">0.02</span></span>
<span id="cb178-12"><a href="#cb178-12" aria-hidden="true" tabindex="-1"></a>gmsh.option.setNumber(<span class="st">&quot;Mesh.MeshSizeMin&quot;</span>, meshsize)</span>
<span id="cb178-13"><a href="#cb178-13" aria-hidden="true" tabindex="-1"></a>gmsh.option.setNumber(<span class="st">&quot;Mesh.MeshSizeMax&quot;</span>, meshsize)</span>
<span id="cb178-14"><a href="#cb178-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-15"><a href="#cb178-15" aria-hidden="true" tabindex="-1"></a><span class="co"># create geometry</span></span>
<span id="cb178-16"><a href="#cb178-16" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="fl">1.0</span></span>
<span id="cb178-17"><a href="#cb178-17" aria-hidden="true" tabindex="-1"></a>W <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb178-18"><a href="#cb178-18" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> <span class="fl">0.1</span></span>
<span id="cb178-19"><a href="#cb178-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-20"><a href="#cb178-20" aria-hidden="true" tabindex="-1"></a>gdim <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb178-21"><a href="#cb178-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-22"><a href="#cb178-22" aria-hidden="true" tabindex="-1"></a>box <span class="op">=</span> gmsh.model.occ.addBox(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, L, W, H)</span>
<span id="cb178-23"><a href="#cb178-23" aria-hidden="true" tabindex="-1"></a>gmsh.model.occ.synchronize()</span>
<span id="cb178-24"><a href="#cb178-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-25"><a href="#cb178-25" aria-hidden="true" tabindex="-1"></a><span class="co"># Remove any existing physical groups with the same (dim, tag)</span></span>
<span id="cb178-26"><a href="#cb178-26" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> dim, tag <span class="kw">in</span> gmsh.model.getPhysicalGroups():</span>
<span id="cb178-27"><a href="#cb178-27" aria-hidden="true" tabindex="-1"></a>  gmsh.model.removePhysicalGroups([(dim, tag)])</span>
<span id="cb178-28"><a href="#cb178-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-29"><a href="#cb178-29" aria-hidden="true" tabindex="-1"></a><span class="co"># get surfaces</span></span>
<span id="cb178-30"><a href="#cb178-30" aria-hidden="true" tabindex="-1"></a>surfaces <span class="op">=</span> gmsh.model.getEntities(dim<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb178-31"><a href="#cb178-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-32"><a href="#cb178-32" aria-hidden="true" tabindex="-1"></a><span class="co"># tolerance for coordinate matching</span></span>
<span id="cb178-33"><a href="#cb178-33" aria-hidden="true" tabindex="-1"></a>tol <span class="op">=</span> <span class="fl">1e-6</span></span>
<span id="cb178-34"><a href="#cb178-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-35"><a href="#cb178-35" aria-hidden="true" tabindex="-1"></a>velocity_surfaces <span class="op">=</span> []</span>
<span id="cb178-36"><a href="#cb178-36" aria-hidden="true" tabindex="-1"></a>impedance_surfaces <span class="op">=</span> []</span>
<span id="cb178-37"><a href="#cb178-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-38"><a href="#cb178-38" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (dim, tag) <span class="kw">in</span> surfaces:</span>
<span id="cb178-39"><a href="#cb178-39" aria-hidden="true" tabindex="-1"></a>  com <span class="op">=</span> gmsh.model.occ.getCenterOfMass(dim, tag)</span>
<span id="cb178-40"><a href="#cb178-40" aria-hidden="true" tabindex="-1"></a>  x, y, z <span class="op">=</span> com</span>
<span id="cb178-41"><a href="#cb178-41" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="bu">abs</span>(x <span class="op">-</span><span class="fl">0.0</span>) <span class="op">&lt;</span> tol:      <span class="co"># x = 0 face</span></span>
<span id="cb178-42"><a href="#cb178-42" aria-hidden="true" tabindex="-1"></a>    velocity_surfaces.append(tag)</span>
<span id="cb178-43"><a href="#cb178-43" aria-hidden="true" tabindex="-1"></a>  <span class="cf">elif</span> <span class="bu">abs</span>(x <span class="op">-</span>L) <span class="op">&lt;</span> tol:      <span class="co"># x = L face</span></span>
<span id="cb178-44"><a href="#cb178-44" aria-hidden="true" tabindex="-1"></a>    impedance_surfaces.append(tag)</span>
<span id="cb178-45"><a href="#cb178-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-46"><a href="#cb178-46" aria-hidden="true" tabindex="-1"></a><span class="co"># setup physical groups</span></span>
<span id="cb178-47"><a href="#cb178-47" aria-hidden="true" tabindex="-1"></a>vol_tag <span class="op">=</span> gmsh.model.addPhysicalGroup(<span class="dv">3</span>, [box], <span class="dv">1</span>)</span>
<span id="cb178-48"><a href="#cb178-48" aria-hidden="true" tabindex="-1"></a>gmsh.model.setPhysicalName(<span class="dv">3</span>, vol_tag, <span class="st">&quot;air_volume&quot;</span>)</span>
<span id="cb178-49"><a href="#cb178-49" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-50"><a href="#cb178-50" aria-hidden="true" tabindex="-1"></a>v_bc_tag <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb178-51"><a href="#cb178-51" aria-hidden="true" tabindex="-1"></a>Z_bc_tag <span class="op">=</span> <span class="dv">3</span></span>
<span id="cb178-52"><a href="#cb178-52" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-53"><a href="#cb178-53" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> velocity_surfaces:</span>
<span id="cb178-54"><a href="#cb178-54" aria-hidden="true" tabindex="-1"></a>  gmsh.model.addPhysicalGroup(<span class="dv">2</span>, velocity_surfaces, v_bc_tag)</span>
<span id="cb178-55"><a href="#cb178-55" aria-hidden="true" tabindex="-1"></a>  gmsh.model.setPhysicalName(<span class="dv">2</span>, v_bc_tag, <span class="st">&quot;velocity_BC&quot;</span>) </span>
<span id="cb178-56"><a href="#cb178-56" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> impedance_surfaces:</span>
<span id="cb178-57"><a href="#cb178-57" aria-hidden="true" tabindex="-1"></a>  gmsh.model.addPhysicalGroup(<span class="dv">2</span>, impedance_surfaces, Z_bc_tag) </span>
<span id="cb178-58"><a href="#cb178-58" aria-hidden="true" tabindex="-1"></a>  gmsh.model.setPhysicalName(<span class="dv">2</span>, Z_bc_tag, <span class="st">&quot;impedance_BC&quot;</span>)</span>
<span id="cb178-59"><a href="#cb178-59" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb178-60"><a href="#cb178-60" aria-hidden="true" tabindex="-1"></a><span class="co"># mesh generation</span></span>
<span id="cb178-61"><a href="#cb178-61" aria-hidden="true" tabindex="-1"></a>gmsh.model.mesh.generate(dim<span class="op">=</span><span class="dv">3</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Info    : Meshing 1D...
Info    : [  0%] Meshing curve 1 (Line)
Info    : [ 10%] Meshing curve 2 (Line)
Info    : [ 20%] Meshing curve 3 (Line)
Info    : [ 30%] Meshing curve 4 (Line)
Info    : [ 40%] Meshing curve 5 (Line)
Info    : [ 50%] Meshing curve 6 (Line)
Info    : [ 60%] Meshing curve 7 (Line)
Info    : [ 60%] Meshing curve 8 (Line)
Info    : [ 70%] Meshing curve 9 (Line)
Info    : [ 80%] Meshing curve 10 (Line)
Info    : [ 90%] Meshing curve 11 (Line)
Info    : [100%] Meshing curve 12 (Line)
Info    : Done meshing 1D (Wall 0.000959s, CPU 0.001921s)
Info    : Meshing 2D...
Info    : [  0%] Meshing surface 1 (Plane, Frontal-Delaunay)
Info    : [ 20%] Meshing surface 2 (Plane, Frontal-Delaunay)
Info    : [ 40%] Meshing surface 3 (Plane, Frontal-Delaunay)
Info    : [ 60%] Meshing surface 4 (Plane, Frontal-Delaunay)
Info    : [ 70%] Meshing surface 5 (Plane, Frontal-Delaunay)
Info    : [ 90%] Meshing surface 6 (Plane, Frontal-Delaunay)
Info    : Done meshing 2D (Wall 0.0359064s, CPU 0.05662s)
Info    : Meshing 3D...
Info    : 3D Meshing 1 volume with 1 connected component
Info    : Tetrahedrizing 1282 nodes...
Info    : Done tetrahedrizing 1290 nodes (Wall 0.0108754s, CPU 0.017445s)
Info    : Reconstructing mesh...
Info    :  - Creating surface mesh
Info    :  - Identifying boundary edges
Info    :  - Recovering boundary
Info    : Done reconstructing mesh (Wall 0.0225103s, CPU 0.036216s)
Info    : Found volume 1
Info    : It. 0 - 0 nodes created - worst tet radius 2.57041 (nodes removed 0 0)
Info    : 3D refinement terminated (1735 nodes total):
Info    :  - 0 Delaunay cavities modified for star shapeness
Info    :  - 0 nodes could not be inserted
Info    :  - 6565 tetrahedra created in 0.0207871 sec. (315821 tets/s)
Info    : 0 node relocations
Info    : Done meshing 3D (Wall 0.0807603s, CPU 0.129058s)
Info    : Optimizing mesh...
Info    : Optimizing volume 1
Info    : Optimization starts (volume = 0.01) with worst = 0.0110445 / average = 0.765866:
Info    : 0.00 &lt; quality &lt; 0.10 :        24 elements
Info    : 0.10 &lt; quality &lt; 0.20 :        51 elements
Info    : 0.20 &lt; quality &lt; 0.30 :        74 elements
Info    : 0.30 &lt; quality &lt; 0.40 :        61 elements
Info    : 0.40 &lt; quality &lt; 0.50 :       192 elements
Info    : 0.50 &lt; quality &lt; 0.60 :       307 elements
Info    : 0.60 &lt; quality &lt; 0.70 :       893 elements
Info    : 0.70 &lt; quality &lt; 0.80 :      1910 elements
Info    : 0.80 &lt; quality &lt; 0.90 :      1996 elements
Info    : 0.90 &lt; quality &lt; 1.00 :      1054 elements
Info    : 149 edge swaps, 2 node relocations (volume = 0.01): worst = 0.300158 / average = 0.781673 (Wall 0.00225179s, CPU 0.003652s)
Info    : No ill-shaped tets in the mesh :-)
Info    : 0.00 &lt; quality &lt; 0.10 :         0 elements
Info    : 0.10 &lt; quality &lt; 0.20 :         0 elements
Info    : 0.20 &lt; quality &lt; 0.30 :         0 elements
Info    : 0.30 &lt; quality &lt; 0.40 :        60 elements
Info    : 0.40 &lt; quality &lt; 0.50 :       159 elements
Info    : 0.50 &lt; quality &lt; 0.60 :       293 elements
Info    : 0.60 &lt; quality &lt; 0.70 :       900 elements
Info    : 0.70 &lt; quality &lt; 0.80 :      1940 elements
Info    : 0.80 &lt; quality &lt; 0.90 :      2017 elements
Info    : 0.90 &lt; quality &lt; 1.00 :      1050 elements
Info    : Done optimizing mesh (Wall 0.00645046s, CPU 0.010335s)
Info    : 1735 nodes 9230 elements</code></pre>
</div>
</div>
<p>We then import the mesh generated by <code>Gmsh</code> with the <code>dolfinx.io.gmshio</code> function</p>
<div id="c949a8bc" class="cell" data-execution_count="158">
<div class="sourceCode" id="cb180"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb180-1"><a href="#cb180-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> csv</span>
<span id="cb180-2"><a href="#cb180-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb180-3"><a href="#cb180-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-4"><a href="#cb180-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb180-5"><a href="#cb180-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb180-6"><a href="#cb180-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb180-7"><a href="#cb180-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-8"><a href="#cb180-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb180-9"><a href="#cb180-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> (</span>
<span id="cb180-10"><a href="#cb180-10" aria-hidden="true" tabindex="-1"></a>  fem,</span>
<span id="cb180-11"><a href="#cb180-11" aria-hidden="true" tabindex="-1"></a>  io,</span>
<span id="cb180-12"><a href="#cb180-12" aria-hidden="true" tabindex="-1"></a>  default_scalar_type,</span>
<span id="cb180-13"><a href="#cb180-13" aria-hidden="true" tabindex="-1"></a>  geometry,</span>
<span id="cb180-14"><a href="#cb180-14" aria-hidden="true" tabindex="-1"></a>  plot,</span>
<span id="cb180-15"><a href="#cb180-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb180-16"><a href="#cb180-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> LinearProblem</span>
<span id="cb180-17"><a href="#cb180-17" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ufl</span>
<span id="cb180-18"><a href="#cb180-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-19"><a href="#cb180-19" aria-hidden="true" tabindex="-1"></a>comm <span class="op">=</span> MPI.COMM_WORLD</span>
<span id="cb180-20"><a href="#cb180-20" aria-hidden="true" tabindex="-1"></a>rank <span class="op">=</span> comm.rank</span>
<span id="cb180-21"><a href="#cb180-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-22"><a href="#cb180-22" aria-hidden="true" tabindex="-1"></a>mesh_data <span class="op">=</span> io.gmshio.model_to_mesh(</span>
<span id="cb180-23"><a href="#cb180-23" aria-hidden="true" tabindex="-1"></a>  gmsh.model, </span>
<span id="cb180-24"><a href="#cb180-24" aria-hidden="true" tabindex="-1"></a>  comm, </span>
<span id="cb180-25"><a href="#cb180-25" aria-hidden="true" tabindex="-1"></a>  <span class="dv">0</span>, </span>
<span id="cb180-26"><a href="#cb180-26" aria-hidden="true" tabindex="-1"></a>  gdim<span class="op">=</span><span class="dv">3</span></span>
<span id="cb180-27"><a href="#cb180-27" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb180-28"><a href="#cb180-28" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-29"><a href="#cb180-29" aria-hidden="true" tabindex="-1"></a>domain, _, facet_tags <span class="op">=</span> mesh_data</span>
<span id="cb180-30"><a href="#cb180-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb180-31"><a href="#cb180-31" aria-hidden="true" tabindex="-1"></a>gmsh.finalize()</span></code></pre></div>
</div>
<p>We define the function space for the unknowns <span class="math inline">\(p_r\)</span> and <span class="math inline">\(p_i\)</span>. We also specify the boundary integration measure <span class="math inline">\(ds\)</span> using <code>ufl</code></p>
<div id="286b7b23" class="cell" data-execution_count="159">
<div class="sourceCode" id="cb181"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb181-1"><a href="#cb181-1" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span>
<span id="cb181-2"><a href="#cb181-2" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> ufl.Measure(<span class="st">&quot;ds&quot;</span>, domain<span class="op">=</span>domain, subdomain_data<span class="op">=</span>facet_tags)</span></code></pre></div>
</div>
<div id="95f382ca" class="cell" data-execution_count="160">
<div class="sourceCode" id="cb182"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb182-1"><a href="#cb182-1" aria-hidden="true" tabindex="-1"></a>results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/helmholtz&quot;</span>)</span>
<span id="cb182-2"><a href="#cb182-2" aria-hidden="true" tabindex="-1"></a>results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb182-3"><a href="#cb182-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-4"><a href="#cb182-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Extract topology from mesh and create pyvista mesh</span></span>
<span id="cb182-5"><a href="#cb182-5" aria-hidden="true" tabindex="-1"></a>topology, cell_types, x <span class="op">=</span> plot.vtk_mesh(V)</span>
<span id="cb182-6"><a href="#cb182-6" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> pyvista.UnstructuredGrid(topology, cell_types, x)</span>
<span id="cb182-7"><a href="#cb182-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-8"><a href="#cb182-8" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb182-9"><a href="#cb182-9" aria-hidden="true" tabindex="-1"></a>plotter.add_mesh(grid, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb182-10"><a href="#cb182-10" aria-hidden="true" tabindex="-1"></a>plotter.add_axes()</span>
<span id="cb182-11"><a href="#cb182-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-12"><a href="#cb182-12" aria-hidden="true" tabindex="-1"></a><span class="co"># if not pyvista.OFF_SCREEN:</span></span>
<span id="cb182-13"><a href="#cb182-13" aria-hidden="true" tabindex="-1"></a><span class="co">#     plotter.show()</span></span>
<span id="cb182-14"><a href="#cb182-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb182-15"><a href="#cb182-15" aria-hidden="true" tabindex="-1"></a><span class="co"># HTML 저장</span></span>
<span id="cb182-16"><a href="#cb182-16" aria-hidden="true" tabindex="-1"></a>plotter.export_html(results_folder<span class="op">/</span><span class="st">&quot;helmholtz_mesh.html&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/helmholtz/helmholtz_mesh.html"
        width="100%" height="400px"
        style="border:none;">
</iframe>
<p><strong>Boundary conditions</strong></p>
<p>We impose a velocity boundary condition of <span class="math inline">\(v_n = 1.0 \times 10^{-5}\)</span> at one end of the tube. For simplicity, we omit the point source in this example (although it could be included using <a href="https://github.com/scientificcomputing/scifem"><code>scifem</code></a>). At the opposite end of the tube, we prescribe an impedance <span class="math inline">\(Z\)</span> computed with the Delaney–Bazley model, assuming a layer of thickness <span class="math inline">\(d = 0.01\)</span> and a flow resistivity <span class="math inline">\(\sigma = 1.5 \times 10^4\)</span>. This choice of impedance—corresponding to a plane wave propagating in free field—produces a solution without reflections</p>
<p>The Delaney–Bazley model is used to compute the characteristic impedance and the wavenumber of the porous layer, which is treated as an equivalent fluid with complex-valued properties:</p>
<p><span class="math display">\[
\begin{aligned}
Z_c(\omega) &amp;= \rho_0 c_0 \left[1 + 0.0571 X^{-0.754} - j\, 0.087 X^{-0.732}\right] \\
k_c(\omega) &amp;= \frac{\omega}{c_0} \left[1 + 0.0978 X^{-0.700} - j\, 0.189 X^{-0.595}\right]
\end{aligned}
\]</span></p>
<p>where <span class="math inline">\(X = \tfrac{\rho_0 f}{\sigma}\)</span></p>
<p>Using these values, we can compute the surface impedance. In the case of a rigid passive absorber mounted on a rigid wall, it is given by:</p>
<p><span class="math display">\[
Z_s = -j\, Z_c \cot(k_c d)
\]</span></p>
<p>Let’s create a function to calculate it</p>
<div id="cd8b234b" class="cell" data-execution_count="161">
<div class="sourceCode" id="cb183"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb183-1"><a href="#cb183-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Air parameters</span></span>
<span id="cb183-2"><a href="#cb183-2" aria-hidden="true" tabindex="-1"></a>rho0 <span class="op">=</span> <span class="fl">1.225</span>  <span class="co"># kg/m^3</span></span>
<span id="cb183-3"><a href="#cb183-3" aria-hidden="true" tabindex="-1"></a>c <span class="op">=</span> <span class="dv">340</span>       <span class="co"># m/s</span></span>
<span id="cb183-4"><a href="#cb183-4" aria-hidden="true" tabindex="-1"></a>p_ref <span class="op">=</span> <span class="fl">2e-5</span></span>
<span id="cb183-5"><a href="#cb183-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-6"><a href="#cb183-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Wall parameters</span></span>
<span id="cb183-7"><a href="#cb183-7" aria-hidden="true" tabindex="-1"></a>sigma <span class="op">=</span> <span class="fl">1.5e4</span>  <span class="co"># ***</span></span>
<span id="cb183-8"><a href="#cb183-8" aria-hidden="true" tabindex="-1"></a>d <span class="op">=</span> <span class="fl">0.01</span>       <span class="co"># ***</span></span>
<span id="cb183-9"><a href="#cb183-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb183-10"><a href="#cb183-10" aria-hidden="true" tabindex="-1"></a><span class="co"># Impedance calculation</span></span>
<span id="cb183-11"><a href="#cb183-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> delany_bazley_layer(f, rho0, c, sigma, d):</span>
<span id="cb183-12"><a href="#cb183-12" aria-hidden="true" tabindex="-1"></a>  X <span class="op">=</span> rho0 <span class="op">*</span>f <span class="op">/</span>sigma</span>
<span id="cb183-13"><a href="#cb183-13" aria-hidden="true" tabindex="-1"></a>  Zc <span class="op">=</span> rho0 <span class="op">*</span>c <span class="op">*</span>(<span class="dv">1</span> <span class="op">+</span><span class="fl">0.0571</span> <span class="op">*</span>(X<span class="op">**-</span><span class="fl">0.754</span>) <span class="op">-</span><span class="ot">1j</span> <span class="op">*</span><span class="fl">0.087</span> <span class="op">*</span>(X<span class="op">**-</span><span class="fl">0.732</span>))</span>
<span id="cb183-14"><a href="#cb183-14" aria-hidden="true" tabindex="-1"></a>  kc <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span>np.pi <span class="op">*</span>f <span class="op">/</span>c <span class="op">*</span>(<span class="dv">1</span> <span class="op">+</span><span class="fl">0.0978</span> <span class="op">*</span>(X<span class="op">**-</span><span class="fl">0.700</span>) <span class="op">-</span><span class="ot">1j</span> <span class="op">*</span><span class="fl">0.189</span> <span class="op">*</span>(X<span class="op">**-</span><span class="fl">0.595</span>))</span>
<span id="cb183-15"><a href="#cb183-15" aria-hidden="true" tabindex="-1"></a>  Z_s <span class="op">=</span> <span class="op">-</span><span class="ot">1j</span> <span class="op">*</span>Zc <span class="op">*</span>(<span class="dv">1</span> <span class="op">/</span>np.tan(kc <span class="op">*</span>d))</span>
<span id="cb183-16"><a href="#cb183-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> Z_s</span></code></pre></div>
</div>
<p>We define the value of the normal velocity at the first end of the tube. Since we are going to compute a sound pressure spectrum, all frequency-dependent variables (i.e., <span class="math inline">\(\omega\)</span>, <span class="math inline">\(k\)</span>, <span class="math inline">\(Z_r\)</span> and <span class="math inline">\(Z_i\)</span>) need to be updated within the frequency loop. To enable this, we initialize them as <code>DOLFINx</code> constants</p>
<div id="fedbcb7d" class="cell" data-execution_count="162">
<div class="sourceCode" id="cb184"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb184-1"><a href="#cb184-1" aria-hidden="true" tabindex="-1"></a><span class="co"># sources (zero in this case)</span></span>
<span id="cb184-2"><a href="#cb184-2" aria-hidden="true" tabindex="-1"></a>q_r <span class="op">=</span> fem.Constant(domain, <span class="fl">0.0</span>)</span>
<span id="cb184-3"><a href="#cb184-3" aria-hidden="true" tabindex="-1"></a>q_i <span class="op">=</span> fem.Constant(domain, <span class="fl">0.0</span>)</span>
<span id="cb184-4"><a href="#cb184-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-5"><a href="#cb184-5" aria-hidden="true" tabindex="-1"></a><span class="co"># velocity boundary condition (real part only here)</span></span>
<span id="cb184-6"><a href="#cb184-6" aria-hidden="true" tabindex="-1"></a>v_nr <span class="op">=</span> <span class="fl">1e-5</span>  <span class="co">#***</span></span>
<span id="cb184-7"><a href="#cb184-7" aria-hidden="true" tabindex="-1"></a>v_ni <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb184-8"><a href="#cb184-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-9"><a href="#cb184-9" aria-hidden="true" tabindex="-1"></a><span class="co"># frequency-dependent variables</span></span>
<span id="cb184-10"><a href="#cb184-10" aria-hidden="true" tabindex="-1"></a>omega <span class="op">=</span> fem.Constant(domain, default_scalar_type(<span class="dv">0</span>))</span>
<span id="cb184-11"><a href="#cb184-11" aria-hidden="true" tabindex="-1"></a>k <span class="op">=</span> fem.Constant(domain, default_scalar_type(<span class="dv">0</span>))</span>
<span id="cb184-12"><a href="#cb184-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-13"><a href="#cb184-13" aria-hidden="true" tabindex="-1"></a>Z_r <span class="op">=</span> fem.Constant(domain, default_scalar_type(<span class="dv">0</span>))</span>
<span id="cb184-14"><a href="#cb184-14" aria-hidden="true" tabindex="-1"></a>Z_i <span class="op">=</span> fem.Constant(domain, default_scalar_type(<span class="dv">0</span>))</span>
<span id="cb184-15"><a href="#cb184-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb184-16"><a href="#cb184-16" aria-hidden="true" tabindex="-1"></a><span class="co"># probe point at center</span></span>
<span id="cb184-17"><a href="#cb184-17" aria-hidden="true" tabindex="-1"></a>probe_points <span class="op">=</span> np.array(</span>
<span id="cb184-18"><a href="#cb184-18" aria-hidden="true" tabindex="-1"></a>  [[L<span class="op">/</span><span class="fl">2.0</span>, W<span class="op">/</span><span class="fl">2.0</span>, H<span class="op">/</span><span class="fl">2.0</span>]], </span>
<span id="cb184-19"><a href="#cb184-19" aria-hidden="true" tabindex="-1"></a>  dtype<span class="op">=</span>np.float64</span>
<span id="cb184-20"><a href="#cb184-20" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb184-21"><a href="#cb184-21" aria-hidden="true" tabindex="-1"></a>coords <span class="op">=</span> V.tabulate_dof_coordinates().reshape((<span class="op">-</span><span class="dv">1</span>, domain.geometry.dim))</span>
<span id="cb184-22"><a href="#cb184-22" aria-hidden="true" tabindex="-1"></a>dof_indices <span class="op">=</span> [</span>
<span id="cb184-23"><a href="#cb184-23" aria-hidden="true" tabindex="-1"></a>  <span class="bu">int</span>(np.argmin(np.linalg.norm(coords <span class="op">-</span>p, axis<span class="op">=</span><span class="dv">1</span>))) <span class="cf">for</span> p <span class="kw">in</span> probe_points</span>
<span id="cb184-24"><a href="#cb184-24" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
</div>
<p><strong>Variational formulation</strong></p>
<p>We can now write the variational formulation</p>
<div id="4d8e24d8" class="cell" data-execution_count="163">
<div class="sourceCode" id="cb185"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb185-1"><a href="#cb185-1" aria-hidden="true" tabindex="-1"></a>p_r <span class="op">=</span> ufl.TrialFunction(V)</span>
<span id="cb185-2"><a href="#cb185-2" aria-hidden="true" tabindex="-1"></a>p_i <span class="op">=</span> ufl.TrialFunction(V)</span>
<span id="cb185-3"><a href="#cb185-3" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> ufl.TestFunction(V)</span>
<span id="cb185-4"><a href="#cb185-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-5"><a href="#cb185-5" aria-hidden="true" tabindex="-1"></a>Delta_Z <span class="op">=</span> Z_r<span class="op">**</span><span class="dv">2</span> <span class="op">+</span>Z_i<span class="op">**</span><span class="dv">2</span></span>
<span id="cb185-6"><a href="#cb185-6" aria-hidden="true" tabindex="-1"></a>coef <span class="op">=</span> omega <span class="op">*</span>rho0 <span class="op">/</span>Delta_Z</span>
<span id="cb185-7"><a href="#cb185-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-8"><a href="#cb185-8" aria-hidden="true" tabindex="-1"></a><span class="co"># bilinear forms</span></span>
<span id="cb185-9"><a href="#cb185-9" aria-hidden="true" tabindex="-1"></a>a_r <span class="op">=</span> ( </span>
<span id="cb185-10"><a href="#cb185-10" aria-hidden="true" tabindex="-1"></a>  (ufl.inner(ufl.grad(p_r), ufl.grad(v)) <span class="op">-</span>k<span class="op">**</span><span class="dv">2</span> <span class="op">*</span>p_r <span class="op">*</span>v) <span class="op">*</span>ufl.dx </span>
<span id="cb185-11"><a href="#cb185-11" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span>coef <span class="op">*</span>(Z_i <span class="op">*</span>p_r <span class="op">-</span>Z_r <span class="op">*</span>p_i) <span class="op">*</span>v <span class="op">*</span>ds(<span class="dv">3</span>)</span>
<span id="cb185-12"><a href="#cb185-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb185-13"><a href="#cb185-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-14"><a href="#cb185-14" aria-hidden="true" tabindex="-1"></a>a_i <span class="op">=</span> (</span>
<span id="cb185-15"><a href="#cb185-15" aria-hidden="true" tabindex="-1"></a>  (ufl.inner(ufl.grad(p_i), ufl.grad(v)) <span class="op">-</span>k<span class="op">**</span><span class="dv">2</span> <span class="op">*</span>p_i <span class="op">*</span>v) <span class="op">*</span>ufl.dx</span>
<span id="cb185-16"><a href="#cb185-16" aria-hidden="true" tabindex="-1"></a>  <span class="op">+</span>coef <span class="op">*</span>(Z_r <span class="op">*</span>p_r <span class="op">+</span>Z_i <span class="op">*</span>p_i) <span class="op">*</span>v <span class="op">*</span>ds(<span class="dv">3</span>)</span>
<span id="cb185-17"><a href="#cb185-17" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb185-18"><a href="#cb185-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb185-19"><a href="#cb185-19" aria-hidden="true" tabindex="-1"></a><span class="co"># RHS (velocity BC only)</span></span>
<span id="cb185-20"><a href="#cb185-20" aria-hidden="true" tabindex="-1"></a>L_r <span class="op">=</span> <span class="op">-</span>omega <span class="op">*</span>rho0 <span class="op">*</span>q_i <span class="op">*</span>v <span class="op">*</span>ufl.dx <span class="op">+</span>omega <span class="op">*</span>rho0 <span class="op">*</span>v_ni <span class="op">*</span>v <span class="op">*</span>ds(<span class="dv">2</span>)</span>
<span id="cb185-21"><a href="#cb185-21" aria-hidden="true" tabindex="-1"></a>L_i <span class="op">=</span>  omega <span class="op">*</span>rho0 <span class="op">*</span>q_r <span class="op">*</span>v <span class="op">*</span>ufl.dx <span class="op">-</span>omega <span class="op">*</span>rho0 <span class="op">*</span>v_nr <span class="op">*</span>v <span class="op">*</span>ds(<span class="dv">2</span>)</span></code></pre></div>
</div>
<p>The <code>LinearProblem</code> class is used to set up the <code>PETSc</code> backend and assemble the system matrix and vector. The solution is stored in a <code>dolfinx.fem.Function</code>, <code>p_r_fun</code> and <code>p_i_fun</code></p>
<div id="e2b1aedf" class="cell" data-execution_count="164">
<div class="sourceCode" id="cb186"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb186-1"><a href="#cb186-1" aria-hidden="true" tabindex="-1"></a>p_r_fun <span class="op">=</span> fem.Function(V)</span>
<span id="cb186-2"><a href="#cb186-2" aria-hidden="true" tabindex="-1"></a>p_r_fun.name <span class="op">=</span> <span class="st">&quot;p_real&quot;</span></span>
<span id="cb186-3"><a href="#cb186-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-4"><a href="#cb186-4" aria-hidden="true" tabindex="-1"></a>p_i_fun <span class="op">=</span> fem.Function(V)</span>
<span id="cb186-5"><a href="#cb186-5" aria-hidden="true" tabindex="-1"></a>p_i_fun.name <span class="op">=</span> <span class="st">&quot;p_imag&quot;</span></span>
<span id="cb186-6"><a href="#cb186-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb186-7"><a href="#cb186-7" aria-hidden="true" tabindex="-1"></a>problem_r <span class="op">=</span> LinearProblem(</span>
<span id="cb186-8"><a href="#cb186-8" aria-hidden="true" tabindex="-1"></a>  a_r, L_r, u<span class="op">=</span>p_r_fun,</span>
<span id="cb186-9"><a href="#cb186-9" aria-hidden="true" tabindex="-1"></a>  petsc_options<span class="op">=</span>{<span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;preonly&quot;</span>, <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;lu&quot;</span>}</span>
<span id="cb186-10"><a href="#cb186-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb186-11"><a href="#cb186-11" aria-hidden="true" tabindex="-1"></a>problem_i <span class="op">=</span> LinearProblem(</span>
<span id="cb186-12"><a href="#cb186-12" aria-hidden="true" tabindex="-1"></a>  a_i, L_i, u<span class="op">=</span>p_i_fun,</span>
<span id="cb186-13"><a href="#cb186-13" aria-hidden="true" tabindex="-1"></a>  petsc_options<span class="op">=</span>{<span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;preonly&quot;</span>, <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;lu&quot;</span>}</span>
<span id="cb186-14"><a href="#cb186-14" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
<p><strong>Frequency loop</strong></p>
<p>Finally, we implement the frequency loop. In this step, the frequency-dependent variables are updated and the system is solved for each frequency</p>
<div id="41a7678e" class="cell" data-execution_count="165">
<div class="sourceCode" id="cb187"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb187-1"><a href="#cb187-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Output files</span></span>
<span id="cb187-2"><a href="#cb187-2" aria-hidden="true" tabindex="-1"></a>xdmf_real <span class="op">=</span> io.XDMFFile(comm, results_folder<span class="op">/</span><span class="st">&quot;p_real.xdmf&quot;</span>, <span class="st">&quot;w&quot;</span>)</span>
<span id="cb187-3"><a href="#cb187-3" aria-hidden="true" tabindex="-1"></a>xdmf_imag <span class="op">=</span> io.XDMFFile(comm, results_folder<span class="op">/</span><span class="st">&quot;p_imag.xdmf&quot;</span>, <span class="st">&quot;w&quot;</span>)</span>
<span id="cb187-4"><a href="#cb187-4" aria-hidden="true" tabindex="-1"></a>xdmf_real.write_mesh(domain)</span>
<span id="cb187-5"><a href="#cb187-5" aria-hidden="true" tabindex="-1"></a>xdmf_imag.write_mesh(domain)</span>
<span id="cb187-6"><a href="#cb187-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-7"><a href="#cb187-7" aria-hidden="true" tabindex="-1"></a>csv_file <span class="op">=</span> results_folder<span class="op">/</span><span class="st">&quot;SPL_probes.csv&quot;</span></span>
<span id="cb187-8"><a href="#cb187-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb187-9"><a href="#cb187-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">with</span> <span class="bu">open</span>(csv_file, <span class="st">&quot;w&quot;</span>, newline<span class="op">=</span><span class="st">&quot;&quot;</span>) <span class="im">as</span> f_:</span>
<span id="cb187-10"><a href="#cb187-10" aria-hidden="true" tabindex="-1"></a>    writer <span class="op">=</span> csv.writer(f_)</span>
<span id="cb187-11"><a href="#cb187-11" aria-hidden="true" tabindex="-1"></a>    writer.writerow([<span class="st">&quot;freq_Hz&quot;</span>, <span class="st">&quot;SPL_probe_center_dB&quot;</span>])</span>
<span id="cb187-12"><a href="#cb187-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-13"><a href="#cb187-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Discrete frequency range</span></span>
<span id="cb187-14"><a href="#cb187-14" aria-hidden="true" tabindex="-1"></a>freq <span class="op">=</span> np.arange(<span class="dv">10</span>, <span class="dv">1000</span>, <span class="dv">5</span>)  <span class="co"># Hz</span></span>
<span id="cb187-15"><a href="#cb187-15" aria-hidden="true" tabindex="-1"></a>SPL_all <span class="op">=</span> []</span>
<span id="cb187-16"><a href="#cb187-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-17"><a href="#cb187-17" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> f <span class="kw">in</span> freq:</span>
<span id="cb187-18"><a href="#cb187-18" aria-hidden="true" tabindex="-1"></a>  omega.value <span class="op">=</span> <span class="dv">2</span> <span class="op">*</span>np.pi <span class="op">*</span>f    </span>
<span id="cb187-19"><a href="#cb187-19" aria-hidden="true" tabindex="-1"></a>  k.value <span class="op">=</span> omega.value <span class="op">/</span>c</span>
<span id="cb187-20"><a href="#cb187-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-21"><a href="#cb187-21" aria-hidden="true" tabindex="-1"></a>  Zs <span class="op">=</span> delany_bazley_layer(f, rho0, c, sigma, d)</span>
<span id="cb187-22"><a href="#cb187-22" aria-hidden="true" tabindex="-1"></a>  Z_r.value <span class="op">=</span> Zs.real</span>
<span id="cb187-23"><a href="#cb187-23" aria-hidden="true" tabindex="-1"></a>  Z_i.value <span class="op">=</span> Zs.imag</span>
<span id="cb187-24"><a href="#cb187-24" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb187-25"><a href="#cb187-25" aria-hidden="true" tabindex="-1"></a>  Delta_Z <span class="op">=</span> Z_r<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> Z_i<span class="op">**</span><span class="dv">2</span></span>
<span id="cb187-26"><a href="#cb187-26" aria-hidden="true" tabindex="-1"></a>  coef <span class="op">=</span> omega <span class="op">*</span>rho0 <span class="op">/</span>Delta_Z</span>
<span id="cb187-27"><a href="#cb187-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-28"><a href="#cb187-28" aria-hidden="true" tabindex="-1"></a>  problem_r.solve()</span>
<span id="cb187-29"><a href="#cb187-29" aria-hidden="true" tabindex="-1"></a>  problem_i.solve()</span>
<span id="cb187-30"><a href="#cb187-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-31"><a href="#cb187-31" aria-hidden="true" tabindex="-1"></a>  xdmf_real.write_function(p_r_fun, <span class="bu">float</span>(f))</span>
<span id="cb187-32"><a href="#cb187-32" aria-hidden="true" tabindex="-1"></a>  xdmf_imag.write_function(p_i_fun, <span class="bu">float</span>(f))  </span>
<span id="cb187-33"><a href="#cb187-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-34"><a href="#cb187-34" aria-hidden="true" tabindex="-1"></a>  p_r_fun.x.scatter_forward()</span>
<span id="cb187-35"><a href="#cb187-35" aria-hidden="true" tabindex="-1"></a>  p_i_fun.x.scatter_forward()</span>
<span id="cb187-36"><a href="#cb187-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-37"><a href="#cb187-37" aria-hidden="true" tabindex="-1"></a>  pr_vals <span class="op">=</span> p_r_fun.x.array</span>
<span id="cb187-38"><a href="#cb187-38" aria-hidden="true" tabindex="-1"></a>  pi_vals <span class="op">=</span> p_i_fun.x.array</span>
<span id="cb187-39"><a href="#cb187-39" aria-hidden="true" tabindex="-1"></a>  probe_SPLs <span class="op">=</span> []</span>
<span id="cb187-40"><a href="#cb187-40" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> idx <span class="kw">in</span> dof_indices:</span>
<span id="cb187-41"><a href="#cb187-41" aria-hidden="true" tabindex="-1"></a>    pr <span class="op">=</span> pr_vals[idx]</span>
<span id="cb187-42"><a href="#cb187-42" aria-hidden="true" tabindex="-1"></a>    pi <span class="op">=</span> pi_vals[idx]</span>
<span id="cb187-43"><a href="#cb187-43" aria-hidden="true" tabindex="-1"></a>    p_complex <span class="op">=</span> pr <span class="op">+</span><span class="ot">1j</span> <span class="op">*</span>pi</span>
<span id="cb187-44"><a href="#cb187-44" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-45"><a href="#cb187-45" aria-hidden="true" tabindex="-1"></a>    spl_db <span class="op">=</span> <span class="dv">20</span> <span class="op">*</span>np.log10(np.<span class="bu">abs</span>(p_complex) <span class="op">/</span>(np.sqrt(<span class="dv">2</span>) <span class="op">*</span>p_ref))</span>
<span id="cb187-46"><a href="#cb187-46" aria-hidden="true" tabindex="-1"></a>    probe_SPLs.append(spl_db)</span>
<span id="cb187-47"><a href="#cb187-47" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-48"><a href="#cb187-48" aria-hidden="true" tabindex="-1"></a>  all_probe_SPLs <span class="op">=</span> comm.gather(probe_SPLs, root<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb187-49"><a href="#cb187-49" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb187-50"><a href="#cb187-50" aria-hidden="true" tabindex="-1"></a>    row <span class="op">=</span> [<span class="bu">float</span>(f)] <span class="op">+</span>all_probe_SPLs[<span class="dv">0</span>]</span>
<span id="cb187-51"><a href="#cb187-51" aria-hidden="true" tabindex="-1"></a>    <span class="cf">with</span> <span class="bu">open</span>(csv_file, <span class="st">&quot;a&quot;</span>, newline<span class="op">=</span><span class="st">&quot;&quot;</span>) <span class="im">as</span> f_:</span>
<span id="cb187-52"><a href="#cb187-52" aria-hidden="true" tabindex="-1"></a>      csv.writer(f_).writerow(row)</span>
<span id="cb187-53"><a href="#cb187-53" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-54"><a href="#cb187-54" aria-hidden="true" tabindex="-1"></a>  SPL_all.append(probe_SPLs[<span class="dv">0</span>])</span>
<span id="cb187-55"><a href="#cb187-55" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb187-56"><a href="#cb187-56" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(</span>
<span id="cb187-57"><a href="#cb187-57" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f&quot;f: </span><span class="sc">{</span>f<span class="sc">:.0f}</span><span class="ss"> Hz,&quot;</span>,</span>
<span id="cb187-58"><a href="#cb187-58" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f&quot;|p|(probe): </span><span class="sc">{</span><span class="dv">10</span><span class="op">**</span>(SPL_all[<span class="op">-</span><span class="dv">1</span>] <span class="op">/</span><span class="dv">20</span>) <span class="op">*</span>np<span class="sc">.</span>sqrt(<span class="dv">2</span>) <span class="op">*</span>p_ref<span class="sc">:.3e}</span><span class="ss"> Pa,&quot;</span>,</span>
<span id="cb187-59"><a href="#cb187-59" aria-hidden="true" tabindex="-1"></a>      <span class="ss">f&quot;SPL: </span><span class="sc">{</span>SPL_all[<span class="op">-</span><span class="dv">1</span>]<span class="sc">:.2f}</span><span class="ss"> dB&quot;</span></span>
<span id="cb187-60"><a href="#cb187-60" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb187-61"><a href="#cb187-61" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb187-62"><a href="#cb187-62" aria-hidden="true" tabindex="-1"></a>xdmf_real.close()</span>
<span id="cb187-63"><a href="#cb187-63" aria-hidden="true" tabindex="-1"></a>xdmf_imag.close()  </span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>f: 10 Hz, |p|(probe): 2.232e-02 Pa, SPL: 57.94 dB
f: 15 Hz, |p|(probe): 1.490e-02 Pa, SPL: 54.43 dB
f: 20 Hz, |p|(probe): 1.120e-02 Pa, SPL: 51.95 dB
f: 25 Hz, |p|(probe): 8.984e-03 Pa, SPL: 50.04 dB
f: 30 Hz, |p|(probe): 7.513e-03 Pa, SPL: 48.49 dB
f: 35 Hz, |p|(probe): 6.467e-03 Pa, SPL: 47.18 dB
f: 40 Hz, |p|(probe): 5.686e-03 Pa, SPL: 46.07 dB
f: 45 Hz, |p|(probe): 5.082e-03 Pa, SPL: 45.09 dB
f: 50 Hz, |p|(probe): 4.602e-03 Pa, SPL: 44.23 dB
f: 55 Hz, |p|(probe): 4.212e-03 Pa, SPL: 43.46 dB
f: 60 Hz, |p|(probe): 3.890e-03 Pa, SPL: 42.77 dB
f: 65 Hz, |p|(probe): 3.620e-03 Pa, SPL: 42.14 dB
f: 70 Hz, |p|(probe): 3.391e-03 Pa, SPL: 41.58 dB
f: 75 Hz, |p|(probe): 3.195e-03 Pa, SPL: 41.06 dB
f: 80 Hz, |p|(probe): 3.025e-03 Pa, SPL: 40.58 dB
f: 85 Hz, |p|(probe): 2.878e-03 Pa, SPL: 40.15 dB
f: 90 Hz, |p|(probe): 2.748e-03 Pa, SPL: 39.75 dB
f: 95 Hz, |p|(probe): 2.634e-03 Pa, SPL: 39.38 dB
f: 100 Hz, |p|(probe): 2.533e-03 Pa, SPL: 39.04 dB
f: 105 Hz, |p|(probe): 2.442e-03 Pa, SPL: 38.72 dB
f: 110 Hz, |p|(probe): 2.361e-03 Pa, SPL: 38.43 dB
f: 115 Hz, |p|(probe): 2.288e-03 Pa, SPL: 38.16 dB
f: 120 Hz, |p|(probe): 2.220e-03 Pa, SPL: 37.90 dB
f: 125 Hz, |p|(probe): 2.158e-03 Pa, SPL: 37.65 dB
f: 130 Hz, |p|(probe): 2.099e-03 Pa, SPL: 37.41 dB
f: 135 Hz, |p|(probe): 2.040e-03 Pa, SPL: 37.16 dB
f: 140 Hz, |p|(probe): 1.979e-03 Pa, SPL: 36.90 dB
f: 145 Hz, |p|(probe): 1.909e-03 Pa, SPL: 36.59 dB
f: 150 Hz, |p|(probe): 1.820e-03 Pa, SPL: 36.17 dB
f: 155 Hz, |p|(probe): 1.681e-03 Pa, SPL: 35.48 dB
f: 160 Hz, |p|(probe): 1.390e-03 Pa, SPL: 33.83 dB
f: 165 Hz, |p|(probe): 1.664e-04 Pa, SPL: 15.39 dB
f: 170 Hz, |p|(probe): 5.048e-03 Pa, SPL: 45.03 dB
f: 175 Hz, |p|(probe): 2.958e-03 Pa, SPL: 40.39 dB
f: 180 Hz, |p|(probe): 2.619e-03 Pa, SPL: 39.33 dB
f: 185 Hz, |p|(probe): 2.489e-03 Pa, SPL: 38.89 dB
f: 190 Hz, |p|(probe): 2.429e-03 Pa, SPL: 38.68 dB
f: 195 Hz, |p|(probe): 2.404e-03 Pa, SPL: 38.59 dB
f: 200 Hz, |p|(probe): 2.399e-03 Pa, SPL: 38.57 dB
f: 205 Hz, |p|(probe): 2.409e-03 Pa, SPL: 38.61 dB
f: 210 Hz, |p|(probe): 2.431e-03 Pa, SPL: 38.69 dB
f: 215 Hz, |p|(probe): 2.464e-03 Pa, SPL: 38.80 dB
f: 220 Hz, |p|(probe): 2.507e-03 Pa, SPL: 38.95 dB
f: 225 Hz, |p|(probe): 2.560e-03 Pa, SPL: 39.13 dB
f: 230 Hz, |p|(probe): 2.623e-03 Pa, SPL: 39.35 dB
f: 235 Hz, |p|(probe): 2.698e-03 Pa, SPL: 39.59 dB
f: 240 Hz, |p|(probe): 2.785e-03 Pa, SPL: 39.87 dB
f: 245 Hz, |p|(probe): 2.887e-03 Pa, SPL: 40.18 dB
f: 250 Hz, |p|(probe): 3.004e-03 Pa, SPL: 40.52 dB
f: 255 Hz, |p|(probe): 3.140e-03 Pa, SPL: 40.91 dB
f: 260 Hz, |p|(probe): 3.297e-03 Pa, SPL: 41.33 dB
f: 265 Hz, |p|(probe): 3.481e-03 Pa, SPL: 41.80 dB
f: 270 Hz, |p|(probe): 3.697e-03 Pa, SPL: 42.32 dB
f: 275 Hz, |p|(probe): 3.951e-03 Pa, SPL: 42.90 dB
f: 280 Hz, |p|(probe): 4.255e-03 Pa, SPL: 43.55 dB
f: 285 Hz, |p|(probe): 4.622e-03 Pa, SPL: 44.27 dB
f: 290 Hz, |p|(probe): 5.074e-03 Pa, SPL: 45.08 dB
f: 295 Hz, |p|(probe): 5.639e-03 Pa, SPL: 45.99 dB
f: 300 Hz, |p|(probe): 6.365e-03 Pa, SPL: 47.04 dB
f: 305 Hz, |p|(probe): 7.328e-03 Pa, SPL: 48.27 dB
f: 310 Hz, |p|(probe): 8.663e-03 Pa, SPL: 49.72 dB
f: 315 Hz, |p|(probe): 1.063e-02 Pa, SPL: 51.50 dB
f: 320 Hz, |p|(probe): 1.381e-02 Pa, SPL: 53.78 dB
f: 325 Hz, |p|(probe): 1.981e-02 Pa, SPL: 56.91 dB
f: 330 Hz, |p|(probe): 3.527e-02 Pa, SPL: 61.92 dB
f: 335 Hz, |p|(probe): 1.646e-01 Pa, SPL: 75.30 dB
f: 340 Hz, |p|(probe): 6.128e-02 Pa, SPL: 66.72 dB
f: 345 Hz, |p|(probe): 2.578e-02 Pa, SPL: 59.20 dB
f: 350 Hz, |p|(probe): 1.632e-02 Pa, SPL: 55.22 dB
f: 355 Hz, |p|(probe): 1.194e-02 Pa, SPL: 52.51 dB
f: 360 Hz, |p|(probe): 9.415e-03 Pa, SPL: 50.45 dB
f: 365 Hz, |p|(probe): 7.778e-03 Pa, SPL: 48.79 dB
f: 370 Hz, |p|(probe): 6.632e-03 Pa, SPL: 47.40 dB
f: 375 Hz, |p|(probe): 5.786e-03 Pa, SPL: 46.22 dB
f: 380 Hz, |p|(probe): 5.136e-03 Pa, SPL: 45.18 dB
f: 385 Hz, |p|(probe): 4.623e-03 Pa, SPL: 44.27 dB
f: 390 Hz, |p|(probe): 4.207e-03 Pa, SPL: 43.45 dB
f: 395 Hz, |p|(probe): 3.864e-03 Pa, SPL: 42.71 dB
f: 400 Hz, |p|(probe): 3.576e-03 Pa, SPL: 42.04 dB
f: 405 Hz, |p|(probe): 3.332e-03 Pa, SPL: 41.42 dB
f: 410 Hz, |p|(probe): 3.122e-03 Pa, SPL: 40.86 dB
f: 415 Hz, |p|(probe): 2.940e-03 Pa, SPL: 40.34 dB
f: 420 Hz, |p|(probe): 2.780e-03 Pa, SPL: 39.85 dB
f: 425 Hz, |p|(probe): 2.638e-03 Pa, SPL: 39.40 dB
f: 430 Hz, |p|(probe): 2.511e-03 Pa, SPL: 38.97 dB
f: 435 Hz, |p|(probe): 2.397e-03 Pa, SPL: 38.56 dB
f: 440 Hz, |p|(probe): 2.292e-03 Pa, SPL: 38.18 dB
f: 445 Hz, |p|(probe): 2.196e-03 Pa, SPL: 37.80 dB
f: 450 Hz, |p|(probe): 2.104e-03 Pa, SPL: 37.43 dB
f: 455 Hz, |p|(probe): 2.017e-03 Pa, SPL: 37.06 dB
f: 460 Hz, |p|(probe): 1.930e-03 Pa, SPL: 36.68 dB
f: 465 Hz, |p|(probe): 1.841e-03 Pa, SPL: 36.27 dB
f: 470 Hz, |p|(probe): 1.745e-03 Pa, SPL: 35.81 dB
f: 475 Hz, |p|(probe): 1.636e-03 Pa, SPL: 35.24 dB
f: 480 Hz, |p|(probe): 1.500e-03 Pa, SPL: 34.49 dB
f: 485 Hz, |p|(probe): 1.316e-03 Pa, SPL: 33.35 dB
f: 490 Hz, |p|(probe): 1.029e-03 Pa, SPL: 31.22 dB
f: 495 Hz, |p|(probe): 4.823e-04 Pa, SPL: 24.63 dB
f: 500 Hz, |p|(probe): 1.079e-03 Pa, SPL: 31.63 dB
f: 505 Hz, |p|(probe): 6.165e-02 Pa, SPL: 66.77 dB
f: 510 Hz, |p|(probe): 5.665e-03 Pa, SPL: 46.03 dB
f: 515 Hz, |p|(probe): 3.850e-03 Pa, SPL: 42.68 dB
f: 520 Hz, |p|(probe): 3.277e-03 Pa, SPL: 41.28 dB
f: 525 Hz, |p|(probe): 3.005e-03 Pa, SPL: 40.53 dB
f: 530 Hz, |p|(probe): 2.855e-03 Pa, SPL: 40.08 dB
f: 535 Hz, |p|(probe): 2.768e-03 Pa, SPL: 39.81 dB
f: 540 Hz, |p|(probe): 2.719e-03 Pa, SPL: 39.66 dB
f: 545 Hz, |p|(probe): 2.697e-03 Pa, SPL: 39.59 dB
f: 550 Hz, |p|(probe): 2.694e-03 Pa, SPL: 39.58 dB
f: 555 Hz, |p|(probe): 2.708e-03 Pa, SPL: 39.62 dB
f: 560 Hz, |p|(probe): 2.736e-03 Pa, SPL: 39.71 dB
f: 565 Hz, |p|(probe): 2.778e-03 Pa, SPL: 39.84 dB
f: 570 Hz, |p|(probe): 2.833e-03 Pa, SPL: 40.01 dB
f: 575 Hz, |p|(probe): 2.901e-03 Pa, SPL: 40.22 dB
f: 580 Hz, |p|(probe): 2.985e-03 Pa, SPL: 40.47 dB
f: 585 Hz, |p|(probe): 3.084e-03 Pa, SPL: 40.75 dB
f: 590 Hz, |p|(probe): 3.201e-03 Pa, SPL: 41.07 dB
f: 595 Hz, |p|(probe): 3.338e-03 Pa, SPL: 41.44 dB
f: 600 Hz, |p|(probe): 3.500e-03 Pa, SPL: 41.85 dB
f: 605 Hz, |p|(probe): 3.690e-03 Pa, SPL: 42.31 dB
f: 610 Hz, |p|(probe): 3.915e-03 Pa, SPL: 42.82 dB
f: 615 Hz, |p|(probe): 4.182e-03 Pa, SPL: 43.40 dB
f: 620 Hz, |p|(probe): 4.504e-03 Pa, SPL: 44.04 dB
f: 625 Hz, |p|(probe): 4.895e-03 Pa, SPL: 44.76 dB
f: 630 Hz, |p|(probe): 5.380e-03 Pa, SPL: 45.58 dB
f: 635 Hz, |p|(probe): 5.992e-03 Pa, SPL: 46.52 dB
f: 640 Hz, |p|(probe): 6.786e-03 Pa, SPL: 47.60 dB
f: 645 Hz, |p|(probe): 7.853e-03 Pa, SPL: 48.87 dB
f: 650 Hz, |p|(probe): 9.358e-03 Pa, SPL: 50.39 dB
f: 655 Hz, |p|(probe): 1.163e-02 Pa, SPL: 52.28 dB
f: 660 Hz, |p|(probe): 1.545e-02 Pa, SPL: 54.75 dB
f: 665 Hz, |p|(probe): 2.319e-02 Pa, SPL: 58.27 dB
f: 670 Hz, |p|(probe): 4.702e-02 Pa, SPL: 64.41 dB
f: 675 Hz, |p|(probe): 1.206e+00 Pa, SPL: 92.60 dB
f: 680 Hz, |p|(probe): 4.325e-02 Pa, SPL: 63.69 dB
f: 685 Hz, |p|(probe): 2.194e-02 Pa, SPL: 57.80 dB
f: 690 Hz, |p|(probe): 1.468e-02 Pa, SPL: 54.30 dB
f: 695 Hz, |p|(probe): 1.102e-02 Pa, SPL: 51.81 dB
f: 700 Hz, |p|(probe): 8.813e-03 Pa, SPL: 49.87 dB
f: 705 Hz, |p|(probe): 7.343e-03 Pa, SPL: 48.29 dB
f: 710 Hz, |p|(probe): 6.295e-03 Pa, SPL: 46.95 dB
f: 715 Hz, |p|(probe): 5.510e-03 Pa, SPL: 45.79 dB
f: 720 Hz, |p|(probe): 4.900e-03 Pa, SPL: 44.77 dB
f: 725 Hz, |p|(probe): 4.414e-03 Pa, SPL: 43.87 dB
f: 730 Hz, |p|(probe): 4.017e-03 Pa, SPL: 43.05 dB
f: 735 Hz, |p|(probe): 3.687e-03 Pa, SPL: 42.30 dB
f: 740 Hz, |p|(probe): 3.408e-03 Pa, SPL: 41.62 dB
f: 745 Hz, |p|(probe): 3.169e-03 Pa, SPL: 40.99 dB
f: 750 Hz, |p|(probe): 2.962e-03 Pa, SPL: 40.40 dB
f: 755 Hz, |p|(probe): 2.781e-03 Pa, SPL: 39.85 dB
f: 760 Hz, |p|(probe): 2.620e-03 Pa, SPL: 39.33 dB
f: 765 Hz, |p|(probe): 2.475e-03 Pa, SPL: 38.84 dB
f: 770 Hz, |p|(probe): 2.344e-03 Pa, SPL: 38.37 dB
f: 775 Hz, |p|(probe): 2.223e-03 Pa, SPL: 37.91 dB
f: 780 Hz, |p|(probe): 2.110e-03 Pa, SPL: 37.45 dB
f: 785 Hz, |p|(probe): 2.002e-03 Pa, SPL: 37.00 dB
f: 790 Hz, |p|(probe): 1.897e-03 Pa, SPL: 36.53 dB
f: 795 Hz, |p|(probe): 1.793e-03 Pa, SPL: 36.04 dB
f: 800 Hz, |p|(probe): 1.684e-03 Pa, SPL: 35.50 dB
f: 805 Hz, |p|(probe): 1.567e-03 Pa, SPL: 34.87 dB
f: 810 Hz, |p|(probe): 1.435e-03 Pa, SPL: 34.11 dB
f: 815 Hz, |p|(probe): 1.276e-03 Pa, SPL: 33.09 dB
f: 820 Hz, |p|(probe): 1.071e-03 Pa, SPL: 31.57 dB
f: 825 Hz, |p|(probe): 7.809e-04 Pa, SPL: 28.82 dB
f: 830 Hz, |p|(probe): 3.158e-04 Pa, SPL: 20.96 dB
f: 835 Hz, |p|(probe): 5.912e-04 Pa, SPL: 26.40 dB
f: 840 Hz, |p|(probe): 3.254e-03 Pa, SPL: 41.22 dB
f: 845 Hz, |p|(probe): 2.715e-01 Pa, SPL: 79.65 dB
f: 850 Hz, |p|(probe): 7.706e-03 Pa, SPL: 48.71 dB
f: 855 Hz, |p|(probe): 4.893e-03 Pa, SPL: 44.76 dB
f: 860 Hz, |p|(probe): 3.978e-03 Pa, SPL: 42.96 dB
f: 865 Hz, |p|(probe): 3.534e-03 Pa, SPL: 41.93 dB
f: 870 Hz, |p|(probe): 3.280e-03 Pa, SPL: 41.29 dB
f: 875 Hz, |p|(probe): 3.123e-03 Pa, SPL: 40.86 dB
f: 880 Hz, |p|(probe): 3.025e-03 Pa, SPL: 40.58 dB
f: 885 Hz, |p|(probe): 2.965e-03 Pa, SPL: 40.41 dB
f: 890 Hz, |p|(probe): 2.934e-03 Pa, SPL: 40.32 dB
f: 895 Hz, |p|(probe): 2.924e-03 Pa, SPL: 40.29 dB
f: 900 Hz, |p|(probe): 2.933e-03 Pa, SPL: 40.31 dB
f: 905 Hz, |p|(probe): 2.958e-03 Pa, SPL: 40.39 dB
f: 910 Hz, |p|(probe): 2.999e-03 Pa, SPL: 40.51 dB
f: 915 Hz, |p|(probe): 3.054e-03 Pa, SPL: 40.67 dB
f: 920 Hz, |p|(probe): 3.126e-03 Pa, SPL: 40.87 dB
f: 925 Hz, |p|(probe): 3.215e-03 Pa, SPL: 41.11 dB
f: 930 Hz, |p|(probe): 3.321e-03 Pa, SPL: 41.39 dB
f: 935 Hz, |p|(probe): 3.448e-03 Pa, SPL: 41.72 dB
f: 940 Hz, |p|(probe): 3.599e-03 Pa, SPL: 42.09 dB
f: 945 Hz, |p|(probe): 3.778e-03 Pa, SPL: 42.51 dB
f: 950 Hz, |p|(probe): 3.989e-03 Pa, SPL: 42.99 dB
f: 955 Hz, |p|(probe): 4.242e-03 Pa, SPL: 43.52 dB
f: 960 Hz, |p|(probe): 4.545e-03 Pa, SPL: 44.12 dB
f: 965 Hz, |p|(probe): 4.914e-03 Pa, SPL: 44.80 dB
f: 970 Hz, |p|(probe): 5.368e-03 Pa, SPL: 45.57 dB
f: 975 Hz, |p|(probe): 5.938e-03 Pa, SPL: 46.44 dB
f: 980 Hz, |p|(probe): 6.671e-03 Pa, SPL: 47.45 dB
f: 985 Hz, |p|(probe): 7.644e-03 Pa, SPL: 48.64 dB
f: 990 Hz, |p|(probe): 8.993e-03 Pa, SPL: 50.05 dB
f: 995 Hz, |p|(probe): 1.098e-02 Pa, SPL: 51.78 dB</code></pre>
</div>
</div>
<div id="16fb165c" class="cell" data-execution_count="166">
<div class="sourceCode" id="cb189"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb189-1"><a href="#cb189-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb189-2"><a href="#cb189-2" aria-hidden="true" tabindex="-1"></a>  plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="dv">4</span>))</span>
<span id="cb189-3"><a href="#cb189-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb189-4"><a href="#cb189-4" aria-hidden="true" tabindex="-1"></a>  plt.plot(freq, SPL_all, marker<span class="op">=</span><span class="st">&quot;o&quot;</span>)</span>
<span id="cb189-5"><a href="#cb189-5" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb189-6"><a href="#cb189-6" aria-hidden="true" tabindex="-1"></a>  plt.xlabel(<span class="st">&quot;Frequency [Hz]&quot;</span>)</span>
<span id="cb189-7"><a href="#cb189-7" aria-hidden="true" tabindex="-1"></a>  plt.ylabel(<span class="st">&quot;SPL [dB re 20 µPa]&quot;</span>)</span>
<span id="cb189-8"><a href="#cb189-8" aria-hidden="true" tabindex="-1"></a>  plt.title(<span class="st">&quot;SPL at domain center (velocity-inlet, DBZ-impedance outlet)&quot;</span>)</span>
<span id="cb189-9"><a href="#cb189-9" aria-hidden="true" tabindex="-1"></a>  plt.grid(<span class="va">True</span>)</span>
<span id="cb189-10"><a href="#cb189-10" aria-hidden="true" tabindex="-1"></a>  plt.tight_layout()</span>
<span id="cb189-11"><a href="#cb189-11" aria-hidden="true" tabindex="-1"></a>  plt.savefig(results_folder<span class="op">/</span><span class="st">&quot;SPL_spectrum.png&quot;</span>, dpi<span class="op">=</span><span class="dv">150</span>)</span>
<span id="cb189-12"><a href="#cb189-12" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb189-13"><a href="#cb189-13" aria-hidden="true" tabindex="-1"></a>  plt.show()</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img src="x_PDE_FEniCS_files/figure-html/cell-167-output-1.png" width="565" height="372" /></p>
</figure>
</div>
</div>
</div>
</section>
<section id="sec-fenicsx-adaptive-mesh" class="level3" data-number="K.7.8">
<h3 data-number="K.7.8"><span class="header-section-number">K.7.8</span> Adaptive mesh refinement with GMSH/FEniCSx</h3>
<p>In this section, we consider an adaptive mesh refinement method applied to the Laplace eigenvalue problem</p>
<section id="solving-the-eigenvalue-problem" class="level4" data-number="K.7.8.1">
<h4 data-number="K.7.8.1"><span class="header-section-number">K.7.8.1</span> Solving the eigenvalue problem</h4>
<p>We consider the Laplace eigenvalue problem with adaptive mesh refinement. The finite element discretization is performed using <code>dolfinx</code>, while <code>PETSc/SLEPc</code> are used for the linear algebra and eigenvalue solver. The geometry is generated with <code>GMSH</code></p>
<p><strong>Problem definition</strong></p>
<p>We study the Laplace eigenvalue problem:</p>
<p><span class="math display">\[
-\Delta u = \lambda u \quad \text{in } \Omega,
\quad u = 0 \quad \text{on } \partial\Omega
\]</span></p>
<p>We use a variational formulation: <span class="math inline">\(~\)</span>Find <span class="math inline">\((\lambda, u) \in \mathbb{R} \times V_h\)</span> such that</p>
<p><span class="math display">\[
a(u, v) = \lambda m(u, v), \quad \forall v \in V_h
\]</span></p>
<p>with</p>
<p><span class="math display">\[
a(u, v) = \int_\Omega \nabla u \cdot \nabla v \, dx,
\quad
m(u, v) = \int_\Omega u v \, dx
\]</span></p>
</section>
<section id="adaptive-mesh-refinement" class="level4" data-number="K.7.8.2">
<h4 data-number="K.7.8.2"><span class="header-section-number">K.7.8.2</span> Adaptive mesh refinement</h4>
<p>Adaptive mesh refinement improves solution accuracy by selectively refining elements where errors are largest. Two common approaches for eigenvalue problems are gradient-based and residual-based error estimation</p>
<p><strong>Gradient-based refinement</strong></p>
<p>Uses the magnitude of the solution gradient as an error indicator:</p>
<p><span class="math display">\[ \eta_K = \int_K |\nabla u_h| \, dx \]</span></p>
<ul>
<li><p>Advantages</p>
<ul>
<li>Simple and computationally cheap</li>
<li>Works well for smooth solutions</li>
<li>Intuitive: large gradients suggest refinement needs</li>
</ul></li>
<li><p>Limitations</p>
<ul>
<li>May over-refine in regions with naturally large gradients</li>
<li>Doesn’t account for actual PDE residual</li>
<li>Less theoretically rigorous</li>
</ul></li>
</ul>
<p><strong>Residual-based refinement</strong></p>
<p>Uses the PDE residual and flux jumps across element boundaries:</p>
<p><span class="math display">\[\eta_K^2 = h_K^2 \|R_K\|_{L^2(K)}^2 + \frac{1}{2} \sum_{e \in \partial K} h_e \|J_e\|_{L^2(e)}^2\]</span>​</p>
<p>where <span class="math inline">\(R_K = \lambda_h u_h\)</span> (interior residual) and <span class="math inline">\(J_e = [\nabla u_h \cdot n]\)</span> (flux jump)</p>
<ul>
<li><p>Advantages</p>
<ul>
<li>Theoretically rigorous error bound</li>
<li>Accounts for both interior and boundary contributions</li>
<li>Better handles singularities and discontinuities</li>
<li>More efficient refinement strategy</li>
</ul></li>
<li><p>Limitations</p>
<ul>
<li>More complex implementation</li>
<li>Higher computational cost</li>
<li>Requires careful treatment of jumps</li>
</ul></li>
</ul>
<p><strong>Implementation tips</strong></p>
<ul>
<li>Threshold selection: Use percentile-based marking (e.g., top 25%)</li>
<li>Scaling: Residual estimator naturally scales with mesh size</li>
<li>Stability: Ensure non-negative error indicators</li>
<li>Convergence: Monitor eigenvalue changes across refinement levels</li>
</ul>
<p>Both methods provide effective adaptive strategies, with residual-based estimation offering superior theoretical foundations at the cost of implementation complexity</p>
</section>
<section id="implementation-3" class="level4" data-number="K.7.8.3">
<h4 data-number="K.7.8.3"><span class="header-section-number">K.7.8.3</span> Implementation</h4>
<p>We begin by importing the necessary packages:</p>
<div id="e0d007a2" class="cell" data-execution_count="167">
<div class="sourceCode" id="cb190"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb190-1"><a href="#cb190-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb190-2"><a href="#cb190-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb190-3"><a href="#cb190-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb190-4"><a href="#cb190-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> petsc4py <span class="im">import</span> PETSc</span>
<span id="cb190-5"><a href="#cb190-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> slepc4py <span class="im">import</span> SLEPc</span>
<span id="cb190-6"><a href="#cb190-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb190-7"><a href="#cb190-7" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> gmsh</span>
<span id="cb190-8"><a href="#cb190-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb190-9"><a href="#cb190-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> fem, mesh, plot, default_scalar_type</span>
<span id="cb190-10"><a href="#cb190-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> assemble_matrix, assemble_vector  <span class="co"># fenicsx 0.9.0</span></span>
<span id="cb190-11"><a href="#cb190-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.mesh <span class="im">import</span> create_unit_square, locate_entities_boundary, refine</span>
<span id="cb190-12"><a href="#cb190-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.io <span class="im">import</span> gmshio, XDMFFile</span>
<span id="cb190-13"><a href="#cb190-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ufl</span></code></pre></div>
</div>
<p>In this section, we’ll go through a complete workflow for generating, converting, and visualizing 2D meshes—specifically a square, an L-shaped domain, and a Pac-Man shape—using <code>Gmsh</code>, <code>FEniCSx</code>, and <code>PyVista</code></p>
<p>Once the meshes are ready, we’ll set up a helper function that solves the eigenvalue problem with <code>SLEPc</code> on a discretized domain</p>
<p>Next, we’ll run the adaptive mesh refinement (AMR) algorithm. To make visualization easier, we’ll also add a helper function that attaches the relevant data to the plotter at each refinement step</p>
<p>Finally, we’ll set up some parameters to check the convergence of the algorithm</p>
<div id="0d6dc5f1" class="cell" data-execution_count="168">
<div class="sourceCode" id="cb191"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb191-1"><a href="#cb191-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> AdaptiveLaplaceEigenSolver:</span>
<span id="cb191-2"><a href="#cb191-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb191-3"><a href="#cb191-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Adaptive Laplace eigenvalue solver with visualization</span></span>
<span id="cb191-4"><a href="#cb191-4" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb191-5"><a href="#cb191-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb191-6"><a href="#cb191-6" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, domain_type<span class="op">=</span><span class="st">&quot;unit_square&quot;</span>, initial_mesh_size<span class="op">=</span><span class="fl">0.1</span>):</span>
<span id="cb191-7"><a href="#cb191-7" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.domain_type <span class="op">=</span> domain_type</span>
<span id="cb191-8"><a href="#cb191-8" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.initial_mesh_size <span class="op">=</span> initial_mesh_size</span>
<span id="cb191-9"><a href="#cb191-9" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.mesh <span class="op">=</span> <span class="va">None</span></span>
<span id="cb191-10"><a href="#cb191-10" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.V <span class="op">=</span> <span class="va">None</span></span>
<span id="cb191-11"><a href="#cb191-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-12"><a href="#cb191-12" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.eigenvalues <span class="op">=</span> []</span>
<span id="cb191-13"><a href="#cb191-13" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.eigenfunctions <span class="op">=</span> []</span>
<span id="cb191-14"><a href="#cb191-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-15"><a href="#cb191-15" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/adaptive_mesh_refinement&quot;</span>)</span>
<span id="cb191-16"><a href="#cb191-16" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb191-17"><a href="#cb191-17" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-18"><a href="#cb191-18" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;Initialized solver for </span><span class="sc">{</span>domain_type<span class="sc">}</span><span class="ss"> domain&quot;</span>)</span>
<span id="cb191-19"><a href="#cb191-19" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-20"><a href="#cb191-20" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> create_domain(<span class="va">self</span>):</span>
<span id="cb191-21"><a href="#cb191-21" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Create computational domain&quot;&quot;&quot;</span></span>
<span id="cb191-22"><a href="#cb191-22" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.domain_type <span class="op">==</span> <span class="st">&quot;unit_square&quot;</span>:</span>
<span id="cb191-23"><a href="#cb191-23" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.mesh <span class="op">=</span> create_unit_square(MPI.COMM_WORLD, <span class="dv">20</span>, <span class="dv">20</span>, mesh.CellType.triangle)</span>
<span id="cb191-24"><a href="#cb191-24" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;Created unit square: </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>_count_n_cells()<span class="sc">}</span><span class="ss"> cells&quot;</span>)</span>
<span id="cb191-25"><a href="#cb191-25" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-26"><a href="#cb191-26" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.domain_type <span class="op">==</span> <span class="st">&quot;l_shape&quot;</span>:</span>
<span id="cb191-27"><a href="#cb191-27" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._create_l_shape_domain()</span>
<span id="cb191-28"><a href="#cb191-28" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-29"><a href="#cb191-29" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.domain_type <span class="op">==</span> <span class="st">&quot;pacman&quot;</span>:</span>
<span id="cb191-30"><a href="#cb191-30" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>._create_pacman_domain()</span>
<span id="cb191-31"><a href="#cb191-31" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-32"><a href="#cb191-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb191-33"><a href="#cb191-33" aria-hidden="true" tabindex="-1"></a>            <span class="cf">raise</span> <span class="pp">ValueError</span>(<span class="ss">f&quot;Unknown domain type: </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>domain_type<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-34"><a href="#cb191-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-35"><a href="#cb191-35" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _count_n_cells(<span class="va">self</span>):</span>
<span id="cb191-36"><a href="#cb191-36" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.mesh.topology.index_map(<span class="dv">2</span>).size_global</span>
<span id="cb191-37"><a href="#cb191-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb191-38"><a href="#cb191-38" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _create_l_shape_domain(<span class="va">self</span>):</span>
<span id="cb191-39"><a href="#cb191-39" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Create L-shaped domain using GMSH&quot;&quot;&quot;</span></span>
<span id="cb191-40"><a href="#cb191-40" aria-hidden="true" tabindex="-1"></a>        gmsh.initialize()</span>
<span id="cb191-41"><a href="#cb191-41" aria-hidden="true" tabindex="-1"></a>        gmsh.model.add(<span class="st">&quot;l_shape&quot;</span>)</span>
<span id="cb191-42"><a href="#cb191-42" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-43"><a href="#cb191-43" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb191-44"><a href="#cb191-44" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create L-shape</span></span>
<span id="cb191-45"><a href="#cb191-45" aria-hidden="true" tabindex="-1"></a>            rect1 <span class="op">=</span> gmsh.model.occ.addRectangle(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb191-46"><a href="#cb191-46" aria-hidden="true" tabindex="-1"></a>            rect2 <span class="op">=</span> gmsh.model.occ.addRectangle(<span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb191-47"><a href="#cb191-47" aria-hidden="true" tabindex="-1"></a>            rect3 <span class="op">=</span> gmsh.model.occ.addRectangle(<span class="dv">1</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="dv">1</span>)</span>
<span id="cb191-48"><a href="#cb191-48" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-49"><a href="#cb191-49" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Fuse rectangles</span></span>
<span id="cb191-50"><a href="#cb191-50" aria-hidden="true" tabindex="-1"></a>            fused1, _ <span class="op">=</span> gmsh.model.occ.fuse([(<span class="dv">2</span>, rect1)], [(<span class="dv">2</span>, rect2)])</span>
<span id="cb191-51"><a href="#cb191-51" aria-hidden="true" tabindex="-1"></a>            fused2, _ <span class="op">=</span> gmsh.model.occ.fuse(fused1, [(<span class="dv">2</span>, rect3)])</span>
<span id="cb191-52"><a href="#cb191-52" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-53"><a href="#cb191-53" aria-hidden="true" tabindex="-1"></a>            gmsh.model.occ.synchronize()</span>
<span id="cb191-54"><a href="#cb191-54" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-55"><a href="#cb191-55" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Add physical groups</span></span>
<span id="cb191-56"><a href="#cb191-56" aria-hidden="true" tabindex="-1"></a>            surfaces <span class="op">=</span> gmsh.model.getEntities(<span class="dv">2</span>)</span>
<span id="cb191-57"><a href="#cb191-57" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> surfaces:</span>
<span id="cb191-58"><a href="#cb191-58" aria-hidden="true" tabindex="-1"></a>                gmsh.model.addPhysicalGroup(<span class="dv">2</span>, [s[<span class="dv">1</span>] <span class="cf">for</span> s <span class="kw">in</span> surfaces], <span class="dv">1</span>)</span>
<span id="cb191-59"><a href="#cb191-59" aria-hidden="true" tabindex="-1"></a>                gmsh.model.setPhysicalName(<span class="dv">2</span>, <span class="dv">1</span>, <span class="st">&quot;LDomain&quot;</span>)</span>
<span id="cb191-60"><a href="#cb191-60" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-61"><a href="#cb191-61" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Set mesh size</span></span>
<span id="cb191-62"><a href="#cb191-62" aria-hidden="true" tabindex="-1"></a>            gmsh.option.setNumber(<span class="st">&quot;Mesh.CharacteristicLengthMin&quot;</span>, <span class="va">self</span>.initial_mesh_size <span class="op">*</span> <span class="fl">0.5</span>)</span>
<span id="cb191-63"><a href="#cb191-63" aria-hidden="true" tabindex="-1"></a>            gmsh.option.setNumber(<span class="st">&quot;Mesh.CharacteristicLengthMax&quot;</span>, <span class="va">self</span>.initial_mesh_size <span class="op">*</span> <span class="fl">2.0</span>)</span>
<span id="cb191-64"><a href="#cb191-64" aria-hidden="true" tabindex="-1"></a>            gmsh.model.mesh.generate(<span class="dv">2</span>)</span>
<span id="cb191-65"><a href="#cb191-65" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-66"><a href="#cb191-66" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Convert to dolfinx</span></span>
<span id="cb191-67"><a href="#cb191-67" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.mesh, ct, ft <span class="op">=</span> gmshio.model_to_mesh(gmsh.model, MPI.COMM_WORLD, <span class="dv">0</span>, gdim<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb191-68"><a href="#cb191-68" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-69"><a href="#cb191-69" aria-hidden="true" tabindex="-1"></a>        <span class="cf">finally</span>:</span>
<span id="cb191-70"><a href="#cb191-70" aria-hidden="true" tabindex="-1"></a>            gmsh.finalize()</span>
<span id="cb191-71"><a href="#cb191-71" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-72"><a href="#cb191-72" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;Created L-shape: </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>_count_n_cells()<span class="sc">}</span><span class="ss"> cells&quot;</span>)</span>
<span id="cb191-73"><a href="#cb191-73" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb191-74"><a href="#cb191-74" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> _create_pacman_domain(<span class="va">self</span>):</span>
<span id="cb191-75"><a href="#cb191-75" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Create Pac-Man domain using GMSH&quot;&quot;&quot;</span></span>
<span id="cb191-76"><a href="#cb191-76" aria-hidden="true" tabindex="-1"></a>        gmsh.initialize()</span>
<span id="cb191-77"><a href="#cb191-77" aria-hidden="true" tabindex="-1"></a>        gmsh.model.add(<span class="st">&quot;pacman&quot;</span>)</span>
<span id="cb191-78"><a href="#cb191-78" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-79"><a href="#cb191-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb191-80"><a href="#cb191-80" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create Pac-Man shape</span></span>
<span id="cb191-81"><a href="#cb191-81" aria-hidden="true" tabindex="-1"></a>            disk <span class="op">=</span> gmsh.model.occ.addDisk(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="fl">1.0</span>, <span class="fl">1.0</span>)</span>
<span id="cb191-82"><a href="#cb191-82" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-83"><a href="#cb191-83" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create mouth triangle</span></span>
<span id="cb191-84"><a href="#cb191-84" aria-hidden="true" tabindex="-1"></a>            angle_rad <span class="op">=</span> np.radians(<span class="dv">30</span>)  <span class="co"># 30-degree mouth opening</span></span>
<span id="cb191-85"><a href="#cb191-85" aria-hidden="true" tabindex="-1"></a>            mouth_length <span class="op">=</span> <span class="fl">1.2</span></span>
<span id="cb191-86"><a href="#cb191-86" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-87"><a href="#cb191-87" aria-hidden="true" tabindex="-1"></a>            p1 <span class="op">=</span> gmsh.model.occ.addPoint(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>)</span>
<span id="cb191-88"><a href="#cb191-88" aria-hidden="true" tabindex="-1"></a>            p2 <span class="op">=</span> gmsh.model.occ.addPoint(mouth_length <span class="op">*</span> np.cos(angle_rad), </span>
<span id="cb191-89"><a href="#cb191-89" aria-hidden="true" tabindex="-1"></a>                                       mouth_length <span class="op">*</span> np.sin(angle_rad), <span class="dv">0</span>)</span>
<span id="cb191-90"><a href="#cb191-90" aria-hidden="true" tabindex="-1"></a>            p3 <span class="op">=</span> gmsh.model.occ.addPoint(mouth_length <span class="op">*</span> np.cos(<span class="op">-</span>angle_rad), </span>
<span id="cb191-91"><a href="#cb191-91" aria-hidden="true" tabindex="-1"></a>                                       mouth_length <span class="op">*</span> np.sin(<span class="op">-</span>angle_rad), <span class="dv">0</span>)</span>
<span id="cb191-92"><a href="#cb191-92" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-93"><a href="#cb191-93" aria-hidden="true" tabindex="-1"></a>            l1 <span class="op">=</span> gmsh.model.occ.addLine(p1, p2)</span>
<span id="cb191-94"><a href="#cb191-94" aria-hidden="true" tabindex="-1"></a>            l2 <span class="op">=</span> gmsh.model.occ.addLine(p2, p3)  </span>
<span id="cb191-95"><a href="#cb191-95" aria-hidden="true" tabindex="-1"></a>            l3 <span class="op">=</span> gmsh.model.occ.addLine(p3, p1)</span>
<span id="cb191-96"><a href="#cb191-96" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-97"><a href="#cb191-97" aria-hidden="true" tabindex="-1"></a>            mouth_loop <span class="op">=</span> gmsh.model.occ.addCurveLoop([l1, l2, l3])</span>
<span id="cb191-98"><a href="#cb191-98" aria-hidden="true" tabindex="-1"></a>            mouth_surface <span class="op">=</span> gmsh.model.occ.addPlaneSurface([mouth_loop])</span>
<span id="cb191-99"><a href="#cb191-99" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-100"><a href="#cb191-100" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Cut mouth from disk</span></span>
<span id="cb191-101"><a href="#cb191-101" aria-hidden="true" tabindex="-1"></a>            pacman, _ <span class="op">=</span> gmsh.model.occ.cut([(<span class="dv">2</span>, disk)], [(<span class="dv">2</span>, mouth_surface)])</span>
<span id="cb191-102"><a href="#cb191-102" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-103"><a href="#cb191-103" aria-hidden="true" tabindex="-1"></a>            gmsh.model.occ.synchronize()</span>
<span id="cb191-104"><a href="#cb191-104" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-105"><a href="#cb191-105" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Add physical groups</span></span>
<span id="cb191-106"><a href="#cb191-106" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> pacman:</span>
<span id="cb191-107"><a href="#cb191-107" aria-hidden="true" tabindex="-1"></a>                dim, tag <span class="op">=</span> pacman[<span class="dv">0</span>]</span>
<span id="cb191-108"><a href="#cb191-108" aria-hidden="true" tabindex="-1"></a>                gmsh.model.addPhysicalGroup(dim, [tag], <span class="dv">1</span>)</span>
<span id="cb191-109"><a href="#cb191-109" aria-hidden="true" tabindex="-1"></a>                gmsh.model.setPhysicalName(dim, <span class="dv">1</span>, <span class="st">&quot;PacmanDomain&quot;</span>)</span>
<span id="cb191-110"><a href="#cb191-110" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-111"><a href="#cb191-111" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Set mesh options</span></span>
<span id="cb191-112"><a href="#cb191-112" aria-hidden="true" tabindex="-1"></a>            gmsh.option.setNumber(<span class="st">&quot;Mesh.CharacteristicLengthMin&quot;</span>, <span class="va">self</span>.initial_mesh_size <span class="op">*</span> <span class="fl">0.5</span>)</span>
<span id="cb191-113"><a href="#cb191-113" aria-hidden="true" tabindex="-1"></a>            gmsh.option.setNumber(<span class="st">&quot;Mesh.CharacteristicLengthMax&quot;</span>, <span class="va">self</span>.initial_mesh_size <span class="op">*</span> <span class="fl">2.0</span>)</span>
<span id="cb191-114"><a href="#cb191-114" aria-hidden="true" tabindex="-1"></a>            gmsh.option.setNumber(<span class="st">&quot;Mesh.Algorithm&quot;</span>, <span class="dv">6</span>)  <span class="co"># Frontal-Delaunay</span></span>
<span id="cb191-115"><a href="#cb191-115" aria-hidden="true" tabindex="-1"></a>            gmsh.model.mesh.generate(<span class="dv">2</span>)</span>
<span id="cb191-116"><a href="#cb191-116" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-117"><a href="#cb191-117" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Convert to dolfinx</span></span>
<span id="cb191-118"><a href="#cb191-118" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.mesh, ct, ft <span class="op">=</span> gmshio.model_to_mesh(gmsh.model, MPI.COMM_WORLD, <span class="dv">0</span>, gdim<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb191-119"><a href="#cb191-119" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-120"><a href="#cb191-120" aria-hidden="true" tabindex="-1"></a>        <span class="cf">finally</span>:</span>
<span id="cb191-121"><a href="#cb191-121" aria-hidden="true" tabindex="-1"></a>            gmsh.finalize()</span>
<span id="cb191-122"><a href="#cb191-122" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-123"><a href="#cb191-123" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;Created Pac-Man: </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>_count_n_cells()<span class="sc">}</span><span class="ss"> cells&quot;</span>)</span>
<span id="cb191-124"><a href="#cb191-124" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb191-125"><a href="#cb191-125" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> solve_eigenvalue_problem(<span class="va">self</span>, n_eigenvalues<span class="op">=</span><span class="dv">6</span>):</span>
<span id="cb191-126"><a href="#cb191-126" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Solve eigenvalue problem on current mesh&quot;&quot;&quot;</span></span>
<span id="cb191-127"><a href="#cb191-127" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create function space</span></span>
<span id="cb191-128"><a href="#cb191-128" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.V <span class="op">=</span> fem.functionspace(<span class="va">self</span>.mesh, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span>
<span id="cb191-129"><a href="#cb191-129" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-130"><a href="#cb191-130" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Define variational forms</span></span>
<span id="cb191-131"><a href="#cb191-131" aria-hidden="true" tabindex="-1"></a>        u <span class="op">=</span> ufl.TrialFunction(<span class="va">self</span>.V)</span>
<span id="cb191-132"><a href="#cb191-132" aria-hidden="true" tabindex="-1"></a>        v <span class="op">=</span> ufl.TestFunction(<span class="va">self</span>.V)</span>
<span id="cb191-133"><a href="#cb191-133" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-134"><a href="#cb191-134" aria-hidden="true" tabindex="-1"></a>        a <span class="op">=</span> ufl.inner(ufl.grad(u), ufl.grad(v)) <span class="op">*</span> ufl.dx  <span class="co"># Stiffness</span></span>
<span id="cb191-135"><a href="#cb191-135" aria-hidden="true" tabindex="-1"></a>        m <span class="op">=</span> ufl.inner(u, v) <span class="op">*</span> ufl.dx                      <span class="co"># Mass</span></span>
<span id="cb191-136"><a href="#cb191-136" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-137"><a href="#cb191-137" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Apply homogeneous Dirichlet boundary conditions</span></span>
<span id="cb191-138"><a href="#cb191-138" aria-hidden="true" tabindex="-1"></a>        boundary_facets <span class="op">=</span> locate_entities_boundary(</span>
<span id="cb191-139"><a href="#cb191-139" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.mesh, <span class="va">self</span>.mesh.topology.dim<span class="op">-</span><span class="dv">1</span>, </span>
<span id="cb191-140"><a href="#cb191-140" aria-hidden="true" tabindex="-1"></a>            <span class="kw">lambda</span> x: np.ones(x.shape[<span class="dv">1</span>], dtype<span class="op">=</span><span class="bu">bool</span>)  <span class="co"># All boundary</span></span>
<span id="cb191-141"><a href="#cb191-141" aria-hidden="true" tabindex="-1"></a>        )</span>
<span id="cb191-142"><a href="#cb191-142" aria-hidden="true" tabindex="-1"></a>        boundary_dofs <span class="op">=</span> fem.locate_dofs_topological(<span class="va">self</span>.V, <span class="va">self</span>.mesh.topology.dim<span class="op">-</span><span class="dv">1</span>, boundary_facets)</span>
<span id="cb191-143"><a href="#cb191-143" aria-hidden="true" tabindex="-1"></a>        bc <span class="op">=</span> fem.dirichletbc(default_scalar_type(<span class="fl">0.0</span>), boundary_dofs, <span class="va">self</span>.V)</span>
<span id="cb191-144"><a href="#cb191-144" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-145"><a href="#cb191-145" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Assemble matrices</span></span>
<span id="cb191-146"><a href="#cb191-146" aria-hidden="true" tabindex="-1"></a>        A <span class="op">=</span> assemble_matrix(fem.form(a), bcs<span class="op">=</span>[bc])</span>
<span id="cb191-147"><a href="#cb191-147" aria-hidden="true" tabindex="-1"></a>        A.assemble()</span>
<span id="cb191-148"><a href="#cb191-148" aria-hidden="true" tabindex="-1"></a>        M <span class="op">=</span> assemble_matrix(fem.form(m), bcs<span class="op">=</span>[bc])</span>
<span id="cb191-149"><a href="#cb191-149" aria-hidden="true" tabindex="-1"></a>        M.assemble()</span>
<span id="cb191-150"><a href="#cb191-150" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-151"><a href="#cb191-151" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Solve using shift-invert</span></span>
<span id="cb191-152"><a href="#cb191-152" aria-hidden="true" tabindex="-1"></a>        eps <span class="op">=</span> SLEPc.EPS().create(MPI.COMM_WORLD)</span>
<span id="cb191-153"><a href="#cb191-153" aria-hidden="true" tabindex="-1"></a>        eps.setOperators(A, M)</span>
<span id="cb191-154"><a href="#cb191-154" aria-hidden="true" tabindex="-1"></a>        eps.setProblemType(SLEPc.EPS.ProblemType.GHEP)</span>
<span id="cb191-155"><a href="#cb191-155" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-156"><a href="#cb191-156" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Set shift based on domain type</span></span>
<span id="cb191-157"><a href="#cb191-157" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="va">self</span>.domain_type <span class="op">==</span> <span class="st">&quot;unit_square&quot;</span>:</span>
<span id="cb191-158"><a href="#cb191-158" aria-hidden="true" tabindex="-1"></a>            shift <span class="op">=</span> <span class="fl">15.0</span></span>
<span id="cb191-159"><a href="#cb191-159" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.domain_type <span class="op">==</span> <span class="st">&quot;l_shape&quot;</span>:</span>
<span id="cb191-160"><a href="#cb191-160" aria-hidden="true" tabindex="-1"></a>            shift <span class="op">=</span> <span class="fl">2.0</span></span>
<span id="cb191-161"><a href="#cb191-161" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> <span class="va">self</span>.domain_type <span class="op">==</span> <span class="st">&quot;pacman&quot;</span>:</span>
<span id="cb191-162"><a href="#cb191-162" aria-hidden="true" tabindex="-1"></a>            shift <span class="op">=</span> <span class="fl">3.0</span></span>
<span id="cb191-163"><a href="#cb191-163" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-164"><a href="#cb191-164" aria-hidden="true" tabindex="-1"></a>        st <span class="op">=</span> eps.getST()</span>
<span id="cb191-165"><a href="#cb191-165" aria-hidden="true" tabindex="-1"></a>        st.setType(SLEPc.ST.Type.SINVERT)</span>
<span id="cb191-166"><a href="#cb191-166" aria-hidden="true" tabindex="-1"></a>        st.setShift(shift)</span>
<span id="cb191-167"><a href="#cb191-167" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-168"><a href="#cb191-168" aria-hidden="true" tabindex="-1"></a>        eps.setWhichEigenpairs(SLEPc.EPS.Which.TARGET_MAGNITUDE)</span>
<span id="cb191-169"><a href="#cb191-169" aria-hidden="true" tabindex="-1"></a>        eps.setTarget(shift)</span>
<span id="cb191-170"><a href="#cb191-170" aria-hidden="true" tabindex="-1"></a>        eps.setDimensions(n_eigenvalues <span class="op">+</span> <span class="dv">3</span>)</span>
<span id="cb191-171"><a href="#cb191-171" aria-hidden="true" tabindex="-1"></a>        eps.setTolerances(<span class="fl">1e-10</span>, <span class="dv">3000</span>)</span>
<span id="cb191-172"><a href="#cb191-172" aria-hidden="true" tabindex="-1"></a>        eps.setType(SLEPc.EPS.Type.KRYLOVSCHUR)</span>
<span id="cb191-173"><a href="#cb191-173" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-174"><a href="#cb191-174" aria-hidden="true" tabindex="-1"></a>        eps.solve()</span>
<span id="cb191-175"><a href="#cb191-175" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-176"><a href="#cb191-176" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract results</span></span>
<span id="cb191-177"><a href="#cb191-177" aria-hidden="true" tabindex="-1"></a>        nconv <span class="op">=</span> eps.getConverged()</span>
<span id="cb191-178"><a href="#cb191-178" aria-hidden="true" tabindex="-1"></a>        results <span class="op">=</span> []</span>
<span id="cb191-179"><a href="#cb191-179" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-180"><a href="#cb191-180" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(nconv):</span>
<span id="cb191-181"><a href="#cb191-181" aria-hidden="true" tabindex="-1"></a>            eigenval <span class="op">=</span> eps.getEigenvalue(i).real</span>
<span id="cb191-182"><a href="#cb191-182" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> eigenval <span class="op">&gt;</span> shift <span class="op">*</span> <span class="fl">0.8</span>:  <span class="co"># Filter based on shift</span></span>
<span id="cb191-183"><a href="#cb191-183" aria-hidden="true" tabindex="-1"></a>                eigenvec <span class="op">=</span> fem.Function(<span class="va">self</span>.V)</span>
<span id="cb191-184"><a href="#cb191-184" aria-hidden="true" tabindex="-1"></a>                eps.getEigenvector(i, eigenvec.x.petsc_vec)</span>
<span id="cb191-185"><a href="#cb191-185" aria-hidden="true" tabindex="-1"></a>                eigenvec.x.scatter_forward()</span>
<span id="cb191-186"><a href="#cb191-186" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-187"><a href="#cb191-187" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Normalize</span></span>
<span id="cb191-188"><a href="#cb191-188" aria-hidden="true" tabindex="-1"></a>                norm <span class="op">=</span> np.sqrt(eigenvec.x.petsc_vec.dot(eigenvec.x.petsc_vec))</span>
<span id="cb191-189"><a href="#cb191-189" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> norm <span class="op">&gt;</span> <span class="fl">1e-12</span>:</span>
<span id="cb191-190"><a href="#cb191-190" aria-hidden="true" tabindex="-1"></a>                    eigenvec.x.petsc_vec.scale(<span class="fl">1.0</span> <span class="op">/</span> norm)</span>
<span id="cb191-191"><a href="#cb191-191" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-192"><a href="#cb191-192" aria-hidden="true" tabindex="-1"></a>                results.append((eigenval, eigenvec))</span>
<span id="cb191-193"><a href="#cb191-193" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-194"><a href="#cb191-194" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Sort and store results</span></span>
<span id="cb191-195"><a href="#cb191-195" aria-hidden="true" tabindex="-1"></a>        results.sort(key<span class="op">=</span><span class="kw">lambda</span> x: x[<span class="dv">0</span>])</span>
<span id="cb191-196"><a href="#cb191-196" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.eigenvalues <span class="op">=</span> [r[<span class="dv">0</span>] <span class="cf">for</span> r <span class="kw">in</span> results[:n_eigenvalues]]</span>
<span id="cb191-197"><a href="#cb191-197" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.eigenfunctions <span class="op">=</span> [r[<span class="dv">1</span>] <span class="cf">for</span> r <span class="kw">in</span> results[:n_eigenvalues]]</span>
<span id="cb191-198"><a href="#cb191-198" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-199"><a href="#cb191-199" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Cleanup</span></span>
<span id="cb191-200"><a href="#cb191-200" aria-hidden="true" tabindex="-1"></a>        eps.destroy()</span>
<span id="cb191-201"><a href="#cb191-201" aria-hidden="true" tabindex="-1"></a>        A.destroy()</span>
<span id="cb191-202"><a href="#cb191-202" aria-hidden="true" tabindex="-1"></a>        M.destroy()</span>
<span id="cb191-203"><a href="#cb191-203" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-204"><a href="#cb191-204" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> <span class="va">self</span>.eigenvalues, <span class="va">self</span>.eigenfunctions</span>
<span id="cb191-205"><a href="#cb191-205" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb191-206"><a href="#cb191-206" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> gradient_estimate_error(<span class="va">self</span>, eigenfunction, eigenvalue):</span>
<span id="cb191-207"><a href="#cb191-207" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb191-208"><a href="#cb191-208" aria-hidden="true" tabindex="-1"></a><span class="co">        Estimate error using gradient-based indicator</span></span>
<span id="cb191-209"><a href="#cb191-209" aria-hidden="true" tabindex="-1"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb191-210"><a href="#cb191-210" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create DG0 space for error indicators</span></span>
<span id="cb191-211"><a href="#cb191-211" aria-hidden="true" tabindex="-1"></a>        W <span class="op">=</span> fem.functionspace(<span class="va">self</span>.mesh, (<span class="st">&quot;DG&quot;</span>, <span class="dv">0</span>))</span>
<span id="cb191-212"><a href="#cb191-212" aria-hidden="true" tabindex="-1"></a>        error_indicator <span class="op">=</span> fem.Function(W)</span>
<span id="cb191-213"><a href="#cb191-213" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-214"><a href="#cb191-214" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Compute gradient magnitude as error indicator</span></span>
<span id="cb191-215"><a href="#cb191-215" aria-hidden="true" tabindex="-1"></a>        u_dg <span class="op">=</span> ufl.TrialFunction(W)        </span>
<span id="cb191-216"><a href="#cb191-216" aria-hidden="true" tabindex="-1"></a>        v_dg <span class="op">=</span> ufl.TestFunction(W)</span>
<span id="cb191-217"><a href="#cb191-217" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb191-218"><a href="#cb191-218" aria-hidden="true" tabindex="-1"></a>        grad_u <span class="op">=</span> ufl.grad(eigenfunction)</span>
<span id="cb191-219"><a href="#cb191-219" aria-hidden="true" tabindex="-1"></a>        grad_norm_expr <span class="op">=</span> ufl.sqrt(ufl.inner(grad_u, grad_u))</span>
<span id="cb191-220"><a href="#cb191-220" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-221"><a href="#cb191-221" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Project gradient norm to DG0</span></span>
<span id="cb191-222"><a href="#cb191-222" aria-hidden="true" tabindex="-1"></a>        a_proj <span class="op">=</span> ufl.inner(u_dg, v_dg) <span class="op">*</span> ufl.dx</span>
<span id="cb191-223"><a href="#cb191-223" aria-hidden="true" tabindex="-1"></a>        L_proj <span class="op">=</span> ufl.inner(grad_norm_expr, v_dg) <span class="op">*</span> ufl.dx</span>
<span id="cb191-224"><a href="#cb191-224" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-225"><a href="#cb191-225" aria-hidden="true" tabindex="-1"></a>        A_proj <span class="op">=</span> assemble_matrix(fem.form(a_proj))</span>
<span id="cb191-226"><a href="#cb191-226" aria-hidden="true" tabindex="-1"></a>        A_proj.assemble()</span>
<span id="cb191-227"><a href="#cb191-227" aria-hidden="true" tabindex="-1"></a>        b_proj <span class="op">=</span> assemble_vector(fem.form(L_proj))</span>
<span id="cb191-228"><a href="#cb191-228" aria-hidden="true" tabindex="-1"></a>        b_proj.assemble()</span>
<span id="cb191-229"><a href="#cb191-229" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-230"><a href="#cb191-230" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Solve projection</span></span>
<span id="cb191-231"><a href="#cb191-231" aria-hidden="true" tabindex="-1"></a>        solver <span class="op">=</span> PETSc.KSP().create()</span>
<span id="cb191-232"><a href="#cb191-232" aria-hidden="true" tabindex="-1"></a>        solver.setOperators(A_proj)</span>
<span id="cb191-233"><a href="#cb191-233" aria-hidden="true" tabindex="-1"></a>        solver.setType(PETSc.KSP.Type.CG)</span>
<span id="cb191-234"><a href="#cb191-234" aria-hidden="true" tabindex="-1"></a>        solver.solve(b_proj, error_indicator.x.petsc_vec)</span>
<span id="cb191-235"><a href="#cb191-235" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-236"><a href="#cb191-236" aria-hidden="true" tabindex="-1"></a>        A_proj.destroy()</span>
<span id="cb191-237"><a href="#cb191-237" aria-hidden="true" tabindex="-1"></a>        b_proj.destroy()</span>
<span id="cb191-238"><a href="#cb191-238" aria-hidden="true" tabindex="-1"></a>        solver.destroy()</span>
<span id="cb191-239"><a href="#cb191-239" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-240"><a href="#cb191-240" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> error_indicator.x.array</span>
<span id="cb191-241"><a href="#cb191-241" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-242"><a href="#cb191-242" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> residual_estimate_error(<span class="va">self</span>, eigenfunction, eigenvalue):</span>
<span id="cb191-243"><a href="#cb191-243" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb191-244"><a href="#cb191-244" aria-hidden="true" tabindex="-1"></a><span class="co">        Residual-based error estimator for eigenvalue problems</span></span>
<span id="cb191-245"><a href="#cb191-245" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb191-246"><a href="#cb191-246" aria-hidden="true" tabindex="-1"></a><span class="co">        η_K² = h_K² ||R_K||²_L²(K) + (1/2) Σ h_e ||J_e||²_L²(e)</span></span>
<span id="cb191-247"><a href="#cb191-247" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb191-248"><a href="#cb191-248" aria-hidden="true" tabindex="-1"></a><span class="co">        where:</span></span>
<span id="cb191-249"><a href="#cb191-249" aria-hidden="true" tabindex="-1"></a><span class="co">        - R_K = λ_h u_h (interior residual, since -Δu_h = λ_h u_h)</span></span>
<span id="cb191-250"><a href="#cb191-250" aria-hidden="true" tabindex="-1"></a><span class="co">        - J_e = [∇u_h · n] (jump in normal flux across interior facets)</span></span>
<span id="cb191-251"><a href="#cb191-251" aria-hidden="true" tabindex="-1"></a><span class="co">        - h_K = cell diameter, h_e = facet size</span></span>
<span id="cb191-252"><a href="#cb191-252" aria-hidden="true" tabindex="-1"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb191-253"><a href="#cb191-253" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Create DG0 space for error indicators</span></span>
<span id="cb191-254"><a href="#cb191-254" aria-hidden="true" tabindex="-1"></a>        W <span class="op">=</span> fem.functionspace(<span class="va">self</span>.mesh, (<span class="st">&quot;DG&quot;</span>, <span class="dv">0</span>))</span>
<span id="cb191-255"><a href="#cb191-255" aria-hidden="true" tabindex="-1"></a>        error_indicator <span class="op">=</span> fem.Function(W)</span>
<span id="cb191-256"><a href="#cb191-256" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-257"><a href="#cb191-257" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Define test function and cell/facet measures</span></span>
<span id="cb191-258"><a href="#cb191-258" aria-hidden="true" tabindex="-1"></a>        w <span class="op">=</span> ufl.TestFunction(W)</span>
<span id="cb191-259"><a href="#cb191-259" aria-hidden="true" tabindex="-1"></a>        h_K <span class="op">=</span> ufl.CellDiameter(<span class="va">self</span>.mesh)</span>
<span id="cb191-260"><a href="#cb191-260" aria-hidden="true" tabindex="-1"></a>        h_e <span class="op">=</span> ufl.FacetArea(<span class="va">self</span>.mesh)  <span class="co"># In 2D, this gives edge length</span></span>
<span id="cb191-261"><a href="#cb191-261" aria-hidden="true" tabindex="-1"></a>        n <span class="op">=</span> ufl.FacetNormal(<span class="va">self</span>.mesh)</span>
<span id="cb191-262"><a href="#cb191-262" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-263"><a href="#cb191-263" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Interior residual: R_K = λ_h * u_h </span></span>
<span id="cb191-264"><a href="#cb191-264" aria-hidden="true" tabindex="-1"></a>        <span class="co"># (since the strong form is -Δu = λu, the residual is λu when Δu ≈ 0)</span></span>
<span id="cb191-265"><a href="#cb191-265" aria-hidden="true" tabindex="-1"></a>        R_K <span class="op">=</span> eigenvalue <span class="op">*</span> eigenfunction</span>
<span id="cb191-266"><a href="#cb191-266" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-267"><a href="#cb191-267" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Jump in normal flux: J_e = [∇u_h · n]</span></span>
<span id="cb191-268"><a href="#cb191-268" aria-hidden="true" tabindex="-1"></a>        grad_u <span class="op">=</span> ufl.grad(eigenfunction)</span>
<span id="cb191-269"><a href="#cb191-269" aria-hidden="true" tabindex="-1"></a>        flux_jump <span class="op">=</span> ufl.jump(grad_u, n)  <span class="co"># Jump across interior facets</span></span>
<span id="cb191-270"><a href="#cb191-270" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-271"><a href="#cb191-271" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Residual-based error estimator</span></span>
<span id="cb191-272"><a href="#cb191-272" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Interior contribution: h_K² ||R_K||²</span></span>
<span id="cb191-273"><a href="#cb191-273" aria-hidden="true" tabindex="-1"></a>        interior_contrib <span class="op">=</span> h_K<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> R_K<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> w <span class="op">*</span> ufl.dx</span>
<span id="cb191-274"><a href="#cb191-274" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-275"><a href="#cb191-275" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Boundary contribution: (1/2) h_e ||J_e||²  </span></span>
<span id="cb191-276"><a href="#cb191-276" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Note: ufl.dS integrates over interior facets only</span></span>
<span id="cb191-277"><a href="#cb191-277" aria-hidden="true" tabindex="-1"></a>        boundary_contrib <span class="op">=</span> <span class="fl">0.5</span> <span class="op">*</span> h_e <span class="op">*</span> flux_jump<span class="op">**</span><span class="dv">2</span> <span class="op">*</span> ufl.avg(w) <span class="op">*</span> ufl.dS</span>
<span id="cb191-278"><a href="#cb191-278" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-279"><a href="#cb191-279" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Total error estimator</span></span>
<span id="cb191-280"><a href="#cb191-280" aria-hidden="true" tabindex="-1"></a>        error_form <span class="op">=</span> interior_contrib <span class="op">+</span> boundary_contrib</span>
<span id="cb191-281"><a href="#cb191-281" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-282"><a href="#cb191-282" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Assemble the error estimator</span></span>
<span id="cb191-283"><a href="#cb191-283" aria-hidden="true" tabindex="-1"></a>        error_vector <span class="op">=</span> assemble_vector(fem.form(error_form))</span>
<span id="cb191-284"><a href="#cb191-284" aria-hidden="true" tabindex="-1"></a>        error_vector.assemble()</span>
<span id="cb191-285"><a href="#cb191-285" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-286"><a href="#cb191-286" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Extract local error indicators and take square root</span></span>
<span id="cb191-287"><a href="#cb191-287" aria-hidden="true" tabindex="-1"></a>        <span class="co"># (since we computed η_K², we need sqrt to get η_K)</span></span>
<span id="cb191-288"><a href="#cb191-288" aria-hidden="true" tabindex="-1"></a>        error_indicators_squared <span class="op">=</span> error_vector.array</span>
<span id="cb191-289"><a href="#cb191-289" aria-hidden="true" tabindex="-1"></a>        error_indicators <span class="op">=</span> np.sqrt(np.maximum(error_indicators_squared, <span class="fl">0.0</span>))  <span class="co"># Ensure non-negative</span></span>
<span id="cb191-290"><a href="#cb191-290" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-291"><a href="#cb191-291" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> error_indicators        </span>
<span id="cb191-292"><a href="#cb191-292" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb191-293"><a href="#cb191-293" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> adaptive_refinement(<span class="va">self</span>, err_estimator<span class="op">=</span><span class="st">&#39;residual&#39;</span>, n_iterations<span class="op">=</span><span class="dv">4</span>, refinement_fraction<span class="op">=</span><span class="fl">0.25</span>, n_eigenvalues<span class="op">=</span><span class="dv">6</span>):</span>
<span id="cb191-294"><a href="#cb191-294" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb191-295"><a href="#cb191-295" aria-hidden="true" tabindex="-1"></a><span class="co">        Perform adaptive mesh refinement</span></span>
<span id="cb191-296"><a href="#cb191-296" aria-hidden="true" tabindex="-1"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb191-297"><a href="#cb191-297" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="ch">\n</span><span class="sc">{</span><span class="st">&#39;=&#39;</span><span class="op">*</span><span class="dv">60</span><span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-298"><a href="#cb191-298" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;ADAPTIVE REFINEMENT for </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>domain_type<span class="sc">.</span>upper()<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-299"><a href="#cb191-299" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="sc">{</span><span class="st">&#39;=&#39;</span><span class="op">*</span><span class="dv">60</span><span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-300"><a href="#cb191-300" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-301"><a href="#cb191-301" aria-hidden="true" tabindex="-1"></a>        refinement_history <span class="op">=</span> []</span>
<span id="cb191-302"><a href="#cb191-302" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-303"><a href="#cb191-303" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> iteration <span class="kw">in</span> <span class="bu">range</span>(n_iterations):</span>
<span id="cb191-304"><a href="#cb191-304" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="ch">\n</span><span class="ss">--- Iteration </span><span class="sc">{</span>iteration <span class="op">+</span> <span class="dv">1</span><span class="sc">}</span><span class="ss">/</span><span class="sc">{</span>n_iterations<span class="sc">}</span><span class="ss"> ---&quot;</span>)</span>
<span id="cb191-305"><a href="#cb191-305" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-306"><a href="#cb191-306" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Solve eigenvalue problem</span></span>
<span id="cb191-307"><a href="#cb191-307" aria-hidden="true" tabindex="-1"></a>            eigenvalues, eigenfunctions <span class="op">=</span> <span class="va">self</span>.solve_eigenvalue_problem(n_eigenvalues)</span>
<span id="cb191-308"><a href="#cb191-308" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-309"><a href="#cb191-309" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;Mesh: </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>_count_n_cells()<span class="sc">}</span><span class="ss"> cells, &quot;</span></span>
<span id="cb191-310"><a href="#cb191-310" aria-hidden="true" tabindex="-1"></a>                  <span class="ss">f&quot;DOFs: </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>V<span class="sc">.</span>dofmap<span class="sc">.</span>index_map<span class="sc">.</span>size_global<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-311"><a href="#cb191-311" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-312"><a href="#cb191-312" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Display first few eigenvalues</span></span>
<span id="cb191-313"><a href="#cb191-313" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i, eigenval <span class="kw">in</span> <span class="bu">enumerate</span>(eigenvalues[:<span class="dv">3</span>]):</span>
<span id="cb191-314"><a href="#cb191-314" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f&quot;λ_</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>eigenval<span class="sc">:.6f}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-315"><a href="#cb191-315" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-316"><a href="#cb191-316" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Save current results</span></span>
<span id="cb191-317"><a href="#cb191-317" aria-hidden="true" tabindex="-1"></a>            <span class="va">self</span>.save_iteration_results(iteration)</span>
<span id="cb191-318"><a href="#cb191-318" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-319"><a href="#cb191-319" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Estimate error for first eigenfunction</span></span>
<span id="cb191-320"><a href="#cb191-320" aria-hidden="true" tabindex="-1"></a>            <span class="cf">if</span> eigenfunctions:</span>
<span id="cb191-321"><a href="#cb191-321" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb191-322"><a href="#cb191-322" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> err_estimator <span class="op">==</span> <span class="st">&#39;residual&#39;</span>:</span>
<span id="cb191-323"><a href="#cb191-323" aria-hidden="true" tabindex="-1"></a>                    error_indicators <span class="op">=</span> <span class="va">self</span>.residual_estimate_error(eigenfunctions[<span class="dv">0</span>], eigenvalues[<span class="dv">0</span>])</span>
<span id="cb191-324"><a href="#cb191-324" aria-hidden="true" tabindex="-1"></a>                <span class="cf">elif</span> err_estimator <span class="op">==</span> <span class="st">&#39;gradient&#39;</span>:</span>
<span id="cb191-325"><a href="#cb191-325" aria-hidden="true" tabindex="-1"></a>                    error_indicators <span class="op">=</span> <span class="va">self</span>.gradient_estimate_error(eigenfunctions[<span class="dv">0</span>], eigenvalues[<span class="dv">0</span>])</span>
<span id="cb191-326"><a href="#cb191-326" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-327"><a href="#cb191-327" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Mark cells for refinement</span></span>
<span id="cb191-328"><a href="#cb191-328" aria-hidden="true" tabindex="-1"></a>                threshold <span class="op">=</span> np.percentile(error_indicators, (<span class="dv">1</span> <span class="op">-</span> refinement_fraction) <span class="op">*</span> <span class="dv">100</span>)</span>
<span id="cb191-329"><a href="#cb191-329" aria-hidden="true" tabindex="-1"></a>                cells_to_refine <span class="op">=</span> np.where(error_indicators <span class="op">&gt;</span> threshold)[<span class="dv">0</span>]</span>
<span id="cb191-330"><a href="#cb191-330" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-331"><a href="#cb191-331" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f&quot;Refining </span><span class="sc">{</span><span class="bu">len</span>(cells_to_refine)<span class="sc">}</span><span class="ss"> cells (threshold: </span><span class="sc">{</span>threshold<span class="sc">:.3f}</span><span class="ss">)&quot;</span>)</span>
<span id="cb191-332"><a href="#cb191-332" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-333"><a href="#cb191-333" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> <span class="bu">len</span>(cells_to_refine) <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb191-334"><a href="#cb191-334" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">print</span>(<span class="st">&quot;No cells to refine, stopping.&quot;</span>)</span>
<span id="cb191-335"><a href="#cb191-335" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">break</span></span>
<span id="cb191-336"><a href="#cb191-336" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-337"><a href="#cb191-337" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Store history</span></span>
<span id="cb191-338"><a href="#cb191-338" aria-hidden="true" tabindex="-1"></a>                refinement_history.append({</span>
<span id="cb191-339"><a href="#cb191-339" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&#39;iteration&#39;</span>: iteration <span class="op">+</span> <span class="dv">1</span>,</span>
<span id="cb191-340"><a href="#cb191-340" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&#39;n_cells&#39;</span>: <span class="va">self</span>._count_n_cells(),</span>
<span id="cb191-341"><a href="#cb191-341" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&#39;n_dofs&#39;</span>: <span class="va">self</span>.V.dofmap.index_map.size_global,</span>
<span id="cb191-342"><a href="#cb191-342" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&#39;eigenvalues&#39;</span>: eigenvalues.copy(),</span>
<span id="cb191-343"><a href="#cb191-343" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&#39;error_max&#39;</span>: error_indicators.<span class="bu">max</span>(),</span>
<span id="cb191-344"><a href="#cb191-344" aria-hidden="true" tabindex="-1"></a>                    <span class="st">&#39;error_mean&#39;</span>: error_indicators.mean()</span>
<span id="cb191-345"><a href="#cb191-345" aria-hidden="true" tabindex="-1"></a>                })</span>
<span id="cb191-346"><a href="#cb191-346" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-347"><a href="#cb191-347" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Refine mesh</span></span>
<span id="cb191-348"><a href="#cb191-348" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> iteration <span class="op">&lt;</span> n_iterations <span class="op">-</span> <span class="dv">1</span>:  <span class="co"># Don&#39;t refine on last iteration</span></span>
<span id="cb191-349"><a href="#cb191-349" aria-hidden="true" tabindex="-1"></a>                    refined_result <span class="op">=</span> refine(<span class="va">self</span>.mesh, cells_to_refine)</span>
<span id="cb191-350"><a href="#cb191-350" aria-hidden="true" tabindex="-1"></a>                    <span class="co"># In dolfinx 0.9.0, refine may return a tuple (mesh, cell_map, vertex_map, facet_map)</span></span>
<span id="cb191-351"><a href="#cb191-351" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">if</span> <span class="bu">isinstance</span>(refined_result, <span class="bu">tuple</span>):</span>
<span id="cb191-352"><a href="#cb191-352" aria-hidden="true" tabindex="-1"></a>                        <span class="va">self</span>.mesh <span class="op">=</span> refined_result[<span class="dv">0</span>]  <span class="co"># Extract just the mesh</span></span>
<span id="cb191-353"><a href="#cb191-353" aria-hidden="true" tabindex="-1"></a>                    <span class="cf">else</span>:</span>
<span id="cb191-354"><a href="#cb191-354" aria-hidden="true" tabindex="-1"></a>                        <span class="va">self</span>.mesh <span class="op">=</span> refined_result</span>
<span id="cb191-355"><a href="#cb191-355" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-356"><a href="#cb191-356" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Final solve and save</span></span>
<span id="cb191-357"><a href="#cb191-357" aria-hidden="true" tabindex="-1"></a>        final_eigenvalues, final_eigenfunctions <span class="op">=</span> <span class="va">self</span>.solve_eigenvalue_problem(n_eigenvalues)</span>
<span id="cb191-358"><a href="#cb191-358" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.save_final_results()</span>
<span id="cb191-359"><a href="#cb191-359" aria-hidden="true" tabindex="-1"></a>        <span class="va">self</span>.print_convergence_summary(refinement_history)</span>
<span id="cb191-360"><a href="#cb191-360" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-361"><a href="#cb191-361" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> refinement_history</span>
<span id="cb191-362"><a href="#cb191-362" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb191-363"><a href="#cb191-363" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> save_iteration_results(<span class="va">self</span>, iteration):</span>
<span id="cb191-364"><a href="#cb191-364" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Save results for current iteration&quot;&quot;&quot;</span></span>
<span id="cb191-365"><a href="#cb191-365" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.eigenvalues <span class="kw">or</span> <span class="kw">not</span> <span class="va">self</span>.eigenfunctions:</span>
<span id="cb191-366"><a href="#cb191-366" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb191-367"><a href="#cb191-367" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-368"><a href="#cb191-368" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Save eigenvalues</span></span>
<span id="cb191-369"><a href="#cb191-369" aria-hidden="true" tabindex="-1"></a>        eigenval_file <span class="op">=</span> <span class="va">self</span>.results_folder <span class="op">/</span> <span class="ss">f&quot;</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>domain_type<span class="sc">}</span><span class="ss">_eigenvalues_iter_</span><span class="sc">{</span>iteration<span class="sc">}</span><span class="ss">.txt&quot;</span></span>
<span id="cb191-370"><a href="#cb191-370" aria-hidden="true" tabindex="-1"></a>        np.savetxt(eigenval_file, <span class="va">self</span>.eigenvalues)</span>
<span id="cb191-371"><a href="#cb191-371" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-372"><a href="#cb191-372" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Save eigenfunctions to XDMF</span></span>
<span id="cb191-373"><a href="#cb191-373" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb191-374"><a href="#cb191-374" aria-hidden="true" tabindex="-1"></a>            xdmf_file <span class="op">=</span> <span class="va">self</span>.results_folder <span class="op">/</span> <span class="ss">f&quot;</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>domain_type<span class="sc">}</span><span class="ss">_eigenfunctions_iter_</span><span class="sc">{</span>iteration<span class="sc">}</span><span class="ss">.xdmf&quot;</span></span>
<span id="cb191-375"><a href="#cb191-375" aria-hidden="true" tabindex="-1"></a>            <span class="cf">with</span> XDMFFile(<span class="va">self</span>.mesh.comm, xdmf_file, <span class="st">&quot;w&quot;</span>) <span class="im">as</span> <span class="bu">file</span>:</span>
<span id="cb191-376"><a href="#cb191-376" aria-hidden="true" tabindex="-1"></a>                <span class="bu">file</span>.write_mesh(<span class="va">self</span>.mesh)</span>
<span id="cb191-377"><a href="#cb191-377" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> i, u <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.eigenfunctions[:<span class="dv">3</span>]):</span>
<span id="cb191-378"><a href="#cb191-378" aria-hidden="true" tabindex="-1"></a>                    u.name <span class="op">=</span> <span class="ss">f&quot;eigenmode_</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">&quot;</span></span>
<span id="cb191-379"><a href="#cb191-379" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">file</span>.write_function(u)</span>
<span id="cb191-380"><a href="#cb191-380" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb191-381"><a href="#cb191-381" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;Could not save XDMF for iteration </span><span class="sc">{</span>iteration<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-382"><a href="#cb191-382" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb191-383"><a href="#cb191-383" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> save_final_results(<span class="va">self</span>):</span>
<span id="cb191-384"><a href="#cb191-384" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Save final results&quot;&quot;&quot;</span></span>
<span id="cb191-385"><a href="#cb191-385" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.eigenvalues <span class="kw">or</span> <span class="kw">not</span> <span class="va">self</span>.eigenfunctions:</span>
<span id="cb191-386"><a href="#cb191-386" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb191-387"><a href="#cb191-387" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-388"><a href="#cb191-388" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Save final eigenvalues</span></span>
<span id="cb191-389"><a href="#cb191-389" aria-hidden="true" tabindex="-1"></a>        final_eigenval_file <span class="op">=</span> <span class="va">self</span>.results_folder <span class="op">/</span> <span class="ss">f&quot;</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>domain_type<span class="sc">}</span><span class="ss">_final_eigenvalues.txt&quot;</span></span>
<span id="cb191-390"><a href="#cb191-390" aria-hidden="true" tabindex="-1"></a>        np.savetxt(final_eigenval_file, <span class="va">self</span>.eigenvalues)</span>
<span id="cb191-391"><a href="#cb191-391" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-392"><a href="#cb191-392" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Save final eigenfunctions</span></span>
<span id="cb191-393"><a href="#cb191-393" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb191-394"><a href="#cb191-394" aria-hidden="true" tabindex="-1"></a>            final_xdmf_file <span class="op">=</span> <span class="va">self</span>.results_folder <span class="op">/</span> <span class="ss">f&quot;</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>domain_type<span class="sc">}</span><span class="ss">_final_eigenfunctions.xdmf&quot;</span></span>
<span id="cb191-395"><a href="#cb191-395" aria-hidden="true" tabindex="-1"></a>            <span class="cf">with</span> XDMFFile(<span class="va">self</span>.mesh.comm, final_xdmf_file, <span class="st">&quot;w&quot;</span>) <span class="im">as</span> <span class="bu">file</span>:</span>
<span id="cb191-396"><a href="#cb191-396" aria-hidden="true" tabindex="-1"></a>                <span class="bu">file</span>.write_mesh(<span class="va">self</span>.mesh)</span>
<span id="cb191-397"><a href="#cb191-397" aria-hidden="true" tabindex="-1"></a>                <span class="cf">for</span> i, u <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="va">self</span>.eigenfunctions):</span>
<span id="cb191-398"><a href="#cb191-398" aria-hidden="true" tabindex="-1"></a>                    u.name <span class="op">=</span> <span class="ss">f&quot;final_eigenmode_</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">&quot;</span></span>
<span id="cb191-399"><a href="#cb191-399" aria-hidden="true" tabindex="-1"></a>                    <span class="bu">file</span>.write_function(u)</span>
<span id="cb191-400"><a href="#cb191-400" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb191-401"><a href="#cb191-401" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;Could not save final XDMF: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-402"><a href="#cb191-402" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb191-403"><a href="#cb191-403" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> visualize_eigenmodes(<span class="va">self</span>, max_modes<span class="op">=</span><span class="dv">4</span>, save_html<span class="op">=</span><span class="va">True</span>, save_png<span class="op">=</span><span class="va">True</span>):</span>
<span id="cb191-404"><a href="#cb191-404" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb191-405"><a href="#cb191-405" aria-hidden="true" tabindex="-1"></a><span class="co">        Create beautiful visualizations of eigenmodes using PyVista</span></span>
<span id="cb191-406"><a href="#cb191-406" aria-hidden="true" tabindex="-1"></a><span class="co">        &quot;&quot;&quot;</span></span>
<span id="cb191-407"><a href="#cb191-407" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="kw">not</span> <span class="va">self</span>.eigenfunctions:</span>
<span id="cb191-408"><a href="#cb191-408" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">&quot;No eigenfunctions to visualize&quot;</span>)</span>
<span id="cb191-409"><a href="#cb191-409" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb191-410"><a href="#cb191-410" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-411"><a href="#cb191-411" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="ch">\n</span><span class="ss">Creating visualizations for </span><span class="sc">{</span><span class="bu">len</span>(<span class="va">self</span>.eigenfunctions)<span class="sc">}</span><span class="ss"> eigenmodes...&quot;</span>)</span>
<span id="cb191-412"><a href="#cb191-412" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-413"><a href="#cb191-413" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> i, (eigenval, eigenfunction) <span class="kw">in</span> <span class="bu">enumerate</span>(<span class="bu">zip</span>(<span class="va">self</span>.eigenvalues[:max_modes], </span>
<span id="cb191-414"><a href="#cb191-414" aria-hidden="true" tabindex="-1"></a>                                                         <span class="va">self</span>.eigenfunctions[:max_modes])):</span>
<span id="cb191-415"><a href="#cb191-415" aria-hidden="true" tabindex="-1"></a>            <span class="cf">try</span>:</span>
<span id="cb191-416"><a href="#cb191-416" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Create PyVista grid</span></span>
<span id="cb191-417"><a href="#cb191-417" aria-hidden="true" tabindex="-1"></a>                topology, cell_types, geometry <span class="op">=</span> plot.vtk_mesh(<span class="va">self</span>.V)</span>
<span id="cb191-418"><a href="#cb191-418" aria-hidden="true" tabindex="-1"></a>                grid <span class="op">=</span> pyvista.UnstructuredGrid(topology, cell_types, geometry)</span>
<span id="cb191-419"><a href="#cb191-419" aria-hidden="true" tabindex="-1"></a>                grid.point_data[<span class="st">&quot;Eigenfunction&quot;</span>] <span class="op">=</span> eigenfunction.x.array.real</span>
<span id="cb191-420"><a href="#cb191-420" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-421"><a href="#cb191-421" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Create beautiful plot</span></span>
<span id="cb191-422"><a href="#cb191-422" aria-hidden="true" tabindex="-1"></a>                plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">True</span>, window_size<span class="op">=</span>(<span class="dv">1200</span>, <span class="dv">800</span>))</span>
<span id="cb191-423"><a href="#cb191-423" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-424"><a href="#cb191-424" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Add mesh with scalar field</span></span>
<span id="cb191-425"><a href="#cb191-425" aria-hidden="true" tabindex="-1"></a>                mesh_actor <span class="op">=</span> plotter.add_mesh(</span>
<span id="cb191-426"><a href="#cb191-426" aria-hidden="true" tabindex="-1"></a>                    grid, </span>
<span id="cb191-427"><a href="#cb191-427" aria-hidden="true" tabindex="-1"></a>                    scalars<span class="op">=</span><span class="st">&quot;Eigenfunction&quot;</span>,</span>
<span id="cb191-428"><a href="#cb191-428" aria-hidden="true" tabindex="-1"></a>                    cmap<span class="op">=</span><span class="st">&quot;RdBu_r&quot;</span>,</span>
<span id="cb191-429"><a href="#cb191-429" aria-hidden="true" tabindex="-1"></a>                    show_edges<span class="op">=</span><span class="va">True</span>,</span>
<span id="cb191-430"><a href="#cb191-430" aria-hidden="true" tabindex="-1"></a>                    scalar_bar_args<span class="op">=</span>{</span>
<span id="cb191-431"><a href="#cb191-431" aria-hidden="true" tabindex="-1"></a>                        <span class="st">&#39;title&#39;</span>: <span class="ss">f&#39;Mode </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ch">\n</span><span class="ss">&#39;</span>,</span>
<span id="cb191-432"><a href="#cb191-432" aria-hidden="true" tabindex="-1"></a>                        <span class="st">&#39;title_font_size&#39;</span>: <span class="dv">14</span>,</span>
<span id="cb191-433"><a href="#cb191-433" aria-hidden="true" tabindex="-1"></a>                        <span class="st">&#39;label_font_size&#39;</span>: <span class="dv">13</span>,</span>
<span id="cb191-434"><a href="#cb191-434" aria-hidden="true" tabindex="-1"></a>                        <span class="st">&#39;n_labels&#39;</span>: <span class="dv">5</span>,</span>
<span id="cb191-435"><a href="#cb191-435" aria-hidden="true" tabindex="-1"></a>                        <span class="st">&#39;width&#39;</span>: <span class="fl">0.6</span>,</span>
<span id="cb191-436"><a href="#cb191-436" aria-hidden="true" tabindex="-1"></a>                        <span class="st">&#39;height&#39;</span>: <span class="fl">0.05</span>,</span>
<span id="cb191-437"><a href="#cb191-437" aria-hidden="true" tabindex="-1"></a>                        <span class="st">&#39;position_x&#39;</span>: <span class="fl">0.2</span>,</span>
<span id="cb191-438"><a href="#cb191-438" aria-hidden="true" tabindex="-1"></a>                        <span class="st">&#39;position_y&#39;</span>: <span class="fl">0.02</span></span>
<span id="cb191-439"><a href="#cb191-439" aria-hidden="true" tabindex="-1"></a>                    }</span>
<span id="cb191-440"><a href="#cb191-440" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb191-441"><a href="#cb191-441" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-442"><a href="#cb191-442" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Set camera and lighting</span></span>
<span id="cb191-443"><a href="#cb191-443" aria-hidden="true" tabindex="-1"></a>                plotter.view_xy()</span>
<span id="cb191-444"><a href="#cb191-444" aria-hidden="true" tabindex="-1"></a>                plotter.camera.zoom(<span class="fl">1.1</span>)</span>
<span id="cb191-445"><a href="#cb191-445" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-446"><a href="#cb191-446" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Add title</span></span>
<span id="cb191-447"><a href="#cb191-447" aria-hidden="true" tabindex="-1"></a>                plotter.add_text(</span>
<span id="cb191-448"><a href="#cb191-448" aria-hidden="true" tabindex="-1"></a>                    <span class="ss">f&#39;</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>domain_type<span class="sc">.</span>replace(<span class="st">&quot;_&quot;</span>, <span class="st">&quot; &quot;</span>)<span class="sc">.</span>title()<span class="sc">}</span><span class="ss">: lambda_</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>eigenval<span class="sc">:.6f}</span><span class="ss">&#39;</span>,</span>
<span id="cb191-449"><a href="#cb191-449" aria-hidden="true" tabindex="-1"></a>                    position<span class="op">=</span><span class="st">&#39;upper_left&#39;</span>,</span>
<span id="cb191-450"><a href="#cb191-450" aria-hidden="true" tabindex="-1"></a>                    font_size<span class="op">=</span><span class="dv">14</span>,</span>
<span id="cb191-451"><a href="#cb191-451" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span><span class="st">&#39;black&#39;</span></span>
<span id="cb191-452"><a href="#cb191-452" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb191-453"><a href="#cb191-453" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-454"><a href="#cb191-454" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Add mesh info</span></span>
<span id="cb191-455"><a href="#cb191-455" aria-hidden="true" tabindex="-1"></a>                plotter.add_text(</span>
<span id="cb191-456"><a href="#cb191-456" aria-hidden="true" tabindex="-1"></a>                    <span class="ss">f&#39;</span><span class="ch">\n\n</span><span class="ss">Cells: </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>_count_n_cells()<span class="sc">}</span><span class="ss">, &#39;</span></span>
<span id="cb191-457"><a href="#cb191-457" aria-hidden="true" tabindex="-1"></a>                    <span class="ss">f&#39;DOFs: </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>V<span class="sc">.</span>dofmap<span class="sc">.</span>index_map<span class="sc">.</span>size_global<span class="sc">}</span><span class="ss">&#39;</span>,</span>
<span id="cb191-458"><a href="#cb191-458" aria-hidden="true" tabindex="-1"></a>                    position<span class="op">=</span><span class="st">&#39;upper_left&#39;</span>,<span class="co">#&#39;lower_right&#39;,</span></span>
<span id="cb191-459"><a href="#cb191-459" aria-hidden="true" tabindex="-1"></a>                    font_size<span class="op">=</span><span class="dv">9</span>,</span>
<span id="cb191-460"><a href="#cb191-460" aria-hidden="true" tabindex="-1"></a>                    color<span class="op">=</span><span class="st">&#39;gray&#39;</span></span>
<span id="cb191-461"><a href="#cb191-461" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb191-462"><a href="#cb191-462" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-463"><a href="#cb191-463" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Save visualizations</span></span>
<span id="cb191-464"><a href="#cb191-464" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> save_html:</span>
<span id="cb191-465"><a href="#cb191-465" aria-hidden="true" tabindex="-1"></a>                    html_file <span class="op">=</span> <span class="va">self</span>.results_folder <span class="op">/</span> <span class="ss">f&quot;</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>domain_type<span class="sc">}</span><span class="ss">_mode_</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">.html&quot;</span></span>
<span id="cb191-466"><a href="#cb191-466" aria-hidden="true" tabindex="-1"></a>                    plotter.export_html(html_file)</span>
<span id="cb191-467"><a href="#cb191-467" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-468"><a href="#cb191-468" aria-hidden="true" tabindex="-1"></a>                <span class="cf">if</span> save_png:</span>
<span id="cb191-469"><a href="#cb191-469" aria-hidden="true" tabindex="-1"></a>                    png_file <span class="op">=</span> <span class="va">self</span>.results_folder <span class="op">/</span> <span class="ss">f&quot;</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>domain_type<span class="sc">}</span><span class="ss">_mode_</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">.png&quot;</span></span>
<span id="cb191-470"><a href="#cb191-470" aria-hidden="true" tabindex="-1"></a>                    plotter.screenshot(png_file, transparent_background<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb191-471"><a href="#cb191-471" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-472"><a href="#cb191-472" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f&quot;✓ Saved visualizations for mode </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-473"><a href="#cb191-473" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-474"><a href="#cb191-474" aria-hidden="true" tabindex="-1"></a>            <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb191-475"><a href="#cb191-475" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f&quot;✗ Visualization error for mode </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-476"><a href="#cb191-476" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb191-477"><a href="#cb191-477" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> create_comparison_plot(<span class="va">self</span>):</span>
<span id="cb191-478"><a href="#cb191-478" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Create comparison plot of all eigenmodes&quot;&quot;&quot;</span></span>
<span id="cb191-479"><a href="#cb191-479" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> <span class="bu">len</span>(<span class="va">self</span>.eigenfunctions) <span class="op">&lt;</span> <span class="dv">4</span>:</span>
<span id="cb191-480"><a href="#cb191-480" aria-hidden="true" tabindex="-1"></a>            <span class="cf">return</span></span>
<span id="cb191-481"><a href="#cb191-481" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-482"><a href="#cb191-482" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb191-483"><a href="#cb191-483" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create 2x2 subplot</span></span>
<span id="cb191-484"><a href="#cb191-484" aria-hidden="true" tabindex="-1"></a>            plotter <span class="op">=</span> pyvista.Plotter(shape<span class="op">=</span>(<span class="dv">2</span>, <span class="dv">2</span>), off_screen<span class="op">=</span><span class="va">True</span>, window_size<span class="op">=</span>(<span class="dv">1600</span>, <span class="dv">1200</span>))</span>
<span id="cb191-485"><a href="#cb191-485" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-486"><a href="#cb191-486" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(<span class="bu">min</span>(<span class="dv">4</span>, <span class="bu">len</span>(<span class="va">self</span>.eigenfunctions))):</span>
<span id="cb191-487"><a href="#cb191-487" aria-hidden="true" tabindex="-1"></a>                eigenval <span class="op">=</span> <span class="va">self</span>.eigenvalues[i]</span>
<span id="cb191-488"><a href="#cb191-488" aria-hidden="true" tabindex="-1"></a>                eigenfunction <span class="op">=</span> <span class="va">self</span>.eigenfunctions[i]</span>
<span id="cb191-489"><a href="#cb191-489" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-490"><a href="#cb191-490" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Create grid</span></span>
<span id="cb191-491"><a href="#cb191-491" aria-hidden="true" tabindex="-1"></a>                topology, cell_types, geometry <span class="op">=</span> plot.vtk_mesh(<span class="va">self</span>.V)</span>
<span id="cb191-492"><a href="#cb191-492" aria-hidden="true" tabindex="-1"></a>                grid <span class="op">=</span> pyvista.UnstructuredGrid(topology, cell_types, geometry)</span>
<span id="cb191-493"><a href="#cb191-493" aria-hidden="true" tabindex="-1"></a>                grid.point_data[<span class="st">&quot;Eigenfunction&quot;</span>] <span class="op">=</span> eigenfunction.x.array.real</span>
<span id="cb191-494"><a href="#cb191-494" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-495"><a href="#cb191-495" aria-hidden="true" tabindex="-1"></a>                <span class="co"># Set subplot</span></span>
<span id="cb191-496"><a href="#cb191-496" aria-hidden="true" tabindex="-1"></a>                row, col <span class="op">=</span> <span class="bu">divmod</span>(i, <span class="dv">2</span>)</span>
<span id="cb191-497"><a href="#cb191-497" aria-hidden="true" tabindex="-1"></a>                plotter.subplot(row, col)</span>
<span id="cb191-498"><a href="#cb191-498" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-499"><a href="#cb191-499" aria-hidden="true" tabindex="-1"></a>                plotter.add_mesh(</span>
<span id="cb191-500"><a href="#cb191-500" aria-hidden="true" tabindex="-1"></a>                    grid,</span>
<span id="cb191-501"><a href="#cb191-501" aria-hidden="true" tabindex="-1"></a>                    scalars<span class="op">=</span><span class="st">&quot;Eigenfunction&quot;</span>, </span>
<span id="cb191-502"><a href="#cb191-502" aria-hidden="true" tabindex="-1"></a>                    cmap<span class="op">=</span><span class="st">&quot;RdBu_r&quot;</span>,</span>
<span id="cb191-503"><a href="#cb191-503" aria-hidden="true" tabindex="-1"></a>                    show_edges<span class="op">=</span><span class="va">False</span>,</span>
<span id="cb191-504"><a href="#cb191-504" aria-hidden="true" tabindex="-1"></a>                    scalar_bar_args<span class="op">=</span>{</span>
<span id="cb191-505"><a href="#cb191-505" aria-hidden="true" tabindex="-1"></a>                        <span class="st">&#39;title&#39;</span>: <span class="ss">f&#39;Mode </span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ch">\n</span><span class="ss">&#39;</span>,</span>
<span id="cb191-506"><a href="#cb191-506" aria-hidden="true" tabindex="-1"></a>                        <span class="st">&#39;title_font_size&#39;</span>: <span class="dv">14</span>,</span>
<span id="cb191-507"><a href="#cb191-507" aria-hidden="true" tabindex="-1"></a>                        <span class="st">&#39;label_font_size&#39;</span>: <span class="dv">13</span>,</span>
<span id="cb191-508"><a href="#cb191-508" aria-hidden="true" tabindex="-1"></a>                    }                    </span>
<span id="cb191-509"><a href="#cb191-509" aria-hidden="true" tabindex="-1"></a>                )</span>
<span id="cb191-510"><a href="#cb191-510" aria-hidden="true" tabindex="-1"></a>                </span>
<span id="cb191-511"><a href="#cb191-511" aria-hidden="true" tabindex="-1"></a>                plotter.add_text(</span>
<span id="cb191-512"><a href="#cb191-512" aria-hidden="true" tabindex="-1"></a>                    <span class="ss">f&#39;lambda_</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>eigenval<span class="sc">:.4f}</span><span class="ss">&#39;</span>, </span>
<span id="cb191-513"><a href="#cb191-513" aria-hidden="true" tabindex="-1"></a>                    position<span class="op">=</span><span class="st">&#39;upper_left&#39;</span>,</span>
<span id="cb191-514"><a href="#cb191-514" aria-hidden="true" tabindex="-1"></a>                    font_size<span class="op">=</span><span class="dv">14</span>)</span>
<span id="cb191-515"><a href="#cb191-515" aria-hidden="true" tabindex="-1"></a>                plotter.view_xy()</span>
<span id="cb191-516"><a href="#cb191-516" aria-hidden="true" tabindex="-1"></a>                plotter.camera.zoom(<span class="fl">0.95</span>)</span>
<span id="cb191-517"><a href="#cb191-517" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-518"><a href="#cb191-518" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Save comparison</span></span>
<span id="cb191-519"><a href="#cb191-519" aria-hidden="true" tabindex="-1"></a>            comparison_file <span class="op">=</span> <span class="va">self</span>.results_folder <span class="op">/</span> <span class="ss">f&quot;</span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>domain_type<span class="sc">}</span><span class="ss">_comparison.png&quot;</span></span>
<span id="cb191-520"><a href="#cb191-520" aria-hidden="true" tabindex="-1"></a>            plotter.screenshot(comparison_file)</span>
<span id="cb191-521"><a href="#cb191-521" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-522"><a href="#cb191-522" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;✓ Saved comparison plot: </span><span class="sc">{</span>comparison_file<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-523"><a href="#cb191-523" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb191-524"><a href="#cb191-524" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb191-525"><a href="#cb191-525" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;✗ Comparison plot error: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-526"><a href="#cb191-526" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb191-527"><a href="#cb191-527" aria-hidden="true" tabindex="-1"></a>    <span class="kw">def</span> print_convergence_summary(<span class="va">self</span>, history):</span>
<span id="cb191-528"><a href="#cb191-528" aria-hidden="true" tabindex="-1"></a>        <span class="co">&quot;&quot;&quot;Print convergence summary&quot;&quot;&quot;</span></span>
<span id="cb191-529"><a href="#cb191-529" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="ch">\n</span><span class="sc">{</span><span class="st">&#39;=&#39;</span><span class="op">*</span><span class="dv">60</span><span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-530"><a href="#cb191-530" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;CONVERGENCE SUMMARY - </span><span class="sc">{</span><span class="va">self</span><span class="sc">.</span>domain_type<span class="sc">.</span>upper()<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-531"><a href="#cb191-531" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="sc">{</span><span class="st">&#39;=&#39;</span><span class="op">*</span><span class="dv">60</span><span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-532"><a href="#cb191-532" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;Iter | Cells | DOFs  | λ_1      | λ_2      | λ_3      | Error&quot;</span>)</span>
<span id="cb191-533"><a href="#cb191-533" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;-&quot;</span> <span class="op">*</span> <span class="dv">60</span>)</span>
<span id="cb191-534"><a href="#cb191-534" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-535"><a href="#cb191-535" aria-hidden="true" tabindex="-1"></a>        <span class="cf">for</span> h <span class="kw">in</span> history:</span>
<span id="cb191-536"><a href="#cb191-536" aria-hidden="true" tabindex="-1"></a>            eigenvals <span class="op">=</span> h[<span class="st">&#39;eigenvalues&#39;</span>]</span>
<span id="cb191-537"><a href="#cb191-537" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="sc">{</span>h[<span class="st">&#39;iteration&#39;</span>]<span class="sc">:4d}</span><span class="ss"> | </span><span class="sc">{</span>h[<span class="st">&#39;n_cells&#39;</span>]<span class="sc">:5d}</span><span class="ss"> | </span><span class="sc">{</span>h[<span class="st">&#39;n_dofs&#39;</span>]<span class="sc">:5d}</span><span class="ss"> | &quot;</span></span>
<span id="cb191-538"><a href="#cb191-538" aria-hidden="true" tabindex="-1"></a>                  <span class="ss">f&quot;</span><span class="sc">{</span>eigenvals[<span class="dv">0</span>]<span class="sc">:8.4f}</span><span class="ss"> | </span><span class="sc">{</span>eigenvals[<span class="dv">1</span>]<span class="sc">:8.4f}</span><span class="ss"> | </span><span class="sc">{</span>eigenvals[<span class="dv">2</span>]<span class="sc">:8.4f}</span><span class="ss"> | &quot;</span></span>
<span id="cb191-539"><a href="#cb191-539" aria-hidden="true" tabindex="-1"></a>                  <span class="ss">f&quot;</span><span class="sc">{</span>h[<span class="st">&#39;error_max&#39;</span>]<span class="sc">:8.3e}</span><span class="ss">&quot;</span>)</span>
<span id="cb191-540"><a href="#cb191-540" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb191-541"><a href="#cb191-541" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> history:</span>
<span id="cb191-542"><a href="#cb191-542" aria-hidden="true" tabindex="-1"></a>            final <span class="op">=</span> history[<span class="op">-</span><span class="dv">1</span>][<span class="st">&#39;eigenvalues&#39;</span>]</span>
<span id="cb191-543"><a href="#cb191-543" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="ch">\n</span><span class="ss">Final eigenvalues:&quot;</span>)</span>
<span id="cb191-544"><a href="#cb191-544" aria-hidden="true" tabindex="-1"></a>            <span class="cf">for</span> i, eigenval <span class="kw">in</span> <span class="bu">enumerate</span>(final[:<span class="dv">6</span>]):</span>
<span id="cb191-545"><a href="#cb191-545" aria-hidden="true" tabindex="-1"></a>                <span class="bu">print</span>(<span class="ss">f&quot;  λ_</span><span class="sc">{</span>i<span class="op">+</span><span class="dv">1</span><span class="sc">}</span><span class="ss"> = </span><span class="sc">{</span>eigenval<span class="sc">:.8f}</span><span class="ss">&quot;</span>)</span></code></pre></div>
</div>
<div id="70dd21ae" class="cell" data-execution_count="169">
<div class="sourceCode" id="cb192"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb192-1"><a href="#cb192-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> run_complete_tests():</span>
<span id="cb192-2"><a href="#cb192-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;Run complete test suite with all domains&quot;&quot;&quot;</span></span>
<span id="cb192-3"><a href="#cb192-3" aria-hidden="true" tabindex="-1"></a>    domains <span class="op">=</span> [<span class="st">&quot;unit_square&quot;</span>, <span class="st">&quot;l_shape&quot;</span>, <span class="st">&quot;pacman&quot;</span>]</span>
<span id="cb192-4"><a href="#cb192-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb192-5"><a href="#cb192-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> domain <span class="kw">in</span> domains:</span>
<span id="cb192-6"><a href="#cb192-6" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="ch">\n</span><span class="sc">{</span><span class="st">&#39;=&#39;</span><span class="op">*</span><span class="dv">80</span><span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb192-7"><a href="#cb192-7" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;TESTING </span><span class="sc">{</span>domain<span class="sc">.</span>upper()<span class="sc">}</span><span class="ss"> DOMAIN&quot;</span>)</span>
<span id="cb192-8"><a href="#cb192-8" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="sc">{</span><span class="st">&#39;=&#39;</span><span class="op">*</span><span class="dv">80</span><span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb192-9"><a href="#cb192-9" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb192-10"><a href="#cb192-10" aria-hidden="true" tabindex="-1"></a>        <span class="cf">try</span>:</span>
<span id="cb192-11"><a href="#cb192-11" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create solver</span></span>
<span id="cb192-12"><a href="#cb192-12" aria-hidden="true" tabindex="-1"></a>            solver <span class="op">=</span> AdaptiveLaplaceEigenSolver(domain_type<span class="op">=</span>domain, initial_mesh_size<span class="op">=</span><span class="fl">0.1</span>)</span>
<span id="cb192-13"><a href="#cb192-13" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb192-14"><a href="#cb192-14" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create domain</span></span>
<span id="cb192-15"><a href="#cb192-15" aria-hidden="true" tabindex="-1"></a>            solver.create_domain()</span>
<span id="cb192-16"><a href="#cb192-16" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb192-17"><a href="#cb192-17" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Run adaptive refinement</span></span>
<span id="cb192-18"><a href="#cb192-18" aria-hidden="true" tabindex="-1"></a>            history <span class="op">=</span> solver.adaptive_refinement(</span>
<span id="cb192-19"><a href="#cb192-19" aria-hidden="true" tabindex="-1"></a>                err_estimator<span class="op">=</span><span class="st">&#39;residual&#39;</span>, <span class="co"># or &#39;gradient&#39;</span></span>
<span id="cb192-20"><a href="#cb192-20" aria-hidden="true" tabindex="-1"></a>                n_iterations<span class="op">=</span><span class="dv">4</span>, </span>
<span id="cb192-21"><a href="#cb192-21" aria-hidden="true" tabindex="-1"></a>                refinement_fraction<span class="op">=</span><span class="fl">0.25</span>, </span>
<span id="cb192-22"><a href="#cb192-22" aria-hidden="true" tabindex="-1"></a>                n_eigenvalues<span class="op">=</span><span class="dv">6</span></span>
<span id="cb192-23"><a href="#cb192-23" aria-hidden="true" tabindex="-1"></a>            )</span>
<span id="cb192-24"><a href="#cb192-24" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb192-25"><a href="#cb192-25" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Create visualizations</span></span>
<span id="cb192-26"><a href="#cb192-26" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;</span><span class="ch">\n</span><span class="ss">Creating visualizations for </span><span class="sc">{</span>domain<span class="sc">}</span><span class="ss">...&quot;</span>)</span>
<span id="cb192-27"><a href="#cb192-27" aria-hidden="true" tabindex="-1"></a>            solver.visualize_eigenmodes(max_modes<span class="op">=</span><span class="dv">4</span>)</span>
<span id="cb192-28"><a href="#cb192-28" aria-hidden="true" tabindex="-1"></a>            solver.create_comparison_plot()</span>
<span id="cb192-29"><a href="#cb192-29" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb192-30"><a href="#cb192-30" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;✓ </span><span class="sc">{</span>domain<span class="sc">}</span><span class="ss"> test completed successfully!&quot;</span>)</span>
<span id="cb192-31"><a href="#cb192-31" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb192-32"><a href="#cb192-32" aria-hidden="true" tabindex="-1"></a>        <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb192-33"><a href="#cb192-33" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;✗ </span><span class="sc">{</span>domain<span class="sc">}</span><span class="ss"> test failed: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb192-34"><a href="#cb192-34" aria-hidden="true" tabindex="-1"></a>            <span class="im">import</span> traceback</span>
<span id="cb192-35"><a href="#cb192-35" aria-hidden="true" tabindex="-1"></a>            traceback.print_exc()</span>
<span id="cb192-36"><a href="#cb192-36" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb192-37"><a href="#cb192-37" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="va">__name__</span> <span class="op">==</span> <span class="st">&quot;__main__&quot;</span>:</span>
<span id="cb192-38"><a href="#cb192-38" aria-hidden="true" tabindex="-1"></a>    run_complete_tests()</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>
================================================================================
TESTING UNIT_SQUARE DOMAIN
================================================================================
Initialized solver for unit_square domain
Created unit square: 800 cells

============================================================
ADAPTIVE REFINEMENT for UNIT_SQUARE
============================================================

--- Iteration 1/4 ---
Mesh: 800 cells, DOFs: 441
λ_1 = 19.861105
λ_2 = 49.871661
λ_3 = 50.168029
Refining 200 cells (threshold: 0.003)

--- Iteration 2/4 ---
Mesh: 1377 cells, DOFs: 733
λ_1 = 19.830708
λ_2 = 49.802740
λ_3 = 49.881808
Refining 344 cells (threshold: 0.002)

--- Iteration 3/4 ---
Mesh: 2452 cells, DOFs: 1281
λ_1 = 19.810581
λ_2 = 49.696385
λ_3 = 49.793126
Refining 613 cells (threshold: 0.001)

--- Iteration 4/4 ---
Mesh: 4385 cells, DOFs: 2268
λ_1 = 19.770349
λ_2 = 49.537673
λ_3 = 49.561696
Refining 1096 cells (threshold: 0.000)

============================================================
CONVERGENCE SUMMARY - UNIT_SQUARE
============================================================
Iter | Cells | DOFs  | λ_1      | λ_2      | λ_3      | Error
------------------------------------------------------------
   1 |   800 |   441 |  19.8611 |  49.8717 |  50.1680 | 5.218e-03
   2 |  1377 |   733 |  19.8307 |  49.8027 |  49.8818 | 3.736e-03
   3 |  2452 |  1281 |  19.8106 |  49.6964 |  49.7931 | 2.560e-03
   4 |  4385 |  2268 |  19.7703 |  49.5377 |  49.5617 | 1.934e-03

Final eigenvalues:
  λ_1 = 19.77034867
  λ_2 = 49.53767254
  λ_3 = 49.56169589
  λ_4 = 79.47168019
  λ_5 = 99.49882125
  λ_6 = 99.52280091

Creating visualizations for unit_square...

Creating visualizations for 6 eigenmodes...
✓ Saved visualizations for mode 1
✓ Saved visualizations for mode 2
✓ Saved visualizations for mode 3
✓ Saved visualizations for mode 4
✓ Saved comparison plot: fenicsx/adaptive_mesh_refinement/unit_square_comparison.png
✓ unit_square test completed successfully!

================================================================================
TESTING L_SHAPE DOMAIN
================================================================================
Initialized solver for l_shape domain
Info    : [  0%] Union                                                                                  Info    : [ 10%] Union                                                                                  Info    : [ 20%] Union                                                                                  Info    : [ 30%] Union                                                                                  Info    : [ 40%] Union                                                                                  Info    : [ 50%] Union                                                                                  Info    : [ 60%] Union                                                                                  Info    : [ 70%] Union                                                                                  Info    : [ 80%] Union - Splitting faces                                                                                                                                                                Info    : Cannot bind existing OpenCASCADE surface 1 to second tag 2
Info    : Could not preserve tag of 2D object 2 (-&gt;1)
Info    : [  0%] Union                                                                                  Info    : [ 10%] Union                                                                                  Info    : [ 20%] Union - Performing Vertex-Face intersection                                                                                Info    : [ 30%] Union                                                                                  Info    : [ 40%] Union                                                                                  Info    : [ 50%] Union                                                                                  Info    : [ 60%] Union                                                                                  Info    : [ 70%] Union - Filling splits of vertices                                                                                Info    : [ 80%] Union - Splitting faces                                                                                                                                                                Info    : Cannot bind existing OpenCASCADE surface 1 to second tag 3
Info    : Could not preserve tag of 2D object 3 (-&gt;1)
Info    : Meshing 1D...
Info    : [  0%] Meshing curve 10 (Line)
Info    : [ 20%] Meshing curve 11 (Line)
Info    : [ 40%] Meshing curve 12 (TrimmedCurve)
Info    : [ 60%] Meshing curve 13 (TrimmedCurve)
Info    : [ 70%] Meshing curve 14 (Line)
Info    : [ 90%] Meshing curve 15 (TrimmedCurve)
Info    : Done meshing 1D (Wall 0.000543167s, CPU 0.000924s)
Info    : Meshing 2D...
Info    : Meshing surface 1 (Plane, Frontal-Delaunay)
Info    : Done meshing 2D (Wall 0.00316362s, CPU 0.005319s)
Info    : 117 nodes 238 elements
Created L-shape: 192 cells

============================================================
ADAPTIVE REFINEMENT for L_SHAPE
============================================================

--- Iteration 1/4 ---
Mesh: 192 cells, DOFs: 117
λ_1 = 10.060838
λ_2 = 15.710424
λ_3 = 20.658319
Refining 48 cells (threshold: 0.038)

--- Iteration 2/4 ---
Mesh: 327 cells, DOFs: 187
λ_1 = 9.981471
λ_2 = 15.611212
λ_3 = 20.499806
Refining 82 cells (threshold: 0.016)

--- Iteration 3/4 ---
Mesh: 580 cells, DOFs: 317
λ_1 = 9.957306
λ_2 = 15.576428
λ_3 = 20.428195
Refining 145 cells (threshold: 0.007)

--- Iteration 4/4 ---
Mesh: 1069 cells, DOFs: 575
λ_1 = 9.897279
λ_2 = 15.461876
λ_3 = 20.171329
Refining 267 cells (threshold: 0.003)

============================================================
CONVERGENCE SUMMARY - L_SHAPE
============================================================
Iter | Cells | DOFs  | λ_1      | λ_2      | λ_3      | Error
------------------------------------------------------------
   1 |   192 |   117 |  10.0608 |  15.7104 |  20.6583 | 8.393e-02
   2 |   327 |   187 |   9.9815 |  15.6112 |  20.4998 | 6.263e-02
   3 |   580 |   317 |   9.9573 |  15.5764 |  20.4282 | 4.397e-02
   4 |  1069 |   575 |   9.8973 |  15.4619 |  20.1713 | 3.239e-02

Final eigenvalues:
  λ_1 = 9.89727924
  λ_2 = 15.46187553
  λ_3 = 20.17132861
  λ_4 = 30.51937004
  λ_5 = 33.34623296

Creating visualizations for l_shape...

Creating visualizations for 5 eigenmodes...
✓ Saved visualizations for mode 1
✓ Saved visualizations for mode 2
✓ Saved visualizations for mode 3
✓ Saved visualizations for mode 4
✓ Saved comparison plot: fenicsx/adaptive_mesh_refinement/l_shape_comparison.png
✓ l_shape test completed successfully!

================================================================================
TESTING PACMAN DOMAIN
================================================================================
Initialized solver for pacman domain
Info    : [  0%] Difference                                                                                  Info    : [ 10%] Difference                                                                                  Info    : [ 20%] Difference                                                                                  Info    : [ 30%] Difference                                                                                  Info    : [ 40%] Difference                                                                                  Info    : [ 50%] Difference                                                                                  Info    : [ 70%] Difference - Filling splits of edges                                                                                Info    : [ 80%] Difference                                                                                  Info    : [ 90%] Difference                                                                                  Info    : Meshing 1D...
Info    : [  0%] Meshing curve 1 (Line)
Info    : [ 40%] Meshing curve 2 (Line)
Info    : [ 70%] Meshing curve 3 (Ellipse)
Info    : Done meshing 1D (Wall 0.000257916s, CPU 0.000447s)
Info    : Meshing 2D...
Info    : Meshing surface 1 (Plane, Frontal-Delaunay)
Info    : Done meshing 2D (Wall 0.00243879s, CPU 0.003967s)
Info    : 106 nodes 213 elements
Created Pac-Man: 173 cells

============================================================
ADAPTIVE REFINEMENT for PACMAN
============================================================

--- Iteration 1/4 ---
Mesh: 173 cells, DOFs: 106
λ_1 = 11.443015
λ_2 = 17.443094
λ_3 = 25.203978
Refining 43 cells (threshold: 0.045)

--- Iteration 2/4 ---
Mesh: 309 cells, DOFs: 178
λ_1 = 11.210718
λ_2 = 17.344920
λ_3 = 24.855278
Refining 77 cells (threshold: 0.018)

--- Iteration 3/4 ---
Mesh: 548 cells, DOFs: 301
λ_1 = 11.145025
λ_2 = 17.288168
λ_3 = 24.746407
Refining 137 cells (threshold: 0.006)

--- Iteration 4/4 ---
Mesh: 955 cells, DOFs: 507
λ_1 = 11.075163
λ_2 = 17.260539
λ_3 = 24.691399
Refining 239 cells (threshold: 0.002)

============================================================
CONVERGENCE SUMMARY - PACMAN
============================================================
Iter | Cells | DOFs  | λ_1      | λ_2      | λ_3      | Error
------------------------------------------------------------
   1 |   173 |   106 |  11.4430 |  17.4431 |  25.2040 | 1.105e-01
   2 |   309 |   178 |  11.2107 |  17.3449 |  24.8553 | 4.971e-02
   3 |   548 |   301 |  11.1450 |  17.2882 |  24.7464 | 3.649e-02
   4 |   955 |   507 |  11.0752 |  17.2605 |  24.6914 | 2.538e-02

Final eigenvalues:
  λ_1 = 11.07516308
  λ_2 = 17.26053949
  λ_3 = 24.69139857
  λ_4 = 33.42244310
  λ_5 = 43.31722488
  λ_6 = 44.00755407

Creating visualizations for pacman...

Creating visualizations for 6 eigenmodes...
✓ Saved visualizations for mode 1
✓ Saved visualizations for mode 2
✓ Saved visualizations for mode 3
✓ Saved visualizations for mode 4
✓ Saved comparison plot: fenicsx/adaptive_mesh_refinement/pacman_comparison.png
✓ pacman test completed successfully!</code></pre>
</div>
</div>
<p><img src="fenicsx/adaptive_mesh_refinement/unit_square_comparison.png" class="img-fluid" /></p>
<iframe src="fenicsx/adaptive_mesh_refinement/unit_square_mode_1.html"
        width="100%" height="400px"
        style="border:none;">
</iframe>
<p><img src="fenicsx/adaptive_mesh_refinement/l_shape_comparison.png" class="img-fluid" /></p>
<iframe src="fenicsx/adaptive_mesh_refinement/l_shape_mode_1.html"
        width="100%" height="400px"
        style="border:none;">
</iframe>
<p><img src="fenicsx/adaptive_mesh_refinement/pacman_comparison.png" class="img-fluid" /></p>
<iframe src="fenicsx/adaptive_mesh_refinement/pacman_mode_1.html"
        width="100%" height="400px"
        style="border:none;">
</iframe>
</section>
</section>
</section>
<section id="subdomains-and-boundary-conditions" class="level2" data-number="K.8">
<h2 data-number="K.8"><span class="header-section-number">K.8</span> Subdomains and boundary conditions</h2>
<section id="combining-dirichlet-and-neumann-conditions" class="level3" data-number="K.8.1">
<h3 data-number="K.8.1"><span class="header-section-number">K.8.1</span> Combining Dirichlet and Neumann conditions</h3>
<p>Author: Jørgen S. Dokken</p>
<p>Let us return to the Poisson problem and explore how to extend both the mathematical formulation and the implementation to handle a Dirichlet condition in combination with a Neumann condition. The domain is still the unit square, but this time we impose the Dirichlet condition <code>u = u_D</code> on the left and right boundaries, while the Neumann condition</p>
<p><span class="math display">\[-\frac{\partial u}{\partial n} = g\]</span></p>
<p>is applied to the remaining boundaries, <span class="math inline">\(y = 0\)</span> and <span class="math inline">\(y = 1\)</span></p>
<p><strong>The PDE problem</strong></p>
<p>Let <span class="math inline">\(\Lambda_D\)</span> and <span class="math inline">\(\Lambda_N\)</span> denote the portions of the boundary <span class="math inline">\(\partial \Omega\)</span> where the Dirichlet and Neumann conditions are prescribed, respectively. The full boundary-value problem is then given by</p>
<p><span class="math display">\[
\begin{aligned}
-\nabla^2 u &amp;= f \quad \text{in } \Omega \\
u &amp;= u_D \quad \text{on } \Lambda_D \\
-\frac{\partial u}{\partial n} &amp;= g \quad \text{on } \Lambda_N
\end{aligned}
\]</span></p>
<p>As before, we choose <span class="math inline">\(u = 1 + x^2 + 2y^2\)</span> as the exact solution and then set <span class="math inline">\(f\)</span>, <span class="math inline">\(g\)</span>, and <span class="math inline">\(u_D\)</span> to match this choice</p>
<p><span class="math display">\[
\begin{aligned}
    f(x,y) &amp;=-6 \\
    u_D(x,y) &amp;=1+x^2+2y^2 \\
    g(x,y) &amp;=
    \begin{cases}
        \phantom{-}0, &amp; y=0\\
        -4, &amp; y=1
    \end{cases}
\end{aligned}
\]</span></p>
<p>To simplify the implementation, we define <span class="math inline">\(g\)</span> as a function over the whole domain <span class="math inline">\(\Omega\)</span>, making sure it has the correct values at <span class="math inline">\(y=0\)</span> and <span class="math inline">\(y=1\)</span>. One possible choice is</p>
<p><span class="math display">\[
g(x,y)=-4y
\]</span></p>
<p><strong>The variational formulation</strong></p>
<p>The first step is to derive the variational formulation. In this case, the boundary term resulting from integration by parts cannot be omitted, since <span class="math inline">\(v\)</span> vanishes only on <span class="math inline">\(\Lambda_D\)</span>. We obtain</p>
<p><span class="math display">\[-\int_\Omega (\nabla^2 u)\, v \,\mathrm{d}x \;=\; \int_\Omega \nabla u \cdot \nabla v \,\mathrm{d}x \;-\; \int_{\partial \Omega}\frac{\partial u}{\partial n} v \,\mathrm{d}s\]</span></p>
<p>and because <span class="math inline">\(v=0\)</span> on <span class="math inline">\(\Lambda_D\)</span>, it follows that</p>
<p><span class="math display">\[-\int_{\partial \Omega}\frac{\partial u}{\partial n} v \,\mathrm{d}s \;=\; - \int_{\Lambda_N}\frac{\partial u}{\partial n} v \,\mathrm{d}s \;=\; \int_{\Lambda_N} g v \,\mathrm{d}s\]</span></p>
<p>by applying the boundary condition on <span class="math inline">\(\Lambda_N\)</span>. The resulting weak form is therefore</p>
<p><span class="math display">\[\int_\Omega \nabla u \cdot \nabla v \,\mathrm{d}x \;=\; \int_\Omega f v \,\mathrm{d}x \;-\; \int_{\Lambda_N} g v \,\mathrm{d}s\]</span></p>
<p>Expressing this equation in the standard notation <span class="math inline">\(a(u,v) = L(v)\)</span>, we have</p>
<p><span class="math display">\[\begin{aligned}
a(u,v) &amp;= \int_\Omega \nabla u \cdot \nabla v \,\mathrm{d}x \\
L(v) &amp;= \int_\Omega f v \,\mathrm{d}x \;-\; \int_{\Lambda_N} g v \,\mathrm{d}s
\end{aligned}\]</span></p>
<p><strong>Implementation</strong></p>
<p>As in the previous example, we start by defining the mesh, the function space, and the bilinear form <span class="math inline">\(a(u,v)\)</span></p>
<div id="9efd4007" class="cell" data-execution_count="170">
<div class="sourceCode" id="cb194"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb194-1"><a href="#cb194-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb194-2"><a href="#cb194-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-3"><a href="#cb194-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb194-4"><a href="#cb194-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb194-5"><a href="#cb194-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-6"><a href="#cb194-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> default_scalar_type</span>
<span id="cb194-7"><a href="#cb194-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem <span class="im">import</span> (Constant, Function, functionspace,</span>
<span id="cb194-8"><a href="#cb194-8" aria-hidden="true" tabindex="-1"></a>  assemble_scalar, dirichletbc, form, locate_dofs_geometrical)</span>
<span id="cb194-9"><a href="#cb194-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> LinearProblem</span>
<span id="cb194-10"><a href="#cb194-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.mesh <span class="im">import</span> create_unit_square</span>
<span id="cb194-11"><a href="#cb194-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.plot <span class="im">import</span> vtk_mesh</span>
<span id="cb194-12"><a href="#cb194-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-13"><a href="#cb194-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ufl <span class="im">import</span> SpatialCoordinate, TestFunction, TrialFunction, dot, ds, dx, grad</span>
<span id="cb194-14"><a href="#cb194-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-15"><a href="#cb194-15" aria-hidden="true" tabindex="-1"></a>mesh <span class="op">=</span> create_unit_square(MPI.COMM_WORLD, <span class="dv">10</span>, <span class="dv">10</span>)</span>
<span id="cb194-16"><a href="#cb194-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-17"><a href="#cb194-17" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span>
<span id="cb194-18"><a href="#cb194-18" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> TrialFunction(V)</span>
<span id="cb194-19"><a href="#cb194-19" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> TestFunction(V)</span>
<span id="cb194-20"><a href="#cb194-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb194-21"><a href="#cb194-21" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> dot(grad(u), grad(v)) <span class="op">*</span>dx</span></code></pre></div>
</div>
<p>Now we turn to the Neumann and Dirichlet boundary conditions. As before, we use a Python function to mark the part of the boundary where the Dirichlet condition should apply. With this function, we can then identify the corresponding degrees of freedom that satisfy the condition</p>
<div id="34cb50b3" class="cell" data-execution_count="171">
<div class="sourceCode" id="cb195"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb195-1"><a href="#cb195-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> u_exact(x):</span>
<span id="cb195-2"><a href="#cb195-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span>x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span><span class="dv">2</span> <span class="op">*</span>x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span></span>
<span id="cb195-3"><a href="#cb195-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-4"><a href="#cb195-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> boundary_D(x):</span>
<span id="cb195-5"><a href="#cb195-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> np.logical_or(np.isclose(x[<span class="dv">0</span>], <span class="dv">0</span>), np.isclose(x[<span class="dv">0</span>], <span class="dv">1</span>))</span>
<span id="cb195-6"><a href="#cb195-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-7"><a href="#cb195-7" aria-hidden="true" tabindex="-1"></a>dofs_D <span class="op">=</span> locate_dofs_geometrical(V, boundary_D)</span>
<span id="cb195-8"><a href="#cb195-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb195-9"><a href="#cb195-9" aria-hidden="true" tabindex="-1"></a>u_bc <span class="op">=</span> Function(V)</span>
<span id="cb195-10"><a href="#cb195-10" aria-hidden="true" tabindex="-1"></a>u_bc.interpolate(u_exact)</span>
<span id="cb195-11"><a href="#cb195-11" aria-hidden="true" tabindex="-1"></a>bc <span class="op">=</span> dirichletbc(u_bc, dofs_D)</span></code></pre></div>
</div>
<p>The next step is to define the Neumann condition. We begin by defining <span class="math inline">\(g\)</span> using <code>UFL</code>’s <code>SpatialCoordinate</code> function, and then create a boundary integration measure <code>ds</code>. Since the test function <span class="math inline">\(v\)</span> vanishes on the Dirichlet boundary, the corresponding integrals drop out. This allows us to simply integrate <code>g *v *ds</code> over the entire boundary</p>
<div id="a5b30259" class="cell" data-execution_count="172">
<div class="sourceCode" id="cb196"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb196-1"><a href="#cb196-1" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> Constant(mesh, default_scalar_type(<span class="op">-</span><span class="dv">6</span>))</span>
<span id="cb196-2"><a href="#cb196-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-3"><a href="#cb196-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> SpatialCoordinate(mesh)</span>
<span id="cb196-4"><a href="#cb196-4" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> <span class="op">-</span><span class="dv">4</span> <span class="op">*</span>x[<span class="dv">1</span>]</span>
<span id="cb196-5"><a href="#cb196-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb196-6"><a href="#cb196-6" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> f <span class="op">*</span>v <span class="op">*</span>dx <span class="op">-</span>g <span class="op">*</span>v <span class="op">*</span>ds</span></code></pre></div>
</div>
<p>At this stage, we are ready to assemble the linear system and solve it</p>
<div id="99fef43e" class="cell" data-execution_count="173">
<div class="sourceCode" id="cb197"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb197-1"><a href="#cb197-1" aria-hidden="true" tabindex="-1"></a>problem <span class="op">=</span> LinearProblem(</span>
<span id="cb197-2"><a href="#cb197-2" aria-hidden="true" tabindex="-1"></a>    a, </span>
<span id="cb197-3"><a href="#cb197-3" aria-hidden="true" tabindex="-1"></a>    L, </span>
<span id="cb197-4"><a href="#cb197-4" aria-hidden="true" tabindex="-1"></a>    bcs<span class="op">=</span>[bc], </span>
<span id="cb197-5"><a href="#cb197-5" aria-hidden="true" tabindex="-1"></a>    petsc_options<span class="op">=</span>{</span>
<span id="cb197-6"><a href="#cb197-6" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;preonly&quot;</span>, </span>
<span id="cb197-7"><a href="#cb197-7" aria-hidden="true" tabindex="-1"></a>        <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;lu&quot;</span>}</span>
<span id="cb197-8"><a href="#cb197-8" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb197-9"><a href="#cb197-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-10"><a href="#cb197-10" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> problem.solve()</span>
<span id="cb197-11"><a href="#cb197-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-12"><a href="#cb197-12" aria-hidden="true" tabindex="-1"></a>V2 <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">2</span>))</span>
<span id="cb197-13"><a href="#cb197-13" aria-hidden="true" tabindex="-1"></a>uex <span class="op">=</span> Function(V2)</span>
<span id="cb197-14"><a href="#cb197-14" aria-hidden="true" tabindex="-1"></a>uex.interpolate(u_exact)</span>
<span id="cb197-15"><a href="#cb197-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-16"><a href="#cb197-16" aria-hidden="true" tabindex="-1"></a>error_L2 <span class="op">=</span> assemble_scalar(form((uh <span class="op">-</span>uex)<span class="op">**</span><span class="dv">2</span> <span class="op">*</span>dx))</span>
<span id="cb197-17"><a href="#cb197-17" aria-hidden="true" tabindex="-1"></a>error_L2 <span class="op">=</span> np.sqrt(MPI.COMM_WORLD.allreduce(error_L2, op<span class="op">=</span>MPI.SUM))</span>
<span id="cb197-18"><a href="#cb197-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-19"><a href="#cb197-19" aria-hidden="true" tabindex="-1"></a>u_vertex_values <span class="op">=</span> uh.x.array</span>
<span id="cb197-20"><a href="#cb197-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-21"><a href="#cb197-21" aria-hidden="true" tabindex="-1"></a>uex_1 <span class="op">=</span> Function(V)</span>
<span id="cb197-22"><a href="#cb197-22" aria-hidden="true" tabindex="-1"></a>uex_1.interpolate(uex)</span>
<span id="cb197-23"><a href="#cb197-23" aria-hidden="true" tabindex="-1"></a>u_ex_vertex_values <span class="op">=</span> uex_1.x.array</span>
<span id="cb197-24"><a href="#cb197-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-25"><a href="#cb197-25" aria-hidden="true" tabindex="-1"></a>error_max <span class="op">=</span> np.<span class="bu">max</span>(np.<span class="bu">abs</span>(u_vertex_values <span class="op">-</span>u_ex_vertex_values))</span>
<span id="cb197-26"><a href="#cb197-26" aria-hidden="true" tabindex="-1"></a>error_max <span class="op">=</span> MPI.COMM_WORLD.allreduce(error_max, op<span class="op">=</span>MPI.MAX)</span>
<span id="cb197-27"><a href="#cb197-27" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb197-28"><a href="#cb197-28" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Error_L2 : </span><span class="sc">{</span>error_L2<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span>
<span id="cb197-29"><a href="#cb197-29" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Error_max : </span><span class="sc">{</span>error_max<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Error_L2 : 5.27e-03
Error_max : 1.78e-15</code></pre>
</div>
</div>
<p><strong>Visualization</strong></p>
<p>To visualize the solution, run the code either as a Python script with <code>off_screen=True</code>, or inside a Jupyter notebook with <code>off_screen=False</code></p>
<div id="89efaa53" class="cell" data-execution_count="174">
<div class="sourceCode" id="cb199"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb199-1"><a href="#cb199-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb199-2"><a href="#cb199-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-3"><a href="#cb199-3" aria-hidden="true" tabindex="-1"></a>results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/bcs_subdomains&quot;</span>)</span>
<span id="cb199-4"><a href="#cb199-4" aria-hidden="true" tabindex="-1"></a>results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb199-5"><a href="#cb199-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-6"><a href="#cb199-6" aria-hidden="true" tabindex="-1"></a>pyvista_cells, cell_types, geometry <span class="op">=</span> vtk_mesh(V)</span>
<span id="cb199-7"><a href="#cb199-7" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> pyvista.UnstructuredGrid(pyvista_cells, cell_types, geometry)</span>
<span id="cb199-8"><a href="#cb199-8" aria-hidden="true" tabindex="-1"></a>grid.point_data[<span class="st">&quot;u&quot;</span>] <span class="op">=</span> uh.x.array</span>
<span id="cb199-9"><a href="#cb199-9" aria-hidden="true" tabindex="-1"></a>grid.set_active_scalars(<span class="st">&quot;u&quot;</span>)</span>
<span id="cb199-10"><a href="#cb199-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-11"><a href="#cb199-11" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb199-12"><a href="#cb199-12" aria-hidden="true" tabindex="-1"></a>plotter.add_text(<span class="st">&quot;uh&quot;</span>, position<span class="op">=</span><span class="st">&quot;upper_edge&quot;</span>, font_size<span class="op">=</span><span class="dv">14</span>, color<span class="op">=</span><span class="st">&quot;black&quot;</span>)</span>
<span id="cb199-13"><a href="#cb199-13" aria-hidden="true" tabindex="-1"></a>plotter.add_mesh(grid, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb199-14"><a href="#cb199-14" aria-hidden="true" tabindex="-1"></a>plotter.view_xy()</span>
<span id="cb199-15"><a href="#cb199-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb199-16"><a href="#cb199-16" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> pyvista.OFF_SCREEN:</span>
<span id="cb199-17"><a href="#cb199-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">#plotter.show()</span></span>
<span id="cb199-18"><a href="#cb199-18" aria-hidden="true" tabindex="-1"></a>    plotter.export_html(results_folder<span class="op">/</span><span class="st">&quot;neumann_dirichlet.html&quot;</span>)</span>
<span id="cb199-19"><a href="#cb199-19" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb199-20"><a href="#cb199-20" aria-hidden="true" tabindex="-1"></a>    figure <span class="op">=</span> plotter.screenshot(results_folder<span class="op">/</span><span class="st">&quot;neumann_dirichlet.png&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/bcs_subdomains/neumann_dirichlet.html"
        width="100%" height="400px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
</section>
<section id="setting-multiple-dirichlet-condition" class="level3" data-number="K.8.2">
<h3 data-number="K.8.2"><span class="header-section-number">K.8.2</span> Setting multiple Dirichlet condition</h3>
<p>In the previous section, we applied the same Dirichlet condition to both the left and right boundaries using a single function. While this works, it is often more flexible to define separate boundary conditions for each side</p>
<p>Let us consider a similar setup to the earlier example, but this time with distinct Dirichlet conditions on the left and right boundaries:</p>
<p><span class="math display">\[
\begin{aligned}
-\nabla^2 u &amp;= f \quad &amp;&amp;\text{in } \Omega \\
u &amp;= u_L \quad &amp;&amp;\text{on } \Lambda_D^L \\
u &amp;= u_R \quad &amp;&amp;\text{on } \Lambda_D^R \\
-\frac{\partial u}{\partial n} &amp;= g \quad &amp;&amp;\text{on } \Lambda_N
\end{aligned}
\]</span></p>
<p>Here, <span class="math inline">\(\Lambda_D^L\)</span> represents the left boundary (<span class="math inline">\(x=0\)</span>), and <span class="math inline">\(\Lambda_D^R\)</span> represents the right boundary (<span class="math inline">\(x=1\)</span>)</p>
<p>For this example, we choose</p>
<ul>
<li><p><span class="math inline">\(u_L(y) = 1 + 2y^2\)</span></p></li>
<li><p><span class="math inline">\(u_R(y) = 2 + 2y^2\)</span></p></li>
<li><p><span class="math inline">\(g(y) = -4y\)</span></p></li>
</ul>
<p>in line with the analytical solution introduced earlier</p>
<p>As before, we begin by defining the mesh, the function space, and the variational formulation</p>
<div id="4470a170" class="cell" data-execution_count="175">
<div class="sourceCode" id="cb200"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb200-1"><a href="#cb200-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb200-2"><a href="#cb200-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb200-3"><a href="#cb200-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb200-4"><a href="#cb200-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-5"><a href="#cb200-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> default_scalar_type</span>
<span id="cb200-6"><a href="#cb200-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem <span class="im">import</span> (</span>
<span id="cb200-7"><a href="#cb200-7" aria-hidden="true" tabindex="-1"></a>  Constant, Function, functionspace,</span>
<span id="cb200-8"><a href="#cb200-8" aria-hidden="true" tabindex="-1"></a>  assemble_scalar, dirichletbc, </span>
<span id="cb200-9"><a href="#cb200-9" aria-hidden="true" tabindex="-1"></a>  form, locate_dofs_geometrical</span>
<span id="cb200-10"><a href="#cb200-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb200-11"><a href="#cb200-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> LinearProblem</span>
<span id="cb200-12"><a href="#cb200-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.mesh <span class="im">import</span> create_unit_square</span>
<span id="cb200-13"><a href="#cb200-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.plot <span class="im">import</span> vtk_mesh</span>
<span id="cb200-14"><a href="#cb200-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-15"><a href="#cb200-15" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ufl <span class="im">import</span> (</span>
<span id="cb200-16"><a href="#cb200-16" aria-hidden="true" tabindex="-1"></a>  SpatialCoordinate, </span>
<span id="cb200-17"><a href="#cb200-17" aria-hidden="true" tabindex="-1"></a>  TrialFunction, TestFunction, </span>
<span id="cb200-18"><a href="#cb200-18" aria-hidden="true" tabindex="-1"></a>  dot, dx, ds, grad</span>
<span id="cb200-19"><a href="#cb200-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb200-20"><a href="#cb200-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-21"><a href="#cb200-21" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> u_exact(x):</span>
<span id="cb200-22"><a href="#cb200-22" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span>x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span><span class="dv">2</span> <span class="op">*</span>x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span></span>
<span id="cb200-23"><a href="#cb200-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-24"><a href="#cb200-24" aria-hidden="true" tabindex="-1"></a>mesh <span class="op">=</span> create_unit_square(MPI.COMM_WORLD, <span class="dv">10</span>, <span class="dv">10</span>)</span>
<span id="cb200-25"><a href="#cb200-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-26"><a href="#cb200-26" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span>
<span id="cb200-27"><a href="#cb200-27" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> TrialFunction(V)</span>
<span id="cb200-28"><a href="#cb200-28" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> TestFunction(V)</span>
<span id="cb200-29"><a href="#cb200-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-30"><a href="#cb200-30" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> dot(grad(u), grad(v)) <span class="op">*</span>dx</span>
<span id="cb200-31"><a href="#cb200-31" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb200-32"><a href="#cb200-32" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> SpatialCoordinate(mesh)</span>
<span id="cb200-33"><a href="#cb200-33" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> Constant(mesh, default_scalar_type(<span class="op">-</span><span class="dv">6</span>))</span>
<span id="cb200-34"><a href="#cb200-34" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> <span class="op">-</span> <span class="dv">4</span> <span class="op">*</span>x[<span class="dv">1</span>]</span>
<span id="cb200-35"><a href="#cb200-35" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> f <span class="op">*</span>v <span class="op">*</span>dx <span class="op">-</span>g <span class="op">*</span>v <span class="op">*</span>ds</span></code></pre></div>
</div>
<p>Our next step is to mark the two boundaries individually, beginning with the left boundary</p>
<div id="a4f028c4" class="cell" data-execution_count="176">
<div class="sourceCode" id="cb201"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb201-1"><a href="#cb201-1" aria-hidden="true" tabindex="-1"></a>dofs_L <span class="op">=</span> locate_dofs_geometrical(V, <span class="kw">lambda</span> x: np.isclose(x[<span class="dv">0</span>], <span class="dv">0</span>))</span>
<span id="cb201-2"><a href="#cb201-2" aria-hidden="true" tabindex="-1"></a>u_L <span class="op">=</span> Function(V)</span>
<span id="cb201-3"><a href="#cb201-3" aria-hidden="true" tabindex="-1"></a>u_L.interpolate(<span class="kw">lambda</span> x: <span class="dv">1</span> <span class="op">+</span><span class="dv">2</span> <span class="op">*</span>x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb201-4"><a href="#cb201-4" aria-hidden="true" tabindex="-1"></a>bc_L <span class="op">=</span> dirichletbc(u_L, dofs_L)</span></code></pre></div>
</div>
<p>Note that we have used <code>lambda</code> functions to compactly define the functions that evaluate the subdomain and the solution. We can use a similar procedure for the right boundary condition, and collect both boundary conditions in the list <code>bcs</code></p>
<div id="d6286051" class="cell" data-execution_count="177">
<div class="sourceCode" id="cb202"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb202-1"><a href="#cb202-1" aria-hidden="true" tabindex="-1"></a>dofs_R <span class="op">=</span> locate_dofs_geometrical(V, <span class="kw">lambda</span> x: np.isclose(x[<span class="dv">0</span>], <span class="dv">1</span>))</span>
<span id="cb202-2"><a href="#cb202-2" aria-hidden="true" tabindex="-1"></a>u_R <span class="op">=</span> Function(V)</span>
<span id="cb202-3"><a href="#cb202-3" aria-hidden="true" tabindex="-1"></a>u_R.interpolate(<span class="kw">lambda</span> x: <span class="dv">2</span> <span class="op">+</span><span class="dv">2</span> <span class="op">*</span>x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb202-4"><a href="#cb202-4" aria-hidden="true" tabindex="-1"></a>bc_R <span class="op">=</span> dirichletbc(u_R, dofs_R)</span>
<span id="cb202-5"><a href="#cb202-5" aria-hidden="true" tabindex="-1"></a>bcs <span class="op">=</span> [bc_R, bc_L]</span></code></pre></div>
</div>
<p>We are now ready to solve the problem once more and evaluate both the <span class="math inline">\(L^2\)</span> error and the maximum error at the mesh vertices</p>
<div id="fdcb8e51" class="cell" data-execution_count="178">
<div class="sourceCode" id="cb203"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb203-1"><a href="#cb203-1" aria-hidden="true" tabindex="-1"></a>problem <span class="op">=</span> LinearProblem(</span>
<span id="cb203-2"><a href="#cb203-2" aria-hidden="true" tabindex="-1"></a>  a, </span>
<span id="cb203-3"><a href="#cb203-3" aria-hidden="true" tabindex="-1"></a>  L, </span>
<span id="cb203-4"><a href="#cb203-4" aria-hidden="true" tabindex="-1"></a>  bcs<span class="op">=</span>bcs, </span>
<span id="cb203-5"><a href="#cb203-5" aria-hidden="true" tabindex="-1"></a>  petsc_options<span class="op">=</span>{<span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;preonly&quot;</span>, <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;lu&quot;</span>}</span>
<span id="cb203-6"><a href="#cb203-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb203-7"><a href="#cb203-7" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> problem.solve()</span>
<span id="cb203-8"><a href="#cb203-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-9"><a href="#cb203-9" aria-hidden="true" tabindex="-1"></a>V2 <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">2</span>))</span>
<span id="cb203-10"><a href="#cb203-10" aria-hidden="true" tabindex="-1"></a>uex <span class="op">=</span> Function(V2)</span>
<span id="cb203-11"><a href="#cb203-11" aria-hidden="true" tabindex="-1"></a>uex.interpolate(u_exact)</span>
<span id="cb203-12"><a href="#cb203-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-13"><a href="#cb203-13" aria-hidden="true" tabindex="-1"></a>error_L2 <span class="op">=</span> assemble_scalar(form((uh <span class="op">-</span>uex)<span class="op">**</span><span class="dv">2</span> <span class="op">*</span>dx))</span>
<span id="cb203-14"><a href="#cb203-14" aria-hidden="true" tabindex="-1"></a>error_L2 <span class="op">=</span> np.sqrt(MPI.COMM_WORLD.allreduce(error_L2, op<span class="op">=</span>MPI.SUM))</span>
<span id="cb203-15"><a href="#cb203-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-16"><a href="#cb203-16" aria-hidden="true" tabindex="-1"></a>u_vertex_values <span class="op">=</span> uh.x.array</span>
<span id="cb203-17"><a href="#cb203-17" aria-hidden="true" tabindex="-1"></a>uex_1 <span class="op">=</span> Function(V)</span>
<span id="cb203-18"><a href="#cb203-18" aria-hidden="true" tabindex="-1"></a>uex_1.interpolate(uex)</span>
<span id="cb203-19"><a href="#cb203-19" aria-hidden="true" tabindex="-1"></a>u_ex_vertex_values <span class="op">=</span> uex_1.x.array</span>
<span id="cb203-20"><a href="#cb203-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-21"><a href="#cb203-21" aria-hidden="true" tabindex="-1"></a>error_max <span class="op">=</span> np.<span class="bu">max</span>(np.<span class="bu">abs</span>(u_vertex_values <span class="op">-</span>u_ex_vertex_values))</span>
<span id="cb203-22"><a href="#cb203-22" aria-hidden="true" tabindex="-1"></a>error_max <span class="op">=</span> MPI.COMM_WORLD.allreduce(error_max, op<span class="op">=</span>MPI.MAX)</span>
<span id="cb203-23"><a href="#cb203-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb203-24"><a href="#cb203-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Error_L2 : </span><span class="sc">{</span>error_L2<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span>
<span id="cb203-25"><a href="#cb203-25" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Error_max : </span><span class="sc">{</span>error_max<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Error_L2 : 5.27e-03
Error_max : 2.22e-15</code></pre>
</div>
</div>
<p><strong>Visualization</strong></p>
<p>To visualize the solution, run the code either as a Python script with <code>off_screen=True</code>, or inside a Jupyter notebook with <code>off_screen=False</code></p>
<div id="bff542c4" class="cell" data-execution_count="179">
<div class="sourceCode" id="cb205"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb205-1"><a href="#cb205-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb205-2"><a href="#cb205-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-3"><a href="#cb205-3" aria-hidden="true" tabindex="-1"></a>results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/bcs_subdomains&quot;</span>)</span>
<span id="cb205-4"><a href="#cb205-4" aria-hidden="true" tabindex="-1"></a>results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb205-5"><a href="#cb205-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-6"><a href="#cb205-6" aria-hidden="true" tabindex="-1"></a>pyvista_cells, cell_types, geometry <span class="op">=</span> vtk_mesh(V)</span>
<span id="cb205-7"><a href="#cb205-7" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> pyvista.UnstructuredGrid(pyvista_cells, cell_types, geometry)</span>
<span id="cb205-8"><a href="#cb205-8" aria-hidden="true" tabindex="-1"></a>grid.point_data[<span class="st">&quot;u&quot;</span>] <span class="op">=</span> uh.x.array</span>
<span id="cb205-9"><a href="#cb205-9" aria-hidden="true" tabindex="-1"></a>grid.set_active_scalars(<span class="st">&quot;u&quot;</span>)</span>
<span id="cb205-10"><a href="#cb205-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-11"><a href="#cb205-11" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb205-12"><a href="#cb205-12" aria-hidden="true" tabindex="-1"></a>plotter.add_text(<span class="st">&quot;uh&quot;</span>, position<span class="op">=</span><span class="st">&quot;upper_edge&quot;</span>, font_size<span class="op">=</span><span class="dv">14</span>, color<span class="op">=</span><span class="st">&quot;black&quot;</span>)</span>
<span id="cb205-13"><a href="#cb205-13" aria-hidden="true" tabindex="-1"></a>plotter.add_mesh(grid, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb205-14"><a href="#cb205-14" aria-hidden="true" tabindex="-1"></a>plotter.view_xy()</span>
<span id="cb205-15"><a href="#cb205-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb205-16"><a href="#cb205-16" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> pyvista.OFF_SCREEN:</span>
<span id="cb205-17"><a href="#cb205-17" aria-hidden="true" tabindex="-1"></a>    <span class="co">#plotter.show()</span></span>
<span id="cb205-18"><a href="#cb205-18" aria-hidden="true" tabindex="-1"></a>    plotter.export_html(results_folder<span class="op">/</span><span class="st">&quot;multiple_dirichlet.html&quot;</span>)</span>
<span id="cb205-19"><a href="#cb205-19" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb205-20"><a href="#cb205-20" aria-hidden="true" tabindex="-1"></a>    figure <span class="op">=</span> plotter.screenshot(results_folder<span class="op">/</span><span class="st">&quot;multiple_dirichlet.png&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/bcs_subdomains/multiple_dirichlet.html"
        width="100%" height="400px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
</section>
<section id="defining-subdomains-for-different-materials" class="level3" data-number="K.8.3">
<h3 data-number="K.8.3"><span class="header-section-number">K.8.3</span> Defining subdomains for different materials</h3>
<p>Author: Jørgen S. Dokken</p>
<p>Many PDE problems involve domains consisting of different materials. In <code>FEniCSx</code>, these cases can be treated by introducing a discontinuous, cell-wise constant function. We can create such a function on any mesh in the following way</p>
<p><strong>Subdomains on built-in meshes</strong></p>
<div id="3288cc8a" class="cell" data-execution_count="180">
<div class="sourceCode" id="cb206"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb206-1"><a href="#cb206-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb206-2"><a href="#cb206-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb206-3"><a href="#cb206-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb206-4"><a href="#cb206-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-5"><a href="#cb206-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> gmsh</span>
<span id="cb206-6"><a href="#cb206-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-7"><a href="#cb206-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> default_scalar_type</span>
<span id="cb206-8"><a href="#cb206-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.mesh <span class="im">import</span> create_unit_square, locate_entities</span>
<span id="cb206-9"><a href="#cb206-9" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem <span class="im">import</span> (</span>
<span id="cb206-10"><a href="#cb206-10" aria-hidden="true" tabindex="-1"></a>  Constant, dirichletbc, Function, functionspace, </span>
<span id="cb206-11"><a href="#cb206-11" aria-hidden="true" tabindex="-1"></a>  assemble_scalar, form, </span>
<span id="cb206-12"><a href="#cb206-12" aria-hidden="true" tabindex="-1"></a>  locate_dofs_geometrical, locate_dofs_topological</span>
<span id="cb206-13"><a href="#cb206-13" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb206-14"><a href="#cb206-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> LinearProblem</span>
<span id="cb206-15"><a href="#cb206-15" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.io <span class="im">import</span> XDMFFile, gmshio</span>
<span id="cb206-16"><a href="#cb206-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.plot <span class="im">import</span> vtk_mesh</span>
<span id="cb206-17"><a href="#cb206-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-18"><a href="#cb206-18" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ufl <span class="im">import</span> (</span>
<span id="cb206-19"><a href="#cb206-19" aria-hidden="true" tabindex="-1"></a>  SpatialCoordinate, TestFunction, TrialFunction,</span>
<span id="cb206-20"><a href="#cb206-20" aria-hidden="true" tabindex="-1"></a>  dx, grad, inner</span>
<span id="cb206-21"><a href="#cb206-21" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb206-22"><a href="#cb206-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb206-23"><a href="#cb206-23" aria-hidden="true" tabindex="-1"></a>mesh <span class="op">=</span> create_unit_square(MPI.COMM_WORLD, <span class="dv">10</span>, <span class="dv">10</span>)</span>
<span id="cb206-24"><a href="#cb206-24" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;DG&quot;</span>, <span class="dv">0</span>))</span></code></pre></div>
</div>
<p>To illustrate the concept, let’s consider a simple two-dimensional example with two materials. The domain <span class="math inline">\(\Omega=[0,1]\times[0,1]\)</span> is split into two subdomains, <span class="math inline">\(\Omega_1=[0,1]\times [0,1/2]\)</span> and <span class="math inline">\(\Omega_2=[0,1]\times[1/2, 1]\)</span>. We start by defining two Python functions, where each function returns <code>True</code> whenever the given coordinate falls inside its corresponding subdomain</p>
<div id="3305dfe2" class="cell" data-execution_count="181">
<div class="sourceCode" id="cb207"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb207-1"><a href="#cb207-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Omega_1(x):</span>
<span id="cb207-2"><a href="#cb207-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x[<span class="dv">1</span>] <span class="op">&lt;=</span> <span class="fl">0.5</span></span>
<span id="cb207-3"><a href="#cb207-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb207-4"><a href="#cb207-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> Omega_2(x):</span>
<span id="cb207-5"><a href="#cb207-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> x[<span class="dv">1</span>] <span class="op">&gt;=</span> <span class="fl">0.5</span></span></code></pre></div>
</div>
<p>Notice that both functions make use of <span class="math inline">\(\leq\)</span> and <span class="math inline">\(\geq\)</span>. This is because <code>FEniCSx</code> evaluates each cell at all of its vertices, and we need every vertex on the interface to return <code>True</code> in order for the interface to be marked correctly</p>
<p>With this in place, we now move on to a variable-coefficient version of the Poisson equation:</p>
<p><span class="math display">\[\begin{aligned}
-\nabla \cdot &amp;[\kappa(x,y)\,\nabla u(x, y)] = 1 &amp;&amp;\text{in } \Omega \\[5pt]
u &amp;= u_D = 1  &amp;&amp;\text{on } \partial\Omega_D = {(0,y), \, y \in [0,1]} \\[5pt]
-\frac{\partial u}{\partial n} &amp;= 0 &amp;&amp;\text{on } \partial\Omega \setminus \partial\Omega_D
\end{aligned}
\]</span></p>
<p>The next step is to define the coefficient <span class="math inline">\(\kappa\)</span></p>
<div id="7aeef4c4" class="cell" data-execution_count="182">
<div class="sourceCode" id="cb208"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb208-1"><a href="#cb208-1" aria-hidden="true" tabindex="-1"></a>kappa <span class="op">=</span> Function(Q)</span>
<span id="cb208-2"><a href="#cb208-2" aria-hidden="true" tabindex="-1"></a>cells_1 <span class="op">=</span> locate_entities(mesh, mesh.topology.dim, Omega_1)</span>
<span id="cb208-3"><a href="#cb208-3" aria-hidden="true" tabindex="-1"></a>cells_2 <span class="op">=</span> locate_entities(mesh, mesh.topology.dim, Omega_2)</span></code></pre></div>
</div>
<p>In the previous code block, we determined which cells (triangular elements) belong to <span class="math inline">\(\Omega_1\)</span> and <span class="math inline">\(\Omega_2\)</span>. Since a DG-0 function has a single degree of freedom per cell, there is a one-to-one correspondence between the degrees of freedom and the cells. We then define the coefficient <span class="math inline">\(\kappa\)</span> by</p>
<p><span class="math display">\[
\kappa =
\begin{cases}
\phantom{.}1 &amp; \text{if } x \in \Omega_1 \\
0.1 &amp; \text{if } x \in \Omega_2
\end{cases}\]</span></p>
<div id="1db51098" class="cell" data-execution_count="183">
<div class="sourceCode" id="cb209"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb209-1"><a href="#cb209-1" aria-hidden="true" tabindex="-1"></a>kappa.x.array[cells_1] <span class="op">=</span> np.full_like(cells_1, <span class="dv">1</span>, dtype<span class="op">=</span>default_scalar_type)</span>
<span id="cb209-2"><a href="#cb209-2" aria-hidden="true" tabindex="-1"></a>kappa.x.array[cells_2] <span class="op">=</span> np.full_like(cells_2, <span class="fl">0.1</span>, dtype<span class="op">=</span>default_scalar_type)</span></code></pre></div>
</div>
<div id="5f7c1536" class="cell" data-execution_count="184">
<div class="sourceCode" id="cb210"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb210-1"><a href="#cb210-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Filter out ghosted cells</span></span>
<span id="cb210-2"><a href="#cb210-2" aria-hidden="true" tabindex="-1"></a>tdim <span class="op">=</span> mesh.topology.dim</span>
<span id="cb210-3"><a href="#cb210-3" aria-hidden="true" tabindex="-1"></a>num_cells_local <span class="op">=</span> mesh.topology.index_map(tdim).size_local</span>
<span id="cb210-4"><a href="#cb210-4" aria-hidden="true" tabindex="-1"></a>marker <span class="op">=</span> np.zeros(num_cells_local, dtype<span class="op">=</span>np.int32)</span>
<span id="cb210-5"><a href="#cb210-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-6"><a href="#cb210-6" aria-hidden="true" tabindex="-1"></a>cells_1 <span class="op">=</span> cells_1[cells_1 <span class="op">&lt;</span> num_cells_local]</span>
<span id="cb210-7"><a href="#cb210-7" aria-hidden="true" tabindex="-1"></a>cells_2 <span class="op">=</span> cells_2[cells_2 <span class="op">&lt;</span> num_cells_local]</span>
<span id="cb210-8"><a href="#cb210-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-9"><a href="#cb210-9" aria-hidden="true" tabindex="-1"></a>marker[cells_1] <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb210-10"><a href="#cb210-10" aria-hidden="true" tabindex="-1"></a>marker[cells_2] <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb210-11"><a href="#cb210-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb210-12"><a href="#cb210-12" aria-hidden="true" tabindex="-1"></a>mesh.topology.create_connectivity(tdim, tdim)</span>
<span id="cb210-13"><a href="#cb210-13" aria-hidden="true" tabindex="-1"></a>topology, cell_types, x <span class="op">=</span> vtk_mesh(mesh, tdim, np.arange(num_cells_local, dtype<span class="op">=</span>np.int32))</span></code></pre></div>
</div>
<div id="f9cef053" class="cell" data-execution_count="185">
<div class="sourceCode" id="cb211"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb211-1"><a href="#cb211-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb211-2"><a href="#cb211-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb211-3"><a href="#cb211-3" aria-hidden="true" tabindex="-1"></a>results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/bcs_subdomains&quot;</span>)</span>
<span id="cb211-4"><a href="#cb211-4" aria-hidden="true" tabindex="-1"></a>results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb211-5"><a href="#cb211-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb211-6"><a href="#cb211-6" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">False</span>, window_size<span class="op">=</span>[<span class="dv">800</span>, <span class="dv">800</span>])</span>
<span id="cb211-7"><a href="#cb211-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb211-8"><a href="#cb211-8" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> pyvista.UnstructuredGrid(topology, cell_types, x)</span>
<span id="cb211-9"><a href="#cb211-9" aria-hidden="true" tabindex="-1"></a>grid.cell_data[<span class="st">&quot;Marker&quot;</span>] <span class="op">=</span> marker</span>
<span id="cb211-10"><a href="#cb211-10" aria-hidden="true" tabindex="-1"></a>grid.set_active_scalars(<span class="st">&quot;Marker&quot;</span>)</span>
<span id="cb211-11"><a href="#cb211-11" aria-hidden="true" tabindex="-1"></a>plotter.add_mesh(grid, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb211-12"><a href="#cb211-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb211-13"><a href="#cb211-13" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> pyvista.OFF_SCREEN:</span>
<span id="cb211-14"><a href="#cb211-14" aria-hidden="true" tabindex="-1"></a>    <span class="co">#plotter.show()</span></span>
<span id="cb211-15"><a href="#cb211-15" aria-hidden="true" tabindex="-1"></a>    plotter.export_html(results_folder<span class="op">/</span><span class="st">&quot;subdomains_structured.html&quot;</span>)</span>
<span id="cb211-16"><a href="#cb211-16" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb211-17"><a href="#cb211-17" aria-hidden="true" tabindex="-1"></a>    figure <span class="op">=</span> plotter.screenshot(results_folder<span class="op">/</span><span class="st">&quot;subdomains_structured.png&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/bcs_subdomains/subdomains_structured.html"
        width="100%" height="400px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
<p>After performing integration by parts, we are now ready to define the variational formulation and the Dirichlet boundary condition</p>
<div id="5fb42a72" class="cell" data-execution_count="186">
<div class="sourceCode" id="cb212"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb212-1"><a href="#cb212-1" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span>
<span id="cb212-2"><a href="#cb212-2" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> TrialFunction(V)</span>
<span id="cb212-3"><a href="#cb212-3" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> TestFunction(V)</span>
<span id="cb212-4"><a href="#cb212-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb212-5"><a href="#cb212-5" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> inner(kappa <span class="op">*</span>grad(u), grad(v)) <span class="op">*</span>dx</span>
<span id="cb212-6"><a href="#cb212-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb212-7"><a href="#cb212-7" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> SpatialCoordinate(mesh)</span>
<span id="cb212-8"><a href="#cb212-8" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> Constant(mesh, default_scalar_type(<span class="dv">1</span>)) <span class="op">*</span>v <span class="op">*</span>dx</span>
<span id="cb212-9"><a href="#cb212-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb212-10"><a href="#cb212-10" aria-hidden="true" tabindex="-1"></a>dofs <span class="op">=</span> locate_dofs_geometrical(V, <span class="kw">lambda</span> x: np.isclose(x[<span class="dv">0</span>], <span class="dv">0</span>))</span>
<span id="cb212-11"><a href="#cb212-11" aria-hidden="true" tabindex="-1"></a>bcs <span class="op">=</span> [dirichletbc(default_scalar_type(<span class="dv">1</span>), dofs, V)]</span></code></pre></div>
</div>
<p>We can now solve the problem and visualize its solution</p>
<div id="36b93895" class="cell" data-execution_count="187">
<div class="sourceCode" id="cb213"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb213-1"><a href="#cb213-1" aria-hidden="true" tabindex="-1"></a>problem <span class="op">=</span> LinearProblem(</span>
<span id="cb213-2"><a href="#cb213-2" aria-hidden="true" tabindex="-1"></a>  a, </span>
<span id="cb213-3"><a href="#cb213-3" aria-hidden="true" tabindex="-1"></a>  L, </span>
<span id="cb213-4"><a href="#cb213-4" aria-hidden="true" tabindex="-1"></a>  bcs<span class="op">=</span>bcs, </span>
<span id="cb213-5"><a href="#cb213-5" aria-hidden="true" tabindex="-1"></a>  petsc_options<span class="op">=</span>{<span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;preonly&quot;</span>, <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;lu&quot;</span>}</span>
<span id="cb213-6"><a href="#cb213-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb213-7"><a href="#cb213-7" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> problem.solve()</span></code></pre></div>
</div>
<div id="71d3be8b" class="cell" data-execution_count="188">
<div class="sourceCode" id="cb214"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb214-1"><a href="#cb214-1" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">False</span>, window_size<span class="op">=</span>[<span class="dv">800</span>, <span class="dv">800</span>])</span>
<span id="cb214-2"><a href="#cb214-2" aria-hidden="true" tabindex="-1"></a>grid_uh <span class="op">=</span> pyvista.UnstructuredGrid(<span class="op">*</span>vtk_mesh(V))</span>
<span id="cb214-3"><a href="#cb214-3" aria-hidden="true" tabindex="-1"></a>grid_uh.point_data[<span class="st">&quot;u&quot;</span>] <span class="op">=</span> uh.x.array.real</span>
<span id="cb214-4"><a href="#cb214-4" aria-hidden="true" tabindex="-1"></a>grid_uh.set_active_scalars(<span class="st">&quot;u&quot;</span>)</span>
<span id="cb214-5"><a href="#cb214-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb214-6"><a href="#cb214-6" aria-hidden="true" tabindex="-1"></a>plotter.add_mesh(grid_uh, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb214-7"><a href="#cb214-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> pyvista.OFF_SCREEN:</span>
<span id="cb214-8"><a href="#cb214-8" aria-hidden="true" tabindex="-1"></a>  <span class="co">#plotter.show()</span></span>
<span id="cb214-9"><a href="#cb214-9" aria-hidden="true" tabindex="-1"></a>  plotter.export_html(results_folder<span class="op">/</span><span class="st">&quot;subdomains_structured2.html&quot;</span>)</span>
<span id="cb214-10"><a href="#cb214-10" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb214-11"><a href="#cb214-11" aria-hidden="true" tabindex="-1"></a>  figure <span class="op">=</span> plotter.screenshot(results_folder<span class="op">/</span><span class="st">&quot;subdomains_structured2.png&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/bcs_subdomains/subdomains_structured2.html"
        width="100%" height="400px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
<p>Distinct behaviors are clearly observed in the two regions, despite both having the same Dirichlet boundary condition at <span class="math inline">\(x=0\)</span> on the left boundary</p>
<p><strong>Interpolation with Python-function</strong></p>
<p>As we saw in the first approach, in many cases the geometrical coordinates can be used to determine which coefficient to apply. Using the unstructured mesh from the previous example, we illustrate an alternative approach based on interpolation</p>
<div id="5912d3e0" class="cell" data-execution_count="189">
<div class="sourceCode" id="cb215"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb215-1"><a href="#cb215-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> eval_kappa(x):</span>
<span id="cb215-2"><a href="#cb215-2" aria-hidden="true" tabindex="-1"></a>  values <span class="op">=</span> np.zeros(x.shape[<span class="dv">1</span>], dtype<span class="op">=</span>default_scalar_type)</span>
<span id="cb215-3"><a href="#cb215-3" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb215-4"><a href="#cb215-4" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Create a boolean array indicating which dofs </span></span>
<span id="cb215-5"><a href="#cb215-5" aria-hidden="true" tabindex="-1"></a>  <span class="co">#   that are in each domain</span></span>
<span id="cb215-6"><a href="#cb215-6" aria-hidden="true" tabindex="-1"></a>  top_coords <span class="op">=</span> x[<span class="dv">1</span>] <span class="op">&gt;</span> <span class="fl">0.5</span></span>
<span id="cb215-7"><a href="#cb215-7" aria-hidden="true" tabindex="-1"></a>  bottom_coords <span class="op">=</span> x[<span class="dv">1</span>] <span class="op">&lt;</span> <span class="fl">0.5</span></span>
<span id="cb215-8"><a href="#cb215-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-9"><a href="#cb215-9" aria-hidden="true" tabindex="-1"></a>  values[top_coords] <span class="op">=</span> np.full(<span class="bu">sum</span>(top_coords), <span class="fl">0.1</span>)</span>
<span id="cb215-10"><a href="#cb215-10" aria-hidden="true" tabindex="-1"></a>  values[bottom_coords] <span class="op">=</span> np.full(<span class="bu">sum</span>(bottom_coords), <span class="dv">1</span>)</span>
<span id="cb215-11"><a href="#cb215-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb215-12"><a href="#cb215-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> values</span></code></pre></div>
</div>
<div id="be206a1c" class="cell" data-execution_count="190">
<div class="sourceCode" id="cb216"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb216-1"><a href="#cb216-1" aria-hidden="true" tabindex="-1"></a>kappa2 <span class="op">=</span> Function(Q)</span>
<span id="cb216-2"><a href="#cb216-2" aria-hidden="true" tabindex="-1"></a>kappa2.interpolate(eval_kappa)</span></code></pre></div>
</div>
<p>We verify this by computing the error between the new function and the previous one</p>
<div id="b38a02bd" class="cell" data-execution_count="191">
<div class="sourceCode" id="cb217"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb217-1"><a href="#cb217-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Difference in kappa&#39;s</span></span>
<span id="cb217-2"><a href="#cb217-2" aria-hidden="true" tabindex="-1"></a>error <span class="op">=</span> mesh.comm.allreduce(assemble_scalar(form((kappa <span class="op">-</span>kappa2)<span class="op">**</span><span class="dv">2</span> <span class="op">*</span>dx)))</span>
<span id="cb217-3"><a href="#cb217-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&#39;</span><span class="sc">{</span>error <span class="op">=</span> <span class="sc">}</span><span class="ss">&#39;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>error = 0.0</code></pre>
</div>
</div>
<p><strong>Subdomains defined from external mesh data</strong></p>
<p>Let us now consider the same problem, but using <code>Gmsh</code> to generate both the mesh and the subdomains. We will then show how to use this data to create discontinuous functions in <code>dolfinx</code></p>
<div id="a55b0686" class="cell" data-execution_count="192">
<div class="sourceCode" id="cb219"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb219-1"><a href="#cb219-1" aria-hidden="true" tabindex="-1"></a>gmsh.initialize()</span>
<span id="cb219-2"><a href="#cb219-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-3"><a href="#cb219-3" aria-hidden="true" tabindex="-1"></a>proc <span class="op">=</span> MPI.COMM_WORLD.rank</span>
<span id="cb219-4"><a href="#cb219-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-5"><a href="#cb219-5" aria-hidden="true" tabindex="-1"></a>top_marker <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb219-6"><a href="#cb219-6" aria-hidden="true" tabindex="-1"></a>bottom_marker <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb219-7"><a href="#cb219-7" aria-hidden="true" tabindex="-1"></a>left_marker <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb219-8"><a href="#cb219-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-9"><a href="#cb219-9" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> proc <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb219-10"><a href="#cb219-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># We create one rectangle for each subdomain</span></span>
<span id="cb219-11"><a href="#cb219-11" aria-hidden="true" tabindex="-1"></a>  gmsh.model.occ.addRectangle(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.5</span>, tag<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb219-12"><a href="#cb219-12" aria-hidden="true" tabindex="-1"></a>  gmsh.model.occ.addRectangle(<span class="dv">0</span>, <span class="fl">0.5</span>, <span class="dv">0</span>, <span class="dv">1</span>, <span class="fl">0.5</span>, tag<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb219-13"><a href="#cb219-13" aria-hidden="true" tabindex="-1"></a>  <span class="co"># We fuse the two rectangles and keep the interface between them</span></span>
<span id="cb219-14"><a href="#cb219-14" aria-hidden="true" tabindex="-1"></a>  gmsh.model.occ.fragment([(<span class="dv">2</span>, <span class="dv">1</span>)], [(<span class="dv">2</span>, <span class="dv">2</span>)])</span>
<span id="cb219-15"><a href="#cb219-15" aria-hidden="true" tabindex="-1"></a>  gmsh.model.occ.synchronize()</span>
<span id="cb219-16"><a href="#cb219-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-17"><a href="#cb219-17" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Mark the top (2) and bottom (1) rectangle</span></span>
<span id="cb219-18"><a href="#cb219-18" aria-hidden="true" tabindex="-1"></a>  top, bottom <span class="op">=</span> <span class="va">None</span>, <span class="va">None</span></span>
<span id="cb219-19"><a href="#cb219-19" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> surface <span class="kw">in</span> gmsh.model.getEntities(dim<span class="op">=</span><span class="dv">2</span>):</span>
<span id="cb219-20"><a href="#cb219-20" aria-hidden="true" tabindex="-1"></a>    com <span class="op">=</span> gmsh.model.occ.getCenterOfMass(surface[<span class="dv">0</span>], surface[<span class="dv">1</span>])</span>
<span id="cb219-21"><a href="#cb219-21" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.allclose(com, [<span class="fl">0.5</span>, <span class="fl">0.25</span>, <span class="dv">0</span>]):</span>
<span id="cb219-22"><a href="#cb219-22" aria-hidden="true" tabindex="-1"></a>      bottom <span class="op">=</span> surface[<span class="dv">1</span>]</span>
<span id="cb219-23"><a href="#cb219-23" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb219-24"><a href="#cb219-24" aria-hidden="true" tabindex="-1"></a>      top <span class="op">=</span> surface[<span class="dv">1</span>]</span>
<span id="cb219-25"><a href="#cb219-25" aria-hidden="true" tabindex="-1"></a>  gmsh.model.addPhysicalGroup(<span class="dv">2</span>, [bottom], bottom_marker)</span>
<span id="cb219-26"><a href="#cb219-26" aria-hidden="true" tabindex="-1"></a>  gmsh.model.addPhysicalGroup(<span class="dv">2</span>, [top], top_marker)</span>
<span id="cb219-27"><a href="#cb219-27" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb219-28"><a href="#cb219-28" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Tag the left boundary</span></span>
<span id="cb219-29"><a href="#cb219-29" aria-hidden="true" tabindex="-1"></a>  left <span class="op">=</span> []</span>
<span id="cb219-30"><a href="#cb219-30" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> line <span class="kw">in</span> gmsh.model.getEntities(dim<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb219-31"><a href="#cb219-31" aria-hidden="true" tabindex="-1"></a>    com <span class="op">=</span> gmsh.model.occ.getCenterOfMass(line[<span class="dv">0</span>], line[<span class="dv">1</span>])</span>
<span id="cb219-32"><a href="#cb219-32" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> np.isclose(com[<span class="dv">0</span>], <span class="dv">0</span>):</span>
<span id="cb219-33"><a href="#cb219-33" aria-hidden="true" tabindex="-1"></a>      left.append(line[<span class="dv">1</span>])</span>
<span id="cb219-34"><a href="#cb219-34" aria-hidden="true" tabindex="-1"></a>  gmsh.model.addPhysicalGroup(<span class="dv">1</span>, left, left_marker)</span>
<span id="cb219-35"><a href="#cb219-35" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb219-36"><a href="#cb219-36" aria-hidden="true" tabindex="-1"></a>  gmsh.model.mesh.generate(<span class="dv">2</span>)</span>
<span id="cb219-37"><a href="#cb219-37" aria-hidden="true" tabindex="-1"></a>  gmsh.write(<span class="bu">str</span>(results_folder<span class="op">/</span><span class="st">&quot;gmsh_mesh.msh&quot;</span>))</span>
<span id="cb219-38"><a href="#cb219-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb219-39"><a href="#cb219-39" aria-hidden="true" tabindex="-1"></a>gmsh.finalize()</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Info    : [  0%] Fragments                                                                                  Info    : [ 10%] Fragments                                                                                  Info    : [ 20%] Fragments                                                                                  Info    : [ 30%] Fragments                                                                                  Info    : [ 40%] Fragments                                                                                  Info    : [ 50%] Fragments                                                                                  Info    : [ 60%] Fragments                                                                                  Info    : [ 70%] Fragments                                                                                  Info    : [ 80%] Fragments - Splitting faces                                                                                                                                                                Info    : Meshing 1D...
Info    : [  0%] Meshing curve 1 (Line)
Info    : [ 20%] Meshing curve 2 (Line)
Info    : [ 30%] Meshing curve 3 (Line)
Info    : [ 50%] Meshing curve 4 (Line)
Info    : [ 60%] Meshing curve 5 (Line)
Info    : [ 80%] Meshing curve 6 (Line)
Info    : [ 90%] Meshing curve 7 (Line)
Info    : Done meshing 1D (Wall 0.000576416s, CPU 0.001009s)
Info    : Meshing 2D...
Info    : [  0%] Meshing surface 1 (Plane, Frontal-Delaunay)
Info    : [ 60%] Meshing surface 2 (Plane, Frontal-Delaunay)
Info    : Done meshing 2D (Wall 0.00336079s, CPU 0.005497s)
Info    : 101 nodes 214 elements
Info    : Writing &#39;fenicsx/bcs_subdomains/gmsh_mesh.msh&#39;...
Info    : Done writing &#39;fenicsx/bcs_subdomains/gmsh_mesh.msh&#39;</code></pre>
</div>
</div>
<p><strong>Read in MSH files with <code>dolfinx</code></strong></p>
<p>You can read MSH files with <code>dolfinx</code>, which initially loads them on a single process and then distributes them across the available ranks in the MPI communicator</p>
<div id="99054505" class="cell" data-execution_count="193">
<div class="sourceCode" id="cb221"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb221-1"><a href="#cb221-1" aria-hidden="true" tabindex="-1"></a>mesh, cell_markers, facet_markers <span class="op">=</span> gmshio.read_from_msh(</span>
<span id="cb221-2"><a href="#cb221-2" aria-hidden="true" tabindex="-1"></a>  results_folder<span class="op">/</span><span class="st">&quot;gmsh_mesh.msh&quot;</span>, </span>
<span id="cb221-3"><a href="#cb221-3" aria-hidden="true" tabindex="-1"></a>  MPI.COMM_WORLD, </span>
<span id="cb221-4"><a href="#cb221-4" aria-hidden="true" tabindex="-1"></a>  gdim<span class="op">=</span><span class="dv">2</span></span>
<span id="cb221-5"><a href="#cb221-5" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Info    : Reading &#39;fenicsx/bcs_subdomains/gmsh_mesh.msh&#39;...
Info    : 15 entities
Info    : 101 nodes
Info    : 176 elements
Info    : Done reading &#39;fenicsx/bcs_subdomains/gmsh_mesh.msh&#39;</code></pre>
</div>
</div>
<p><strong>Convert <code>msh</code>-files to <code>XDMF</code> using <code>meshio</code></strong></p>
<p>We will use <code>meshio</code> to read in the <code>msh</code> file, and convert it to a more suitable IO format. We start by creating a convenience function for extracting data for a single cell type, and creating a new <code>meshio.Mesh</code></p>
<div id="f24fa203" class="cell" data-execution_count="194">
<div class="sourceCode" id="cb223"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb223-1"><a href="#cb223-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> meshio</span>
<span id="cb223-2"><a href="#cb223-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-3"><a href="#cb223-3" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> create_mesh(mesh, cell_type, prune_z<span class="op">=</span><span class="va">False</span>):</span>
<span id="cb223-4"><a href="#cb223-4" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb223-5"><a href="#cb223-5" aria-hidden="true" tabindex="-1"></a>  points <span class="op">=</span> mesh.points[:, :<span class="dv">2</span>] <span class="cf">if</span> prune_z <span class="cf">else</span> mesh.points</span>
<span id="cb223-6"><a href="#cb223-6" aria-hidden="true" tabindex="-1"></a>  cells <span class="op">=</span> mesh.get_cells_type(cell_type)</span>
<span id="cb223-7"><a href="#cb223-7" aria-hidden="true" tabindex="-1"></a>  cell_data <span class="op">=</span> mesh.get_cell_data(<span class="st">&quot;gmsh:physical&quot;</span>, cell_type)</span>
<span id="cb223-8"><a href="#cb223-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb223-9"><a href="#cb223-9" aria-hidden="true" tabindex="-1"></a>  out_mesh <span class="op">=</span> meshio.Mesh(</span>
<span id="cb223-10"><a href="#cb223-10" aria-hidden="true" tabindex="-1"></a>    points<span class="op">=</span>points, </span>
<span id="cb223-11"><a href="#cb223-11" aria-hidden="true" tabindex="-1"></a>    cells<span class="op">=</span>{cell_type: cells}, </span>
<span id="cb223-12"><a href="#cb223-12" aria-hidden="true" tabindex="-1"></a>    cell_data<span class="op">=</span>{<span class="st">&quot;name_to_read&quot;</span>: [cell_data.astype(np.int32)]}</span>
<span id="cb223-13"><a href="#cb223-13" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb223-14"><a href="#cb223-14" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb223-15"><a href="#cb223-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> out_mesh</span></code></pre></div>
</div>
<p>This function returns a <code>meshio</code> mesh, including physical markers for the specified type. The <code>prune_z</code> argument is used when working with two-dimensional meshes. The last coordinate in the <code>mesh</code> (since it is generated in 3D space) must be removed for <code>dolfinx</code> to recognize it as a two-dimensional geometry</p>
<div id="7d9af404" class="cell" data-execution_count="195">
<div class="sourceCode" id="cb224"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb224-1"><a href="#cb224-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> proc <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb224-2"><a href="#cb224-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Read in mesh</span></span>
<span id="cb224-3"><a href="#cb224-3" aria-hidden="true" tabindex="-1"></a>  msh <span class="op">=</span> meshio.read(results_folder<span class="op">/</span><span class="st">&quot;gmsh_mesh.msh&quot;</span>)</span>
<span id="cb224-4"><a href="#cb224-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-5"><a href="#cb224-5" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Create and save one file for the mesh, and one file for the facets</span></span>
<span id="cb224-6"><a href="#cb224-6" aria-hidden="true" tabindex="-1"></a>  triangle_mesh <span class="op">=</span> create_mesh(msh, <span class="st">&quot;triangle&quot;</span>, prune_z<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb224-7"><a href="#cb224-7" aria-hidden="true" tabindex="-1"></a>  line_mesh <span class="op">=</span> create_mesh(msh, <span class="st">&quot;line&quot;</span>, prune_z<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb224-8"><a href="#cb224-8" aria-hidden="true" tabindex="-1"></a>  meshio.write(results_folder<span class="op">/</span><span class="st">&quot;mesh.xdmf&quot;</span>, triangle_mesh)</span>
<span id="cb224-9"><a href="#cb224-9" aria-hidden="true" tabindex="-1"></a>  meshio.write(results_folder<span class="op">/</span><span class="st">&quot;mt.xdmf&quot;</span>, line_mesh)</span>
<span id="cb224-10"><a href="#cb224-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb224-11"><a href="#cb224-11" aria-hidden="true" tabindex="-1"></a>MPI.COMM_WORLD.barrier()</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code></code></pre>
</div>
</div>
<p>We have written the mesh and cell markers to one file, and the facet markers to a separate file. This data can be read in <code>dolfinx</code> using <code>XDMFFile.read_mesh</code> and <code>XDMFFile.read_meshtags</code>. A <code>dolfinx.MeshTags</code> object stores the entity indices and their corresponding marker values in two one-dimensional arrays</p>
<p>Note that the mesh was generated and written using a single processor. However, since the <code>XDMF</code> format supports parallel I/O, the mesh can be read in parallel</p>
<div id="45082cf3" class="cell" data-execution_count="196">
<div class="sourceCode" id="cb226"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb226-1"><a href="#cb226-1" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> XDMFFile(</span>
<span id="cb226-2"><a href="#cb226-2" aria-hidden="true" tabindex="-1"></a>  MPI.COMM_WORLD, </span>
<span id="cb226-3"><a href="#cb226-3" aria-hidden="true" tabindex="-1"></a>  results_folder<span class="op">/</span><span class="st">&quot;mesh.xdmf&quot;</span>, <span class="st">&quot;r&quot;</span></span>
<span id="cb226-4"><a href="#cb226-4" aria-hidden="true" tabindex="-1"></a>) <span class="im">as</span> xdmf:</span>
<span id="cb226-5"><a href="#cb226-5" aria-hidden="true" tabindex="-1"></a>  mesh <span class="op">=</span> xdmf.read_mesh(name<span class="op">=</span><span class="st">&quot;Grid&quot;</span>)</span>
<span id="cb226-6"><a href="#cb226-6" aria-hidden="true" tabindex="-1"></a>  ct <span class="op">=</span> xdmf.read_meshtags(mesh, name<span class="op">=</span><span class="st">&quot;Grid&quot;</span>)</span>
<span id="cb226-7"><a href="#cb226-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb226-8"><a href="#cb226-8" aria-hidden="true" tabindex="-1"></a>mesh.topology.create_connectivity(mesh.topology.dim, mesh.topology.dim <span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb226-9"><a href="#cb226-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb226-10"><a href="#cb226-10" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> XDMFFile(</span>
<span id="cb226-11"><a href="#cb226-11" aria-hidden="true" tabindex="-1"></a>  MPI.COMM_WORLD, </span>
<span id="cb226-12"><a href="#cb226-12" aria-hidden="true" tabindex="-1"></a>  results_folder<span class="op">/</span><span class="st">&quot;mt.xdmf&quot;</span>, <span class="st">&quot;r&quot;</span></span>
<span id="cb226-13"><a href="#cb226-13" aria-hidden="true" tabindex="-1"></a>) <span class="im">as</span> xdmf:</span>
<span id="cb226-14"><a href="#cb226-14" aria-hidden="true" tabindex="-1"></a>  ft <span class="op">=</span> xdmf.read_meshtags(mesh, name<span class="op">=</span><span class="st">&quot;Grid&quot;</span>)</span></code></pre></div>
</div>
<p>Having read the mesh together with the associated cell and facet data, we can now construct the discontinuous function <code>kappa</code> as follows:</p>
<div id="f44f2bed" class="cell" data-execution_count="197">
<div class="sourceCode" id="cb227"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb227-1"><a href="#cb227-1" aria-hidden="true" tabindex="-1"></a>Q <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;DG&quot;</span>, <span class="dv">0</span>))</span>
<span id="cb227-2"><a href="#cb227-2" aria-hidden="true" tabindex="-1"></a>kappa <span class="op">=</span> Function(Q)</span>
<span id="cb227-3"><a href="#cb227-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb227-4"><a href="#cb227-4" aria-hidden="true" tabindex="-1"></a>bottom_cells <span class="op">=</span> ct.find(bottom_marker)</span>
<span id="cb227-5"><a href="#cb227-5" aria-hidden="true" tabindex="-1"></a>kappa.x.array[bottom_cells] <span class="op">=</span> np.full_like(</span>
<span id="cb227-6"><a href="#cb227-6" aria-hidden="true" tabindex="-1"></a>  bottom_cells, </span>
<span id="cb227-7"><a href="#cb227-7" aria-hidden="true" tabindex="-1"></a>  <span class="dv">1</span>, </span>
<span id="cb227-8"><a href="#cb227-8" aria-hidden="true" tabindex="-1"></a>  dtype<span class="op">=</span>default_scalar_type</span>
<span id="cb227-9"><a href="#cb227-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb227-10"><a href="#cb227-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb227-11"><a href="#cb227-11" aria-hidden="true" tabindex="-1"></a>top_cells <span class="op">=</span> ct.find(top_marker)</span>
<span id="cb227-12"><a href="#cb227-12" aria-hidden="true" tabindex="-1"></a>kappa.x.array[top_cells] <span class="op">=</span> np.full_like(</span>
<span id="cb227-13"><a href="#cb227-13" aria-hidden="true" tabindex="-1"></a>  top_cells, </span>
<span id="cb227-14"><a href="#cb227-14" aria-hidden="true" tabindex="-1"></a>  <span class="fl">0.1</span>, </span>
<span id="cb227-15"><a href="#cb227-15" aria-hidden="true" tabindex="-1"></a>  dtype<span class="op">=</span>default_scalar_type</span>
<span id="cb227-16"><a href="#cb227-16" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
<p>The facet data <code>ft</code> can also be used efficiently to construct the Dirichlet boundary condition</p>
<div id="56c4024c" class="cell" data-execution_count="198">
<div class="sourceCode" id="cb228"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb228-1"><a href="#cb228-1" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span>
<span id="cb228-2"><a href="#cb228-2" aria-hidden="true" tabindex="-1"></a>u_bc <span class="op">=</span> Function(V)</span>
<span id="cb228-3"><a href="#cb228-3" aria-hidden="true" tabindex="-1"></a>left_facets <span class="op">=</span> ft.find(left_marker)</span>
<span id="cb228-4"><a href="#cb228-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-5"><a href="#cb228-5" aria-hidden="true" tabindex="-1"></a>mesh.topology.create_connectivity(mesh.topology.dim <span class="op">-</span><span class="dv">1</span>, mesh.topology.dim)</span>
<span id="cb228-6"><a href="#cb228-6" aria-hidden="true" tabindex="-1"></a>left_dofs <span class="op">=</span> locate_dofs_topological(V, mesh.topology.dim <span class="op">-</span><span class="dv">1</span>, left_facets)</span>
<span id="cb228-7"><a href="#cb228-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb228-8"><a href="#cb228-8" aria-hidden="true" tabindex="-1"></a>bcs <span class="op">=</span> [dirichletbc(default_scalar_type(<span class="dv">1</span>), left_dofs, V)]</span></code></pre></div>
</div>
<p>We can now solve the problem in a fashion similar to that used above</p>
<div id="c908231a" class="cell" data-execution_count="199">
<div class="sourceCode" id="cb229"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb229-1"><a href="#cb229-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> TrialFunction(V)</span>
<span id="cb229-2"><a href="#cb229-2" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> TestFunction(V)</span>
<span id="cb229-3"><a href="#cb229-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-4"><a href="#cb229-4" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> inner(kappa <span class="op">*</span>grad(u), grad(v)) <span class="op">*</span>dx</span>
<span id="cb229-5"><a href="#cb229-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-6"><a href="#cb229-6" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> SpatialCoordinate(mesh)</span>
<span id="cb229-7"><a href="#cb229-7" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> Constant(mesh, default_scalar_type(<span class="dv">1</span>)) <span class="op">*</span>v <span class="op">*</span>dx</span>
<span id="cb229-8"><a href="#cb229-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb229-9"><a href="#cb229-9" aria-hidden="true" tabindex="-1"></a>problem <span class="op">=</span> LinearProblem(</span>
<span id="cb229-10"><a href="#cb229-10" aria-hidden="true" tabindex="-1"></a>  a, </span>
<span id="cb229-11"><a href="#cb229-11" aria-hidden="true" tabindex="-1"></a>  L, </span>
<span id="cb229-12"><a href="#cb229-12" aria-hidden="true" tabindex="-1"></a>  bcs<span class="op">=</span>bcs, </span>
<span id="cb229-13"><a href="#cb229-13" aria-hidden="true" tabindex="-1"></a>  petsc_options<span class="op">=</span>{<span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;preonly&quot;</span>, <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;lu&quot;</span>}</span>
<span id="cb229-14"><a href="#cb229-14" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb229-15"><a href="#cb229-15" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> problem.solve()</span></code></pre></div>
</div>
<div id="1cc11b15" class="cell" data-execution_count="200">
<div class="sourceCode" id="cb230"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb230-1"><a href="#cb230-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Since dolfinx.MeshTag contains a value for every cell in the geometry, </span></span>
<span id="cb230-2"><a href="#cb230-2" aria-hidden="true" tabindex="-1"></a><span class="co"># we can attach it directly to the grid</span></span>
<span id="cb230-3"><a href="#cb230-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-4"><a href="#cb230-4" aria-hidden="true" tabindex="-1"></a>tdim <span class="op">=</span> mesh.topology.dim</span>
<span id="cb230-5"><a href="#cb230-5" aria-hidden="true" tabindex="-1"></a>mesh.topology.create_connectivity(tdim, tdim)</span>
<span id="cb230-6"><a href="#cb230-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-7"><a href="#cb230-7" aria-hidden="true" tabindex="-1"></a>topology, cell_types, x <span class="op">=</span> vtk_mesh(mesh, tdim)</span>
<span id="cb230-8"><a href="#cb230-8" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> pyvista.UnstructuredGrid(topology, cell_types, x)</span>
<span id="cb230-9"><a href="#cb230-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-10"><a href="#cb230-10" aria-hidden="true" tabindex="-1"></a>num_local_cells <span class="op">=</span> mesh.topology.index_map(tdim).size_local</span>
<span id="cb230-11"><a href="#cb230-11" aria-hidden="true" tabindex="-1"></a>grid.cell_data[<span class="st">&quot;Marker&quot;</span>] <span class="op">=</span> ct.values[ct.indices <span class="op">&lt;</span> num_local_cells]</span>
<span id="cb230-12"><a href="#cb230-12" aria-hidden="true" tabindex="-1"></a>grid.set_active_scalars(<span class="st">&quot;Marker&quot;</span>)</span>
<span id="cb230-13"><a href="#cb230-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-14"><a href="#cb230-14" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">False</span>, window_size<span class="op">=</span>[<span class="dv">800</span>, <span class="dv">800</span>])</span>
<span id="cb230-15"><a href="#cb230-15" aria-hidden="true" tabindex="-1"></a>plotter.add_mesh(grid, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb230-16"><a href="#cb230-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb230-17"><a href="#cb230-17" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> pyvista.OFF_SCREEN:</span>
<span id="cb230-18"><a href="#cb230-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">#plotter.show()</span></span>
<span id="cb230-19"><a href="#cb230-19" aria-hidden="true" tabindex="-1"></a>  plotter.export_html(results_folder<span class="op">/</span><span class="st">&quot;subdomains_unstructured.html&quot;</span>)</span>
<span id="cb230-20"><a href="#cb230-20" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb230-21"><a href="#cb230-21" aria-hidden="true" tabindex="-1"></a>  figure <span class="op">=</span> plotter.screenshot(results_folder<span class="op">/</span><span class="st">&quot;subdomains_unstructured.png&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/bcs_subdomains/subdomains_unstructured.html"
        width="100%" height="400px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
<div id="0f0fe834" class="cell" data-execution_count="201">
<div class="sourceCode" id="cb231"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb231-1"><a href="#cb231-1" aria-hidden="true" tabindex="-1"></a>grid_uh <span class="op">=</span> pyvista.UnstructuredGrid(<span class="op">*</span>vtk_mesh(V))</span>
<span id="cb231-2"><a href="#cb231-2" aria-hidden="true" tabindex="-1"></a>grid_uh.point_data[<span class="st">&quot;u&quot;</span>] <span class="op">=</span> uh.x.array.real</span>
<span id="cb231-3"><a href="#cb231-3" aria-hidden="true" tabindex="-1"></a>grid_uh.set_active_scalars(<span class="st">&quot;u&quot;</span>)</span>
<span id="cb231-4"><a href="#cb231-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-5"><a href="#cb231-5" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">False</span>, window_size<span class="op">=</span>[<span class="dv">800</span>, <span class="dv">800</span>])</span>
<span id="cb231-6"><a href="#cb231-6" aria-hidden="true" tabindex="-1"></a>plotter.add_mesh(grid_uh, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb231-7"><a href="#cb231-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb231-8"><a href="#cb231-8" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> pyvista.OFF_SCREEN:</span>
<span id="cb231-9"><a href="#cb231-9" aria-hidden="true" tabindex="-1"></a>  <span class="co">#plotter.show()</span></span>
<span id="cb231-10"><a href="#cb231-10" aria-hidden="true" tabindex="-1"></a>  plotter.export_html(results_folder<span class="op">/</span><span class="st">&quot;subdomains_unstructured_u.html&quot;</span>)</span>
<span id="cb231-11"><a href="#cb231-11" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb231-12"><a href="#cb231-12" aria-hidden="true" tabindex="-1"></a>  figure <span class="op">=</span> plotter.screenshot(results_folder<span class="op">/</span><span class="st">&quot;subdomains_unstructured_u.png&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/bcs_subdomains/subdomains_unstructured_u.html"
        width="100%" height="400px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
</section>
<section id="setting-multiple-dirichlet-neumann-and-robin-conditions" class="level3" data-number="K.8.4">
<h3 data-number="K.8.4"><span class="header-section-number">K.8.4</span> Setting multiple Dirichlet, Neumann, and Robin conditions</h3>
<p>Author: Hans Petter Langtangen and Anders Logg</p>
<p>We now look at the variable-coefficient example from the previous section. In this part, we will show how to apply a combination of Dirichlet, Neumann, and Robin boundary conditions to this problem</p>
<p>We split the boundary into three distinct parts:</p>
<ul>
<li><p><span class="math inline">\(\Gamma_D\)</span> for Dirichlet conditions:</p>
<p><span class="math inline">\(\phantom{-\kappa\partial}u=u_D^i \quad\text{on } \Gamma_D^i \quad\)</span> where <span class="math inline">\(\;\Gamma_D=\Gamma_D^0\cup \Gamma_D^1 \cup \dots\)</span></p></li>
<li><p><span class="math inline">\(\Gamma_N\)</span> for Neumann conditions:</p>
<p><span class="math inline">\(\displaystyle -\kappa \frac{\partial u}{\partial n}=g_j \quad\text{on } \Gamma_N^j \quad\)</span> where <span class="math inline">\(\;\Gamma_N=\Gamma_N^0\cup \Gamma_N^1 \cup \dots\)</span></p></li>
<li><p><span class="math inline">\(\Gamma_R\)</span> for Robin conditions:</p>
<p><span class="math inline">\(\displaystyle -\kappa \frac{\partial u}{\partial n}=r_k (u -s_k) \quad\text{on } \Gamma_R^k \quad\)</span> where <span class="math inline">\(\;\Gamma_R=\Gamma_R^0\cup \Gamma_R^1 \cup \dots\)</span></p></li>
</ul>
<p>where <span class="math inline">\(r_k\)</span> and <span class="math inline">\(s_k\)</span> are prescribed functions. The Robin condition is commonly used to model heat transfer to the surroundings and arises naturally from Newton’s law of cooling. In this case, <span class="math inline">\(r_k\)</span> represents the heat transfer coefficient, and <span class="math inline">\(s_k\)</span> is the ambient temperature. Both may depend on space and time</p>
<p><strong>The PDE problem and variational formulation</strong></p>
<p>We can summarize the PDE problem as follows:</p>
<p><span class="math display">\[\begin{aligned}
-\nabla &amp;\cdot (\kappa \nabla u) = f &amp;&amp;\text{in } \Omega\\[6pt]
u &amp;= u_D^i \quad &amp;&amp;\text{on } \Gamma_D^i \\[5pt]
-\kappa \frac{\partial u}{\partial n} &amp;= g_j &amp;&amp;\text{on } \Gamma_N^j\\
-\kappa \frac{\partial u}{\partial n} &amp;= r_k (u - s_k) &amp;&amp;\text{on } \Gamma_R^k
\end{aligned}\]</span></p>
<p>As usual, we multiply the equation by a test function <span class="math inline">\(v\)</span> and integrate by parts:</p>
<p><span class="math display">\[-\int_{\Omega} \nabla \cdot (\kappa \nabla u)\, v \,\mathrm{d}x
= \int_{\Omega} \kappa \nabla u \cdot \nabla v \,\mathrm{d}x
    -   \int_{\partial \Omega} \kappa \frac{\partial u}{\partial n} v \,\mathrm{d}s\]</span></p>
<p>On the Dirichlet part (<span class="math inline">\(\Gamma_D^i\)</span>), the boundary integral vanishes since <span class="math inline">\(v = 0\)</span>. On the remaining parts of the boundary, we split the contributions into the Neumann boundaries (<span class="math inline">\(\Gamma_N^j\)</span>) and the Robin boundaries (<span class="math inline">\(\Gamma_R^k\)</span>). Inserting the boundary conditions, we obtain</p>
<p><span class="math display">\[-\int_{\partial\Omega} \kappa \frac{\partial u}{\partial n} v \,\mathrm{d}s
= \sum_j \int_{\Gamma_N^j} g_j v \,\mathrm{d}s
    +   \sum_k \int_{\Gamma_R^k} r_k (u - s_k) v \,\mathrm{d}s\]</span></p>
<p>Thus, the variational problem can be written as</p>
<p><span class="math display">\[\begin{aligned}
F(u, v)
&amp;= \int_\Omega \kappa \nabla u \cdot \nabla v \,\mathrm{d}x
    +   \sum_j \int_{\Gamma_N^j} g_j v \,\mathrm{d}s \\
&amp;\quad + \sum_k \int_{\Gamma_R^k} r_k (u - s_k) v \,\mathrm{d}s
    -   \int_\Omega f v \,\mathrm{d}x = 0
\end{aligned}\]</span></p>
<p>We are accustomed to writing the variational formulation in the form <span class="math inline">\(a(u, v) = L(v)\)</span>. This requires identifying the integrals that depend on the trial function <span class="math inline">\(u\)</span> and collecting them in <span class="math inline">\(a(u, v)\)</span>, while the remaining terms form <span class="math inline">\(L(v)\)</span>. Note that the Robin condition contributes to both <span class="math inline">\(a(u, v)\)</span> and <span class="math inline">\(L(v)\)</span></p>
<p>Thus, we have</p>
<p><span class="math display">\[a(u, v) = \int_{\Omega} \kappa \nabla u \cdot \nabla v \,\mathrm{d}x
    +\sum_k \int_{\Gamma_R^k} r_k \, u \, v \,\mathrm{d}s\]</span></p>
<p><span class="math display">\[L(v) = \int_{\Omega} f \, v \,\mathrm{d}x
    -\sum_j \int_{\Gamma_N^j} g_j \, v \,\mathrm{d}s
    +\sum_k \int_{\Gamma_R^k} r_k \, s_k \, v \,\mathrm{d}s\]</span></p>
<p><strong>Implementation</strong></p>
<p>First, we define the domain <span class="math inline">\(\Omega\)</span> to be the unit square <span class="math inline">\([0,1] \times [0,1]\)</span></p>
<div id="9da57450" class="cell" data-execution_count="202">
<div class="sourceCode" id="cb232"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb232-1"><a href="#cb232-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb232-2"><a href="#cb232-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb232-3"><a href="#cb232-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb232-4"><a href="#cb232-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-5"><a href="#cb232-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> default_scalar_type</span>
<span id="cb232-6"><a href="#cb232-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.mesh <span class="im">import</span> create_unit_square, locate_entities, meshtags</span>
<span id="cb232-7"><a href="#cb232-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem <span class="im">import</span> (</span>
<span id="cb232-8"><a href="#cb232-8" aria-hidden="true" tabindex="-1"></a>  Constant, Function, functionspace, assemble_scalar, </span>
<span id="cb232-9"><a href="#cb232-9" aria-hidden="true" tabindex="-1"></a>  dirichletbc, form, locate_dofs_topological</span>
<span id="cb232-10"><a href="#cb232-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb232-11"><a href="#cb232-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> LinearProblem</span>
<span id="cb232-12"><a href="#cb232-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.io <span class="im">import</span> XDMFFile</span>
<span id="cb232-13"><a href="#cb232-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.plot <span class="im">import</span> vtk_mesh</span>
<span id="cb232-14"><a href="#cb232-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-15"><a href="#cb232-15" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ufl <span class="im">import</span> (</span>
<span id="cb232-16"><a href="#cb232-16" aria-hidden="true" tabindex="-1"></a>  FacetNormal, Measure, SpatialCoordinate, </span>
<span id="cb232-17"><a href="#cb232-17" aria-hidden="true" tabindex="-1"></a>  TestFunction, TrialFunction, </span>
<span id="cb232-18"><a href="#cb232-18" aria-hidden="true" tabindex="-1"></a>  div, dot, dx, grad, inner, lhs, rhs</span>
<span id="cb232-19"><a href="#cb232-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb232-20"><a href="#cb232-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb232-21"><a href="#cb232-21" aria-hidden="true" tabindex="-1"></a>mesh <span class="op">=</span> create_unit_square(MPI.COMM_WORLD, <span class="dv">10</span>, <span class="dv">10</span>)</span></code></pre></div>
</div>
<p>In this section, we solve the Poisson problem for the manufactured solution</p>
<p><span class="math display">\[u_{ex} = 1 + x^2 + 2y^2\]</span></p>
<p>which gives <span class="math inline">\(\kappa = 1\)</span> and <span class="math inline">\(f = -6\)</span>. The next step is to define the boundary condition parameters and specify where to apply them. In this example, we apply the following:</p>
<p><span class="math display">\[
\begin{aligned}
\phantom{-\kappa} u &amp;= u_D &amp;&amp;\quad \text{for } x=0,1\\[5pt]
-\kappa \frac{\partial u}{\partial n} &amp;= r(u - s) &amp;&amp;\quad \text{for } y=0\\
-\kappa \frac{\partial u}{\partial n} &amp;= g_0 &amp;&amp;\quad \text{for } y=1
\end{aligned}\]</span></p>
<p>To reproduce the analytical solution, we set</p>
<p><span class="math display">\[
\begin{aligned}
u_D &amp;= u_{ex} = 1 + x^2 + 2y^2 \\
g_0 &amp;= -\left.\frac{\partial u_{ex}}{\partial y}\right\vert_{y=1} = -4y \big\vert_{y=1} = -4
\end{aligned}\]</span></p>
<p>The Robin condition can be specified in many ways. Since</p>
<p><span class="math display">\[-\left.\frac{\partial u_{ex}}{\partial n}\right\vert_{y=0} = \left.\frac{\partial u_{ex}}{\partial y}\right\vert_{y=0} = 4y \big\vert_{y=0} = 0\]</span></p>
<p>we can choose <span class="math inline">\(r \neq 0\)</span> arbitrarily and set <span class="math inline">\(s = u_{ex}\)</span>. Here, we choose <span class="math inline">\(r = 1000\)</span></p>
<p>We can now define all the necessary variables and assemble the traditional part of the variational form</p>
<div id="ac04f0a3" class="cell" data-execution_count="203">
<div class="sourceCode" id="cb233"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb233-1"><a href="#cb233-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> SpatialCoordinate(mesh)</span>
<span id="cb233-2"><a href="#cb233-2" aria-hidden="true" tabindex="-1"></a>u_ex <span class="op">=</span> <span class="kw">lambda</span> x: <span class="dv">1</span> <span class="op">+</span>x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span><span class="dv">2</span><span class="op">*</span>x[<span class="dv">1</span>]<span class="op">**</span><span class="dv">2</span></span>
<span id="cb233-3"><a href="#cb233-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-4"><a href="#cb233-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Define physical parameters and boundary condtions</span></span>
<span id="cb233-5"><a href="#cb233-5" aria-hidden="true" tabindex="-1"></a>kappa <span class="op">=</span> Constant(mesh, default_scalar_type(<span class="dv">1</span>))</span>
<span id="cb233-6"><a href="#cb233-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-7"><a href="#cb233-7" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="op">-</span>div(grad(u_ex(x)))</span>
<span id="cb233-8"><a href="#cb233-8" aria-hidden="true" tabindex="-1"></a>n <span class="op">=</span> FacetNormal(mesh)</span>
<span id="cb233-9"><a href="#cb233-9" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> <span class="op">-</span>dot(n, grad(u_ex(x)))</span>
<span id="cb233-10"><a href="#cb233-10" aria-hidden="true" tabindex="-1"></a>s <span class="op">=</span> u_ex(x)</span>
<span id="cb233-11"><a href="#cb233-11" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> Constant(mesh, default_scalar_type(<span class="dv">1000</span>))</span>
<span id="cb233-12"><a href="#cb233-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-13"><a href="#cb233-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Define function space and standard part of variational form</span></span>
<span id="cb233-14"><a href="#cb233-14" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span>
<span id="cb233-15"><a href="#cb233-15" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> TrialFunction(V)</span>
<span id="cb233-16"><a href="#cb233-16" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> TestFunction(V)</span>
<span id="cb233-17"><a href="#cb233-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb233-18"><a href="#cb233-18" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> kappa <span class="op">*</span>inner(grad(u), grad(v)) <span class="op">*</span>dx <span class="op">-</span>inner(f, v) <span class="op">*</span>dx</span></code></pre></div>
</div>
<p>We begin by identifying the facets on each boundary and creating a custom integration measure, <code>ds</code></p>
<div id="b4cbe02b" class="cell" data-execution_count="204">
<div class="sourceCode" id="cb234"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb234-1"><a href="#cb234-1" aria-hidden="true" tabindex="-1"></a>boundaries <span class="op">=</span> [</span>
<span id="cb234-2"><a href="#cb234-2" aria-hidden="true" tabindex="-1"></a>  (<span class="dv">1</span>, <span class="kw">lambda</span> x: np.isclose(x[<span class="dv">0</span>], <span class="dv">0</span>)),</span>
<span id="cb234-3"><a href="#cb234-3" aria-hidden="true" tabindex="-1"></a>  (<span class="dv">2</span>, <span class="kw">lambda</span> x: np.isclose(x[<span class="dv">0</span>], <span class="dv">1</span>)),</span>
<span id="cb234-4"><a href="#cb234-4" aria-hidden="true" tabindex="-1"></a>  (<span class="dv">3</span>, <span class="kw">lambda</span> x: np.isclose(x[<span class="dv">1</span>], <span class="dv">0</span>)),</span>
<span id="cb234-5"><a href="#cb234-5" aria-hidden="true" tabindex="-1"></a>  (<span class="dv">4</span>, <span class="kw">lambda</span> x: np.isclose(x[<span class="dv">1</span>], <span class="dv">1</span>))</span>
<span id="cb234-6"><a href="#cb234-6" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
</div>
<p>Next, we go through each boundary condition and generate <code>MeshTags</code> that mark the corresponding facets</p>
<div id="67633171" class="cell" data-execution_count="205">
<div class="sourceCode" id="cb235"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb235-1"><a href="#cb235-1" aria-hidden="true" tabindex="-1"></a>facet_indices, facet_markers <span class="op">=</span> [], []</span>
<span id="cb235-2"><a href="#cb235-2" aria-hidden="true" tabindex="-1"></a>fdim <span class="op">=</span> mesh.topology.dim <span class="op">-</span><span class="dv">1</span></span>
<span id="cb235-3"><a href="#cb235-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-4"><a href="#cb235-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> (marker, locator) <span class="kw">in</span> boundaries:</span>
<span id="cb235-5"><a href="#cb235-5" aria-hidden="true" tabindex="-1"></a>  facets <span class="op">=</span> locate_entities(mesh, fdim, locator)</span>
<span id="cb235-6"><a href="#cb235-6" aria-hidden="true" tabindex="-1"></a>  facet_indices.append(facets)</span>
<span id="cb235-7"><a href="#cb235-7" aria-hidden="true" tabindex="-1"></a>  facet_markers.append(np.full_like(facets, marker))</span>
<span id="cb235-8"><a href="#cb235-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-9"><a href="#cb235-9" aria-hidden="true" tabindex="-1"></a>facet_indices <span class="op">=</span> np.hstack(facet_indices).astype(np.int32)</span>
<span id="cb235-10"><a href="#cb235-10" aria-hidden="true" tabindex="-1"></a>facet_markers <span class="op">=</span> np.hstack(facet_markers).astype(np.int32)</span>
<span id="cb235-11"><a href="#cb235-11" aria-hidden="true" tabindex="-1"></a>sorted_facets <span class="op">=</span> np.argsort(facet_indices)</span>
<span id="cb235-12"><a href="#cb235-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb235-13"><a href="#cb235-13" aria-hidden="true" tabindex="-1"></a>facet_tag <span class="op">=</span> meshtags(</span>
<span id="cb235-14"><a href="#cb235-14" aria-hidden="true" tabindex="-1"></a>  mesh, </span>
<span id="cb235-15"><a href="#cb235-15" aria-hidden="true" tabindex="-1"></a>  fdim, </span>
<span id="cb235-16"><a href="#cb235-16" aria-hidden="true" tabindex="-1"></a>  facet_indices[sorted_facets], </span>
<span id="cb235-17"><a href="#cb235-17" aria-hidden="true" tabindex="-1"></a>  facet_markers[sorted_facets]</span>
<span id="cb235-18"><a href="#cb235-18" aria-hidden="true" tabindex="-1"></a>)</span></code></pre></div>
</div>
<p><strong>Debugging boundary condition</strong></p>
<p>A simple way to debug boundary conditions is to visualize the boundaries in <code>ParaView</code>. We do this by writing the <code>MeshTags</code> to a file, after which individual boundaries can be examined using the <code>Threshold</code> filter</p>
<div id="ca61e716" class="cell" data-execution_count="206">
<div class="sourceCode" id="cb236"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb236-1"><a href="#cb236-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb236-2"><a href="#cb236-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb236-3"><a href="#cb236-3" aria-hidden="true" tabindex="-1"></a>results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/fundamentals&quot;</span>)</span>
<span id="cb236-4"><a href="#cb236-4" aria-hidden="true" tabindex="-1"></a>results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb236-5"><a href="#cb236-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb236-6"><a href="#cb236-6" aria-hidden="true" tabindex="-1"></a>mesh.topology.create_connectivity(mesh.topology.dim <span class="op">-</span><span class="dv">1</span>, mesh.topology.dim)</span>
<span id="cb236-7"><a href="#cb236-7" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> XDMFFile(mesh.comm, results_folder<span class="op">/</span><span class="st">&quot;facet_tags.xdmf&quot;</span>, <span class="st">&quot;w&quot;</span>) <span class="im">as</span> xdmf:</span>
<span id="cb236-8"><a href="#cb236-8" aria-hidden="true" tabindex="-1"></a>  xdmf.write_mesh(mesh)</span>
<span id="cb236-9"><a href="#cb236-9" aria-hidden="true" tabindex="-1"></a>  xdmf.write_meshtags(facet_tag, mesh.geometry)</span></code></pre></div>
</div>
<p>Next, we define a custom integration measure <code>ds</code>, which can be used to restrict integration to selected facets. Using <code>ds(1)</code> ensures that we integrate only over facets that have been assigned the value <code>1</code> in the corresponding <code>facet_tag</code></p>
<div id="d10fcf96" class="cell" data-execution_count="207">
<div class="sourceCode" id="cb237"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb237-1"><a href="#cb237-1" aria-hidden="true" tabindex="-1"></a>ds <span class="op">=</span> Measure(<span class="st">&quot;ds&quot;</span>, domain<span class="op">=</span>mesh, subdomain_data<span class="op">=</span>facet_tag)</span></code></pre></div>
</div>
<p>We define a general boundary condition class that can handle different types of boundary conditions</p>
<div id="3a843e58" class="cell" data-execution_count="208">
<div class="sourceCode" id="cb238"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb238-1"><a href="#cb238-1" aria-hidden="true" tabindex="-1"></a><span class="kw">class</span> BoundaryCondition():</span>
<span id="cb238-2"><a href="#cb238-2" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb238-3"><a href="#cb238-3" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="fu">__init__</span>(<span class="va">self</span>, BCtype, marker, values):</span>
<span id="cb238-4"><a href="#cb238-4" aria-hidden="true" tabindex="-1"></a>    <span class="va">self</span>._type <span class="op">=</span> BCtype</span>
<span id="cb238-5"><a href="#cb238-5" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> BCtype <span class="op">==</span> <span class="st">&quot;Dirichlet&quot;</span>:</span>
<span id="cb238-6"><a href="#cb238-6" aria-hidden="true" tabindex="-1"></a>      u_D <span class="op">=</span> Function(V)</span>
<span id="cb238-7"><a href="#cb238-7" aria-hidden="true" tabindex="-1"></a>      u_D.interpolate(values)</span>
<span id="cb238-8"><a href="#cb238-8" aria-hidden="true" tabindex="-1"></a>      facets <span class="op">=</span> facet_tag.find(marker)</span>
<span id="cb238-9"><a href="#cb238-9" aria-hidden="true" tabindex="-1"></a>      dofs <span class="op">=</span> locate_dofs_topological(V, fdim, facets)</span>
<span id="cb238-10"><a href="#cb238-10" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>._bc <span class="op">=</span> dirichletbc(u_D, dofs)</span>
<span id="cb238-11"><a href="#cb238-11" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> BCtype <span class="op">==</span> <span class="st">&quot;Neumann&quot;</span>:</span>
<span id="cb238-12"><a href="#cb238-12" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>._bc <span class="op">=</span> inner(values, v) <span class="op">*</span>ds(marker)</span>
<span id="cb238-13"><a href="#cb238-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">elif</span> BCtype <span class="op">==</span> <span class="st">&quot;Robin&quot;</span>:</span>
<span id="cb238-14"><a href="#cb238-14" aria-hidden="true" tabindex="-1"></a>      <span class="va">self</span>._bc <span class="op">=</span> values[<span class="dv">0</span>] <span class="op">*</span>inner(u <span class="op">-</span>values[<span class="dv">1</span>], v) <span class="op">*</span>ds(marker)</span>
<span id="cb238-15"><a href="#cb238-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb238-16"><a href="#cb238-16" aria-hidden="true" tabindex="-1"></a>      <span class="cf">raise</span> <span class="pp">TypeError</span>(<span class="ss">f&quot;Unknown boundary condition: </span><span class="sc">{</span>BCtype<span class="sc">:s}</span><span class="ss">&quot;</span>)</span>
<span id="cb238-17"><a href="#cb238-17" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb238-18"><a href="#cb238-18" aria-hidden="true" tabindex="-1"></a>  <span class="at">@property</span></span>
<span id="cb238-19"><a href="#cb238-19" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> bc(<span class="va">self</span>):</span>
<span id="cb238-20"><a href="#cb238-20" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">self</span>._bc</span>
<span id="cb238-21"><a href="#cb238-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb238-22"><a href="#cb238-22" aria-hidden="true" tabindex="-1"></a>  <span class="at">@property</span></span>
<span id="cb238-23"><a href="#cb238-23" aria-hidden="true" tabindex="-1"></a>  <span class="kw">def</span> <span class="bu">type</span>(<span class="va">self</span>):</span>
<span id="cb238-24"><a href="#cb238-24" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="va">self</span>._type</span>
<span id="cb238-25"><a href="#cb238-25" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb238-26"><a href="#cb238-26" aria-hidden="true" tabindex="-1"></a><span class="co"># Define the Dirichlet, Neumann, and Robin conditions</span></span>
<span id="cb238-27"><a href="#cb238-27" aria-hidden="true" tabindex="-1"></a>boundary_conditions <span class="op">=</span> [</span>
<span id="cb238-28"><a href="#cb238-28" aria-hidden="true" tabindex="-1"></a>  BoundaryCondition(<span class="st">&quot;Dirichlet&quot;</span>, <span class="dv">1</span>, u_ex),</span>
<span id="cb238-29"><a href="#cb238-29" aria-hidden="true" tabindex="-1"></a>  BoundaryCondition(<span class="st">&quot;Dirichlet&quot;</span>, <span class="dv">2</span>, u_ex),</span>
<span id="cb238-30"><a href="#cb238-30" aria-hidden="true" tabindex="-1"></a>  BoundaryCondition(<span class="st">&quot;Robin&quot;</span>, <span class="dv">3</span>, (r, s)),</span>
<span id="cb238-31"><a href="#cb238-31" aria-hidden="true" tabindex="-1"></a>  BoundaryCondition(<span class="st">&quot;Neumann&quot;</span>, <span class="dv">4</span>, g)</span>
<span id="cb238-32"><a href="#cb238-32" aria-hidden="true" tabindex="-1"></a>]</span></code></pre></div>
</div>
<p>Next, we go through each boundary condition and add it to <span class="math inline">\(L(v)\)</span> or include it in the list of Dirichlet boundary conditions, depending on its type</p>
<div id="e2756978" class="cell" data-execution_count="209">
<div class="sourceCode" id="cb239"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb239-1"><a href="#cb239-1" aria-hidden="true" tabindex="-1"></a>bcs <span class="op">=</span> []</span>
<span id="cb239-2"><a href="#cb239-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> condition <span class="kw">in</span> boundary_conditions:</span>
<span id="cb239-3"><a href="#cb239-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> condition.<span class="bu">type</span> <span class="op">==</span> <span class="st">&quot;Dirichlet&quot;</span>:</span>
<span id="cb239-4"><a href="#cb239-4" aria-hidden="true" tabindex="-1"></a>    bcs.append(condition.bc)</span>
<span id="cb239-5"><a href="#cb239-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb239-6"><a href="#cb239-6" aria-hidden="true" tabindex="-1"></a>    F <span class="op">+=</span> condition.bc</span></code></pre></div>
</div>
<p>We can now create the bilinear form <span class="math inline">\(a\)</span> and the linear form <span class="math inline">\(L\)</span> using the <code>ufl</code> functions <code>lhs</code> and <code>rhs</code></p>
<div id="78f13654" class="cell" data-execution_count="210">
<div class="sourceCode" id="cb240"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb240-1"><a href="#cb240-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Solve linear variational problem</span></span>
<span id="cb240-2"><a href="#cb240-2" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> lhs(F)</span>
<span id="cb240-3"><a href="#cb240-3" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> rhs(F)</span>
<span id="cb240-4"><a href="#cb240-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb240-5"><a href="#cb240-5" aria-hidden="true" tabindex="-1"></a>problem <span class="op">=</span> LinearProblem(</span>
<span id="cb240-6"><a href="#cb240-6" aria-hidden="true" tabindex="-1"></a>  a, </span>
<span id="cb240-7"><a href="#cb240-7" aria-hidden="true" tabindex="-1"></a>  L, </span>
<span id="cb240-8"><a href="#cb240-8" aria-hidden="true" tabindex="-1"></a>  bcs<span class="op">=</span>bcs, </span>
<span id="cb240-9"><a href="#cb240-9" aria-hidden="true" tabindex="-1"></a>  petsc_options<span class="op">=</span>{<span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;preonly&quot;</span>, <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;lu&quot;</span>}</span>
<span id="cb240-10"><a href="#cb240-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb240-11"><a href="#cb240-11" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> problem.solve()</span></code></pre></div>
</div>
<div id="90dd6592" class="cell" data-execution_count="211">
<div class="sourceCode" id="cb241"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb241-1"><a href="#cb241-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb241-2"><a href="#cb241-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-3"><a href="#cb241-3" aria-hidden="true" tabindex="-1"></a>results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/bcs_subdomains&quot;</span>)</span>
<span id="cb241-4"><a href="#cb241-4" aria-hidden="true" tabindex="-1"></a>results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb241-5"><a href="#cb241-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-6"><a href="#cb241-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Visualize solution</span></span>
<span id="cb241-7"><a href="#cb241-7" aria-hidden="true" tabindex="-1"></a>pyvista_cells, cell_types, geometry <span class="op">=</span> vtk_mesh(V)</span>
<span id="cb241-8"><a href="#cb241-8" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> pyvista.UnstructuredGrid(pyvista_cells, cell_types, geometry)</span>
<span id="cb241-9"><a href="#cb241-9" aria-hidden="true" tabindex="-1"></a>grid.point_data[<span class="st">&quot;u&quot;</span>] <span class="op">=</span> uh.x.array</span>
<span id="cb241-10"><a href="#cb241-10" aria-hidden="true" tabindex="-1"></a>grid.set_active_scalars(<span class="st">&quot;u&quot;</span>)</span>
<span id="cb241-11"><a href="#cb241-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-12"><a href="#cb241-12" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb241-13"><a href="#cb241-13" aria-hidden="true" tabindex="-1"></a>plotter.add_text(<span class="st">&quot;uh&quot;</span>, position<span class="op">=</span><span class="st">&quot;upper_edge&quot;</span>, font_size<span class="op">=</span><span class="dv">14</span>, color<span class="op">=</span><span class="st">&quot;black&quot;</span>)</span>
<span id="cb241-14"><a href="#cb241-14" aria-hidden="true" tabindex="-1"></a>plotter.add_mesh(grid, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb241-15"><a href="#cb241-15" aria-hidden="true" tabindex="-1"></a>plotter.view_xy()</span>
<span id="cb241-16"><a href="#cb241-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb241-17"><a href="#cb241-17" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> pyvista.OFF_SCREEN:</span>
<span id="cb241-18"><a href="#cb241-18" aria-hidden="true" tabindex="-1"></a>  <span class="co">#plotter.show()</span></span>
<span id="cb241-19"><a href="#cb241-19" aria-hidden="true" tabindex="-1"></a>  plotter.export_html(results_folder<span class="op">/</span><span class="st">&quot;robin_neumann_dirichlet.html&quot;</span>)</span>
<span id="cb241-20"><a href="#cb241-20" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb241-21"><a href="#cb241-21" aria-hidden="true" tabindex="-1"></a>  figure <span class="op">=</span> plotter.screenshot(results_folder<span class="op">/</span><span class="st">&quot;robin_neumann_dirichlet.png&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/bcs_subdomains/robin_neumann_dirichlet.html"
        width="100%" height="400px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
<p><strong>Verification</strong></p>
<p>Following the approach used in the previous problems, we calculate the error of the computed solution and compare it to the analytical solution</p>
<div id="93e6f5e3" class="cell" data-execution_count="212">
<div class="sourceCode" id="cb242"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb242-1"><a href="#cb242-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Compute L2 error and error at nodes</span></span>
<span id="cb242-2"><a href="#cb242-2" aria-hidden="true" tabindex="-1"></a>V_ex <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">2</span>))</span>
<span id="cb242-3"><a href="#cb242-3" aria-hidden="true" tabindex="-1"></a>u_exact <span class="op">=</span> Function(V_ex)</span>
<span id="cb242-4"><a href="#cb242-4" aria-hidden="true" tabindex="-1"></a>u_exact.interpolate(u_ex)</span>
<span id="cb242-5"><a href="#cb242-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb242-6"><a href="#cb242-6" aria-hidden="true" tabindex="-1"></a>error_L2 <span class="op">=</span> np.sqrt(</span>
<span id="cb242-7"><a href="#cb242-7" aria-hidden="true" tabindex="-1"></a>  mesh.comm.allreduce(</span>
<span id="cb242-8"><a href="#cb242-8" aria-hidden="true" tabindex="-1"></a>    assemble_scalar(form((uh <span class="op">-</span>u_exact)<span class="op">**</span><span class="dv">2</span> <span class="op">*</span>dx)), </span>
<span id="cb242-9"><a href="#cb242-9" aria-hidden="true" tabindex="-1"></a>    op<span class="op">=</span>MPI.SUM</span>
<span id="cb242-10"><a href="#cb242-10" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb242-11"><a href="#cb242-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb242-12"><a href="#cb242-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb242-13"><a href="#cb242-13" aria-hidden="true" tabindex="-1"></a>u_vertex_values <span class="op">=</span> uh.x.array</span>
<span id="cb242-14"><a href="#cb242-14" aria-hidden="true" tabindex="-1"></a>uex_1 <span class="op">=</span> Function(V)</span>
<span id="cb242-15"><a href="#cb242-15" aria-hidden="true" tabindex="-1"></a>uex_1.interpolate(u_ex)</span>
<span id="cb242-16"><a href="#cb242-16" aria-hidden="true" tabindex="-1"></a>u_ex_vertex_values <span class="op">=</span> uex_1.x.array</span>
<span id="cb242-17"><a href="#cb242-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb242-18"><a href="#cb242-18" aria-hidden="true" tabindex="-1"></a>error_max <span class="op">=</span> np.<span class="bu">max</span>(np.<span class="bu">abs</span>(u_vertex_values <span class="op">-</span>u_ex_vertex_values))</span>
<span id="cb242-19"><a href="#cb242-19" aria-hidden="true" tabindex="-1"></a>error_max <span class="op">=</span> mesh.comm.allreduce(error_max, op<span class="op">=</span>MPI.MAX)</span>
<span id="cb242-20"><a href="#cb242-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb242-21"><a href="#cb242-21" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Error_L2 : </span><span class="sc">{</span>error_L2<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span>
<span id="cb242-22"><a href="#cb242-22" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Error_max : </span><span class="sc">{</span>error_max<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Error_L2 : 4.86e-03
Error_max : 2.07e-03</code></pre>
</div>
</div>
</section>
<section id="component-wise-dirichlet-bc" class="level3" data-number="K.8.5">
<h3 data-number="K.8.5"><span class="header-section-number">K.8.5</span> Component-wise Dirichlet BC</h3>
<p>Author: Jørgen S. Dokken</p>
<p>We consider the linear elasticity problem on the rectangular domain <span class="math inline">\(\Omega=[0,L]\times[0,H]\)</span> with displacement <span class="math inline">\(u=(u_x,u_y)\)</span>. The strong form with the boundary conditions is</p>
<p><span class="math display">\[
\begin{aligned}
-\,\nabla\cdot\sigma(u) &amp;= f &amp;&amp;\quad\text{in }\Omega\\[2mm]
u &amp;= 0 &amp;&amp;\quad\text{on }\partial \Omega_{\text{bottom}}\\[2mm]
u_x &amp;= 0, \;\sigma(u_y) \cdot n_y = 0 &amp;&amp;\quad\text{on }\partial\Omega_{\text{right}} \\[2mm]
\sigma(u)\cdot n &amp;= 0 &amp;&amp;\quad\text{on }\partial\Omega_{\text{rest}}
\end{aligned}\]</span></p>
<p>where the stress and strain are given by</p>
<p><span class="math display">\[\begin{aligned}
\sigma(u) &amp;= \lambda\,\mathrm{tr}(\epsilon(u))\,I + 2\mu\,\epsilon(u)\\[2mm]
\epsilon(u) &amp;= \tfrac{1}{2}\big(\nabla u + \nabla u^T\big)
\end{aligned}\]</span></p>
<p><strong>Physical interpretation</strong></p>
<ul>
<li><p><span class="math inline">\(\partial \Omega_{\text{bottom}}\)</span>: The boundary is fully clamped, meaning both displacement components vanish</p></li>
<li><p><span class="math inline">\(\partial\Omega_{\text{right}}\)</span>: Only the horizontal displacement is constrained, while the vertical displacement <span class="math inline">\(u_y\)</span> is left free</p></li>
<li><p><span class="math inline">\(\partial\Omega_{\text{rest}}\)</span>: These boundaries are traction-free</p></li>
</ul>
<p>The chosen combination of boundary conditions eliminates possible rigid body motions. This ensures that the variational problem admits a unique solution, i.e. the problem is well-posed</p>
<p><strong>Variational formulation</strong></p>
<p>We now turn to the weak form of the elasticity problem. Multiplying the PDE by a test function <span class="math inline">\(v\)</span> and integrating by parts yields the variational form</p>
<p><span class="math display">\[a(u,v) = L(v)\]</span></p>
<p>where</p>
<p><span class="math display">\[\begin{aligned}
a(u,v) &amp;= \int_\Omega \sigma(u):\epsilon(v) \,\mathrm{d}x \\
L(v) &amp;= \int_\Omega f \cdot v \,\mathrm{d}x
\end{aligned}\]</span></p>
<p>Note that the Neumann boundary conditions on <span class="math inline">\(\Gamma_N\)</span> (traction-free boundaries) are naturally included in the weak formulation, and therefore do not need to be imposed explicitly</p>
<div id="16d4505a" class="cell" data-execution_count="213">
<div class="sourceCode" id="cb244"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb244-1"><a href="#cb244-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb244-2"><a href="#cb244-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb244-3"><a href="#cb244-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb244-4"><a href="#cb244-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-5"><a href="#cb244-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> default_scalar_type</span>
<span id="cb244-6"><a href="#cb244-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.mesh <span class="im">import</span> CellType, create_rectangle, locate_entities_boundary</span>
<span id="cb244-7"><a href="#cb244-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem <span class="im">import</span> (</span>
<span id="cb244-8"><a href="#cb244-8" aria-hidden="true" tabindex="-1"></a>  Constant, dirichletbc, Function, functionspace, </span>
<span id="cb244-9"><a href="#cb244-9" aria-hidden="true" tabindex="-1"></a>  locate_dofs_geometrical, locate_dofs_topological</span>
<span id="cb244-10"><a href="#cb244-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb244-11"><a href="#cb244-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> LinearProblem</span>
<span id="cb244-12"><a href="#cb244-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.plot <span class="im">import</span> vtk_mesh</span>
<span id="cb244-13"><a href="#cb244-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-14"><a href="#cb244-14" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> petsc4py <span class="im">import</span> PETSc</span>
<span id="cb244-15"><a href="#cb244-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-16"><a href="#cb244-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ufl <span class="im">import</span> (</span>
<span id="cb244-17"><a href="#cb244-17" aria-hidden="true" tabindex="-1"></a>  Identity, Measure, TestFunction, TrialFunction, </span>
<span id="cb244-18"><a href="#cb244-18" aria-hidden="true" tabindex="-1"></a>  dot, dx, inner, grad, nabla_div, sym</span>
<span id="cb244-19"><a href="#cb244-19" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb244-20"><a href="#cb244-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-21"><a href="#cb244-21" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb244-22"><a href="#cb244-22" aria-hidden="true" tabindex="-1"></a>H <span class="op">=</span> <span class="fl">1.3</span></span>
<span id="cb244-23"><a href="#cb244-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb244-24"><a href="#cb244-24" aria-hidden="true" tabindex="-1"></a>lambda_ <span class="op">=</span> <span class="fl">1.25</span></span>
<span id="cb244-25"><a href="#cb244-25" aria-hidden="true" tabindex="-1"></a>mu <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb244-26"><a href="#cb244-26" aria-hidden="true" tabindex="-1"></a>rho <span class="op">=</span> <span class="dv">1</span></span>
<span id="cb244-27"><a href="#cb244-27" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> <span class="dv">1</span></span></code></pre></div>
</div>
<p>As in the previous demos, we begin by defining the computational mesh and the corresponding function space. The function space is chosen to represent vector-valued functions, since the unknown displacement field <span class="math inline">\(u = (u_x, u_y)\)</span> has two components</p>
<div id="43cac3de" class="cell" data-execution_count="214">
<div class="sourceCode" id="cb245"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb245-1"><a href="#cb245-1" aria-hidden="true" tabindex="-1"></a>mesh <span class="op">=</span> create_rectangle(</span>
<span id="cb245-2"><a href="#cb245-2" aria-hidden="true" tabindex="-1"></a>  MPI.COMM_WORLD, </span>
<span id="cb245-3"><a href="#cb245-3" aria-hidden="true" tabindex="-1"></a>  np.array([[<span class="dv">0</span>, <span class="dv">0</span>], [L, H]]), </span>
<span id="cb245-4"><a href="#cb245-4" aria-hidden="true" tabindex="-1"></a>  [<span class="dv">30</span>, <span class="dv">30</span>], </span>
<span id="cb245-5"><a href="#cb245-5" aria-hidden="true" tabindex="-1"></a>  cell_type<span class="op">=</span>CellType.triangle,</span>
<span id="cb245-6"><a href="#cb245-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb245-7"><a href="#cb245-7" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>, (mesh.geometry.dim,)))</span></code></pre></div>
</div>
<p><strong>Boundary conditions</strong></p>
<p>Next, we define the boundary conditions for our problem</p>
<div id="67a8e9a9" class="cell" data-execution_count="215">
<div class="sourceCode" id="cb246"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb246-1"><a href="#cb246-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define geometric tolerance</span></span>
<span id="cb246-2"><a href="#cb246-2" aria-hidden="true" tabindex="-1"></a>tol <span class="op">=</span> <span class="fl">1e-8</span></span>
<span id="cb246-3"><a href="#cb246-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-4"><a href="#cb246-4" aria-hidden="true" tabindex="-1"></a><span class="co"># Locate boundary facets</span></span>
<span id="cb246-5"><a href="#cb246-5" aria-hidden="true" tabindex="-1"></a>bottom_facets <span class="op">=</span> locate_entities_boundary(</span>
<span id="cb246-6"><a href="#cb246-6" aria-hidden="true" tabindex="-1"></a>  mesh, </span>
<span id="cb246-7"><a href="#cb246-7" aria-hidden="true" tabindex="-1"></a>  mesh.topology.dim <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb246-8"><a href="#cb246-8" aria-hidden="true" tabindex="-1"></a>  <span class="kw">lambda</span> x: np.isclose(x[<span class="dv">1</span>], <span class="fl">0.0</span>, atol<span class="op">=</span>tol)</span>
<span id="cb246-9"><a href="#cb246-9" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb246-10"><a href="#cb246-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-11"><a href="#cb246-11" aria-hidden="true" tabindex="-1"></a>right_facets <span class="op">=</span> locate_entities_boundary(</span>
<span id="cb246-12"><a href="#cb246-12" aria-hidden="true" tabindex="-1"></a>  mesh, </span>
<span id="cb246-13"><a href="#cb246-13" aria-hidden="true" tabindex="-1"></a>  mesh.topology.dim <span class="op">-</span><span class="dv">1</span>,</span>
<span id="cb246-14"><a href="#cb246-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">lambda</span> x: np.isclose(x[<span class="dv">0</span>], L, atol<span class="op">=</span>tol)</span>
<span id="cb246-15"><a href="#cb246-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb246-16"><a href="#cb246-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-17"><a href="#cb246-17" aria-hidden="true" tabindex="-1"></a><span class="co"># Define boundary conditions</span></span>
<span id="cb246-18"><a href="#cb246-18" aria-hidden="true" tabindex="-1"></a>u_bc <span class="op">=</span> Function(V)</span>
<span id="cb246-19"><a href="#cb246-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-20"><a href="#cb246-20" aria-hidden="true" tabindex="-1"></a><span class="co"># Γ_D (bottom): u = (0,0)</span></span>
<span id="cb246-21"><a href="#cb246-21" aria-hidden="true" tabindex="-1"></a>bc_bottom <span class="op">=</span> dirichletbc(</span>
<span id="cb246-22"><a href="#cb246-22" aria-hidden="true" tabindex="-1"></a>  PETSc.ScalarType((<span class="fl">0.0</span>, <span class="fl">0.0</span>)), </span>
<span id="cb246-23"><a href="#cb246-23" aria-hidden="true" tabindex="-1"></a>  locate_dofs_topological(V, mesh.topology.dim <span class="op">-</span><span class="dv">1</span>, bottom_facets), </span>
<span id="cb246-24"><a href="#cb246-24" aria-hidden="true" tabindex="-1"></a>  V</span>
<span id="cb246-25"><a href="#cb246-25" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb246-26"><a href="#cb246-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-27"><a href="#cb246-27" aria-hidden="true" tabindex="-1"></a><span class="co"># Γ_{Dx} (right): u_x = 0</span></span>
<span id="cb246-28"><a href="#cb246-28" aria-hidden="true" tabindex="-1"></a>bc_right_x <span class="op">=</span> dirichletbc(</span>
<span id="cb246-29"><a href="#cb246-29" aria-hidden="true" tabindex="-1"></a>  PETSc.ScalarType(<span class="fl">0.0</span>),</span>
<span id="cb246-30"><a href="#cb246-30" aria-hidden="true" tabindex="-1"></a>  locate_dofs_topological(V.sub(<span class="dv">0</span>), mesh.topology.dim <span class="op">-</span><span class="dv">1</span>, right_facets),</span>
<span id="cb246-31"><a href="#cb246-31" aria-hidden="true" tabindex="-1"></a>  V.sub(<span class="dv">0</span>)</span>
<span id="cb246-32"><a href="#cb246-32" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb246-33"><a href="#cb246-33" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb246-34"><a href="#cb246-34" aria-hidden="true" tabindex="-1"></a><span class="co"># Collect Dirichlet boundary conditions</span></span>
<span id="cb246-35"><a href="#cb246-35" aria-hidden="true" tabindex="-1"></a>bcs <span class="op">=</span> [bc_bottom, bc_right_x]</span></code></pre></div>
</div>
<p>Note that the traction-free boundaries <span class="math inline">\(\Gamma_N\)</span> do not require explicit constraints in the variational formulation, since they are naturally included through the weak form of the problem</p>
<div id="c6d660bd" class="cell" data-execution_count="216">
<div class="sourceCode" id="cb247"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb247-1"><a href="#cb247-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Strain and stress</span></span>
<span id="cb247-2"><a href="#cb247-2" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> epsilon(u):</span>
<span id="cb247-3"><a href="#cb247-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> sym(grad(u))</span>
<span id="cb247-4"><a href="#cb247-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-5"><a href="#cb247-5" aria-hidden="true" tabindex="-1"></a><span class="co"># linear problem: tr(epsilon(u)) = nabla_div(u)</span></span>
<span id="cb247-6"><a href="#cb247-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> sigma(u):</span>
<span id="cb247-7"><a href="#cb247-7" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> lambda_ <span class="op">*</span>nabla_div(u) <span class="op">*</span>Identity(<span class="bu">len</span>(u)) <span class="op">+</span> <span class="dv">2</span> <span class="op">*</span>mu <span class="op">*</span>epsilon(u)</span>
<span id="cb247-8"><a href="#cb247-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-9"><a href="#cb247-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Body force</span></span>
<span id="cb247-10"><a href="#cb247-10" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> Constant(mesh, default_scalar_type((<span class="dv">0</span>, <span class="op">-</span>rho <span class="op">*</span>g)))</span>
<span id="cb247-11"><a href="#cb247-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-12"><a href="#cb247-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Define trial and test functions</span></span>
<span id="cb247-13"><a href="#cb247-13" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> TrialFunction(V)</span>
<span id="cb247-14"><a href="#cb247-14" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> TestFunction(V)</span>
<span id="cb247-15"><a href="#cb247-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb247-16"><a href="#cb247-16" aria-hidden="true" tabindex="-1"></a><span class="co"># Bilinear form and linear form</span></span>
<span id="cb247-17"><a href="#cb247-17" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> inner(sigma(u), epsilon(v)) <span class="op">*</span>dx</span>
<span id="cb247-18"><a href="#cb247-18" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> dot(f, v) <span class="op">*</span>dx  <span class="co"># +dot(T, v) *ds</span></span></code></pre></div>
</div>
<p>As in the previous demos, we now assemble the system matrix and right-hand side vector, and then use <code>PETSc</code> to solve the resulting variational problem</p>
<div id="ba71e410" class="cell" data-execution_count="217">
<div class="sourceCode" id="cb248"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb248-1"><a href="#cb248-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Define linear problem using PETSc</span></span>
<span id="cb248-2"><a href="#cb248-2" aria-hidden="true" tabindex="-1"></a>problem <span class="op">=</span> LinearProblem(</span>
<span id="cb248-3"><a href="#cb248-3" aria-hidden="true" tabindex="-1"></a>  a, </span>
<span id="cb248-4"><a href="#cb248-4" aria-hidden="true" tabindex="-1"></a>  L, </span>
<span id="cb248-5"><a href="#cb248-5" aria-hidden="true" tabindex="-1"></a>  bcs<span class="op">=</span>bcs,</span>
<span id="cb248-6"><a href="#cb248-6" aria-hidden="true" tabindex="-1"></a>  petsc_options<span class="op">=</span>{</span>
<span id="cb248-7"><a href="#cb248-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;preonly&quot;</span>,</span>
<span id="cb248-8"><a href="#cb248-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;lu&quot;</span></span>
<span id="cb248-9"><a href="#cb248-9" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb248-10"><a href="#cb248-10" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb248-11"><a href="#cb248-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-12"><a href="#cb248-12" aria-hidden="true" tabindex="-1"></a><span class="co"># Solve the system</span></span>
<span id="cb248-13"><a href="#cb248-13" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> problem.solve()</span>
<span id="cb248-14"><a href="#cb248-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb248-15"><a href="#cb248-15" aria-hidden="true" tabindex="-1"></a><span class="co"># Print solver information</span></span>
<span id="cb248-16"><a href="#cb248-16" aria-hidden="true" tabindex="-1"></a>PETSc.Sys.Print(<span class="st">&quot;Linear system solved.&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Linear system solved.</code></pre>
</div>
</div>
<p><strong>Visualization</strong></p>
<div id="c1bca0d5" class="cell" data-execution_count="218">
<div class="sourceCode" id="cb250"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb250-1"><a href="#cb250-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb250-2"><a href="#cb250-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-3"><a href="#cb250-3" aria-hidden="true" tabindex="-1"></a>results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/bcs_subdomains&quot;</span>)</span>
<span id="cb250-4"><a href="#cb250-4" aria-hidden="true" tabindex="-1"></a>results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb250-5"><a href="#cb250-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-6"><a href="#cb250-6" aria-hidden="true" tabindex="-1"></a>topology, cell_types, x <span class="op">=</span> vtk_mesh(V)</span>
<span id="cb250-7"><a href="#cb250-7" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> pyvista.UnstructuredGrid(topology, cell_types, x)</span>
<span id="cb250-8"><a href="#cb250-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-9"><a href="#cb250-9" aria-hidden="true" tabindex="-1"></a>vals <span class="op">=</span> np.zeros((x.shape[<span class="dv">0</span>], <span class="dv">3</span>))</span>
<span id="cb250-10"><a href="#cb250-10" aria-hidden="true" tabindex="-1"></a>vals[:, :<span class="bu">len</span>(uh)] <span class="op">=</span> uh.x.array.reshape((x.shape[<span class="dv">0</span>], <span class="bu">len</span>(uh)))</span>
<span id="cb250-11"><a href="#cb250-11" aria-hidden="true" tabindex="-1"></a>grid[<span class="st">&quot;u&quot;</span>] <span class="op">=</span> vals</span>
<span id="cb250-12"><a href="#cb250-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-13"><a href="#cb250-13" aria-hidden="true" tabindex="-1"></a><span class="co"># Create plotter and pyvista grid</span></span>
<span id="cb250-14"><a href="#cb250-14" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb250-15"><a href="#cb250-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-16"><a href="#cb250-16" aria-hidden="true" tabindex="-1"></a>actor_0 <span class="op">=</span> plotter.add_mesh(grid, style<span class="op">=</span><span class="st">&quot;wireframe&quot;</span>, color<span class="op">=</span><span class="st">&quot;k&quot;</span>)</span>
<span id="cb250-17"><a href="#cb250-17" aria-hidden="true" tabindex="-1"></a>warped <span class="op">=</span> grid.warp_by_vector(<span class="st">&quot;u&quot;</span>, factor<span class="op">=</span><span class="fl">1.1</span>)</span>
<span id="cb250-18"><a href="#cb250-18" aria-hidden="true" tabindex="-1"></a>actor_1 <span class="op">=</span> plotter.add_mesh(warped, opacity<span class="op">=</span><span class="fl">0.8</span>)</span>
<span id="cb250-19"><a href="#cb250-19" aria-hidden="true" tabindex="-1"></a>plotter.view_xy()</span>
<span id="cb250-20"><a href="#cb250-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb250-21"><a href="#cb250-21" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> pyvista.OFF_SCREEN:</span>
<span id="cb250-22"><a href="#cb250-22" aria-hidden="true" tabindex="-1"></a>  <span class="co">##p.show()</span></span>
<span id="cb250-23"><a href="#cb250-23" aria-hidden="true" tabindex="-1"></a>  plotter.export_html(results_folder<span class="op">/</span><span class="st">&quot;component.html&quot;</span>)</span>
<span id="cb250-24"><a href="#cb250-24" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb250-25"><a href="#cb250-25" aria-hidden="true" tabindex="-1"></a>  fig_array <span class="op">=</span> plotter.screenshot(results_folder<span class="op">/</span><span class="st">&quot;component.png&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/bcs_subdomains/component.html"
        width="100%" height="400px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
</section>
<section id="electromagnetics-example" class="level3" data-number="K.8.6">
<h3 data-number="K.8.6"><span class="header-section-number">K.8.6</span> Electromagnetics example</h3>
<p>Author: Hans Petter Langtangen, Anders Logg and Jørgen S. Dokken</p>
<p>In this example, we consider an iron cylinder with copper wires wound around it, as illustrated below</p>
<p><img src="figures/fenicsx_wire.png" class="img-fluid" /></p>
<p>A static current of <span class="math inline">\(J = 1\,\text{A}\)</span> flows through the copper wires. Our goal is to compute the magnetic field <span class="math inline">\(B\)</span> in the iron cylinder, the copper wires, and the surrounding vacuum</p>
<p>To simplify the problem, we note that the cylinder extends far in the <span class="math inline">\(z\)</span>-direction, so the field can be assumed to be independent of the <span class="math inline">\(z\)</span>-coordinate. This reduces the problem to a two-dimensional cross-section in the <span class="math inline">\(x\)</span>–<span class="math inline">\(y\)</span> plane</p>
<p>We begin with Maxwell’s equations in magnetostatics:</p>
<p><span class="math display">\[\nabla \cdot \mathbf{B} = 0, \quad \nabla \times \mathbf{H} = \mathbf{J}
\]</span></p>
<p>where <span class="math inline">\(\mathbf{B}\)</span> is the magnetic flux density, <span class="math inline">\(\mathbf{H}\)</span> is the magnetic field intensity, and <span class="math inline">\(\mathbf{J}\)</span> is the current density. The constitutive relation connects <span class="math inline">\(\mathbf{B}\)</span> and <span class="math inline">\(\mathbf{H}\)</span>:</p>
<p><span class="math display">\[\mathbf{B} = \mu \mathbf{H}\]</span></p>
<p>with <span class="math inline">\(\mu\)</span> denoting the magnetic permeability of the medium</p>
<p><strong>Step 1:</strong> Introducing the Vector Potential</p>
<p>Since <span class="math inline">\(\nabla \cdot \mathbf{B} = 0\)</span>, we may represent the magnetic flux density using a vector potential <span class="math inline">\(\mathbf{A}\)</span>:</p>
<p><span class="math display">\[\mathbf{B} = \nabla \times \mathbf{A}\]</span></p>
<p><strong>Step 2:</strong> Substituting into Ampère’s Law</p>
<p>Using <span class="math inline">\(\mathbf{B} = \mu \mathbf{H}\)</span>, Ampère’s law becomes</p>
<p><span class="math display">\[\nabla \times \left(\frac{1}{\mu} \nabla \times \mathbf{A}\right) = \mathbf{J}\]</span></p>
<p><strong>Step 3:</strong> Reduction to 2D</p>
<p>For a long cylinder aligned with the <span class="math inline">\(z\)</span>-axis and a current flowing along <span class="math inline">\(z\)</span>, symmetry implies that the vector potential has only a <span class="math inline">\(z\)</span>-component:</p>
<p><span class="math display">\[\mathbf{A}(x,y) = (0,0, A_z(x,y))\]</span></p>
<p>Thus, the magnetic flux density lies in the <span class="math inline">\(x\)</span>-<span class="math inline">\(y\)</span> plane</p>
<p><strong>Step 4:</strong> Scalar Poisson Equation</p>
<p>With this reduction, the vector equation simplifies to a scalar Poisson equation for <span class="math inline">\(A_z\)</span>:</p>
<p><span class="math display">\[-\nabla \cdot \left(\frac{1}{\mu} \nabla A_z\right) = J_z\]</span></p>
<p><span class="math display">\[\lim_{\vert(x,y)\vert\to \infty}A_z = 0\]</span></p>
<p>where <span class="math inline">\(J_z\)</span> is the <span class="math inline">\(z\)</span>-component of the current density. Once <span class="math inline">\(A_z\)</span> is known, the magnetic field can be recovered as</p>
<p><span class="math display">\[\mathbf{B} = \nabla \times \mathbf{A} =
\left(\frac{\partial A_z}{\partial y}, \; -\frac{\partial A_z}{\partial x}, \; 0 \right)\]</span></p>
<p>Since we cannot compute on an infinite domain, we truncate the problem by surrounding the cylinder with a sufficiently large disk. On the boundary of this disk, we impose the condition <span class="math inline">\(A_z = 0\)</span></p>
<p>The current density <span class="math inline">\(J_z\)</span> is prescribed inside the circular cross-sections of the copper wires. In the interior set of circles, we assign a current of <span class="math inline">\(+1\,\mathrm{A}\)</span>, while in the exterior set of circles, we assign a current of <span class="math inline">\(-1\,\mathrm{A}\)</span>. This ensures that the net current in the domain is balanced, making the problem well-posed and allowing for a consistent computation of the magnetic field throughout the iron, copper, and vacuum regions</p>
<p><strong>Variational formulation</strong></p>
<p>To derive the variational problem, we multiply the governing PDE by a test function <span class="math inline">\(v\)</span> and integrate over the computational domain <span class="math inline">\(\Omega\)</span>:</p>
<p><span class="math display">\[-\int_\Omega \nabla \cdot \left( \mu^{-1} \nabla A_z \right) v \,\mathrm{d}x = \int_\Omega J_z v \,\mathrm{d}x\]</span></p>
<p>Applying integration by parts (Green’s theorem) gives</p>
<p><span class="math display">\[\int_\Omega \mu^{-1} \nabla A_z \cdot \nabla v \,\mathrm{d}x
    -\int_{\partial \Omega} \mu^{-1} \frac{\partial A_z}{\partial n} v \,\mathrm{d}s = \int_\Omega J_z v \,\mathrm{d}x\]</span></p>
<p>On the boundary <span class="math inline">\(\partial \Omega\)</span>, we have prescribed <span class="math inline">\(A_z = 0\)</span>, which implies that the test function <span class="math inline">\(v\)</span> also vanishes there. Consequently, the boundary integral disappears, leaving us with the variational formulation:</p>
<p><span class="math display">\[a(A_z, v) = L(v)\]</span></p>
<p>where</p>
<p><span class="math display">\[ a(A_z, v) = \int_\Omega \mu^{-1} \nabla A_z \cdot \nabla v \,\mathrm{d}x, \qquad
L(v) = \int_\Omega J_z v \,\mathrm{d}x\]</span></p>
<p>Thus, the problem reduces to finding <span class="math inline">\(A_z \in V\)</span>, where <span class="math inline">\(V\)</span> is the appropriate function space with homogeneous Dirichlet boundary conditions, such that</p>
<p><span class="math display">\[a(A_z, v) = L(v) \quad \text{for all } v \in V\]</span></p>
<p><strong>Meshing a complex structure with subdomains</strong></p>
<p>We now turn to the practical implementation of the problem. The first step is to create the computational mesh. We can construct this geometry in <code>GMSH</code>. Each physical region (iron, copper wires, vacuum, and outer boundary) is tagged with unique markers. These markers are preserved when the mesh is imported into <code>dolfinx</code>, and they allow us to assign different material parameters and source terms</p>
<div id="35623bf2" class="cell" data-execution_count="219">
<div class="sourceCode" id="cb251"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb251-1"><a href="#cb251-1" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb251-2"><a href="#cb251-2" aria-hidden="true" tabindex="-1"></a><span class="co">Electromagnetic coil geometry generation using Gmsh and DOLFINx.</span></span>
<span id="cb251-3"><a href="#cb251-3" aria-hidden="true" tabindex="-1"></a><span class="co">This script creates a 2D geometry consisting of:</span></span>
<span id="cb251-4"><a href="#cb251-4" aria-hidden="true" tabindex="-1"></a><span class="co">- Iron cylinder (magnetic core)</span></span>
<span id="cb251-5"><a href="#cb251-5" aria-hidden="true" tabindex="-1"></a><span class="co">- Copper wire windings (inner and outer)</span></span>
<span id="cb251-6"><a href="#cb251-6" aria-hidden="true" tabindex="-1"></a><span class="co">- Vacuum/air background</span></span>
<span id="cb251-7"><a href="#cb251-7" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb251-8"><a href="#cb251-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-9"><a href="#cb251-9" aria-hidden="true" tabindex="-1"></a><span class="co"># Import required libraries</span></span>
<span id="cb251-10"><a href="#cb251-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb251-11"><a href="#cb251-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb251-12"><a href="#cb251-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-13"><a href="#cb251-13" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> gmsh</span>
<span id="cb251-14"><a href="#cb251-14" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb251-15"><a href="#cb251-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-16"><a href="#cb251-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> default_scalar_type</span>
<span id="cb251-17"><a href="#cb251-17" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem <span class="im">import</span> (dirichletbc, Expression, Function, functionspace, </span>
<span id="cb251-18"><a href="#cb251-18" aria-hidden="true" tabindex="-1"></a>                        locate_dofs_topological)</span>
<span id="cb251-19"><a href="#cb251-19" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> LinearProblem</span>
<span id="cb251-20"><a href="#cb251-20" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.io <span class="im">import</span> XDMFFile</span>
<span id="cb251-21"><a href="#cb251-21" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.io.gmshio <span class="im">import</span> model_to_mesh</span>
<span id="cb251-22"><a href="#cb251-22" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.mesh <span class="im">import</span> compute_midpoints, locate_entities_boundary</span>
<span id="cb251-23"><a href="#cb251-23" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.plot <span class="im">import</span> vtk_mesh</span>
<span id="cb251-24"><a href="#cb251-24" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-25"><a href="#cb251-25" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ufl <span class="im">import</span> TestFunction, TrialFunction, as_vector, dot, dx, grad, inner</span>
<span id="cb251-26"><a href="#cb251-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-27"><a href="#cb251-27" aria-hidden="true" tabindex="-1"></a><span class="co"># MPI configuration</span></span>
<span id="cb251-28"><a href="#cb251-28" aria-hidden="true" tabindex="-1"></a>rank <span class="op">=</span> MPI.COMM_WORLD.rank</span>
<span id="cb251-29"><a href="#cb251-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-30"><a href="#cb251-30" aria-hidden="true" tabindex="-1"></a><span class="co"># Initialize Gmsh</span></span>
<span id="cb251-31"><a href="#cb251-31" aria-hidden="true" tabindex="-1"></a>gmsh.initialize()</span>
<span id="cb251-32"><a href="#cb251-32" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-33"><a href="#cb251-33" aria-hidden="true" tabindex="-1"></a><span class="co"># ============================================================================</span></span>
<span id="cb251-34"><a href="#cb251-34" aria-hidden="true" tabindex="-1"></a><span class="co"># GEOMETRY PARAMETERS</span></span>
<span id="cb251-35"><a href="#cb251-35" aria-hidden="true" tabindex="-1"></a><span class="co"># ============================================================================</span></span>
<span id="cb251-36"><a href="#cb251-36" aria-hidden="true" tabindex="-1"></a>R <span class="op">=</span> <span class="dv">5</span>      <span class="co"># Radius of computational domain</span></span>
<span id="cb251-37"><a href="#cb251-37" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-38"><a href="#cb251-38" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> <span class="dv">1</span>      <span class="co"># Inner radius of iron cylinder</span></span>
<span id="cb251-39"><a href="#cb251-39" aria-hidden="true" tabindex="-1"></a>b <span class="op">=</span> <span class="fl">1.2</span>    <span class="co"># Outer radius of iron cylinder</span></span>
<span id="cb251-40"><a href="#cb251-40" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-41"><a href="#cb251-41" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">8</span>      <span class="co"># Number of copper wire windings</span></span>
<span id="cb251-42"><a href="#cb251-42" aria-hidden="true" tabindex="-1"></a>c_1 <span class="op">=</span> <span class="fl">0.8</span>  <span class="co"># Radius of inner copper wire circle</span></span>
<span id="cb251-43"><a href="#cb251-43" aria-hidden="true" tabindex="-1"></a>c_2 <span class="op">=</span> <span class="fl">1.4</span>  <span class="co"># Radius of outer copper wire circle</span></span>
<span id="cb251-44"><a href="#cb251-44" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> <span class="fl">0.1</span>    <span class="co"># Radius of individual copper wires</span></span>
<span id="cb251-45"><a href="#cb251-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-46"><a href="#cb251-46" aria-hidden="true" tabindex="-1"></a><span class="co"># Mesh parameters</span></span>
<span id="cb251-47"><a href="#cb251-47" aria-hidden="true" tabindex="-1"></a>gdim <span class="op">=</span> <span class="dv">2</span>           <span class="co"># Geometric dimension (2D problem)</span></span>
<span id="cb251-48"><a href="#cb251-48" aria-hidden="true" tabindex="-1"></a>model_rank <span class="op">=</span> <span class="dv">0</span>     <span class="co"># MPI rank responsible for geometry creation</span></span>
<span id="cb251-49"><a href="#cb251-49" aria-hidden="true" tabindex="-1"></a>mesh_comm <span class="op">=</span> MPI.COMM_WORLD</span>
<span id="cb251-50"><a href="#cb251-50" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-51"><a href="#cb251-51" aria-hidden="true" tabindex="-1"></a><span class="co"># ============================================================================</span></span>
<span id="cb251-52"><a href="#cb251-52" aria-hidden="true" tabindex="-1"></a><span class="co"># GEOMETRY CREATION</span></span>
<span id="cb251-53"><a href="#cb251-53" aria-hidden="true" tabindex="-1"></a><span class="co"># ============================================================================</span></span>
<span id="cb251-54"><a href="#cb251-54" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> mesh_comm.rank <span class="op">==</span> model_rank:</span>
<span id="cb251-55"><a href="#cb251-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-56"><a href="#cb251-56" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb251-57"><a href="#cb251-57" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create background domain (vacuum/air)</span></span>
<span id="cb251-58"><a href="#cb251-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb251-59"><a href="#cb251-59" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Creating background domain...&quot;</span>)</span>
<span id="cb251-60"><a href="#cb251-60" aria-hidden="true" tabindex="-1"></a>    background <span class="op">=</span> gmsh.model.occ.addDisk(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, R, R)</span>
<span id="cb251-61"><a href="#cb251-61" aria-hidden="true" tabindex="-1"></a>    gmsh.model.occ.synchronize()    </span>
<span id="cb251-62"><a href="#cb251-62" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-63"><a href="#cb251-63" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb251-64"><a href="#cb251-64" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create iron cylinder (magnetic core)</span></span>
<span id="cb251-65"><a href="#cb251-65" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb251-66"><a href="#cb251-66" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Creating iron cylinder geometry...&quot;</span>)</span>
<span id="cb251-67"><a href="#cb251-67" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-68"><a href="#cb251-68" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create outer and inner boundaries of iron cylinder</span></span>
<span id="cb251-69"><a href="#cb251-69" aria-hidden="true" tabindex="-1"></a>    outer_iron <span class="op">=</span> gmsh.model.occ.addCircle(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, b)</span>
<span id="cb251-70"><a href="#cb251-70" aria-hidden="true" tabindex="-1"></a>    inner_iron <span class="op">=</span> gmsh.model.occ.addCircle(<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>, a)</span>
<span id="cb251-71"><a href="#cb251-71" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-72"><a href="#cb251-72" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create curve loops and surface for iron cylinder (annular region)</span></span>
<span id="cb251-73"><a href="#cb251-73" aria-hidden="true" tabindex="-1"></a>    gmsh.model.occ.addCurveLoop([outer_iron], <span class="dv">5</span>)</span>
<span id="cb251-74"><a href="#cb251-74" aria-hidden="true" tabindex="-1"></a>    gmsh.model.occ.addCurveLoop([inner_iron], <span class="dv">6</span>)</span>
<span id="cb251-75"><a href="#cb251-75" aria-hidden="true" tabindex="-1"></a>    iron <span class="op">=</span> gmsh.model.occ.addPlaneSurface([<span class="dv">5</span>, <span class="dv">6</span>])  <span class="co"># Surface with hole</span></span>
<span id="cb251-76"><a href="#cb251-76" aria-hidden="true" tabindex="-1"></a>    gmsh.model.occ.synchronize()</span>
<span id="cb251-77"><a href="#cb251-77" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-78"><a href="#cb251-78" aria-hidden="true" tabindex="-1"></a>     <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb251-79"><a href="#cb251-79" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create copper wire windings</span></span>
<span id="cb251-80"><a href="#cb251-80" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb251-81"><a href="#cb251-81" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Creating </span><span class="sc">{</span>N<span class="sc">}</span><span class="ss"> inner and </span><span class="sc">{</span>N<span class="sc">}</span><span class="ss"> outer copper wire windings...&quot;</span>)</span>
<span id="cb251-82"><a href="#cb251-82" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-83"><a href="#cb251-83" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Inner copper wires (North polarity) - evenly distributed</span></span>
<span id="cb251-84"><a href="#cb251-84" aria-hidden="true" tabindex="-1"></a>    angles_N <span class="op">=</span> [i <span class="op">*</span> <span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">/</span> N <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N)]</span>
<span id="cb251-85"><a href="#cb251-85" aria-hidden="true" tabindex="-1"></a>    wires_N <span class="op">=</span> []</span>
<span id="cb251-86"><a href="#cb251-86" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> angles_N:</span>
<span id="cb251-87"><a href="#cb251-87" aria-hidden="true" tabindex="-1"></a>        x_pos <span class="op">=</span> c_1 <span class="op">*</span> np.cos(v)</span>
<span id="cb251-88"><a href="#cb251-88" aria-hidden="true" tabindex="-1"></a>        y_pos <span class="op">=</span> c_1 <span class="op">*</span> np.sin(v)</span>
<span id="cb251-89"><a href="#cb251-89" aria-hidden="true" tabindex="-1"></a>        wire <span class="op">=</span> gmsh.model.occ.addDisk(x_pos, y_pos, <span class="dv">0</span>, r, r)</span>
<span id="cb251-90"><a href="#cb251-90" aria-hidden="true" tabindex="-1"></a>        wires_N.append((<span class="dv">2</span>, wire))</span>
<span id="cb251-91"><a href="#cb251-91" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-92"><a href="#cb251-92" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Outer copper wires (South polarity) - offset by half angle</span></span>
<span id="cb251-93"><a href="#cb251-93" aria-hidden="true" tabindex="-1"></a>    angles_S <span class="op">=</span> [(i <span class="op">+</span> <span class="fl">0.5</span>) <span class="op">*</span> <span class="dv">2</span> <span class="op">*</span> np.pi <span class="op">/</span> N <span class="cf">for</span> i <span class="kw">in</span> <span class="bu">range</span>(N)]</span>
<span id="cb251-94"><a href="#cb251-94" aria-hidden="true" tabindex="-1"></a>    wires_S <span class="op">=</span> []</span>
<span id="cb251-95"><a href="#cb251-95" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> v <span class="kw">in</span> angles_S:</span>
<span id="cb251-96"><a href="#cb251-96" aria-hidden="true" tabindex="-1"></a>        x_pos <span class="op">=</span> c_2 <span class="op">*</span> np.cos(v)</span>
<span id="cb251-97"><a href="#cb251-97" aria-hidden="true" tabindex="-1"></a>        y_pos <span class="op">=</span> c_2 <span class="op">*</span> np.sin(v)</span>
<span id="cb251-98"><a href="#cb251-98" aria-hidden="true" tabindex="-1"></a>        wire <span class="op">=</span> gmsh.model.occ.addDisk(x_pos, y_pos, <span class="dv">0</span>, r, r)</span>
<span id="cb251-99"><a href="#cb251-99" aria-hidden="true" tabindex="-1"></a>        wires_S.append((<span class="dv">2</span>, wire))</span>
<span id="cb251-100"><a href="#cb251-100" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-101"><a href="#cb251-101" aria-hidden="true" tabindex="-1"></a>    gmsh.model.occ.synchronize()</span>
<span id="cb251-102"><a href="#cb251-102" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-103"><a href="#cb251-103" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb251-104"><a href="#cb251-104" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Boolean operations to create final geometry</span></span>
<span id="cb251-105"><a href="#cb251-105" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb251-106"><a href="#cb251-106" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Performing boolean operations...&quot;</span>)</span>
<span id="cb251-107"><a href="#cb251-107" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-108"><a href="#cb251-108" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Combine all surfaces for fragmentation</span></span>
<span id="cb251-109"><a href="#cb251-109" aria-hidden="true" tabindex="-1"></a>    all_surfaces <span class="op">=</span> [(<span class="dv">2</span>, iron)]</span>
<span id="cb251-110"><a href="#cb251-110" aria-hidden="true" tabindex="-1"></a>    all_surfaces.extend(wires_S)</span>
<span id="cb251-111"><a href="#cb251-111" aria-hidden="true" tabindex="-1"></a>    all_surfaces.extend(wires_N)</span>
<span id="cb251-112"><a href="#cb251-112" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-113"><a href="#cb251-113" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Fragment the background domain with all other surfaces</span></span>
<span id="cb251-114"><a href="#cb251-114" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This creates non-overlapping regions</span></span>
<span id="cb251-115"><a href="#cb251-115" aria-hidden="true" tabindex="-1"></a>    whole_domain <span class="op">=</span> gmsh.model.occ.fragment([(<span class="dv">2</span>, background)], all_surfaces)</span>
<span id="cb251-116"><a href="#cb251-116" aria-hidden="true" tabindex="-1"></a>    gmsh.model.occ.synchronize()</span>
<span id="cb251-117"><a href="#cb251-117" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-118"><a href="#cb251-118" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb251-119"><a href="#cb251-119" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Assign physical markers to different regions</span></span>
<span id="cb251-120"><a href="#cb251-120" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Physical markers are used for material properties:</span></span>
<span id="cb251-121"><a href="#cb251-121" aria-hidden="true" tabindex="-1"></a>    <span class="co"># - Tag 0: Vacuum/air background</span></span>
<span id="cb251-122"><a href="#cb251-122" aria-hidden="true" tabindex="-1"></a>    <span class="co"># - Tag 1: Iron cylinder</span></span>
<span id="cb251-123"><a href="#cb251-123" aria-hidden="true" tabindex="-1"></a>    <span class="co"># - Tags 2 to N+1: Inner copper wires</span></span>
<span id="cb251-124"><a href="#cb251-124" aria-hidden="true" tabindex="-1"></a>    <span class="co"># - Tags N+2 to 2*N+1: Outer copper wires</span></span>
<span id="cb251-125"><a href="#cb251-125" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb251-126"><a href="#cb251-126" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Assigning physical markers...&quot;</span>)</span>
<span id="cb251-127"><a href="#cb251-127" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-128"><a href="#cb251-128" aria-hidden="true" tabindex="-1"></a>    inner_tag <span class="op">=</span> <span class="dv">2</span></span>
<span id="cb251-129"><a href="#cb251-129" aria-hidden="true" tabindex="-1"></a>    outer_tag <span class="op">=</span> <span class="dv">2</span> <span class="op">+</span> N</span>
<span id="cb251-130"><a href="#cb251-130" aria-hidden="true" tabindex="-1"></a>    background_surfaces <span class="op">=</span> []</span>
<span id="cb251-131"><a href="#cb251-131" aria-hidden="true" tabindex="-1"></a>    other_surfaces <span class="op">=</span> []</span>
<span id="cb251-132"><a href="#cb251-132" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-133"><a href="#cb251-133" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Classify each surface based on geometric properties</span></span>
<span id="cb251-134"><a href="#cb251-134" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> domain <span class="kw">in</span> whole_domain[<span class="dv">0</span>]:</span>
<span id="cb251-135"><a href="#cb251-135" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Get center of mass and total mass of the domain</span></span>
<span id="cb251-136"><a href="#cb251-136" aria-hidden="true" tabindex="-1"></a>        com <span class="op">=</span> gmsh.model.occ.getCenterOfMass(domain[<span class="dv">0</span>], domain[<span class="dv">1</span>])</span>
<span id="cb251-137"><a href="#cb251-137" aria-hidden="true" tabindex="-1"></a>        mass <span class="op">=</span> gmsh.model.occ.getMass(domain[<span class="dv">0</span>], domain[<span class="dv">1</span>])</span>
<span id="cb251-138"><a href="#cb251-138" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-139"><a href="#cb251-139" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Identify iron cylinder by its characteristic mass</span></span>
<span id="cb251-140"><a href="#cb251-140" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.isclose(mass, np.pi <span class="op">*</span> (b<span class="op">**</span><span class="dv">2</span> <span class="op">-</span> a<span class="op">**</span><span class="dv">2</span>), rtol<span class="op">=</span><span class="fl">1e-3</span>):</span>
<span id="cb251-141"><a href="#cb251-141" aria-hidden="true" tabindex="-1"></a>            gmsh.model.addPhysicalGroup(domain[<span class="dv">0</span>], [domain[<span class="dv">1</span>]], tag<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb251-142"><a href="#cb251-142" aria-hidden="true" tabindex="-1"></a>            other_surfaces.append(domain)</span>
<span id="cb251-143"><a href="#cb251-143" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;  Iron cylinder identified (tag=1)&quot;</span>)        </span>
<span id="cb251-144"><a href="#cb251-144" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-145"><a href="#cb251-145" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Identify background surfaces by center of mass at origin</span></span>
<span id="cb251-146"><a href="#cb251-146" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> np.allclose(com, [<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">0</span>], atol<span class="op">=</span><span class="fl">1e-6</span>):</span>
<span id="cb251-147"><a href="#cb251-147" aria-hidden="true" tabindex="-1"></a>            background_surfaces.append(domain[<span class="dv">1</span>])        </span>
<span id="cb251-148"><a href="#cb251-148" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb251-149"><a href="#cb251-149" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Identify inner copper wires by distance from origin</span></span>
<span id="cb251-150"><a href="#cb251-150" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> np.isclose(np.linalg.norm(com), c_1, rtol<span class="op">=</span><span class="fl">1e-3</span>):</span>
<span id="cb251-151"><a href="#cb251-151" aria-hidden="true" tabindex="-1"></a>            gmsh.model.addPhysicalGroup(domain[<span class="dv">0</span>], [domain[<span class="dv">1</span>]], inner_tag)</span>
<span id="cb251-152"><a href="#cb251-152" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;  Inner wire identified (tag=</span><span class="sc">{</span>inner_tag<span class="sc">}</span><span class="ss">)&quot;</span>)</span>
<span id="cb251-153"><a href="#cb251-153" aria-hidden="true" tabindex="-1"></a>            inner_tag <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb251-154"><a href="#cb251-154" aria-hidden="true" tabindex="-1"></a>            other_surfaces.append(domain)</span>
<span id="cb251-155"><a href="#cb251-155" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb251-156"><a href="#cb251-156" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Identify outer copper wires by distance from origin</span></span>
<span id="cb251-157"><a href="#cb251-157" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> np.isclose(np.linalg.norm(com), c_2, rtol<span class="op">=</span><span class="fl">1e-3</span>):</span>
<span id="cb251-158"><a href="#cb251-158" aria-hidden="true" tabindex="-1"></a>            gmsh.model.addPhysicalGroup(domain[<span class="dv">0</span>], [domain[<span class="dv">1</span>]], outer_tag)</span>
<span id="cb251-159"><a href="#cb251-159" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="ss">f&quot;  Outer wire identified (tag=</span><span class="sc">{</span>outer_tag<span class="sc">}</span><span class="ss">)&quot;</span>)</span>
<span id="cb251-160"><a href="#cb251-160" aria-hidden="true" tabindex="-1"></a>            outer_tag <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb251-161"><a href="#cb251-161" aria-hidden="true" tabindex="-1"></a>            other_surfaces.append(domain)</span>
<span id="cb251-162"><a href="#cb251-162" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-163"><a href="#cb251-163" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Assign physical marker for vacuum/air background</span></span>
<span id="cb251-164"><a href="#cb251-164" aria-hidden="true" tabindex="-1"></a>    gmsh.model.addPhysicalGroup(<span class="dv">2</span>, background_surfaces, tag<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb251-165"><a href="#cb251-165" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  Background/vacuum regions identified (tag=0)&quot;</span>)</span>
<span id="cb251-166"><a href="#cb251-166" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-167"><a href="#cb251-167" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb251-168"><a href="#cb251-168" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Configure adaptive mesh sizing</span></span>
<span id="cb251-169"><a href="#cb251-169" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb251-170"><a href="#cb251-170" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Configuring mesh size fields...&quot;</span>)</span>
<span id="cb251-171"><a href="#cb251-171" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-172"><a href="#cb251-172" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create distance field from wire and iron boundaries</span></span>
<span id="cb251-173"><a href="#cb251-173" aria-hidden="true" tabindex="-1"></a>    gmsh.model.mesh.field.add(<span class="st">&quot;Distance&quot;</span>, <span class="dv">1</span>)</span>
<span id="cb251-174"><a href="#cb251-174" aria-hidden="true" tabindex="-1"></a>    edges <span class="op">=</span> gmsh.model.getBoundary(other_surfaces, oriented<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb251-175"><a href="#cb251-175" aria-hidden="true" tabindex="-1"></a>    gmsh.model.mesh.field.setNumbers(<span class="dv">1</span>, <span class="st">&quot;EdgesList&quot;</span>, [e[<span class="dv">1</span>] <span class="cf">for</span> e <span class="kw">in</span> edges])</span>
<span id="cb251-176"><a href="#cb251-176" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-177"><a href="#cb251-177" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create threshold field for adaptive sizing</span></span>
<span id="cb251-178"><a href="#cb251-178" aria-hidden="true" tabindex="-1"></a>    gmsh.model.mesh.field.add(<span class="st">&quot;Threshold&quot;</span>, <span class="dv">2</span>)</span>
<span id="cb251-179"><a href="#cb251-179" aria-hidden="true" tabindex="-1"></a>    gmsh.model.mesh.field.setNumber(<span class="dv">2</span>, <span class="st">&quot;IField&quot;</span>, <span class="dv">1</span>)</span>
<span id="cb251-180"><a href="#cb251-180" aria-hidden="true" tabindex="-1"></a>    gmsh.model.mesh.field.setNumber(<span class="dv">2</span>, <span class="st">&quot;LcMin&quot;</span>, r <span class="op">/</span> <span class="dv">3</span>)    <span class="co"># Fine mesh near wires</span></span>
<span id="cb251-181"><a href="#cb251-181" aria-hidden="true" tabindex="-1"></a>    gmsh.model.mesh.field.setNumber(<span class="dv">2</span>, <span class="st">&quot;LcMax&quot;</span>, <span class="dv">6</span> <span class="op">*</span> r)    <span class="co"># Coarse mesh far away</span></span>
<span id="cb251-182"><a href="#cb251-182" aria-hidden="true" tabindex="-1"></a>    gmsh.model.mesh.field.setNumber(<span class="dv">2</span>, <span class="st">&quot;DistMin&quot;</span>, <span class="dv">4</span> <span class="op">*</span> r)  <span class="co"># Distance for fine mesh</span></span>
<span id="cb251-183"><a href="#cb251-183" aria-hidden="true" tabindex="-1"></a>    gmsh.model.mesh.field.setNumber(<span class="dv">2</span>, <span class="st">&quot;DistMax&quot;</span>, <span class="dv">10</span> <span class="op">*</span> r) <span class="co"># Distance for coarse mesh</span></span>
<span id="cb251-184"><a href="#cb251-184" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-185"><a href="#cb251-185" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set minimum field as background mesh</span></span>
<span id="cb251-186"><a href="#cb251-186" aria-hidden="true" tabindex="-1"></a>    gmsh.model.mesh.field.add(<span class="st">&quot;Min&quot;</span>, <span class="dv">5</span>)</span>
<span id="cb251-187"><a href="#cb251-187" aria-hidden="true" tabindex="-1"></a>    gmsh.model.mesh.field.setNumbers(<span class="dv">5</span>, <span class="st">&quot;FieldsList&quot;</span>, [<span class="dv">2</span>])</span>
<span id="cb251-188"><a href="#cb251-188" aria-hidden="true" tabindex="-1"></a>    gmsh.model.mesh.field.setAsBackgroundMesh(<span class="dv">5</span>)</span>
<span id="cb251-189"><a href="#cb251-189" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-190"><a href="#cb251-190" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb251-191"><a href="#cb251-191" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate and optimize mesh</span></span>
<span id="cb251-192"><a href="#cb251-192" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb251-193"><a href="#cb251-193" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Generating mesh...&quot;</span>)</span>
<span id="cb251-194"><a href="#cb251-194" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-195"><a href="#cb251-195" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use Frontal-Delaunay algorithm for 2D meshing</span></span>
<span id="cb251-196"><a href="#cb251-196" aria-hidden="true" tabindex="-1"></a>    gmsh.option.setNumber(<span class="st">&quot;Mesh.Algorithm&quot;</span>, <span class="dv">7</span>)</span>
<span id="cb251-197"><a href="#cb251-197" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-198"><a href="#cb251-198" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Generate 2D mesh</span></span>
<span id="cb251-199"><a href="#cb251-199" aria-hidden="true" tabindex="-1"></a>    gmsh.model.mesh.generate(gdim)</span>
<span id="cb251-200"><a href="#cb251-200" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-201"><a href="#cb251-201" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Optimize mesh quality using Netgen optimizer</span></span>
<span id="cb251-202"><a href="#cb251-202" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Optimizing mesh quality...&quot;</span>)</span>
<span id="cb251-203"><a href="#cb251-203" aria-hidden="true" tabindex="-1"></a>    gmsh.model.mesh.optimize(<span class="st">&quot;Netgen&quot;</span>)</span>
<span id="cb251-204"><a href="#cb251-204" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb251-205"><a href="#cb251-205" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Geometry and mesh generation completed successfully!&quot;</span>)</span>
<span id="cb251-206"><a href="#cb251-206" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb251-207"><a href="#cb251-207" aria-hidden="true" tabindex="-1"></a><span class="co"># Note: After this point, you would typically:</span></span>
<span id="cb251-208"><a href="#cb251-208" aria-hidden="true" tabindex="-1"></a><span class="co"># 1. Convert the Gmsh model to DOLFINx mesh using model_to_mesh()</span></span>
<span id="cb251-209"><a href="#cb251-209" aria-hidden="true" tabindex="-1"></a><span class="co"># 2. Set up the electromagnetic problem (Maxwell&#39;s equations)</span></span>
<span id="cb251-210"><a href="#cb251-210" aria-hidden="true" tabindex="-1"></a><span class="co"># 3. Apply boundary conditions</span></span>
<span id="cb251-211"><a href="#cb251-211" aria-hidden="true" tabindex="-1"></a><span class="co"># 4. Solve the finite element problem</span></span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Creating background domain...
Creating iron cylinder geometry...
Creating 8 inner and 8 outer copper wire windings...
Performing boolean operations...
Info    : [  0%] Fragments                                                                                  Info    : [ 10%] Fragments                                                                                  Info    : [ 20%] Fragments                                                                                  Info    : [ 30%] Fragments                                                                                  Info    : [ 40%] Fragments                                                                                  Info    : [ 70%] Fragments                                                                                  Info    : [ 80%] Fragments - Making faces                                                                                Info    : [ 90%] Fragments - Adding holes                                                                                Assigning physical markers...
  Iron cylinder identified (tag=1)
  Outer wire identified (tag=10)
  Outer wire identified (tag=11)
  Outer wire identified (tag=12)
  Outer wire identified (tag=13)
  Outer wire identified (tag=14)
  Outer wire identified (tag=15)
  Outer wire identified (tag=16)
  Outer wire identified (tag=17)
  Inner wire identified (tag=2)
  Inner wire identified (tag=3)
  Inner wire identified (tag=4)
  Inner wire identified (tag=5)
  Inner wire identified (tag=6)
  Inner wire identified (tag=7)
  Inner wire identified (tag=8)
  Inner wire identified (tag=9)
  Background/vacuum regions identified (tag=0)
Configuring mesh size fields...
Generating mesh...
Info    : Meshing 1D...
Info    : [  0%] Meshing curve 1 (Ellipse)
Info    : [ 10%] Meshing curve 2 (Ellipse)
Info    : [ 20%] Meshing curve 3 (Ellipse)
Info    : [ 20%] Meshing curve 4 (Ellipse)
Info    : [ 30%] Meshing curve 5 (Ellipse)
Info    : [ 30%] Meshing curve 6 (Ellipse)
Info    : [ 40%] Meshing curve 7 (Ellipse)
Info    : [ 40%] Meshing curve 8 (Circle)
Info    : [ 50%] Meshing curve 9 (Ellipse)
Info    : [ 50%] Meshing curve 10 (Ellipse)
Info    : [ 60%] Meshing curve 11 (Circle)
Info    : [ 60%] Meshing curve 12 (Ellipse)
Info    : [ 70%] Meshing curve 13 (Ellipse)
Info    : [ 70%] Meshing curve 14 (Ellipse)
Info    : [ 80%] Meshing curve 15 (Ellipse)
Info    : [ 80%] Meshing curve 16 (Ellipse)
Info    : [ 90%] Meshing curve 17 (Ellipse)
Info    : [ 90%] Meshing curve 18 (Ellipse)
Info    : [100%] Meshing curve 19 (Ellipse)
Info    : Done meshing 1D (Wall 0.00794679s, CPU 0.012966s)
Info    : Meshing 2D...
Info    : [  0%] Meshing surface 2 (Plane, Bamg)
Info    : [  0%] BAMG succeeded 1668 vertices 2920 triangles
Info    : [ 10%] Meshing surface 3 (Plane, Bamg)
Info    : [ 10%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 10%] BAMG succeeded 46 vertices 71 triangles
Info    : [ 10%] BAMG succeeded 46 vertices 71 triangles
Info    : [ 20%] Meshing surface 4 (Plane, Bamg)
Info    : [ 20%] BAMG succeeded 48 vertices 75 triangles
Info    : [ 20%] BAMG succeeded 48 vertices 75 triangles
Info    : [ 20%] Meshing surface 5 (Plane, Bamg)
Info    : [ 20%] BAMG succeeded 50 vertices 79 triangles
Info    : [ 20%] BAMG succeeded 48 vertices 75 triangles
Info    : [ 20%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 20%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 30%] Meshing surface 6 (Plane, Bamg)
Info    : [ 30%] BAMG succeeded 46 vertices 71 triangles
Info    : [ 30%] Meshing surface 7 (Plane, Bamg)
Info    : [ 30%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 30%] BAMG succeeded 46 vertices 71 triangles
Info    : [ 30%] BAMG succeeded 45 vertices 69 triangles
Info    : [ 30%] BAMG succeeded 45 vertices 69 triangles
Info    : [ 40%] Meshing surface 8 (Plane, Bamg)
Info    : [ 40%] BAMG succeeded 48 vertices 75 triangles
Info    : [ 40%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 40%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 40%] Meshing surface 9 (Plane, Bamg)
Info    : [ 40%] BAMG succeeded 45 vertices 69 triangles
Info    : [ 50%] Meshing surface 10 (Plane, Bamg)
Info    : [ 50%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 50%] BAMG succeeded 46 vertices 71 triangles
Info    : [ 50%] BAMG succeeded 46 vertices 71 triangles
Info    : [ 50%] Meshing surface 11 (Plane, Bamg)
Info    : [ 50%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 50%] BAMG succeeded 46 vertices 71 triangles
Info    : [ 50%] BAMG succeeded 46 vertices 71 triangles
Info    : [ 60%] Meshing surface 12 (Plane, Bamg)
Info    : [ 60%] BAMG succeeded 48 vertices 75 triangles
Info    : [ 60%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 60%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 60%] Meshing surface 13 (Plane, Bamg)
Info    : [ 60%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 60%] BAMG succeeded 46 vertices 71 triangles
Info    : [ 60%] BAMG succeeded 45 vertices 69 triangles
Info    : [ 60%] BAMG succeeded 45 vertices 69 triangles
Info    : [ 70%] Meshing surface 14 (Plane, Bamg)
Info    : [ 70%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 70%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 70%] Meshing surface 15 (Plane, Bamg)
Info    : [ 70%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 70%] BAMG succeeded 46 vertices 71 triangles
Info    : [ 70%] BAMG succeeded 46 vertices 71 triangles
Info    : [ 80%] Meshing surface 16 (Plane, Bamg)
Info    : [ 80%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 80%] BAMG succeeded 46 vertices 71 triangles
Info    : [ 80%] BAMG succeeded 45 vertices 69 triangles
Info    : [ 80%] BAMG succeeded 45 vertices 69 triangles
Info    : [ 80%] Meshing surface 17 (Plane, Bamg)
Info    : [ 80%] BAMG succeeded 48 vertices 75 triangles
Info    : [ 80%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 80%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 90%] Meshing surface 18 (Plane, Bamg)
Info    : [ 90%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 90%] BAMG succeeded 47 vertices 73 triangles
Info    : [ 90%] Meshing surface 19 (Plane, Bamg)
Info    : [ 90%] BAMG succeeded 5939 vertices 11462 triangles
Info    : [ 90%] BAMG succeeded 5999 vertices 11582 triangles
Info    : [ 90%] BAMG succeeded 5996 vertices 11576 triangles
Info    : [100%] Meshing surface 20 (Plane, Bamg)
Info    : [100%] BAMG succeeded 3289 vertices 6251 triangles
Info    : [100%] BAMG succeeded 3199 vertices 6071 triangles
Info    : [100%] BAMG succeeded 3192 vertices 6057 triangles
Info    : Done meshing 2D (Wall 2.59035s, CPU 3.94834s)
Info    : 10876 nodes 22489 elements
Optimizing mesh quality...
Info    : Optimizing mesh (Netgen)...
Info    : Done optimizing mesh (Wall 1.458e-06s, CPU 5e-06s)
Geometry and mesh generation completed successfully!</code></pre>
</div>
</div>
<p>Following the Navier–Stokes tutorial, we load the mesh directly into DOLFINx without first writing it to a file</p>
<div id="11acb068" class="cell" data-execution_count="220">
<div class="sourceCode" id="cb253"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb253-1"><a href="#cb253-1" aria-hidden="true" tabindex="-1"></a>mesh, ct, _ <span class="op">=</span> model_to_mesh(gmsh.model, mesh_comm, model_rank, gdim<span class="op">=</span><span class="dv">2</span>)</span>
<span id="cb253-2"><a href="#cb253-2" aria-hidden="true" tabindex="-1"></a>gmsh.finalize()</span></code></pre></div>
</div>
<p>To inspect the mesh, we use <code>ParaView</code> and obtain the following result</p>
<div id="a64219ec" class="cell" data-execution_count="221">
<div class="sourceCode" id="cb254"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb254-1"><a href="#cb254-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb254-2"><a href="#cb254-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-3"><a href="#cb254-3" aria-hidden="true" tabindex="-1"></a>results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/bcs_subdomains&quot;</span>)</span>
<span id="cb254-4"><a href="#cb254-4" aria-hidden="true" tabindex="-1"></a>results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb254-5"><a href="#cb254-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb254-6"><a href="#cb254-6" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> XDMFFile(MPI.COMM_WORLD, results_folder<span class="op">/</span><span class="st">&quot;mt_electro.xdmf&quot;</span>, <span class="st">&quot;w&quot;</span>) <span class="im">as</span> xdmf:</span>
<span id="cb254-7"><a href="#cb254-7" aria-hidden="true" tabindex="-1"></a>    xdmf.write_mesh(mesh)</span>
<span id="cb254-8"><a href="#cb254-8" aria-hidden="true" tabindex="-1"></a>    xdmf.write_meshtags(ct, mesh.geometry)</span></code></pre></div>
</div>
<p><img src="fenicsx/bcs_subdomains/mt_electro.png" class="img-fluid" /></p>
<p>We can also visualize the subdomains using <code>PyVista</code></p>
<div id="ebb83fb8" class="cell" data-execution_count="222">
<div class="sourceCode" id="cb255"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb255-1"><a href="#cb255-1" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb255-2"><a href="#cb255-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-3"><a href="#cb255-3" aria-hidden="true" tabindex="-1"></a>tdim <span class="op">=</span> mesh.topology.dim</span>
<span id="cb255-4"><a href="#cb255-4" aria-hidden="true" tabindex="-1"></a>mesh.topology.create_connectivity(tdim, tdim)</span>
<span id="cb255-5"><a href="#cb255-5" aria-hidden="true" tabindex="-1"></a>num_local_cells <span class="op">=</span> mesh.topology.index_map(tdim).size_local</span>
<span id="cb255-6"><a href="#cb255-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-7"><a href="#cb255-7" aria-hidden="true" tabindex="-1"></a>grid <span class="op">=</span> pyvista.UnstructuredGrid(<span class="op">*</span>vtk_mesh(mesh, tdim))</span>
<span id="cb255-8"><a href="#cb255-8" aria-hidden="true" tabindex="-1"></a>grid.cell_data[<span class="st">&quot;Marker&quot;</span>] <span class="op">=</span> ct.values[ct.indices <span class="op">&lt;</span> num_local_cells]</span>
<span id="cb255-9"><a href="#cb255-9" aria-hidden="true" tabindex="-1"></a>grid.set_active_scalars(<span class="st">&quot;Marker&quot;</span>)</span>
<span id="cb255-10"><a href="#cb255-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-11"><a href="#cb255-11" aria-hidden="true" tabindex="-1"></a>actor <span class="op">=</span> plotter.add_mesh(grid, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb255-12"><a href="#cb255-12" aria-hidden="true" tabindex="-1"></a>plotter.view_xy()</span>
<span id="cb255-13"><a href="#cb255-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb255-14"><a href="#cb255-14" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> pyvista.OFF_SCREEN:</span>
<span id="cb255-15"><a href="#cb255-15" aria-hidden="true" tabindex="-1"></a>    <span class="co">#plotter.show()</span></span>
<span id="cb255-16"><a href="#cb255-16" aria-hidden="true" tabindex="-1"></a>    plotter.export_html(results_folder<span class="op">/</span><span class="st">&quot;cell_tags.html&quot;</span>)    </span>
<span id="cb255-17"><a href="#cb255-17" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb255-18"><a href="#cb255-18" aria-hidden="true" tabindex="-1"></a>    cell_tag_fig <span class="op">=</span> plotter.screenshot(results_folder<span class="op">/</span><span class="st">&quot;cell_tags.png&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/bcs_subdomains/cell_tags.html"
        width="100%" height="800px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
<p>Next, we define discontinuous functions for permeability <span class="math inline">\(\mu\)</span> and current <span class="math inline">\(J_z\)</span>, based on the <code>MeshTags</code> as in <a href="12_3_Defining_Subdomains_for_Different_Materials">Defining subdomains for different materials</a></p>
<div id="6be11da7" class="cell" data-execution_count="223">
<div class="sourceCode" id="cb256"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb256-1"><a href="#cb256-1" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb256-2"><a href="#cb256-2" aria-hidden="true" tabindex="-1"></a><span class="co">Material properties and current density setup for electromagnetic simulation.</span></span>
<span id="cb256-3"><a href="#cb256-3" aria-hidden="true" tabindex="-1"></a><span class="co">This code assigns material properties (permeability) and current densities </span></span>
<span id="cb256-4"><a href="#cb256-4" aria-hidden="true" tabindex="-1"></a><span class="co">to different regions of the electromagnetic coil geometry.</span></span>
<span id="cb256-5"><a href="#cb256-5" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb256-6"><a href="#cb256-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-7"><a href="#cb256-7" aria-hidden="true" tabindex="-1"></a><span class="co"># ============================================================================</span></span>
<span id="cb256-8"><a href="#cb256-8" aria-hidden="true" tabindex="-1"></a><span class="co"># MATERIAL PROPERTIES AND CURRENT DENSITY SETUP</span></span>
<span id="cb256-9"><a href="#cb256-9" aria-hidden="true" tabindex="-1"></a><span class="co"># ============================================================================</span></span>
<span id="cb256-10"><a href="#cb256-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-11"><a href="#cb256-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> setup_material_properties(mesh, ct, N):</span>
<span id="cb256-12"><a href="#cb256-12" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb256-13"><a href="#cb256-13" aria-hidden="true" tabindex="-1"></a><span class="co">    Set up material properties and current densities for electromagnetic simulation.</span></span>
<span id="cb256-14"><a href="#cb256-14" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb256-15"><a href="#cb256-15" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb256-16"><a href="#cb256-16" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------</span></span>
<span id="cb256-17"><a href="#cb256-17" aria-hidden="true" tabindex="-1"></a><span class="co">    mesh : dolfinx.mesh.Mesh</span></span>
<span id="cb256-18"><a href="#cb256-18" aria-hidden="true" tabindex="-1"></a><span class="co">        The computational mesh</span></span>
<span id="cb256-19"><a href="#cb256-19" aria-hidden="true" tabindex="-1"></a><span class="co">    ct : dolfinx.mesh.MeshTags</span></span>
<span id="cb256-20"><a href="#cb256-20" aria-hidden="true" tabindex="-1"></a><span class="co">        Cell tags identifying different material regions</span></span>
<span id="cb256-21"><a href="#cb256-21" aria-hidden="true" tabindex="-1"></a><span class="co">    N : int</span></span>
<span id="cb256-22"><a href="#cb256-22" aria-hidden="true" tabindex="-1"></a><span class="co">        Number of copper wire windings</span></span>
<span id="cb256-23"><a href="#cb256-23" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb256-24"><a href="#cb256-24" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb256-25"><a href="#cb256-25" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb256-26"><a href="#cb256-26" aria-hidden="true" tabindex="-1"></a><span class="co">    mu : dolfinx.fem.Function</span></span>
<span id="cb256-27"><a href="#cb256-27" aria-hidden="true" tabindex="-1"></a><span class="co">        Magnetic permeability function</span></span>
<span id="cb256-28"><a href="#cb256-28" aria-hidden="true" tabindex="-1"></a><span class="co">    J : dolfinx.fem.Function</span></span>
<span id="cb256-29"><a href="#cb256-29" aria-hidden="true" tabindex="-1"></a><span class="co">        Current density function</span></span>
<span id="cb256-30"><a href="#cb256-30" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb256-31"><a href="#cb256-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb256-32"><a href="#cb256-32" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create discontinuous Galerkin function space (piecewise constant)</span></span>
<span id="cb256-33"><a href="#cb256-33" aria-hidden="true" tabindex="-1"></a>    <span class="co"># DG(0) is appropriate for material properties that are constant within each element</span></span>
<span id="cb256-34"><a href="#cb256-34" aria-hidden="true" tabindex="-1"></a>    Q <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;DG&quot;</span>, <span class="dv">0</span>))</span>
<span id="cb256-35"><a href="#cb256-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb256-36"><a href="#cb256-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get unique material tags from the mesh</span></span>
<span id="cb256-37"><a href="#cb256-37" aria-hidden="true" tabindex="-1"></a>    material_tags <span class="op">=</span> np.unique(ct.values)</span>
<span id="cb256-38"><a href="#cb256-38" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Found material tags: </span><span class="sc">{</span>material_tags<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb256-39"><a href="#cb256-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb256-40"><a href="#cb256-40" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize functions for magnetic permeability and current density</span></span>
<span id="cb256-41"><a href="#cb256-41" aria-hidden="true" tabindex="-1"></a>    mu <span class="op">=</span> Function(Q)  <span class="co"># Magnetic permeability [H/m]</span></span>
<span id="cb256-42"><a href="#cb256-42" aria-hidden="true" tabindex="-1"></a>    J <span class="op">=</span> Function(Q)   <span class="co"># Current density [A/m²]</span></span>
<span id="cb256-43"><a href="#cb256-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb256-44"><a href="#cb256-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Initialize current density to zero everywhere</span></span>
<span id="cb256-45"><a href="#cb256-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (only copper wires will have non-zero current)</span></span>
<span id="cb256-46"><a href="#cb256-46" aria-hidden="true" tabindex="-1"></a>    J.x.array[:] <span class="op">=</span> <span class="fl">0.0</span></span>
<span id="cb256-47"><a href="#cb256-47" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb256-48"><a href="#cb256-48" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Assigning material properties...&quot;</span>)</span>
<span id="cb256-49"><a href="#cb256-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb256-50"><a href="#cb256-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb256-51"><a href="#cb256-51" aria-hidden="true" tabindex="-1"></a>    <span class="co"># MATERIAL PROPERTY DEFINITIONS</span></span>
<span id="cb256-52"><a href="#cb256-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb256-53"><a href="#cb256-53" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb256-54"><a href="#cb256-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Physical constants and material properties</span></span>
<span id="cb256-55"><a href="#cb256-55" aria-hidden="true" tabindex="-1"></a>    mu_0 <span class="op">=</span> <span class="dv">4</span> <span class="op">*</span> np.pi <span class="op">*</span> <span class="fl">1e-7</span>        <span class="co"># Vacuum permeability [H/m]</span></span>
<span id="cb256-56"><a href="#cb256-56" aria-hidden="true" tabindex="-1"></a>    mu_copper <span class="op">=</span> <span class="fl">1.26e-6</span>            <span class="co"># Copper permeability ≈ μ₀ [H/m]</span></span>
<span id="cb256-57"><a href="#cb256-57" aria-hidden="true" tabindex="-1"></a>    mu_iron <span class="op">=</span> <span class="fl">1e-5</span>                 <span class="co"># Iron permeability (simplified) [H/m]</span></span>
<span id="cb256-58"><a href="#cb256-58" aria-hidden="true" tabindex="-1"></a>                                   <span class="co"># Note: Real iron μ ≈ 6.3e-3, but using 1e-5 here</span></span>
<span id="cb256-59"><a href="#cb256-59" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb256-60"><a href="#cb256-60" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Current density magnitude [A/m²]</span></span>
<span id="cb256-61"><a href="#cb256-61" aria-hidden="true" tabindex="-1"></a>    current_density_positive <span class="op">=</span> <span class="fl">1.0</span>   <span class="co"># Inner wires (North polarity)</span></span>
<span id="cb256-62"><a href="#cb256-62" aria-hidden="true" tabindex="-1"></a>    current_density_negative <span class="op">=</span> <span class="op">-</span><span class="fl">1.0</span>  <span class="co"># Outer wires (South polarity)</span></span>
<span id="cb256-63"><a href="#cb256-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb256-64"><a href="#cb256-64" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb256-65"><a href="#cb256-65" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ASSIGN PROPERTIES TO EACH MATERIAL REGION</span></span>
<span id="cb256-66"><a href="#cb256-66" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb256-67"><a href="#cb256-67" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb256-68"><a href="#cb256-68" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> tag <span class="kw">in</span> material_tags:</span>
<span id="cb256-69"><a href="#cb256-69" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Find all cells belonging to this material tag</span></span>
<span id="cb256-70"><a href="#cb256-70" aria-hidden="true" tabindex="-1"></a>        cells <span class="op">=</span> ct.find(tag)</span>
<span id="cb256-71"><a href="#cb256-71" aria-hidden="true" tabindex="-1"></a>        num_cells <span class="op">=</span> <span class="bu">len</span>(cells)</span>
<span id="cb256-72"><a href="#cb256-72" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb256-73"><a href="#cb256-73" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Assign magnetic permeability based on material type</span></span>
<span id="cb256-74"><a href="#cb256-74" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> tag <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb256-75"><a href="#cb256-75" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Vacuum/air background</span></span>
<span id="cb256-76"><a href="#cb256-76" aria-hidden="true" tabindex="-1"></a>            mu_value <span class="op">=</span> mu_0</span>
<span id="cb256-77"><a href="#cb256-77" aria-hidden="true" tabindex="-1"></a>            material_name <span class="op">=</span> <span class="st">&quot;Vacuum/Air&quot;</span></span>
<span id="cb256-78"><a href="#cb256-78" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb256-79"><a href="#cb256-79" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> tag <span class="op">==</span> <span class="dv">1</span>:</span>
<span id="cb256-80"><a href="#cb256-80" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Iron cylinder (magnetic core)</span></span>
<span id="cb256-81"><a href="#cb256-81" aria-hidden="true" tabindex="-1"></a>            mu_value <span class="op">=</span> mu_iron</span>
<span id="cb256-82"><a href="#cb256-82" aria-hidden="true" tabindex="-1"></a>            material_name <span class="op">=</span> <span class="st">&quot;Iron&quot;</span></span>
<span id="cb256-83"><a href="#cb256-83" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb256-84"><a href="#cb256-84" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb256-85"><a href="#cb256-85" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Copper wires (both inner and outer)</span></span>
<span id="cb256-86"><a href="#cb256-86" aria-hidden="true" tabindex="-1"></a>            mu_value <span class="op">=</span> mu_copper</span>
<span id="cb256-87"><a href="#cb256-87" aria-hidden="true" tabindex="-1"></a>            material_name <span class="op">=</span> <span class="st">&quot;Copper&quot;</span></span>
<span id="cb256-88"><a href="#cb256-88" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb256-89"><a href="#cb256-89" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Set permeability values for all cells in this region</span></span>
<span id="cb256-90"><a href="#cb256-90" aria-hidden="true" tabindex="-1"></a>        mu.x.array[cells] <span class="op">=</span> np.full_like(cells, mu_value, dtype<span class="op">=</span>default_scalar_type)</span>
<span id="cb256-91"><a href="#cb256-91" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb256-92"><a href="#cb256-92" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb256-93"><a href="#cb256-93" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ASSIGN CURRENT DENSITIES TO COPPER WIRES</span></span>
<span id="cb256-94"><a href="#cb256-94" aria-hidden="true" tabindex="-1"></a>        <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb256-95"><a href="#cb256-95" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb256-96"><a href="#cb256-96" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Inner copper wires (tags 2 to N+1) - positive current (North polarity)</span></span>
<span id="cb256-97"><a href="#cb256-97" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> tag <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span>, <span class="dv">2</span> <span class="op">+</span> N):</span>
<span id="cb256-98"><a href="#cb256-98" aria-hidden="true" tabindex="-1"></a>            J.x.array[cells] <span class="op">=</span> np.full_like(cells, current_density_positive, </span>
<span id="cb256-99"><a href="#cb256-99" aria-hidden="true" tabindex="-1"></a>                                          dtype<span class="op">=</span>default_scalar_type)</span>
<span id="cb256-100"><a href="#cb256-100" aria-hidden="true" tabindex="-1"></a>            current_info <span class="op">=</span> <span class="ss">f&quot; | J = +</span><span class="sc">{</span>current_density_positive<span class="sc">}</span><span class="ss"> A/m²&quot;</span></span>
<span id="cb256-101"><a href="#cb256-101" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb256-102"><a href="#cb256-102" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Outer copper wires (tags N+2 to 2N+1) - negative current (South polarity)</span></span>
<span id="cb256-103"><a href="#cb256-103" aria-hidden="true" tabindex="-1"></a>        <span class="cf">elif</span> tag <span class="kw">in</span> <span class="bu">range</span>(<span class="dv">2</span> <span class="op">+</span> N, <span class="dv">2</span> <span class="op">*</span> N <span class="op">+</span> <span class="dv">2</span>):</span>
<span id="cb256-104"><a href="#cb256-104" aria-hidden="true" tabindex="-1"></a>            J.x.array[cells] <span class="op">=</span> np.full_like(cells, current_density_negative, </span>
<span id="cb256-105"><a href="#cb256-105" aria-hidden="true" tabindex="-1"></a>                                          dtype<span class="op">=</span>default_scalar_type)</span>
<span id="cb256-106"><a href="#cb256-106" aria-hidden="true" tabindex="-1"></a>            current_info <span class="op">=</span> <span class="ss">f&quot; | J = </span><span class="sc">{</span>current_density_negative<span class="sc">}</span><span class="ss"> A/m²&quot;</span></span>
<span id="cb256-107"><a href="#cb256-107" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb256-108"><a href="#cb256-108" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb256-109"><a href="#cb256-109" aria-hidden="true" tabindex="-1"></a>            <span class="co"># Non-conducting materials (vacuum, iron)</span></span>
<span id="cb256-110"><a href="#cb256-110" aria-hidden="true" tabindex="-1"></a>            current_info <span class="op">=</span> <span class="st">&quot; | J = 0 A/m²&quot;</span></span>
<span id="cb256-111"><a href="#cb256-111" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb256-112"><a href="#cb256-112" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Print material assignment summary</span></span>
<span id="cb256-113"><a href="#cb256-113" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;  Tag </span><span class="sc">{</span>tag<span class="sc">:2d}</span><span class="ss">: </span><span class="sc">{</span>material_name<span class="sc">:10s}</span><span class="ss"> &quot;</span></span>
<span id="cb256-114"><a href="#cb256-114" aria-hidden="true" tabindex="-1"></a>              <span class="ss">f&quot;| μ = </span><span class="sc">{</span>mu_value<span class="sc">:.2e}</span><span class="ss"> H/m</span><span class="sc">{</span>current_info<span class="sc">}</span><span class="ss"> &quot;</span></span>
<span id="cb256-115"><a href="#cb256-115" aria-hidden="true" tabindex="-1"></a>              <span class="ss">f&quot;| </span><span class="sc">{</span>num_cells<span class="sc">:4d}</span><span class="ss"> cells&quot;</span>)</span>
<span id="cb256-116"><a href="#cb256-116" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb256-117"><a href="#cb256-117" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Material properties assignment completed.&quot;</span>)</span>
<span id="cb256-118"><a href="#cb256-118" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb256-119"><a href="#cb256-119" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> mu, J</span>
<span id="cb256-120"><a href="#cb256-120" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-121"><a href="#cb256-121" aria-hidden="true" tabindex="-1"></a><span class="co"># ============================================================================</span></span>
<span id="cb256-122"><a href="#cb256-122" aria-hidden="true" tabindex="-1"></a><span class="co"># USAGE EXAMPLE</span></span>
<span id="cb256-123"><a href="#cb256-123" aria-hidden="true" tabindex="-1"></a><span class="co"># ============================================================================</span></span>
<span id="cb256-124"><a href="#cb256-124" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb256-125"><a href="#cb256-125" aria-hidden="true" tabindex="-1"></a><span class="co"># Assuming mesh, ct, and N are already defined from the geometry creation</span></span>
<span id="cb256-126"><a href="#cb256-126" aria-hidden="true" tabindex="-1"></a>mu, J <span class="op">=</span> setup_material_properties(mesh, ct, N)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Found material tags: [ 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17]
Assigning material properties...
  Tag  0: Vacuum/Air | μ = 1.26e-06 H/m | J = 0 A/m² | 17633 cells
  Tag  1: Iron       | μ = 1.00e-05 H/m | J = 0 A/m² | 2920 cells
  Tag  2: Copper     | μ = 1.26e-06 H/m | J = +1.0 A/m² |   71 cells
  Tag  3: Copper     | μ = 1.26e-06 H/m | J = +1.0 A/m² |   75 cells
  Tag  4: Copper     | μ = 1.26e-06 H/m | J = +1.0 A/m² |   73 cells
  Tag  5: Copper     | μ = 1.26e-06 H/m | J = +1.0 A/m² |   71 cells
  Tag  6: Copper     | μ = 1.26e-06 H/m | J = +1.0 A/m² |   69 cells
  Tag  7: Copper     | μ = 1.26e-06 H/m | J = +1.0 A/m² |   73 cells
  Tag  8: Copper     | μ = 1.26e-06 H/m | J = +1.0 A/m² |   69 cells
  Tag  9: Copper     | μ = 1.26e-06 H/m | J = +1.0 A/m² |   71 cells
  Tag 10: Copper     | μ = 1.26e-06 H/m | J = -1.0 A/m² |   71 cells
  Tag 11: Copper     | μ = 1.26e-06 H/m | J = -1.0 A/m² |   73 cells
  Tag 12: Copper     | μ = 1.26e-06 H/m | J = -1.0 A/m² |   69 cells
  Tag 13: Copper     | μ = 1.26e-06 H/m | J = -1.0 A/m² |   73 cells
  Tag 14: Copper     | μ = 1.26e-06 H/m | J = -1.0 A/m² |   71 cells
  Tag 15: Copper     | μ = 1.26e-06 H/m | J = -1.0 A/m² |   69 cells
  Tag 16: Copper     | μ = 1.26e-06 H/m | J = -1.0 A/m² |   73 cells
  Tag 17: Copper     | μ = 1.26e-06 H/m | J = -1.0 A/m² |   73 cells
Material properties assignment completed.</code></pre>
</div>
</div>
<p>In the code above, a slightly less extreme value for the magnetic permeability of iron was chosen to make the solution more illustrative; otherwise, the field in the iron cylinder would dominate completely</p>
<p>We now proceed to define the weak problem</p>
<div id="eb527c62" class="cell" data-execution_count="224">
<div class="sourceCode" id="cb258"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb258-1"><a href="#cb258-1" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb258-2"><a href="#cb258-2" aria-hidden="true" tabindex="-1"></a><span class="co">Finite Element Formulation for 2D Electromagnetic Problem (Magnetostatic).</span></span>
<span id="cb258-3"><a href="#cb258-3" aria-hidden="true" tabindex="-1"></a><span class="co">This code sets up the weak form for solving ∇×(1/μ ∇×A) = J</span></span>
<span id="cb258-4"><a href="#cb258-4" aria-hidden="true" tabindex="-1"></a><span class="co">where A is the magnetic vector potential (z-component only in 2D)</span></span>
<span id="cb258-5"><a href="#cb258-5" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb258-6"><a href="#cb258-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-7"><a href="#cb258-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> setup_electromagnetic_problem(mesh, mu, J):</span>
<span id="cb258-8"><a href="#cb258-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb258-9"><a href="#cb258-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Set up finite element formulation for 2D magnetostatic problem.</span></span>
<span id="cb258-10"><a href="#cb258-10" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb258-11"><a href="#cb258-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb258-12"><a href="#cb258-12" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------</span></span>
<span id="cb258-13"><a href="#cb258-13" aria-hidden="true" tabindex="-1"></a><span class="co">    mesh : dolfinx.mesh.Mesh</span></span>
<span id="cb258-14"><a href="#cb258-14" aria-hidden="true" tabindex="-1"></a><span class="co">        Computational mesh</span></span>
<span id="cb258-15"><a href="#cb258-15" aria-hidden="true" tabindex="-1"></a><span class="co">    mu : dolfinx.fem.Function  </span></span>
<span id="cb258-16"><a href="#cb258-16" aria-hidden="true" tabindex="-1"></a><span class="co">        Magnetic permeability function</span></span>
<span id="cb258-17"><a href="#cb258-17" aria-hidden="true" tabindex="-1"></a><span class="co">    J : dolfinx.fem.Function</span></span>
<span id="cb258-18"><a href="#cb258-18" aria-hidden="true" tabindex="-1"></a><span class="co">        Current density function</span></span>
<span id="cb258-19"><a href="#cb258-19" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb258-20"><a href="#cb258-20" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb258-21"><a href="#cb258-21" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb258-22"><a href="#cb258-22" aria-hidden="true" tabindex="-1"></a><span class="co">    a : ufl.Form</span></span>
<span id="cb258-23"><a href="#cb258-23" aria-hidden="true" tabindex="-1"></a><span class="co">        Bilinear form (left-hand side)</span></span>
<span id="cb258-24"><a href="#cb258-24" aria-hidden="true" tabindex="-1"></a><span class="co">    L : ufl.Form  </span></span>
<span id="cb258-25"><a href="#cb258-25" aria-hidden="true" tabindex="-1"></a><span class="co">        Linear form (right-hand side)</span></span>
<span id="cb258-26"><a href="#cb258-26" aria-hidden="true" tabindex="-1"></a><span class="co">    bc : dolfinx.fem.DirichletBC</span></span>
<span id="cb258-27"><a href="#cb258-27" aria-hidden="true" tabindex="-1"></a><span class="co">        Boundary condition</span></span>
<span id="cb258-28"><a href="#cb258-28" aria-hidden="true" tabindex="-1"></a><span class="co">    V : dolfinx.fem.FunctionSpace</span></span>
<span id="cb258-29"><a href="#cb258-29" aria-hidden="true" tabindex="-1"></a><span class="co">        Function space</span></span>
<span id="cb258-30"><a href="#cb258-30" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb258-31"><a href="#cb258-31" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb258-32"><a href="#cb258-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Setting up finite element formulation...&quot;</span>)</span>
<span id="cb258-33"><a href="#cb258-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb258-34"><a href="#cb258-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb258-35"><a href="#cb258-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Function Space Definition</span></span>
<span id="cb258-36"><a href="#cb258-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb258-37"><a href="#cb258-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Use first-order Lagrange elements (P1) for magnetic vector potential</span></span>
<span id="cb258-38"><a href="#cb258-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># In 2D, we solve for A_z component only (out-of-plane)</span></span>
<span id="cb258-39"><a href="#cb258-39" aria-hidden="true" tabindex="-1"></a>    V <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span>
<span id="cb258-40"><a href="#cb258-40" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb258-41"><a href="#cb258-41" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Function space: P1 Lagrange elements&quot;</span>)</span>
<span id="cb258-42"><a href="#cb258-42" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Total DOFs: </span><span class="sc">{</span>V<span class="sc">.</span>dofmap<span class="sc">.</span>index_map<span class="sc">.</span>size_global<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb258-43"><a href="#cb258-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb258-44"><a href="#cb258-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb258-45"><a href="#cb258-45" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Boundary Conditions</span></span>
<span id="cb258-46"><a href="#cb258-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb258-47"><a href="#cb258-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Apply homogeneous Dirichlet BC: A_z = 0 on entire boundary</span></span>
<span id="cb258-48"><a href="#cb258-48" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This assumes the magnetic vector potential vanishes at far-field</span></span>
<span id="cb258-49"><a href="#cb258-49" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb258-50"><a href="#cb258-50" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get topological dimension for boundary identification</span></span>
<span id="cb258-51"><a href="#cb258-51" aria-hidden="true" tabindex="-1"></a>    tdim <span class="op">=</span> mesh.topology.dim  <span class="co"># Should be 2 for 2D problem</span></span>
<span id="cb258-52"><a href="#cb258-52" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb258-53"><a href="#cb258-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Locate all boundary facets (edges in 2D, faces in 3D)</span></span>
<span id="cb258-54"><a href="#cb258-54" aria-hidden="true" tabindex="-1"></a>    <span class="co"># The lambda function returns True for all boundary points</span></span>
<span id="cb258-55"><a href="#cb258-55" aria-hidden="true" tabindex="-1"></a>    facets <span class="op">=</span> locate_entities_boundary(mesh, tdim <span class="op">-</span> <span class="dv">1</span>, </span>
<span id="cb258-56"><a href="#cb258-56" aria-hidden="true" tabindex="-1"></a>                                    <span class="kw">lambda</span> x: np.full(x.shape[<span class="dv">1</span>], <span class="va">True</span>))</span>
<span id="cb258-57"><a href="#cb258-57" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb258-58"><a href="#cb258-58" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Find degrees of freedom on boundary facets</span></span>
<span id="cb258-59"><a href="#cb258-59" aria-hidden="true" tabindex="-1"></a>    dofs <span class="op">=</span> locate_dofs_topological(V, tdim <span class="op">-</span> <span class="dv">1</span>, facets)</span>
<span id="cb258-60"><a href="#cb258-60" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb258-61"><a href="#cb258-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create homogeneous Dirichlet boundary condition: A_z = 0</span></span>
<span id="cb258-62"><a href="#cb258-62" aria-hidden="true" tabindex="-1"></a>    bc <span class="op">=</span> dirichletbc(default_scalar_type(<span class="dv">0</span>), dofs, V)</span>
<span id="cb258-63"><a href="#cb258-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb258-64"><a href="#cb258-64" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Boundary condition: A_z = 0 on </span><span class="sc">{</span><span class="bu">len</span>(facets)<span class="sc">}</span><span class="ss"> boundary facets&quot;</span>)</span>
<span id="cb258-65"><a href="#cb258-65" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Constrained DOFs: </span><span class="sc">{</span><span class="bu">len</span>(dofs)<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb258-66"><a href="#cb258-66" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb258-67"><a href="#cb258-67" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb258-68"><a href="#cb258-68" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Weak Form Definition</span></span>
<span id="cb258-69"><a href="#cb258-69" aria-hidden="true" tabindex="-1"></a>    <span class="co"># ------------------------------------------------------------------------</span></span>
<span id="cb258-70"><a href="#cb258-70" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Define trial and test functions</span></span>
<span id="cb258-71"><a href="#cb258-71" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> TrialFunction(V)  <span class="co"># Trial function (A_z)</span></span>
<span id="cb258-72"><a href="#cb258-72" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> TestFunction(V)   <span class="co"># Test function</span></span>
<span id="cb258-73"><a href="#cb258-73" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb258-74"><a href="#cb258-74" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Bilinear form: a(u,v) = ∫ (1/μ) ∇u · ∇v dx</span></span>
<span id="cb258-75"><a href="#cb258-75" aria-hidden="true" tabindex="-1"></a>    <span class="co"># This comes from the weak form of ∇×(1/μ ∇×A) = J</span></span>
<span id="cb258-76"><a href="#cb258-76" aria-hidden="true" tabindex="-1"></a>    <span class="co"># In 2D: ∇×A = (∂A_z/∂y, -∂A_z/∂x), so |∇×A|² = |∇A_z|²</span></span>
<span id="cb258-77"><a href="#cb258-77" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> (<span class="dv">1</span> <span class="op">/</span> mu) <span class="op">*</span> dot(grad(u), grad(v)) <span class="op">*</span> dx</span>
<span id="cb258-78"><a href="#cb258-78" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb258-79"><a href="#cb258-79" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Linear form: L(v) = ∫ J·v dx  </span></span>
<span id="cb258-80"><a href="#cb258-80" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Current density source term</span></span>
<span id="cb258-81"><a href="#cb258-81" aria-hidden="true" tabindex="-1"></a>    L <span class="op">=</span> J <span class="op">*</span> v <span class="op">*</span> dx</span>
<span id="cb258-82"><a href="#cb258-82" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb258-83"><a href="#cb258-83" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Weak form successfully defined:&quot;</span>)</span>
<span id="cb258-84"><a href="#cb258-84" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;  Bilinear form: a(u,v) = ∫ (1/μ) ∇u·∇v dx&quot;</span>)</span>
<span id="cb258-85"><a href="#cb258-85" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;  Linear form:   L(v)   = ∫ J v dx&quot;</span>)</span>
<span id="cb258-86"><a href="#cb258-86" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;  Boundary condition: u = 0 on ∂Ω&quot;</span>)</span>
<span id="cb258-87"><a href="#cb258-87" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb258-88"><a href="#cb258-88" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> a, L, bc, V</span>
<span id="cb258-89"><a href="#cb258-89" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb258-90"><a href="#cb258-90" aria-hidden="true" tabindex="-1"></a>a, L, bc, V <span class="op">=</span> setup_electromagnetic_problem(mesh, mu, J)    </span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Setting up finite element formulation...
Function space: P1 Lagrange elements
Total DOFs: 10876
Boundary condition: A_z = 0 on 53 boundary facets
Constrained DOFs: 53
Weak form successfully defined:
  Bilinear form: a(u,v) = ∫ (1/μ) ∇u·∇v dx
  Linear form:   L(v)   = ∫ J v dx
  Boundary condition: u = 0 on ∂Ω</code></pre>
</div>
</div>
<p>We are now ready to solve the linear problem</p>
<div id="a64ab3b3" class="cell" data-execution_count="225">
<div class="sourceCode" id="cb260"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb260-1"><a href="#cb260-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> solve_electromagnetic_enhanced(V, a, L, bc, solver_options<span class="op">=</span><span class="va">None</span>):</span>
<span id="cb260-2"><a href="#cb260-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb260-3"><a href="#cb260-3" aria-hidden="true" tabindex="-1"></a><span class="co">    Enhanced solver with better control and monitoring.</span></span>
<span id="cb260-4"><a href="#cb260-4" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb260-5"><a href="#cb260-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb260-6"><a href="#cb260-6" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Setting up enhanced electromagnetic solver...&quot;</span>)</span>
<span id="cb260-7"><a href="#cb260-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb260-8"><a href="#cb260-8" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create solution function</span></span>
<span id="cb260-9"><a href="#cb260-9" aria-hidden="true" tabindex="-1"></a>    A_z <span class="op">=</span> Function(V)</span>
<span id="cb260-10"><a href="#cb260-10" aria-hidden="true" tabindex="-1"></a>    A_z.name <span class="op">=</span> <span class="st">&quot;MagneticVectorPotential&quot;</span>  <span class="co"># For visualization</span></span>
<span id="cb260-11"><a href="#cb260-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb260-12"><a href="#cb260-12" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Default solver options</span></span>
<span id="cb260-13"><a href="#cb260-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> solver_options <span class="kw">is</span> <span class="va">None</span>:</span>
<span id="cb260-14"><a href="#cb260-14" aria-hidden="true" tabindex="-1"></a>        solver_options <span class="op">=</span> {</span>
<span id="cb260-15"><a href="#cb260-15" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;cg&quot;</span>,           <span class="co"># Conjugate Gradient</span></span>
<span id="cb260-16"><a href="#cb260-16" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;hypre&quot;</span>,         <span class="co"># Hypre preconditioner  </span></span>
<span id="cb260-17"><a href="#cb260-17" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;ksp_rtol&quot;</span>: <span class="fl">1e-8</span>,           <span class="co"># Relative tolerance</span></span>
<span id="cb260-18"><a href="#cb260-18" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;ksp_atol&quot;</span>: <span class="fl">1e-12</span>,          <span class="co"># Absolute tolerance</span></span>
<span id="cb260-19"><a href="#cb260-19" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;ksp_max_it&quot;</span>: <span class="dv">1000</span>,         <span class="co"># Maximum iterations</span></span>
<span id="cb260-20"><a href="#cb260-20" aria-hidden="true" tabindex="-1"></a>            <span class="st">&quot;ksp_monitor&quot;</span>: <span class="va">None</span>,        <span class="co"># Monitor convergence</span></span>
<span id="cb260-21"><a href="#cb260-21" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb260-22"><a href="#cb260-22" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb260-23"><a href="#cb260-23" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create linear problem with custom options</span></span>
<span id="cb260-24"><a href="#cb260-24" aria-hidden="true" tabindex="-1"></a>    problem <span class="op">=</span> LinearProblem(</span>
<span id="cb260-25"><a href="#cb260-25" aria-hidden="true" tabindex="-1"></a>        a, L, </span>
<span id="cb260-26"><a href="#cb260-26" aria-hidden="true" tabindex="-1"></a>        u<span class="op">=</span>A_z, </span>
<span id="cb260-27"><a href="#cb260-27" aria-hidden="true" tabindex="-1"></a>        bcs<span class="op">=</span>[bc],</span>
<span id="cb260-28"><a href="#cb260-28" aria-hidden="true" tabindex="-1"></a>        petsc_options<span class="op">=</span>solver_options</span>
<span id="cb260-29"><a href="#cb260-29" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb260-30"><a href="#cb260-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb260-31"><a href="#cb260-31" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Solver configuration:&quot;</span>)</span>
<span id="cb260-32"><a href="#cb260-32" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  Method: </span><span class="sc">{</span>solver_options<span class="sc">.</span>get(<span class="st">&#39;ksp_type&#39;</span>, <span class="st">&#39;default&#39;</span>)<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb260-33"><a href="#cb260-33" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  Preconditioner: </span><span class="sc">{</span>solver_options<span class="sc">.</span>get(<span class="st">&#39;pc_type&#39;</span>, <span class="st">&#39;default&#39;</span>)<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb260-34"><a href="#cb260-34" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  Tolerance: </span><span class="sc">{</span>solver_options<span class="sc">.</span>get(<span class="st">&#39;ksp_rtol&#39;</span>, <span class="st">&#39;default&#39;</span>)<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb260-35"><a href="#cb260-35" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb260-36"><a href="#cb260-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Solve with timing</span></span>
<span id="cb260-37"><a href="#cb260-37" aria-hidden="true" tabindex="-1"></a>    <span class="im">import</span> time</span>
<span id="cb260-38"><a href="#cb260-38" aria-hidden="true" tabindex="-1"></a>    start_time <span class="op">=</span> time.time()</span>
<span id="cb260-39"><a href="#cb260-39" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb260-40"><a href="#cb260-40" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb260-41"><a href="#cb260-41" aria-hidden="true" tabindex="-1"></a>        problem.solve()</span>
<span id="cb260-42"><a href="#cb260-42" aria-hidden="true" tabindex="-1"></a>        solve_time <span class="op">=</span> time.time() <span class="op">-</span>start_time</span>
<span id="cb260-43"><a href="#cb260-43" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb260-44"><a href="#cb260-44" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="st">&quot;✅ Solution completed successfully!&quot;</span>)</span>
<span id="cb260-45"><a href="#cb260-45" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;  Solve time: </span><span class="sc">{</span>solve_time<span class="sc">:.3f}</span><span class="ss"> seconds&quot;</span>)</span>
<span id="cb260-46"><a href="#cb260-46" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;  Solution range: [</span><span class="sc">{</span>A_z<span class="sc">.</span>x<span class="sc">.</span>array<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.6e}</span><span class="ss">, </span><span class="sc">{</span>A_z<span class="sc">.</span>x<span class="sc">.</span>array<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.6e}</span><span class="ss">]&quot;</span>)</span>
<span id="cb260-47"><a href="#cb260-47" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;  Solution norm: </span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(A_z.x.array)<span class="sc">:.6e}</span><span class="ss">&quot;</span>)</span>
<span id="cb260-48"><a href="#cb260-48" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb260-49"><a href="#cb260-49" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Check for reasonable solution</span></span>
<span id="cb260-50"><a href="#cb260-50" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> np.<span class="bu">all</span>(np.<span class="bu">abs</span>(A_z.x.array) <span class="op">&lt;</span> <span class="fl">1e-15</span>):</span>
<span id="cb260-51"><a href="#cb260-51" aria-hidden="true" tabindex="-1"></a>            <span class="bu">print</span>(<span class="st">&quot;⚠️  WARNING: Solution is nearly zero - check source terms and materials&quot;</span>)</span>
<span id="cb260-52"><a href="#cb260-52" aria-hidden="true" tabindex="-1"></a>            </span>
<span id="cb260-53"><a href="#cb260-53" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb260-54"><a href="#cb260-54" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;❌ Solver failed: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb260-55"><a href="#cb260-55" aria-hidden="true" tabindex="-1"></a>        <span class="cf">raise</span></span>
<span id="cb260-56"><a href="#cb260-56" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb260-57"><a href="#cb260-57" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> A_z</span>
<span id="cb260-58"><a href="#cb260-58" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb260-59"><a href="#cb260-59" aria-hidden="true" tabindex="-1"></a>A_z <span class="op">=</span> solve_electromagnetic_enhanced(V, a, L, bc)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Setting up enhanced electromagnetic solver...
Solver configuration:
  Method: cg
  Preconditioner: hypre
  Tolerance: 1e-08
  Residual norms for dolfinx_solve_13925901584 solve.
  0 KSP Residual norm 3.661164896118e-06
  1 KSP Residual norm 2.826271663116e-07
  2 KSP Residual norm 1.606074567321e-08
  3 KSP Residual norm 1.403862576077e-09
  4 KSP Residual norm 1.508422786680e-10
  5 KSP Residual norm 7.954226990338e-12
  6 KSP Residual norm 5.500187386065e-13
✅ Solution completed successfully!
  Solve time: 0.041 seconds
  Solution range: [-7.261425e-09, 9.401582e-08]
  Solution norm: 5.363288e-06</code></pre>
</div>
</div>
<p>As we have computed the magnetic potential, we can now calculate the magnetic field by setting <span class="math inline">\(\mathbf{B} = \nabla \times A_z\)</span>. Note that, since we have chosen a function space of first-order piecewise linear functions to represent the potential, the curl of a function in this space is a discontinuous zeroth-order function (i.e., a function that is constant on each cell). We use <code>dolfinx.fem.Expression</code> to interpolate the curl into the function space <code>W</code></p>
<div id="56d2b720" class="cell" data-execution_count="226">
<div class="sourceCode" id="cb262"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb262-1"><a href="#cb262-1" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb262-2"><a href="#cb262-2" aria-hidden="true" tabindex="-1"></a><span class="co">Magnetic flux density calculation from magnetic vector potential.</span></span>
<span id="cb262-3"><a href="#cb262-3" aria-hidden="true" tabindex="-1"></a><span class="co">This code computes B = ∇ × A where A = A_z ẑ in 2D.</span></span>
<span id="cb262-4"><a href="#cb262-4" aria-hidden="true" tabindex="-1"></a><span class="co">Result: B = (∂A_z/∂y, -∂A_z/∂x) = (B_x, B_y)</span></span>
<span id="cb262-5"><a href="#cb262-5" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb262-6"><a href="#cb262-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb262-7"><a href="#cb262-7" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> calculate_magnetic_field(mesh, A_z):</span>
<span id="cb262-8"><a href="#cb262-8" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb262-9"><a href="#cb262-9" aria-hidden="true" tabindex="-1"></a><span class="co">    Magnetic field calculation</span></span>
<span id="cb262-10"><a href="#cb262-10" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb262-11"><a href="#cb262-11" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb262-12"><a href="#cb262-12" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------</span></span>
<span id="cb262-13"><a href="#cb262-13" aria-hidden="true" tabindex="-1"></a><span class="co">    mesh : dolfinx.mesh.Mesh</span></span>
<span id="cb262-14"><a href="#cb262-14" aria-hidden="true" tabindex="-1"></a><span class="co">        Computational mesh</span></span>
<span id="cb262-15"><a href="#cb262-15" aria-hidden="true" tabindex="-1"></a><span class="co">    A_z : dolfinx.fem.Function</span></span>
<span id="cb262-16"><a href="#cb262-16" aria-hidden="true" tabindex="-1"></a><span class="co">        Magnetic vector potential (z-component)</span></span>
<span id="cb262-17"><a href="#cb262-17" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb262-18"><a href="#cb262-18" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb262-19"><a href="#cb262-19" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb262-20"><a href="#cb262-20" aria-hidden="true" tabindex="-1"></a><span class="co">    B : dolfinx.fem.Function</span></span>
<span id="cb262-21"><a href="#cb262-21" aria-hidden="true" tabindex="-1"></a><span class="co">        Magnetic flux density vector field (B_x, B_y)</span></span>
<span id="cb262-22"><a href="#cb262-22" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb262-23"><a href="#cb262-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb262-24"><a href="#cb262-24" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Calculating magnetic flux density B = ∇ × A...&quot;</span>)</span>
<span id="cb262-25"><a href="#cb262-25" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb262-26"><a href="#cb262-26" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create vector function space for B field</span></span>
<span id="cb262-27"><a href="#cb262-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># DG(0) = piecewise constant discontinuous elements</span></span>
<span id="cb262-28"><a href="#cb262-28" aria-hidden="true" tabindex="-1"></a>    <span class="co"># (mesh.geometry.dim, ) creates vector space with 2 components in 2D</span></span>
<span id="cb262-29"><a href="#cb262-29" aria-hidden="true" tabindex="-1"></a>    W <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;DG&quot;</span>, <span class="dv">0</span>, (mesh.geometry.dim, )))</span>
<span id="cb262-30"><a href="#cb262-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb262-31"><a href="#cb262-31" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create function to store magnetic flux density</span></span>
<span id="cb262-32"><a href="#cb262-32" aria-hidden="true" tabindex="-1"></a>    B <span class="op">=</span> Function(W)</span>
<span id="cb262-33"><a href="#cb262-33" aria-hidden="true" tabindex="-1"></a>    B.name <span class="op">=</span> <span class="st">&quot;MagneticFluxDensity&quot;</span></span>
<span id="cb262-34"><a href="#cb262-34" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb262-35"><a href="#cb262-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate B = ∇ × A = (∂A_z/∂y, -∂A_z/∂x) in 2D</span></span>
<span id="cb262-36"><a href="#cb262-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># A_z.dx(0) = ∂A_z/∂x (derivative w.r.t. first coordinate)  </span></span>
<span id="cb262-37"><a href="#cb262-37" aria-hidden="true" tabindex="-1"></a>    <span class="co"># A_z.dx(1) = ∂A_z/∂y (derivative w.r.t. second coordinate)</span></span>
<span id="cb262-38"><a href="#cb262-38" aria-hidden="true" tabindex="-1"></a>    B_expr <span class="op">=</span> Expression(</span>
<span id="cb262-39"><a href="#cb262-39" aria-hidden="true" tabindex="-1"></a>        as_vector((A_z.dx(<span class="dv">1</span>), <span class="op">-</span>A_z.dx(<span class="dv">0</span>))), </span>
<span id="cb262-40"><a href="#cb262-40" aria-hidden="true" tabindex="-1"></a>        W.element.interpolation_points()</span>
<span id="cb262-41"><a href="#cb262-41" aria-hidden="true" tabindex="-1"></a>    )</span>
<span id="cb262-42"><a href="#cb262-42" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb262-43"><a href="#cb262-43" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Interpolate the expression onto the DG function space</span></span>
<span id="cb262-44"><a href="#cb262-44" aria-hidden="true" tabindex="-1"></a>    B.interpolate(B_expr)</span>
<span id="cb262-45"><a href="#cb262-45" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb262-46"><a href="#cb262-46" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Calculate magnitude for reporting</span></span>
<span id="cb262-47"><a href="#cb262-47" aria-hidden="true" tabindex="-1"></a>    B_magnitude <span class="op">=</span> np.sqrt(B.x.array[<span class="dv">0</span>::<span class="dv">2</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> B.x.array[<span class="dv">1</span>::<span class="dv">2</span>]<span class="op">**</span><span class="dv">2</span>)</span>
<span id="cb262-48"><a href="#cb262-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb262-49"><a href="#cb262-49" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;✅ Magnetic flux density calculated successfully!&quot;</span>)</span>
<span id="cb262-50"><a href="#cb262-50" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  B_x range: [</span><span class="sc">{</span>B<span class="sc">.</span>x<span class="sc">.</span>array[<span class="dv">0</span>::<span class="dv">2</span>]<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.6e}</span><span class="ss">, </span><span class="sc">{</span>B<span class="sc">.</span>x<span class="sc">.</span>array[<span class="dv">0</span>::<span class="dv">2</span>]<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.6e}</span><span class="ss">] T&quot;</span>)</span>
<span id="cb262-51"><a href="#cb262-51" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  B_y range: [</span><span class="sc">{</span>B<span class="sc">.</span>x<span class="sc">.</span>array[<span class="dv">1</span>::<span class="dv">2</span>]<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.6e}</span><span class="ss">, </span><span class="sc">{</span>B<span class="sc">.</span>x<span class="sc">.</span>array[<span class="dv">1</span>::<span class="dv">2</span>]<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.6e}</span><span class="ss">] T&quot;</span>) </span>
<span id="cb262-52"><a href="#cb262-52" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;  |B| range: [</span><span class="sc">{</span>B_magnitude<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.6e}</span><span class="ss">, </span><span class="sc">{</span>B_magnitude<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.6e}</span><span class="ss">] T&quot;</span>)</span>
<span id="cb262-53"><a href="#cb262-53" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb262-54"><a href="#cb262-54" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> B</span>
<span id="cb262-55"><a href="#cb262-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb262-56"><a href="#cb262-56" aria-hidden="true" tabindex="-1"></a>B <span class="op">=</span> calculate_magnetic_field(mesh, A_z)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Calculating magnetic flux density B = ∇ × A...
✅ Magnetic flux density calculated successfully!
  B_x range: [-3.937855e-07, 3.938244e-07] T
  B_y range: [-3.949178e-07, 3.951507e-07] T
  |B| range: [1.098956e-14, 3.951633e-07] T</code></pre>
</div>
</div>
<p>Note that we use <code>ufl.as_vector</code> to interpret the Python tuple <code>(A_z.dx(1), -A_z.dx(0))</code> as a vector in UFL</p>
<p>We now plot the magnetic potential <code>A_z</code> and the magnetic field <code>B</code>. To do this, we first create a new <code>plotter</code></p>
<div id="69ae9e68" class="cell" data-execution_count="227">
<div class="sourceCode" id="cb264"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb264-1"><a href="#cb264-1" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb264-2"><a href="#cb264-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-3"><a href="#cb264-3" aria-hidden="true" tabindex="-1"></a>Az_grid <span class="op">=</span> pyvista.UnstructuredGrid(<span class="op">*</span>vtk_mesh(V))</span>
<span id="cb264-4"><a href="#cb264-4" aria-hidden="true" tabindex="-1"></a>Az_grid.point_data[<span class="st">&quot;A_z&quot;</span>] <span class="op">=</span> A_z.x.array</span>
<span id="cb264-5"><a href="#cb264-5" aria-hidden="true" tabindex="-1"></a>Az_grid.set_active_scalars(<span class="st">&quot;A_z&quot;</span>)</span>
<span id="cb264-6"><a href="#cb264-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-7"><a href="#cb264-7" aria-hidden="true" tabindex="-1"></a>warp <span class="op">=</span> Az_grid.warp_by_scalar(<span class="st">&quot;A_z&quot;</span>, factor<span class="op">=</span><span class="fl">1e7</span>)</span>
<span id="cb264-8"><a href="#cb264-8" aria-hidden="true" tabindex="-1"></a>actor <span class="op">=</span> plotter.add_mesh(warp, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb264-9"><a href="#cb264-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb264-10"><a href="#cb264-10" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> pyvista.OFF_SCREEN:</span>
<span id="cb264-11"><a href="#cb264-11" aria-hidden="true" tabindex="-1"></a>    <span class="co">#plotter.show()</span></span>
<span id="cb264-12"><a href="#cb264-12" aria-hidden="true" tabindex="-1"></a>    plotter.export_html(results_folder<span class="op">/</span><span class="st">&quot;Az.html&quot;</span>)    </span>
<span id="cb264-13"><a href="#cb264-13" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb264-14"><a href="#cb264-14" aria-hidden="true" tabindex="-1"></a>    Az_fig <span class="op">=</span> plotter.screenshot(results_folder<span class="op">/</span><span class="st">&quot;Az.png&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/bcs_subdomains/Az.html"
        width="100%" height="800px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
<p><strong>Visualizing the magnetic field</strong></p>
<p>Since the magnetic field is a piecewise-constant vector field, we need to create a custom plotting function. We begin by computing the midpoints of each cell, which are the locations where we want to visualize the cell-wise constant vectors. Next, we extract the data from the function <code>B</code> and reshape it into 3D vectors. Finally, we associate each vector with its corresponding midpoint using <code>pyvista.PolyData</code></p>
<div id="630c2f82" class="cell" data-execution_count="228">
<div class="sourceCode" id="cb265"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb265-1"><a href="#cb265-1" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb265-2"><a href="#cb265-2" aria-hidden="true" tabindex="-1"></a><span class="co">Magnetic field visualization using PyVista for 2D electromagnetic simulation.</span></span>
<span id="cb265-3"><a href="#cb265-3" aria-hidden="true" tabindex="-1"></a><span class="co">This code creates vector glyphs to visualize the magnetic flux density B field.</span></span>
<span id="cb265-4"><a href="#cb265-4" aria-hidden="true" tabindex="-1"></a><span class="co">&quot;&quot;&quot;</span></span>
<span id="cb265-5"><a href="#cb265-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-6"><a href="#cb265-6" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> visualize_magnetic_field(mesh, B, scale_factor<span class="op">=</span><span class="fl">2e6</span>):</span>
<span id="cb265-7"><a href="#cb265-7" aria-hidden="true" tabindex="-1"></a>    <span class="co">&quot;&quot;&quot;</span></span>
<span id="cb265-8"><a href="#cb265-8" aria-hidden="true" tabindex="-1"></a><span class="co">    Magnetic field visualization</span></span>
<span id="cb265-9"><a href="#cb265-9" aria-hidden="true" tabindex="-1"></a><span class="co">    </span></span>
<span id="cb265-10"><a href="#cb265-10" aria-hidden="true" tabindex="-1"></a><span class="co">    Parameters:</span></span>
<span id="cb265-11"><a href="#cb265-11" aria-hidden="true" tabindex="-1"></a><span class="co">    -----------</span></span>
<span id="cb265-12"><a href="#cb265-12" aria-hidden="true" tabindex="-1"></a><span class="co">    mesh : dolfinx.mesh.Mesh</span></span>
<span id="cb265-13"><a href="#cb265-13" aria-hidden="true" tabindex="-1"></a><span class="co">        The computational mesh</span></span>
<span id="cb265-14"><a href="#cb265-14" aria-hidden="true" tabindex="-1"></a><span class="co">    B : dolfinx.fem.Function</span></span>
<span id="cb265-15"><a href="#cb265-15" aria-hidden="true" tabindex="-1"></a><span class="co">        Magnetic flux density vector field</span></span>
<span id="cb265-16"><a href="#cb265-16" aria-hidden="true" tabindex="-1"></a><span class="co">    scale_factor : float</span></span>
<span id="cb265-17"><a href="#cb265-17" aria-hidden="true" tabindex="-1"></a><span class="co">        Scaling factor for vector glyphs</span></span>
<span id="cb265-18"><a href="#cb265-18" aria-hidden="true" tabindex="-1"></a><span class="co">        </span></span>
<span id="cb265-19"><a href="#cb265-19" aria-hidden="true" tabindex="-1"></a><span class="co">    Returns:</span></span>
<span id="cb265-20"><a href="#cb265-20" aria-hidden="true" tabindex="-1"></a><span class="co">    --------</span></span>
<span id="cb265-21"><a href="#cb265-21" aria-hidden="true" tabindex="-1"></a><span class="co">    plotter : pyvista.Plotter</span></span>
<span id="cb265-22"><a href="#cb265-22" aria-hidden="true" tabindex="-1"></a><span class="co">        Configured plotter object</span></span>
<span id="cb265-23"><a href="#cb265-23" aria-hidden="true" tabindex="-1"></a><span class="co">    &quot;&quot;&quot;</span></span>
<span id="cb265-24"><a href="#cb265-24" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-25"><a href="#cb265-25" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;Setting up magnetic field visualization...&quot;</span>)</span>
<span id="cb265-26"><a href="#cb265-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-27"><a href="#cb265-27" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Extract function space information from B</span></span>
<span id="cb265-28"><a href="#cb265-28" aria-hidden="true" tabindex="-1"></a>    W <span class="op">=</span> B.function_space  <span class="co"># Get function space from B field</span></span>
<span id="cb265-29"><a href="#cb265-29" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-30"><a href="#cb265-30" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create plotter</span></span>
<span id="cb265-31"><a href="#cb265-31" aria-hidden="true" tabindex="-1"></a>    plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb265-32"><a href="#cb265-32" aria-hidden="true" tabindex="-1"></a>    plotter.set_position([<span class="dv">0</span>, <span class="dv">0</span>, <span class="dv">5</span>])  <span class="co"># Camera position</span></span>
<span id="cb265-33"><a href="#cb265-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-34"><a href="#cb265-34" aria-hidden="true" tabindex="-1"></a>    <span class="co"># -----------------------------------------------------------------------</span></span>
<span id="cb265-35"><a href="#cb265-35" aria-hidden="true" tabindex="-1"></a>    <span class="co"># MESH SETUP (with ghost cells for parallel processing)</span></span>
<span id="cb265-36"><a href="#cb265-36" aria-hidden="true" tabindex="-1"></a>    <span class="co"># -----------------------------------------------------------------------</span></span>
<span id="cb265-37"><a href="#cb265-37" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-38"><a href="#cb265-38" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get topology information including ghost cells</span></span>
<span id="cb265-39"><a href="#cb265-39" aria-hidden="true" tabindex="-1"></a>    top_imap <span class="op">=</span> mesh.topology.index_map(mesh.topology.dim)</span>
<span id="cb265-40"><a href="#cb265-40" aria-hidden="true" tabindex="-1"></a>    num_cells <span class="op">=</span> top_imap.size_local <span class="op">+</span> top_imap.num_ghosts</span>
<span id="cb265-41"><a href="#cb265-41" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-42"><a href="#cb265-42" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Total cells (including ghosts): </span><span class="sc">{</span>num_cells<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb265-43"><a href="#cb265-43" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-44"><a href="#cb265-44" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Ensure connectivity is created</span></span>
<span id="cb265-45"><a href="#cb265-45" aria-hidden="true" tabindex="-1"></a>    mesh.topology.create_connectivity(mesh.topology.dim, mesh.topology.dim)</span>
<span id="cb265-46"><a href="#cb265-46" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-47"><a href="#cb265-47" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Compute cell midpoints for vector placement</span></span>
<span id="cb265-48"><a href="#cb265-48" aria-hidden="true" tabindex="-1"></a>    cell_indices <span class="op">=</span> np.arange(num_cells, dtype<span class="op">=</span>np.int32)</span>
<span id="cb265-49"><a href="#cb265-49" aria-hidden="true" tabindex="-1"></a>    midpoints <span class="op">=</span> compute_midpoints(mesh, mesh.topology.dim, cell_indices)</span>
<span id="cb265-50"><a href="#cb265-50" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-51"><a href="#cb265-51" aria-hidden="true" tabindex="-1"></a>    <span class="co"># -----------------------------------------------------------------------</span></span>
<span id="cb265-52"><a href="#cb265-52" aria-hidden="true" tabindex="-1"></a>    <span class="co"># VECTOR FIELD DATA PREPARATION</span></span>
<span id="cb265-53"><a href="#cb265-53" aria-hidden="true" tabindex="-1"></a>    <span class="co"># -----------------------------------------------------------------------</span></span>
<span id="cb265-54"><a href="#cb265-54" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-55"><a href="#cb265-55" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Get DOF information </span></span>
<span id="cb265-56"><a href="#cb265-56" aria-hidden="true" tabindex="-1"></a>    num_dofs <span class="op">=</span> W.dofmap.index_map.size_local <span class="op">+</span> W.dofmap.index_map.num_ghosts</span>
<span id="cb265-57"><a href="#cb265-57" aria-hidden="true" tabindex="-1"></a>    block_size <span class="op">=</span> W.dofmap.index_map_bs  <span class="co"># Should be 2 for 2D vector field</span></span>
<span id="cb265-58"><a href="#cb265-58" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-59"><a href="#cb265-59" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;DOFs: </span><span class="sc">{</span>num_dofs<span class="sc">}</span><span class="ss">, Block size: </span><span class="sc">{</span>block_size<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb265-60"><a href="#cb265-60" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-61"><a href="#cb265-61" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Verify consistency</span></span>
<span id="cb265-62"><a href="#cb265-62" aria-hidden="true" tabindex="-1"></a>    <span class="cf">assert</span> num_cells <span class="op">==</span> num_dofs, <span class="ss">f&quot;Mismatch: </span><span class="sc">{</span>num_cells<span class="sc">}</span><span class="ss"> cells vs </span><span class="sc">{</span>num_dofs<span class="sc">}</span><span class="ss"> DOFs&quot;</span></span>
<span id="cb265-63"><a href="#cb265-63" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-64"><a href="#cb265-64" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Prepare 3D vector data (PyVista requires 3D vectors)</span></span>
<span id="cb265-65"><a href="#cb265-65" aria-hidden="true" tabindex="-1"></a>    values <span class="op">=</span> np.zeros((num_dofs, <span class="dv">3</span>), dtype<span class="op">=</span>np.float64)</span>
<span id="cb265-66"><a href="#cb265-66" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-67"><a href="#cb265-67" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Reshape B field data and assign to first 2 components</span></span>
<span id="cb265-68"><a href="#cb265-68" aria-hidden="true" tabindex="-1"></a>    <span class="co"># B.x.array is [Bx0, By0, Bx1, By1, ...] for DG elements</span></span>
<span id="cb265-69"><a href="#cb265-69" aria-hidden="true" tabindex="-1"></a>    B_reshaped <span class="op">=</span> B.x.array.real.reshape(num_dofs, block_size)</span>
<span id="cb265-70"><a href="#cb265-70" aria-hidden="true" tabindex="-1"></a>    values[:, :mesh.geometry.dim] <span class="op">=</span> B_reshaped  <span class="co"># Fill (Bx, By, 0)</span></span>
<span id="cb265-71"><a href="#cb265-71" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-72"><a href="#cb265-72" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;B field range: [</span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(values, axis<span class="op">=</span><span class="dv">1</span>)<span class="sc">.</span><span class="bu">min</span>()<span class="sc">:.3e}</span><span class="ss">, &quot;</span></span>
<span id="cb265-73"><a href="#cb265-73" aria-hidden="true" tabindex="-1"></a>          <span class="ss">f&quot;</span><span class="sc">{</span>np<span class="sc">.</span>linalg<span class="sc">.</span>norm(values, axis<span class="op">=</span><span class="dv">1</span>)<span class="sc">.</span><span class="bu">max</span>()<span class="sc">:.3e}</span><span class="ss">] T&quot;</span>)</span>
<span id="cb265-74"><a href="#cb265-74" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-75"><a href="#cb265-75" aria-hidden="true" tabindex="-1"></a>    <span class="co"># -----------------------------------------------------------------------</span></span>
<span id="cb265-76"><a href="#cb265-76" aria-hidden="true" tabindex="-1"></a>    <span class="co"># PYVISTA VISUALIZATION SETUP  </span></span>
<span id="cb265-77"><a href="#cb265-77" aria-hidden="true" tabindex="-1"></a>    <span class="co"># -----------------------------------------------------------------------</span></span>
<span id="cb265-78"><a href="#cb265-78" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-79"><a href="#cb265-79" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create point cloud at cell midpoints</span></span>
<span id="cb265-80"><a href="#cb265-80" aria-hidden="true" tabindex="-1"></a>    cloud <span class="op">=</span> pyvista.PolyData(midpoints)</span>
<span id="cb265-81"><a href="#cb265-81" aria-hidden="true" tabindex="-1"></a>    cloud[<span class="st">&quot;B&quot;</span>] <span class="op">=</span> values  <span class="co"># Attach vector field data</span></span>
<span id="cb265-82"><a href="#cb265-82" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-83"><a href="#cb265-83" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Create vector glyphs (arrows) </span></span>
<span id="cb265-84"><a href="#cb265-84" aria-hidden="true" tabindex="-1"></a>    glyphs <span class="op">=</span> cloud.glyph(<span class="st">&quot;B&quot;</span>, factor<span class="op">=</span>scale_factor)</span>
<span id="cb265-85"><a href="#cb265-85" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-86"><a href="#cb265-86" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add wireframe mesh</span></span>
<span id="cb265-87"><a href="#cb265-87" aria-hidden="true" tabindex="-1"></a>    <span class="cf">try</span>:</span>
<span id="cb265-88"><a href="#cb265-88" aria-hidden="true" tabindex="-1"></a>        <span class="co"># Convert DOLFINx mesh to PyVista grid</span></span>
<span id="cb265-89"><a href="#cb265-89" aria-hidden="true" tabindex="-1"></a>        grid <span class="op">=</span> vtk_mesh(mesh, mesh.topology.dim)[<span class="dv">0</span>]</span>
<span id="cb265-90"><a href="#cb265-90" aria-hidden="true" tabindex="-1"></a>        actor_mesh <span class="op">=</span> plotter.add_mesh(grid, style<span class="op">=</span><span class="st">&quot;wireframe&quot;</span>, color<span class="op">=</span><span class="st">&quot;k&quot;</span>, </span>
<span id="cb265-91"><a href="#cb265-91" aria-hidden="true" tabindex="-1"></a>                                     line_width<span class="op">=</span><span class="dv">1</span>, opacity<span class="op">=</span><span class="fl">0.3</span>)</span>
<span id="cb265-92"><a href="#cb265-92" aria-hidden="true" tabindex="-1"></a>    <span class="cf">except</span> <span class="pp">Exception</span> <span class="im">as</span> e:</span>
<span id="cb265-93"><a href="#cb265-93" aria-hidden="true" tabindex="-1"></a>        <span class="bu">print</span>(<span class="ss">f&quot;⚠️  Could not add mesh wireframe: </span><span class="sc">{</span>e<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb265-94"><a href="#cb265-94" aria-hidden="true" tabindex="-1"></a>        actor_mesh <span class="op">=</span> <span class="va">None</span></span>
<span id="cb265-95"><a href="#cb265-95" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-96"><a href="#cb265-96" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Add vector field glyphs</span></span>
<span id="cb265-97"><a href="#cb265-97" aria-hidden="true" tabindex="-1"></a>    actor_vectors <span class="op">=</span> plotter.add_mesh(glyphs, color<span class="op">=</span><span class="st">&quot;red&quot;</span>, </span>
<span id="cb265-98"><a href="#cb265-98" aria-hidden="true" tabindex="-1"></a>                                   scalar_bar_args<span class="op">=</span>{<span class="st">&quot;title&quot;</span>: <span class="st">&quot;B [T]&quot;</span>})</span>
<span id="cb265-99"><a href="#cb265-99" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-100"><a href="#cb265-100" aria-hidden="true" tabindex="-1"></a>    <span class="co"># Set up camera and view</span></span>
<span id="cb265-101"><a href="#cb265-101" aria-hidden="true" tabindex="-1"></a>    plotter.camera_position <span class="op">=</span> <span class="st">&quot;xy&quot;</span>  <span class="co"># Top-down view for 2D</span></span>
<span id="cb265-102"><a href="#cb265-102" aria-hidden="true" tabindex="-1"></a>    plotter.add_axes()</span>
<span id="cb265-103"><a href="#cb265-103" aria-hidden="true" tabindex="-1"></a>    plotter.show_grid()</span>
<span id="cb265-104"><a href="#cb265-104" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-105"><a href="#cb265-105" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="st">&quot;✅ Visualization setup complete!&quot;</span>)</span>
<span id="cb265-106"><a href="#cb265-106" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb265-107"><a href="#cb265-107" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> plotter</span>
<span id="cb265-108"><a href="#cb265-108" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb265-109"><a href="#cb265-109" aria-hidden="true" tabindex="-1"></a>plotter <span class="op">=</span> visualize_magnetic_field(mesh, B)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Setting up magnetic field visualization...
Total cells (including ghosts): 21697
DOFs: 21697, Block size: 2
B field range: [1.099e-14, 3.952e-07] T
⚠️  Could not add mesh wireframe: NumPy array could not be wrapped pyvista.
✅ Visualization setup complete!</code></pre>
</div>
</div>
<div id="017b8344" class="cell" data-execution_count="229">
<div class="sourceCode" id="cb267"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb267-1"><a href="#cb267-1" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> pyvista.OFF_SCREEN:</span>
<span id="cb267-2"><a href="#cb267-2" aria-hidden="true" tabindex="-1"></a>    <span class="co">#plotter.show()</span></span>
<span id="cb267-3"><a href="#cb267-3" aria-hidden="true" tabindex="-1"></a>    plotter.export_html(results_folder<span class="op">/</span><span class="st">&quot;B.html&quot;</span>)    </span>
<span id="cb267-4"><a href="#cb267-4" aria-hidden="true" tabindex="-1"></a><span class="cf">else</span>:</span>
<span id="cb267-5"><a href="#cb267-5" aria-hidden="true" tabindex="-1"></a>    Az_fig <span class="op">=</span> plotter.screenshot(results_folder<span class="op">/</span><span class="st">&quot;B.png&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/bcs_subdomains/B.html"
        width="100%" height="800px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
</section>
</section>
<section id="best-practices-for-fenicsx" class="level2" data-number="K.9">
<h2 data-number="K.9"><span class="header-section-number">K.9</span> Best Practices for FEniCSx</h2>
<section id="solver-configuration" class="level3" data-number="K.9.1">
<h3 data-number="K.9.1"><span class="header-section-number">K.9.1</span> Solver configuration</h3>
<p>Author: Jørgen S. Dokken</p>
<p>In this section, we demonstrate how to specify the linear algebra solver to be used for solving our PDEs, and how to verify the implementation by examining convergence rates:</p>
<p><span class="math display">\[-\Delta u = f \quad \text{in } \Omega, \qquad
u = u_D \quad \text{on } \partial \Omega\]</span></p>
<p>Using the manufactured solution <span class="math inline">\(u_D = \cos(2\pi x)\cos(2\pi y)\)</span>, we obtain the right-hand side function <span class="math inline">\(f = 8\pi^2 \cos(2\pi x)\cos(2\pi y)\)</span></p>
<p>We begin by creating a generic module that evaluates the analytical solution at any point <span class="math inline">\(x\)</span></p>
<div id="8fd561c6" class="cell" data-execution_count="230">
<div class="sourceCode" id="cb268"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb268-1"><a href="#cb268-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy</span>
<span id="cb268-2"><a href="#cb268-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb268-3"><a href="#cb268-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> petsc4py <span class="im">import</span> PETSc</span>
<span id="cb268-4"><a href="#cb268-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb268-5"><a href="#cb268-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.mesh <span class="im">import</span> create_unit_square, locate_entities_boundary</span>
<span id="cb268-6"><a href="#cb268-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem <span class="im">import</span> dirichletbc, functionspace, Function, locate_dofs_topological</span>
<span id="cb268-7"><a href="#cb268-7" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> LinearProblem</span>
<span id="cb268-8"><a href="#cb268-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb268-9"><a href="#cb268-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ufl</span>
<span id="cb268-10"><a href="#cb268-10" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ufl <span class="im">import</span> SpatialCoordinate, TestFunction, TrialFunction, div, dx, inner, grad</span>
<span id="cb268-11"><a href="#cb268-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb268-12"><a href="#cb268-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb268-13"><a href="#cb268-13" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> u_ex(mod):</span>
<span id="cb268-14"><a href="#cb268-14" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> <span class="kw">lambda</span> x: mod.cos(<span class="dv">2</span> <span class="op">*</span> mod.pi <span class="op">*</span> x[<span class="dv">0</span>]) <span class="op">*</span> mod.cos(<span class="dv">2</span> <span class="op">*</span> mod.pi <span class="op">*</span> x[<span class="dv">1</span>])</span></code></pre></div>
</div>
<p>Note that the return type of <code>u_ex</code> is a lambda function. Therefore, we can define two separate lambda functions: one using <code>NumPy</code> (for interpolation) and one using <code>UFL</code> (for defining the source term)</p>
<div id="676d18b4" class="cell" data-execution_count="231">
<div class="sourceCode" id="cb269"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb269-1"><a href="#cb269-1" aria-hidden="true" tabindex="-1"></a>u_numpy <span class="op">=</span> u_ex(numpy)</span>
<span id="cb269-2"><a href="#cb269-2" aria-hidden="true" tabindex="-1"></a>u_ufl <span class="op">=</span> u_ex(ufl)</span></code></pre></div>
</div>
<p>We begin by defining the source term in <code>UFL</code>, using <code>ufl.SpatialCoordinate</code> as the input to <code>u_ufl</code></p>
<div id="77b2f162" class="cell" data-execution_count="232">
<div class="sourceCode" id="cb270"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb270-1"><a href="#cb270-1" aria-hidden="true" tabindex="-1"></a>mesh <span class="op">=</span> create_unit_square(MPI.COMM_WORLD, <span class="dv">30</span>, <span class="dv">30</span>)</span>
<span id="cb270-2"><a href="#cb270-2" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> SpatialCoordinate(mesh)</span>
<span id="cb270-3"><a href="#cb270-3" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="op">-</span>div(grad(u_ufl(x)))</span></code></pre></div>
</div>
<p>Next, let us define our linear variational problem</p>
<div id="596a9163" class="cell" data-execution_count="233">
<div class="sourceCode" id="cb271"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb271-1"><a href="#cb271-1" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span>
<span id="cb271-2"><a href="#cb271-2" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> TrialFunction(V)</span>
<span id="cb271-3"><a href="#cb271-3" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> TestFunction(V)</span>
<span id="cb271-4"><a href="#cb271-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-5"><a href="#cb271-5" aria-hidden="true" tabindex="-1"></a>a <span class="op">=</span> inner(grad(u), grad(v)) <span class="op">*</span>dx</span>
<span id="cb271-6"><a href="#cb271-6" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> f <span class="op">*</span>v <span class="op">*</span>dx</span>
<span id="cb271-7"><a href="#cb271-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-8"><a href="#cb271-8" aria-hidden="true" tabindex="-1"></a>u_bc <span class="op">=</span> Function(V)</span>
<span id="cb271-9"><a href="#cb271-9" aria-hidden="true" tabindex="-1"></a>u_bc.interpolate(u_numpy)</span>
<span id="cb271-10"><a href="#cb271-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb271-11"><a href="#cb271-11" aria-hidden="true" tabindex="-1"></a>facets <span class="op">=</span> locate_entities_boundary(</span>
<span id="cb271-12"><a href="#cb271-12" aria-hidden="true" tabindex="-1"></a>  mesh, </span>
<span id="cb271-13"><a href="#cb271-13" aria-hidden="true" tabindex="-1"></a>  mesh.topology.dim <span class="op">-</span><span class="dv">1</span>, </span>
<span id="cb271-14"><a href="#cb271-14" aria-hidden="true" tabindex="-1"></a>  <span class="kw">lambda</span> x: numpy.full(x.shape[<span class="dv">1</span>], <span class="va">True</span>)</span>
<span id="cb271-15"><a href="#cb271-15" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb271-16"><a href="#cb271-16" aria-hidden="true" tabindex="-1"></a>dofs <span class="op">=</span> locate_dofs_topological(V, mesh.topology.dim <span class="op">-</span><span class="dv">1</span>, facets)</span>
<span id="cb271-17"><a href="#cb271-17" aria-hidden="true" tabindex="-1"></a>bcs <span class="op">=</span> [dirichletbc(u_bc, dofs)]</span></code></pre></div>
</div>
<p>We begin by solving the problem using LU factorization, a direct solver method similar to Gaussian elimination</p>
<div id="140937b9" class="cell" data-execution_count="234">
<div class="sourceCode" id="cb272"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb272-1"><a href="#cb272-1" aria-hidden="true" tabindex="-1"></a>default_problem <span class="op">=</span> LinearProblem(</span>
<span id="cb272-2"><a href="#cb272-2" aria-hidden="true" tabindex="-1"></a>  a, </span>
<span id="cb272-3"><a href="#cb272-3" aria-hidden="true" tabindex="-1"></a>  L, </span>
<span id="cb272-4"><a href="#cb272-4" aria-hidden="true" tabindex="-1"></a>  bcs<span class="op">=</span>bcs,</span>
<span id="cb272-5"><a href="#cb272-5" aria-hidden="true" tabindex="-1"></a>  petsc_options<span class="op">=</span>{<span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;preonly&quot;</span>, <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;lu&quot;</span>}</span>
<span id="cb272-6"><a href="#cb272-6" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb272-7"><a href="#cb272-7" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> default_problem.solve()</span></code></pre></div>
</div>
<p>We now examine the solver process by inspecting the <code>PETSc</code> solver. Since the view options in <code>PETSc</code> are not adapted for notebooks (for example, <code>solver.view()</code> prints output to the terminal when used in a <code>.py</code> file), we instead write the solver output to a file, read it back, and then print it</p>
<div id="43419c24" class="cell" data-execution_count="235">
<div class="sourceCode" id="cb273"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb273-1"><a href="#cb273-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb273-2"><a href="#cb273-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-3"><a href="#cb273-3" aria-hidden="true" tabindex="-1"></a>results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/best_practices&quot;</span>)</span>
<span id="cb273-4"><a href="#cb273-4" aria-hidden="true" tabindex="-1"></a>results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb273-5"><a href="#cb273-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-6"><a href="#cb273-6" aria-hidden="true" tabindex="-1"></a>lu_solver <span class="op">=</span> default_problem.solver</span>
<span id="cb273-7"><a href="#cb273-7" aria-hidden="true" tabindex="-1"></a>viewer <span class="op">=</span> PETSc.Viewer().createASCII(<span class="bu">str</span>(results_folder<span class="op">/</span><span class="st">&quot;lu_output.txt&quot;</span>))</span>
<span id="cb273-8"><a href="#cb273-8" aria-hidden="true" tabindex="-1"></a>lu_solver.view(viewer)</span>
<span id="cb273-9"><a href="#cb273-9" aria-hidden="true" tabindex="-1"></a>viewer.destroy()</span>
<span id="cb273-10"><a href="#cb273-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb273-11"><a href="#cb273-11" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="bu">str</span>(results_folder<span class="op">/</span><span class="st">&quot;lu_output.txt&quot;</span>), <span class="st">&quot;r&quot;</span>) <span class="im">as</span> solver_output:</span>
<span id="cb273-12"><a href="#cb273-12" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> line <span class="kw">in</span> solver_output:</span>
<span id="cb273-13"><a href="#cb273-13" aria-hidden="true" tabindex="-1"></a>      <span class="bu">print</span>(line.rstrip()) </span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>KSP Object: (dolfinx_solve_15442131248) 1 MPI process
  type: preonly
  maximum iterations=10000, initial guess is zero
  tolerances: relative=1e-05, absolute=1e-50, divergence=10000.
  left preconditioning
  using NONE norm type for convergence test
PC Object: (dolfinx_solve_15442131248) 1 MPI process
  type: lu
    out-of-place factorization
    tolerance for zero pivot 2.22045e-14
    matrix ordering: nd
    factor fill ratio given 5., needed 5.08301
      Factored matrix follows:
        Mat Object: (dolfinx_solve_15442131248) 1 MPI process
          type: seqaij
          rows=961, cols=961
          package used to perform factorization: petsc
          total: nonzeros=32943, allocated nonzeros=32943
            not using I-node routines
  linear system matrix = precond matrix:
  Mat Object: (dolfinx_solve_15442131248) 1 MPI process
    type: seqaij
    rows=961, cols=961
    total: nonzeros=6481, allocated nonzeros=6481
    total number of mallocs used during MatSetValues calls=0
      not using I-node routines</code></pre>
</div>
</div>
<p>This is a robust and straightforward method, and it is recommended for problems with up to a few thousand unknowns. It can be used efficiently for many 2D problems and smaller 3D problems. However, sparse LU decomposition quickly becomes inefficient, since for an <span class="math inline">\(N \times N\)</span> matrix the number of floating-point operations scales as <span class="math inline">\(\sim \tfrac{2}{3}N^3\)</span></p>
<p>For larger problems, we instead turn to iterative methods, which are faster and require less memory</p>
<p><strong>How to choose a linear solver and preconditioner</strong></p>
<p>Since the Poisson equation leads to a symmetric, positive-definite system matrix, the optimal Krylov solver is the conjugate gradient (CG) method. By default, the preconditioner is incomplete LU factorization (ILU), a widely used and robust choice</p>
<p>The preconditioner can be changed by setting “<code>pc_type</code>” to any of the other <code>PETSc</code> preconditioners, as listed in the <a href="https://petsc.org/release/manual/ksp/#tab-kspdefaults"><code>PETSc</code> KSP solvers</a> and <a href="https://petsc.org/release/manual/ksp/#tab-pcdefaults"><code>PETSc</code> preconditioners</a> documentation</p>
<p>Any <code>PETSc</code> option can be set through the <code>petsc_options</code> input, including the absolute tolerance (“<code>ksp_atol</code>”), relative tolerance (“<code>ksp_rtol</code>”), and maximum number of iterations (“<code>ksp_max_it</code>”)</p>
<div id="e67ab004" class="cell" data-execution_count="236">
<div class="sourceCode" id="cb275"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb275-1"><a href="#cb275-1" aria-hidden="true" tabindex="-1"></a>cg_problem <span class="op">=</span> LinearProblem(</span>
<span id="cb275-2"><a href="#cb275-2" aria-hidden="true" tabindex="-1"></a>  a, </span>
<span id="cb275-3"><a href="#cb275-3" aria-hidden="true" tabindex="-1"></a>  L, </span>
<span id="cb275-4"><a href="#cb275-4" aria-hidden="true" tabindex="-1"></a>  bcs<span class="op">=</span>bcs,</span>
<span id="cb275-5"><a href="#cb275-5" aria-hidden="true" tabindex="-1"></a>  petsc_options<span class="op">=</span>{</span>
<span id="cb275-6"><a href="#cb275-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;cg&quot;</span>, </span>
<span id="cb275-7"><a href="#cb275-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;ksp_rtol&quot;</span>: <span class="fl">1e-6</span>, </span>
<span id="cb275-8"><a href="#cb275-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;ksp_atol&quot;</span>: <span class="fl">1e-10</span>, </span>
<span id="cb275-9"><a href="#cb275-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;ksp_max_it&quot;</span>: <span class="dv">1000</span></span>
<span id="cb275-10"><a href="#cb275-10" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb275-11"><a href="#cb275-11" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb275-12"><a href="#cb275-12" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> cg_problem.solve()</span>
<span id="cb275-13"><a href="#cb275-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-14"><a href="#cb275-14" aria-hidden="true" tabindex="-1"></a>cg_solver <span class="op">=</span> cg_problem.solver</span>
<span id="cb275-15"><a href="#cb275-15" aria-hidden="true" tabindex="-1"></a>viewer <span class="op">=</span> PETSc.Viewer().createASCII(<span class="bu">str</span>(results_folder<span class="op">/</span><span class="st">&quot;cg_output.txt&quot;</span>))</span>
<span id="cb275-16"><a href="#cb275-16" aria-hidden="true" tabindex="-1"></a>cg_solver.view(viewer)</span>
<span id="cb275-17"><a href="#cb275-17" aria-hidden="true" tabindex="-1"></a>viewer.destroy()</span>
<span id="cb275-18"><a href="#cb275-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb275-19"><a href="#cb275-19" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="bu">str</span>(results_folder<span class="op">/</span><span class="st">&quot;cg_output.txt&quot;</span>), <span class="st">&quot;r&quot;</span>) <span class="im">as</span> solver_output:</span>
<span id="cb275-20"><a href="#cb275-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> line <span class="kw">in</span> solver_output.readlines():</span>
<span id="cb275-21"><a href="#cb275-21" aria-hidden="true" tabindex="-1"></a>      <span class="bu">print</span>(line.rstrip())    </span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>KSP Object: (dolfinx_solve_6274814096) 1 MPI process
  type: cg
  maximum iterations=1000, initial guess is zero
  tolerances: relative=1e-06, absolute=1e-10, divergence=10000.
  left preconditioning
  using PRECONDITIONED norm type for convergence test
PC Object: (dolfinx_solve_6274814096) 1 MPI process
  type: ilu
    out-of-place factorization
    0 levels of fill
    tolerance for zero pivot 2.22045e-14
    matrix ordering: natural
    factor fill ratio given 1., needed 1.
      Factored matrix follows:
        Mat Object: (dolfinx_solve_6274814096) 1 MPI process
          type: seqaij
          rows=961, cols=961
          package used to perform factorization: petsc
          total: nonzeros=6481, allocated nonzeros=6481
            not using I-node routines
  linear system matrix = precond matrix:
  Mat Object: (dolfinx_solve_6274814096) 1 MPI process
    type: seqaij
    rows=961, cols=961
    total: nonzeros=6481, allocated nonzeros=6481
    total number of mallocs used during MatSetValues calls=0
      not using I-node routines</code></pre>
</div>
</div>
<p>For non-symmetric systems, it is preferable to use a Krylov solver designed for such problems, for example <code>GMRES</code></p>
<div id="b68b4d4d" class="cell" data-execution_count="237">
<div class="sourceCode" id="cb277"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb277-1"><a href="#cb277-1" aria-hidden="true" tabindex="-1"></a>gmres_problem <span class="op">=</span> LinearProblem(</span>
<span id="cb277-2"><a href="#cb277-2" aria-hidden="true" tabindex="-1"></a>  a, </span>
<span id="cb277-3"><a href="#cb277-3" aria-hidden="true" tabindex="-1"></a>  L, </span>
<span id="cb277-4"><a href="#cb277-4" aria-hidden="true" tabindex="-1"></a>  bcs<span class="op">=</span>bcs,</span>
<span id="cb277-5"><a href="#cb277-5" aria-hidden="true" tabindex="-1"></a>  petsc_options<span class="op">=</span>{</span>
<span id="cb277-6"><a href="#cb277-6" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;gmres&quot;</span>, </span>
<span id="cb277-7"><a href="#cb277-7" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;ksp_rtol&quot;</span>: <span class="fl">1e-6</span>, </span>
<span id="cb277-8"><a href="#cb277-8" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;ksp_atol&quot;</span>: <span class="fl">1e-10</span>, </span>
<span id="cb277-9"><a href="#cb277-9" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;ksp_max_it&quot;</span>: <span class="dv">1000</span>, </span>
<span id="cb277-10"><a href="#cb277-10" aria-hidden="true" tabindex="-1"></a>    <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;none&quot;</span></span>
<span id="cb277-11"><a href="#cb277-11" aria-hidden="true" tabindex="-1"></a>  }</span>
<span id="cb277-12"><a href="#cb277-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb277-13"><a href="#cb277-13" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> gmres_problem.solve()</span>
<span id="cb277-14"><a href="#cb277-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-15"><a href="#cb277-15" aria-hidden="true" tabindex="-1"></a>gmres_solver <span class="op">=</span> gmres_problem.solver</span>
<span id="cb277-16"><a href="#cb277-16" aria-hidden="true" tabindex="-1"></a>viewer <span class="op">=</span> PETSc.Viewer().createASCII(<span class="bu">str</span>(results_folder<span class="op">/</span><span class="st">&quot;gmres_output.txt&quot;</span>))</span>
<span id="cb277-17"><a href="#cb277-17" aria-hidden="true" tabindex="-1"></a>gmres_solver.view(viewer)</span>
<span id="cb277-18"><a href="#cb277-18" aria-hidden="true" tabindex="-1"></a>viewer.destroy()</span>
<span id="cb277-19"><a href="#cb277-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb277-20"><a href="#cb277-20" aria-hidden="true" tabindex="-1"></a><span class="cf">with</span> <span class="bu">open</span>(<span class="bu">str</span>(results_folder<span class="op">/</span><span class="st">&quot;gmres_output.txt&quot;</span>), <span class="st">&quot;r&quot;</span>) <span class="im">as</span> solver_output:</span>
<span id="cb277-21"><a href="#cb277-21" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> line <span class="kw">in</span> solver_output.readlines():</span>
<span id="cb277-22"><a href="#cb277-22" aria-hidden="true" tabindex="-1"></a>      <span class="bu">print</span>(line.rstrip())       </span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>KSP Object: (dolfinx_solve_15446579088) 1 MPI process
  type: gmres
    restart=30, using Classical (unmodified) Gram-Schmidt Orthogonalization with no iterative refinement
    happy breakdown tolerance 1e-30
  maximum iterations=1000, initial guess is zero
  tolerances: relative=1e-06, absolute=1e-10, divergence=10000.
  left preconditioning
  using PRECONDITIONED norm type for convergence test
PC Object: (dolfinx_solve_15446579088) 1 MPI process
  type: none
  linear system matrix = precond matrix:
  Mat Object: (dolfinx_solve_15446579088) 1 MPI process
    type: seqaij
    rows=961, cols=961
    total: nonzeros=6481, allocated nonzeros=6481
    total number of mallocs used during MatSetValues calls=0
      not using I-node routines</code></pre>
</div>
</div>
<div class="callout callout-style-default callout-note callout-titled">
<div class="callout-header d-flex align-content-center">
<div class="callout-icon-container">
<i class='callout-icon'></i>
</div>
<div class="callout-title-container flex-fill">
Note
</div>
</div>
<div class="callout-body-container callout-body">
<p>When using manufactured solutions, we often expect the error to be close to machine precision. However, this becomes more complicated when iterative methods are employed. The key issue is ensuring that the error introduced by the iterative solver remains smaller than the tolerance used in the convergence test. For linear elements and small meshes, a tolerance in the range of <span class="math inline">\(10^{-12}\)</span> to <span class="math inline">\(10^{-14}\)</span> also works well when using Krylov solvers</p>
</div>
</div>
</section>
<section id="jit-options-and-visualization-using-pandas" class="level3" data-number="K.9.2">
<h3 data-number="K.9.2"><span class="header-section-number">K.9.2</span> JIT options and visualization using Pandas</h3>
<p>Author: Jørgen S. Dokken</p>
<p>In this section, we explore how to optimize and inspect the integration kernels used in <code>dolfinx</code>. As seen in the previous demos, <code>dolfinx</code> uses the Unified Form Language (<a href="https://github.com/FEniCS/ufl/"><code>UFL</code></a>) to describe variational problems</p>
<p>These <code>UFL</code> descriptions must be translated into code for assembling the right- and left-hand sides of the discrete variational problem</p>
<p><code>dolfinx</code> uses <a href="https://github.com/FEniCS/ffcx/"><code>ffcx</code></a> to generate efficient <code>C</code> code for assembling element matrices. This <code>C</code> code is then compiled via <a href="https://cffi.readthedocs.io/en/latest/"><code>CFFI</code></a>, and a variety of compilation options can be specified</p>
<p>We begin by specifying the current directory as the location to store the generated <code>C</code> files. The current directory is obtained using <code>pathlib</code></p>
<div id="3b000cad" class="cell" data-execution_count="238">
<div class="sourceCode" id="cb279"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb279-1"><a href="#cb279-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> time</span>
<span id="cb279-2"><a href="#cb279-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> typing <span class="im">import</span> Dict</span>
<span id="cb279-3"><a href="#cb279-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb279-4"><a href="#cb279-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-5"><a href="#cb279-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb279-6"><a href="#cb279-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pandas <span class="im">as</span> pd</span>
<span id="cb279-7"><a href="#cb279-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-8"><a href="#cb279-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb279-9"><a href="#cb279-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> seaborn</span>
<span id="cb279-10"><a href="#cb279-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-11"><a href="#cb279-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.mesh <span class="im">import</span> create_unit_cube</span>
<span id="cb279-12"><a href="#cb279-12" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem <span class="im">import</span> functionspace, form</span>
<span id="cb279-13"><a href="#cb279-13" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> assemble_matrix</span>
<span id="cb279-14"><a href="#cb279-14" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-15"><a href="#cb279-15" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ufl</span>
<span id="cb279-16"><a href="#cb279-16" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ufl <span class="im">import</span> TestFunction, TrialFunction, dx, inner</span>
<span id="cb279-17"><a href="#cb279-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb279-18"><a href="#cb279-18" aria-hidden="true" tabindex="-1"></a>cache_dir <span class="op">=</span> <span class="ss">f&quot;</span><span class="sc">{</span><span class="bu">str</span>(Path.cwd())<span class="sc">}</span><span class="ss">/.cache&quot;</span></span>
<span id="cb279-19"><a href="#cb279-19" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Directory to put C files in: </span><span class="sc">{</span>cache_dir<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Directory to put C files in: /Users/kyyoo/Documents/notebooks/SeoulTechPSE.github.io/.cache</code></pre>
</div>
</div>
<p>Next, we generate a general function to assemble the mass matrix for a unit cube. Note that we use <code>dolfinx.fem.form</code> to compile the variational form. For code that uses <code>dolfinx.fem.petsc.LinearProblem</code>, you can pass <code>jit_options</code> as a keyword argument</p>
<div id="3d4f609b" class="cell" data-execution_count="239">
<div class="sourceCode" id="cb281"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb281-1"><a href="#cb281-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> compile_form(space: <span class="bu">str</span>, degree: <span class="bu">int</span>, jit_options: Dict):</span>
<span id="cb281-2"><a href="#cb281-2" aria-hidden="true" tabindex="-1"></a>    N <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb281-3"><a href="#cb281-3" aria-hidden="true" tabindex="-1"></a>    mesh <span class="op">=</span> create_unit_cube(MPI.COMM_WORLD, N, N, N)</span>
<span id="cb281-4"><a href="#cb281-4" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb281-5"><a href="#cb281-5" aria-hidden="true" tabindex="-1"></a>    V <span class="op">=</span> functionspace(mesh, (space, degree))</span>
<span id="cb281-6"><a href="#cb281-6" aria-hidden="true" tabindex="-1"></a>    u <span class="op">=</span> TrialFunction(V)</span>
<span id="cb281-7"><a href="#cb281-7" aria-hidden="true" tabindex="-1"></a>    v <span class="op">=</span> TestFunction(V)</span>
<span id="cb281-8"><a href="#cb281-8" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb281-9"><a href="#cb281-9" aria-hidden="true" tabindex="-1"></a>    a <span class="op">=</span> inner(u, v) <span class="op">*</span>dx</span>
<span id="cb281-10"><a href="#cb281-10" aria-hidden="true" tabindex="-1"></a>    a_compiled <span class="op">=</span> form(a, jit_options<span class="op">=</span>jit_options)</span>
<span id="cb281-11"><a href="#cb281-11" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb281-12"><a href="#cb281-12" aria-hidden="true" tabindex="-1"></a>    start <span class="op">=</span> time.perf_counter()</span>
<span id="cb281-13"><a href="#cb281-13" aria-hidden="true" tabindex="-1"></a>    assemble_matrix(a_compiled)</span>
<span id="cb281-14"><a href="#cb281-14" aria-hidden="true" tabindex="-1"></a>    end <span class="op">=</span> time.perf_counter()</span>
<span id="cb281-15"><a href="#cb281-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb281-16"><a href="#cb281-16" aria-hidden="true" tabindex="-1"></a>    <span class="cf">return</span> end <span class="op">-</span>start</span></code></pre></div>
</div>
<p>We begin by examining the different levels of optimization that the <code>C</code> compiler can apply to the generated code. A list of available optimization options, along with their explanations, can be found <a href="https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html">here</a></p>
<div id="142550bc" class="cell" data-execution_count="240">
<div class="sourceCode" id="cb282"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb282-1"><a href="#cb282-1" aria-hidden="true" tabindex="-1"></a>optimization_options <span class="op">=</span> [<span class="st">&quot;-O1&quot;</span>, <span class="st">&quot;-O2&quot;</span>, <span class="st">&quot;-O3&quot;</span>, <span class="st">&quot;-Ofast&quot;</span>]</span></code></pre></div>
</div>
<p>The next option to consider is whether to compile the code with <code>-march=native</code>. This option enables CPU-specific instructions for the local machine, which can lead to different results on different systems. More information can be found <a href="https://gcc.gnu.org/onlinedocs/gcc/AArch64-Options.html#g_t-march-and--mcpu-Feature-Modifiers">here</a></p>
<div id="942487a3" class="cell" data-execution_count="241">
<div class="sourceCode" id="cb283"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb283-1"><a href="#cb283-1" aria-hidden="true" tabindex="-1"></a>march_native <span class="op">=</span> [<span class="va">True</span>, <span class="va">False</span>]</span></code></pre></div>
</div>
<p>We select a subset of finite element spaces and vary the order of each space to examine how it affects the assembly time under different compilation option</p>
<div id="04c79c9e" class="cell" data-execution_count="242">
<div class="sourceCode" id="cb284"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb284-1"><a href="#cb284-1" aria-hidden="true" tabindex="-1"></a>results <span class="op">=</span> {<span class="st">&quot;Space&quot;</span>: [], <span class="st">&quot;Degree&quot;</span>: [], <span class="st">&quot;Options&quot;</span>: [], <span class="st">&quot;Time&quot;</span>: []}</span>
<span id="cb284-2"><a href="#cb284-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> space <span class="kw">in</span> [<span class="st">&quot;N1curl&quot;</span>, <span class="st">&quot;Lagrange&quot;</span>, <span class="st">&quot;RT&quot;</span>]:</span>
<span id="cb284-3"><a href="#cb284-3" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> degree <span class="kw">in</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]:</span>
<span id="cb284-4"><a href="#cb284-4" aria-hidden="true" tabindex="-1"></a>    <span class="cf">for</span> native <span class="kw">in</span> march_native:</span>
<span id="cb284-5"><a href="#cb284-5" aria-hidden="true" tabindex="-1"></a>      <span class="cf">for</span> option <span class="kw">in</span> optimization_options:</span>
<span id="cb284-6"><a href="#cb284-6" aria-hidden="true" tabindex="-1"></a>        <span class="cf">if</span> native:</span>
<span id="cb284-7"><a href="#cb284-7" aria-hidden="true" tabindex="-1"></a>          cffi_options <span class="op">=</span> [option, <span class="st">&quot;-march=native&quot;</span>]</span>
<span id="cb284-8"><a href="#cb284-8" aria-hidden="true" tabindex="-1"></a>        <span class="cf">else</span>:</span>
<span id="cb284-9"><a href="#cb284-9" aria-hidden="true" tabindex="-1"></a>          cffi_options <span class="op">=</span> [option]</span>
<span id="cb284-10"><a href="#cb284-10" aria-hidden="true" tabindex="-1"></a>        jit_options <span class="op">=</span> {</span>
<span id="cb284-11"><a href="#cb284-11" aria-hidden="true" tabindex="-1"></a>          <span class="st">&quot;cffi_extra_compile_args&quot;</span>: cffi_options,</span>
<span id="cb284-12"><a href="#cb284-12" aria-hidden="true" tabindex="-1"></a>          <span class="st">&quot;cache_dir&quot;</span>: cache_dir, </span>
<span id="cb284-13"><a href="#cb284-13" aria-hidden="true" tabindex="-1"></a>          <span class="st">&quot;cffi_libraries&quot;</span>: [<span class="st">&quot;m&quot;</span>]</span>
<span id="cb284-14"><a href="#cb284-14" aria-hidden="true" tabindex="-1"></a>        }</span>
<span id="cb284-15"><a href="#cb284-15" aria-hidden="true" tabindex="-1"></a>        </span>
<span id="cb284-16"><a href="#cb284-16" aria-hidden="true" tabindex="-1"></a>        runtime <span class="op">=</span> compile_form(space, degree, jit_options<span class="op">=</span>jit_options)</span>
<span id="cb284-17"><a href="#cb284-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb284-18"><a href="#cb284-18" aria-hidden="true" tabindex="-1"></a>        results[<span class="st">&quot;Space&quot;</span>].append(space)</span>
<span id="cb284-19"><a href="#cb284-19" aria-hidden="true" tabindex="-1"></a>        results[<span class="st">&quot;Degree&quot;</span>].append(<span class="bu">str</span>(degree))</span>
<span id="cb284-20"><a href="#cb284-20" aria-hidden="true" tabindex="-1"></a>        results[<span class="st">&quot;Options&quot;</span>].append(<span class="st">&quot;</span><span class="ch">\n</span><span class="st">&quot;</span>.join(cffi_options))</span>
<span id="cb284-21"><a href="#cb284-21" aria-hidden="true" tabindex="-1"></a>        results[<span class="st">&quot;Time&quot;</span>].append(runtime)</span></code></pre></div>
</div>
<p>We have now stored all the results in a dictionary. To visualize them, we use <code>pandas</code> and its <code>DataFrame</code> class. In a Jupyter notebook, the data can be inspected as follows:</p>
<div id="04f2492c" class="cell" data-execution_count="243">
<div class="sourceCode" id="cb285"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb285-1"><a href="#cb285-1" aria-hidden="true" tabindex="-1"></a>results_df <span class="op">=</span> pd.DataFrame.from_dict(results)</span>
<span id="cb285-2"><a href="#cb285-2" aria-hidden="true" tabindex="-1"></a>results_df</span></code></pre></div>
<div class="cell-output cell-output-display" data-execution_count="242">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>

<table class="dataframe caption-top" data-quarto-postprocess="true" data-border="1">
<thead>
<tr class="header" style="text-align: right;">
<th data-quarto-table-cell-role="th"></th>
<th data-quarto-table-cell-role="th">Space</th>
<th data-quarto-table-cell-role="th">Degree</th>
<th data-quarto-table-cell-role="th">Options</th>
<th data-quarto-table-cell-role="th">Time</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td data-quarto-table-cell-role="th">0</td>
<td>N1curl</td>
<td>1</td>
<td>-O1\n-march=native</td>
<td>0.019308</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">1</td>
<td>N1curl</td>
<td>1</td>
<td>-O2\n-march=native</td>
<td>0.017671</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">2</td>
<td>N1curl</td>
<td>1</td>
<td>-O3\n-march=native</td>
<td>0.017058</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">3</td>
<td>N1curl</td>
<td>1</td>
<td>-Ofast\n-march=native</td>
<td>0.017915</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">4</td>
<td>N1curl</td>
<td>1</td>
<td>-O1</td>
<td>0.017438</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">...</td>
<td>...</td>
<td>...</td>
<td>...</td>
<td>...</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">67</td>
<td>RT</td>
<td>3</td>
<td>-Ofast\n-march=native</td>
<td>0.505654</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">68</td>
<td>RT</td>
<td>3</td>
<td>-O1</td>
<td>0.521109</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">69</td>
<td>RT</td>
<td>3</td>
<td>-O2</td>
<td>0.486454</td>
</tr>
<tr class="even">
<td data-quarto-table-cell-role="th">70</td>
<td>RT</td>
<td>3</td>
<td>-O3</td>
<td>0.471805</td>
</tr>
<tr class="odd">
<td data-quarto-table-cell-role="th">71</td>
<td>RT</td>
<td>3</td>
<td>-Ofast</td>
<td>0.475377</td>
</tr>
</tbody>
</table>

<p>72 rows × 4 columns</p>
</div>
</div>
</div>
<p>We can now create a plot for each element type to visualize how the results vary with different compilation options. A new column is created for each element type and degree</p>
<div id="e53b3887" class="cell" data-execution_count="244">
<div class="sourceCode" id="cb286"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb286-1"><a href="#cb286-1" aria-hidden="true" tabindex="-1"></a>seaborn.<span class="bu">set</span>(style<span class="op">=</span><span class="st">&quot;ticks&quot;</span>)</span>
<span id="cb286-2"><a href="#cb286-2" aria-hidden="true" tabindex="-1"></a>seaborn.set_style(<span class="st">&quot;darkgrid&quot;</span>)</span>
<span id="cb286-3"><a href="#cb286-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-4"><a href="#cb286-4" aria-hidden="true" tabindex="-1"></a>results_df[<span class="st">&quot;Element&quot;</span>] <span class="op">=</span> results_df[<span class="st">&quot;Space&quot;</span>] <span class="op">+</span><span class="st">&quot; &quot;</span> <span class="op">+</span>results_df[<span class="st">&quot;Degree&quot;</span>]</span>
<span id="cb286-5"><a href="#cb286-5" aria-hidden="true" tabindex="-1"></a>hue_order <span class="op">=</span> <span class="bu">sorted</span>(results_df[<span class="st">&quot;Space&quot;</span>].unique())</span>
<span id="cb286-6"><a href="#cb286-6" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> degree <span class="kw">in</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]:</span>
<span id="cb286-7"><a href="#cb286-7" aria-hidden="true" tabindex="-1"></a>  df_degree <span class="op">=</span> results_df[results_df[<span class="st">&quot;Degree&quot;</span>] <span class="op">==</span> <span class="bu">str</span>(degree)]</span>
<span id="cb286-8"><a href="#cb286-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb286-9"><a href="#cb286-9" aria-hidden="true" tabindex="-1"></a>  g <span class="op">=</span> seaborn.catplot(</span>
<span id="cb286-10"><a href="#cb286-10" aria-hidden="true" tabindex="-1"></a>    x<span class="op">=</span><span class="st">&quot;Options&quot;</span>, </span>
<span id="cb286-11"><a href="#cb286-11" aria-hidden="true" tabindex="-1"></a>    y<span class="op">=</span><span class="st">&quot;Time&quot;</span>, </span>
<span id="cb286-12"><a href="#cb286-12" aria-hidden="true" tabindex="-1"></a>    hue<span class="op">=</span><span class="st">&quot;Space&quot;</span>,</span>
<span id="cb286-13"><a href="#cb286-13" aria-hidden="true" tabindex="-1"></a>    hue_order<span class="op">=</span>hue_order, </span>
<span id="cb286-14"><a href="#cb286-14" aria-hidden="true" tabindex="-1"></a>    kind<span class="op">=</span><span class="st">&quot;bar&quot;</span>, </span>
<span id="cb286-15"><a href="#cb286-15" aria-hidden="true" tabindex="-1"></a>    data<span class="op">=</span>df_degree,</span>
<span id="cb286-16"><a href="#cb286-16" aria-hidden="true" tabindex="-1"></a>    height<span class="op">=</span><span class="dv">3</span>,</span>
<span id="cb286-17"><a href="#cb286-17" aria-hidden="true" tabindex="-1"></a>    aspect<span class="op">=</span><span class="fl">4.0</span>)</span>
<span id="cb286-18"><a href="#cb286-18" aria-hidden="true" tabindex="-1"></a>  g.fig.suptitle(<span class="ss">f&quot;Degree = </span><span class="sc">{</span>degree<span class="sc">}</span><span class="ss">&quot;</span>, y<span class="op">=</span><span class="fl">1.02</span>)</span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img src="x_PDE_FEniCS_files/figure-html/cell-245-output-1.png" width="1253" height="295" /></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img src="x_PDE_FEniCS_files/figure-html/cell-245-output-2.png" width="1244" height="295" /></p>
</figure>
</div>
</div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img src="x_PDE_FEniCS_files/figure-html/cell-245-output-3.png" width="1254" height="295" /></p>
</figure>
</div>
</div>
</div>
<p>We observe that the compile time increases as the degree of the function space grows, and that the greatest speedup is achieved when using <code>-O3</code> or <code>-Ofast</code> in combination with <code>-march=native</code></p>
</section>
<section id="error-control-computing-convergence-rates" class="level3" data-number="K.9.3">
<h3 data-number="K.9.3"><span class="header-section-number">K.9.3</span> Error control: Computing convergence rates</h3>
<p>Author: Jørgen S. Dokken, Hans Petter Langtangen, Anders Logg</p>
<p>For any numerical method, one of the most fundamental questions is its convergence rate: how fast the error decreases as the resolution is increased (i.e., as the mesh size is decreased)</p>
<p>In the finite element method, this typically involves proving—either theoretically or empirically—that the error <span class="math inline">\(\| u - u_h \|\)</span> is bounded by a constant times the mesh size <span class="math inline">\(h\)</span> raised to some power <span class="math inline">\(p\)</span>, that is,</p>
<p><span class="math display">\[\| u - u_h \| \le C \, h^p\]</span></p>
<p>for some constant <span class="math inline">\(C\)</span> independent of the mesh. The number <span class="math inline">\(p\)</span> is called the convergence rate of the method. Note that different norms, such as the <span class="math inline">\(L^2\)</span>-norm or the <span class="math inline">\(H^1\)</span>-norm, generally yield different convergence rates</p>
<p><strong>Computing error norms</strong></p>
<p>We first construct a manufactured problem based on the same configuration used in the solver</p>
<div id="9032dd0f" class="cell" data-execution_count="245">
<div class="sourceCode" id="cb287"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb287-1"><a href="#cb287-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb287-2"><a href="#cb287-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb287-3"><a href="#cb287-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-4"><a href="#cb287-4" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx <span class="im">import</span> default_scalar_type</span>
<span id="cb287-5"><a href="#cb287-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.mesh <span class="im">import</span> create_unit_square, locate_entities_boundary</span>
<span id="cb287-6"><a href="#cb287-6" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem <span class="im">import</span> (Expression, Function, functionspace,</span>
<span id="cb287-7"><a href="#cb287-7" aria-hidden="true" tabindex="-1"></a>                         assemble_scalar, dirichletbc, form, locate_dofs_topological)</span>
<span id="cb287-8"><a href="#cb287-8" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dolfinx.fem.petsc <span class="im">import</span> LinearProblem</span>
<span id="cb287-9"><a href="#cb287-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-10"><a href="#cb287-10" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ufl</span>
<span id="cb287-11"><a href="#cb287-11" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> ufl <span class="im">import</span> (SpatialCoordinate, TestFunction, TrialFunction, </span>
<span id="cb287-12"><a href="#cb287-12" aria-hidden="true" tabindex="-1"></a>                 div, dot, dx, grad, inner)</span>
<span id="cb287-13"><a href="#cb287-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-14"><a href="#cb287-14" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> u_ex(mod):</span>
<span id="cb287-15"><a href="#cb287-15" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="kw">lambda</span> x: mod.cos(<span class="dv">2</span> <span class="op">*</span>mod.pi <span class="op">*</span>x[<span class="dv">0</span>]) <span class="op">*</span>mod.cos(<span class="dv">2</span> <span class="op">*</span>mod.pi <span class="op">*</span>x[<span class="dv">1</span>])</span>
<span id="cb287-16"><a href="#cb287-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-17"><a href="#cb287-17" aria-hidden="true" tabindex="-1"></a>u_numpy <span class="op">=</span> u_ex(np)</span>
<span id="cb287-18"><a href="#cb287-18" aria-hidden="true" tabindex="-1"></a>u_ufl <span class="op">=</span> u_ex(ufl)</span>
<span id="cb287-19"><a href="#cb287-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-20"><a href="#cb287-20" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> solve_poisson(N<span class="op">=</span><span class="dv">10</span>, degree<span class="op">=</span><span class="dv">1</span>):</span>
<span id="cb287-21"><a href="#cb287-21" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-22"><a href="#cb287-22" aria-hidden="true" tabindex="-1"></a>  mesh <span class="op">=</span> create_unit_square(MPI.COMM_WORLD, N, N)</span>
<span id="cb287-23"><a href="#cb287-23" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb287-24"><a href="#cb287-24" aria-hidden="true" tabindex="-1"></a>  x <span class="op">=</span> SpatialCoordinate(mesh)</span>
<span id="cb287-25"><a href="#cb287-25" aria-hidden="true" tabindex="-1"></a>  f <span class="op">=</span> <span class="op">-</span>div(grad(u_ufl(x)))</span>
<span id="cb287-26"><a href="#cb287-26" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb287-27"><a href="#cb287-27" aria-hidden="true" tabindex="-1"></a>  V <span class="op">=</span> functionspace(mesh, (<span class="st">&quot;Lagrange&quot;</span>, degree))</span>
<span id="cb287-28"><a href="#cb287-28" aria-hidden="true" tabindex="-1"></a>  u <span class="op">=</span> TrialFunction(V)</span>
<span id="cb287-29"><a href="#cb287-29" aria-hidden="true" tabindex="-1"></a>  v <span class="op">=</span> TestFunction(V)</span>
<span id="cb287-30"><a href="#cb287-30" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb287-31"><a href="#cb287-31" aria-hidden="true" tabindex="-1"></a>  a <span class="op">=</span> inner(grad(u), grad(v)) <span class="op">*</span>dx</span>
<span id="cb287-32"><a href="#cb287-32" aria-hidden="true" tabindex="-1"></a>  L <span class="op">=</span> f <span class="op">*</span>v <span class="op">*</span>dx</span>
<span id="cb287-33"><a href="#cb287-33" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb287-34"><a href="#cb287-34" aria-hidden="true" tabindex="-1"></a>  u_bc <span class="op">=</span> Function(V)</span>
<span id="cb287-35"><a href="#cb287-35" aria-hidden="true" tabindex="-1"></a>  u_bc.interpolate(u_numpy)</span>
<span id="cb287-36"><a href="#cb287-36" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb287-37"><a href="#cb287-37" aria-hidden="true" tabindex="-1"></a>  facets <span class="op">=</span> locate_entities_boundary(</span>
<span id="cb287-38"><a href="#cb287-38" aria-hidden="true" tabindex="-1"></a>    mesh, </span>
<span id="cb287-39"><a href="#cb287-39" aria-hidden="true" tabindex="-1"></a>    mesh.topology.dim <span class="op">-</span><span class="dv">1</span>, </span>
<span id="cb287-40"><a href="#cb287-40" aria-hidden="true" tabindex="-1"></a>    <span class="kw">lambda</span> x: np.full(x.shape[<span class="dv">1</span>], <span class="va">True</span>)</span>
<span id="cb287-41"><a href="#cb287-41" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb287-42"><a href="#cb287-42" aria-hidden="true" tabindex="-1"></a>  dofs <span class="op">=</span> locate_dofs_topological(</span>
<span id="cb287-43"><a href="#cb287-43" aria-hidden="true" tabindex="-1"></a>    V, </span>
<span id="cb287-44"><a href="#cb287-44" aria-hidden="true" tabindex="-1"></a>    mesh.topology.dim <span class="op">-</span><span class="dv">1</span>, </span>
<span id="cb287-45"><a href="#cb287-45" aria-hidden="true" tabindex="-1"></a>    facets</span>
<span id="cb287-46"><a href="#cb287-46" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb287-47"><a href="#cb287-47" aria-hidden="true" tabindex="-1"></a>  bcs <span class="op">=</span> [dirichletbc(u_bc, dofs)]</span>
<span id="cb287-48"><a href="#cb287-48" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb287-49"><a href="#cb287-49" aria-hidden="true" tabindex="-1"></a>  default_problem <span class="op">=</span> LinearProblem(</span>
<span id="cb287-50"><a href="#cb287-50" aria-hidden="true" tabindex="-1"></a>    a, </span>
<span id="cb287-51"><a href="#cb287-51" aria-hidden="true" tabindex="-1"></a>    L, </span>
<span id="cb287-52"><a href="#cb287-52" aria-hidden="true" tabindex="-1"></a>    bcs<span class="op">=</span>bcs, </span>
<span id="cb287-53"><a href="#cb287-53" aria-hidden="true" tabindex="-1"></a>    petsc_options<span class="op">=</span>{<span class="st">&quot;ksp_type&quot;</span>: <span class="st">&quot;preonly&quot;</span>, <span class="st">&quot;pc_type&quot;</span>: <span class="st">&quot;lu&quot;</span>}</span>
<span id="cb287-54"><a href="#cb287-54" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb287-55"><a href="#cb287-55" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb287-56"><a href="#cb287-56" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> default_problem.solve(), u_ufl(x)</span></code></pre></div>
</div>
<p>Now, we compute the error between the analytical solution <span class="math inline">\(u_{\text{ex}} = u_{\text{ufl}}(x)\)</span> and the approximate solution <span class="math inline">\(u_h\)</span>. The <span class="math inline">\(L^2\)</span>-norm of the error</p>
<p><span class="math display">\[\| u_e - u_h \|_{L^2(\Omega)} = \left( \int_\Omega |u_e - u_h|^2 \, dx \right)^{1/2}\]</span></p>
<p>measures the pointwise accuracy of the approximate solution in an average sense. It quantifies how close <span class="math inline">\(u_h\)</span> is to <span class="math inline">\(u_e\)</span> in terms of their values</p>
<div id="ba6458a5" class="cell" data-execution_count="246">
<div class="sourceCode" id="cb288"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb288-1"><a href="#cb288-1" aria-hidden="true" tabindex="-1"></a>uh, u_ex <span class="op">=</span> solve_poisson(<span class="dv">10</span>)</span>
<span id="cb288-2"><a href="#cb288-2" aria-hidden="true" tabindex="-1"></a>comm <span class="op">=</span> uh.function_space.mesh.comm</span>
<span id="cb288-3"><a href="#cb288-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-4"><a href="#cb288-4" aria-hidden="true" tabindex="-1"></a>error_L2 <span class="op">=</span> form((uh <span class="op">-</span>u_ex)<span class="op">**</span><span class="dv">2</span> <span class="op">*</span>ufl.dx)</span>
<span id="cb288-5"><a href="#cb288-5" aria-hidden="true" tabindex="-1"></a>E_L2 <span class="op">=</span> np.sqrt(comm.allreduce(assemble_scalar(error_L2), MPI.SUM))</span>
<span id="cb288-6"><a href="#cb288-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb288-7"><a href="#cb288-7" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb288-8"><a href="#cb288-8" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f&quot;L2-error: </span><span class="sc">{</span>E_L2<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>L2-error: 5.28e-02</code></pre>
</div>
</div>
<p>Sometimes it is of interest to compute the error of the gradient field, <span class="math inline">\(\| \nabla (u_e - u_h) \|\)</span>, often referred to as the <span class="math inline">\(H_0^1\)</span>-norm of the error. This can be expressed as</p>
<p><span class="math display">\[\left( \int_\Omega \lvert \nabla (u_e - u_h) \rvert^2 \, dx \right)^{1/2}\]</span></p>
<p>The <span class="math inline">\(H_0^1\)</span>-norm measures the error in the so-called energy space, which is particularly relevant for elliptic partial differential equations, as it reflects how well the numerical solution captures the energy of the exact solution</p>
<div id="b00d7a46" class="cell" data-execution_count="247">
<div class="sourceCode" id="cb290"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb290-1"><a href="#cb290-1" aria-hidden="true" tabindex="-1"></a>eh <span class="op">=</span> uh <span class="op">-</span>u_ex</span>
<span id="cb290-2"><a href="#cb290-2" aria-hidden="true" tabindex="-1"></a>error_H10 <span class="op">=</span> form(dot(grad(eh), grad(eh)) <span class="op">*</span>dx)</span>
<span id="cb290-3"><a href="#cb290-3" aria-hidden="true" tabindex="-1"></a>E_H10 <span class="op">=</span> np.sqrt(comm.allreduce(assemble_scalar(error_H10), op<span class="op">=</span>MPI.SUM))</span>
<span id="cb290-4"><a href="#cb290-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb290-5"><a href="#cb290-5" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb290-6"><a href="#cb290-6" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f&quot;H01-error: </span><span class="sc">{</span>E_H10<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>H01-error: 1.36e+00</code></pre>
</div>
</div>
<p><strong>Reliable error norm computation</strong></p>
<p>However, expanding the expression gives</p>
<p><span class="math display">\[(u_{\text{ex}} - u_h)^2 = u_{\text{ex}}^2 + u_h^2 - 2u_{\text{ex}}u_h\]</span></p>
<p>If the error is small (while the solutions themselves are of moderate size), this calculation involves subtracting two quantities of order one—namely <span class="math inline">\(u_{\text{ex}}^2 + u_h^2 \sim 1\)</span> and <span class="math inline">\(2u_{\text{ex}}u_h \sim 1\)</span>—to obtain a much smaller number. This subtraction is prone to round-off errors</p>
<p>To avoid this issue, we interpolate both the approximate and the exact solutions into a higher-order function space. We then subtract their degrees of freedom to form an explicit error function. Finally, we assemble (integrate) the squared error and take the square root to obtain the <span class="math inline">\(L^2\)</span>-norm</p>
<div id="8ca9caf8" class="cell" data-execution_count="248">
<div class="sourceCode" id="cb292"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb292-1"><a href="#cb292-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> error_L2(uh, u_ex, degree_raise<span class="op">=</span><span class="dv">3</span>):</span>
<span id="cb292-2"><a href="#cb292-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-3"><a href="#cb292-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Create higher order function space</span></span>
<span id="cb292-4"><a href="#cb292-4" aria-hidden="true" tabindex="-1"></a>  mesh <span class="op">=</span> uh.function_space.mesh</span>
<span id="cb292-5"><a href="#cb292-5" aria-hidden="true" tabindex="-1"></a>  degree <span class="op">=</span> uh.function_space.ufl_element().degree</span>
<span id="cb292-6"><a href="#cb292-6" aria-hidden="true" tabindex="-1"></a>  family <span class="op">=</span> uh.function_space.ufl_element().family_name</span>
<span id="cb292-7"><a href="#cb292-7" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb292-8"><a href="#cb292-8" aria-hidden="true" tabindex="-1"></a>  W <span class="op">=</span> functionspace(mesh, (family, degree <span class="op">+</span>degree_raise))</span>
<span id="cb292-9"><a href="#cb292-9" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb292-10"><a href="#cb292-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Interpolate approximate solution</span></span>
<span id="cb292-11"><a href="#cb292-11" aria-hidden="true" tabindex="-1"></a>  u_W <span class="op">=</span> Function(W)</span>
<span id="cb292-12"><a href="#cb292-12" aria-hidden="true" tabindex="-1"></a>  u_W.interpolate(uh)</span>
<span id="cb292-13"><a href="#cb292-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-14"><a href="#cb292-14" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Interpolate exact solution, special handling if exact solution</span></span>
<span id="cb292-15"><a href="#cb292-15" aria-hidden="true" tabindex="-1"></a>  <span class="co"># is a ufl expression or a python lambda function</span></span>
<span id="cb292-16"><a href="#cb292-16" aria-hidden="true" tabindex="-1"></a>  u_ex_W <span class="op">=</span> Function(W)</span>
<span id="cb292-17"><a href="#cb292-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="bu">isinstance</span>(u_ex, ufl.core.expr.Expr):</span>
<span id="cb292-18"><a href="#cb292-18" aria-hidden="true" tabindex="-1"></a>    u_expr <span class="op">=</span> Expression(u_ex, W.element.interpolation_points())</span>
<span id="cb292-19"><a href="#cb292-19" aria-hidden="true" tabindex="-1"></a>    u_ex_W.interpolate(u_expr)</span>
<span id="cb292-20"><a href="#cb292-20" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb292-21"><a href="#cb292-21" aria-hidden="true" tabindex="-1"></a>    u_ex_W.interpolate(u_ex)</span>
<span id="cb292-22"><a href="#cb292-22" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-23"><a href="#cb292-23" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Compute the error in the higher order function space</span></span>
<span id="cb292-24"><a href="#cb292-24" aria-hidden="true" tabindex="-1"></a>  e_W <span class="op">=</span> Function(W)</span>
<span id="cb292-25"><a href="#cb292-25" aria-hidden="true" tabindex="-1"></a>  e_W.x.array[:] <span class="op">=</span> u_W.x.array <span class="op">-</span>u_ex_W.x.array</span>
<span id="cb292-26"><a href="#cb292-26" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb292-27"><a href="#cb292-27" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Integrate the error</span></span>
<span id="cb292-28"><a href="#cb292-28" aria-hidden="true" tabindex="-1"></a>  error <span class="op">=</span> form(ufl.inner(e_W, e_W) <span class="op">*</span>ufl.dx)</span>
<span id="cb292-29"><a href="#cb292-29" aria-hidden="true" tabindex="-1"></a>  error_local <span class="op">=</span> assemble_scalar(error)</span>
<span id="cb292-30"><a href="#cb292-30" aria-hidden="true" tabindex="-1"></a>  error_global <span class="op">=</span> mesh.comm.allreduce(error_local, op<span class="op">=</span>MPI.SUM)</span>
<span id="cb292-31"><a href="#cb292-31" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb292-32"><a href="#cb292-32" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> np.sqrt(error_global)</span></code></pre></div>
</div>
<p><strong>Computing convergence rates</strong></p>
<p>Let us consider a sequence of mesh resolutions</p>
<p><span class="math display">\[h_0 &gt; h_1 &gt; h_2 &gt; \cdots, \qquad h_i = \frac{1}{N_i}\]</span></p>
<p>where <span class="math inline">\(N_i\)</span> denotes the number of subdivisions (or degrees of freedom) in the discretization. We compute the numerical error for a range of values of <span class="math inline">\(N_i\)</span></p>
<div id="1278b0a0" class="cell" data-execution_count="249">
<div class="sourceCode" id="cb293"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb293-1"><a href="#cb293-1" aria-hidden="true" tabindex="-1"></a>Ns <span class="op">=</span> [<span class="dv">4</span>, <span class="dv">8</span>, <span class="dv">16</span>, <span class="dv">32</span>, <span class="dv">64</span>]</span>
<span id="cb293-2"><a href="#cb293-2" aria-hidden="true" tabindex="-1"></a>Es <span class="op">=</span> np.zeros(<span class="bu">len</span>(Ns), dtype<span class="op">=</span>default_scalar_type)</span>
<span id="cb293-3"><a href="#cb293-3" aria-hidden="true" tabindex="-1"></a>hs <span class="op">=</span> np.zeros(<span class="bu">len</span>(Ns), dtype<span class="op">=</span>np.float64)</span>
<span id="cb293-4"><a href="#cb293-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-5"><a href="#cb293-5" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> i, N <span class="kw">in</span> <span class="bu">enumerate</span>(Ns):</span>
<span id="cb293-6"><a href="#cb293-6" aria-hidden="true" tabindex="-1"></a>  uh, u_ex <span class="op">=</span> solve_poisson(N, degree<span class="op">=</span><span class="dv">1</span>)</span>
<span id="cb293-7"><a href="#cb293-7" aria-hidden="true" tabindex="-1"></a>  comm <span class="op">=</span> uh.function_space.mesh.comm</span>
<span id="cb293-8"><a href="#cb293-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb293-9"><a href="#cb293-9" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Accepts either u_numpy or u_ex</span></span>
<span id="cb293-10"><a href="#cb293-10" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Use u_numpy for L2 error (no JIT needed)</span></span>
<span id="cb293-11"><a href="#cb293-11" aria-hidden="true" tabindex="-1"></a>  hs[i] <span class="op">=</span> <span class="fl">1.</span> <span class="op">/</span>Ns[i]</span>
<span id="cb293-12"><a href="#cb293-12" aria-hidden="true" tabindex="-1"></a>  Es[i] <span class="op">=</span> error_L2(uh, u_numpy)</span>
<span id="cb293-13"><a href="#cb293-13" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb293-14"><a href="#cb293-14" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;h: </span><span class="sc">{</span>hs[i]<span class="sc">:.2e}</span><span class="ss"> Error: </span><span class="sc">{</span>Es[i]<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>h: 2.50e-01 Error: 2.43e-01
h: 1.25e-01 Error: 7.96e-02
h: 6.25e-02 Error: 2.15e-02
h: 3.12e-02 Error: 5.47e-03
h: 1.56e-02 Error: 1.37e-03</code></pre>
</div>
</div>
<p>If we assume that the error <span class="math inline">\(E_i\)</span> can be expressed as</p>
<p><span class="math inline">\(E_i = C h_i^r\)</span></p>
<p>with unknown constants <span class="math inline">\(C\)</span> and <span class="math inline">\(r\)</span>, then by comparing two consecutive experiments</p>
<p><span class="math display">\[E_{i-1} = C h_{i-1}^r, \qquad E_i = C h_i^r\]</span></p>
<p>we can solve for <span class="math inline">\(r\)</span>:</p>
<p><span class="math display">\[r = \frac{\ln(E_i / E_{i-1})}{\ln(h_i / h_{i-1})}\]</span></p>
<p>As <span class="math inline">\(i\)</span> increases, the computed values of <span class="math inline">\(r\)</span> should approach the expected convergence rate, which in the case of the <span class="math inline">\(L^2\)</span>-error is typically the polynomial degree plus one. This calculation can be implemented compactly using <code>NumPy</code></p>
<div id="df439f5b" class="cell" data-execution_count="250">
<div class="sourceCode" id="cb295"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb295-1"><a href="#cb295-1" aria-hidden="true" tabindex="-1"></a>rates <span class="op">=</span> np.log(Es[<span class="dv">1</span>:] <span class="op">/</span>Es[:<span class="op">-</span><span class="dv">1</span>]) <span class="op">/</span>np.log(hs[<span class="dv">1</span>:] <span class="op">/</span>hs[:<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb295-2"><a href="#cb295-2" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb295-3"><a href="#cb295-3" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f&quot;Rates: </span><span class="sc">{</span>rates<span class="sc">}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Rates: [1.61228695 1.89147568 1.97191247 1.99290382]</code></pre>
</div>
</div>
<p>We perform a similar study for different polynomial orders to verify the previous claim</p>
<div id="f44611d9" class="cell" data-execution_count="251">
<div class="sourceCode" id="cb297"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb297-1"><a href="#cb297-1" aria-hidden="true" tabindex="-1"></a>degrees <span class="op">=</span> [<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>, <span class="dv">4</span>]</span>
<span id="cb297-2"><a href="#cb297-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> degree <span class="kw">in</span> degrees:</span>
<span id="cb297-3"><a href="#cb297-3" aria-hidden="true" tabindex="-1"></a>  hs <span class="op">=</span> np.zeros(<span class="bu">len</span>(Ns), dtype<span class="op">=</span>np.float64)</span>
<span id="cb297-4"><a href="#cb297-4" aria-hidden="true" tabindex="-1"></a>  Es <span class="op">=</span> np.zeros(<span class="bu">len</span>(Ns), dtype<span class="op">=</span>default_scalar_type)</span>
<span id="cb297-5"><a href="#cb297-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb297-6"><a href="#cb297-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i, N <span class="kw">in</span> <span class="bu">enumerate</span>(Ns):</span>
<span id="cb297-7"><a href="#cb297-7" aria-hidden="true" tabindex="-1"></a>    uh, u_ex <span class="op">=</span> solve_poisson(N, degree<span class="op">=</span>degree)</span>
<span id="cb297-8"><a href="#cb297-8" aria-hidden="true" tabindex="-1"></a>    comm <span class="op">=</span> uh.function_space.mesh.comm</span>
<span id="cb297-9"><a href="#cb297-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-10"><a href="#cb297-10" aria-hidden="true" tabindex="-1"></a>    hs[i] <span class="op">=</span> <span class="fl">1.</span> <span class="op">/</span>Ns[i]    </span>
<span id="cb297-11"><a href="#cb297-11" aria-hidden="true" tabindex="-1"></a>    Es[i] <span class="op">=</span> error_L2(uh, u_numpy, degree_raise<span class="op">=</span><span class="dv">3</span>)</span>
<span id="cb297-12"><a href="#cb297-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb297-13"><a href="#cb297-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb297-14"><a href="#cb297-14" aria-hidden="true" tabindex="-1"></a>      <span class="bu">print</span>(<span class="ss">f&quot;h: </span><span class="sc">{</span>hs[i]<span class="sc">:.2e}</span><span class="ss"> Error: </span><span class="sc">{</span>Es[i]<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span>
<span id="cb297-15"><a href="#cb297-15" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb297-16"><a href="#cb297-16" aria-hidden="true" tabindex="-1"></a>  rates <span class="op">=</span> np.log(Es[<span class="dv">1</span>:] <span class="op">/</span>Es[:<span class="op">-</span><span class="dv">1</span>]) <span class="op">/</span>np.log(hs[<span class="dv">1</span>:] <span class="op">/</span>hs[:<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb297-17"><a href="#cb297-17" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb297-18"><a href="#cb297-18" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Polynomial degree </span><span class="sc">{</span>degree<span class="sc">:d}</span><span class="ss">, Rates </span><span class="sc">{</span>rates<span class="sc">}</span><span class="ch">\n</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>h: 2.50e-01 Error: 2.43e-01
h: 1.25e-01 Error: 7.96e-02
h: 6.25e-02 Error: 2.15e-02
h: 3.12e-02 Error: 5.47e-03
h: 1.56e-02 Error: 1.37e-03
Polynomial degree 1, Rates [1.61228695 1.89147568 1.97191247 1.99290382]

h: 2.50e-01 Error: 3.52e-02
h: 1.25e-01 Error: 4.39e-03
h: 6.25e-02 Error: 5.50e-04
h: 3.12e-02 Error: 6.88e-05
h: 1.56e-02 Error: 8.60e-06
Polynomial degree 2, Rates [3.00109101 2.99828073 2.99822291 2.99930786]

h: 2.50e-01 Error: 5.54e-03
h: 1.25e-01 Error: 3.35e-04
h: 6.25e-02 Error: 1.99e-05
h: 3.12e-02 Error: 1.21e-06
h: 1.56e-02 Error: 7.49e-08
Polynomial degree 3, Rates [4.04795047 4.07357659 4.03728992 4.01645269]

h: 2.50e-01 Error: 7.20e-04
h: 1.25e-01 Error: 2.42e-05
h: 6.25e-02 Error: 7.75e-07
h: 3.12e-02 Error: 2.44e-08
h: 1.56e-02 Error: 7.64e-10
Polynomial degree 4, Rates [4.896908   4.96084158 4.98926012 4.99766448]
</code></pre>
</div>
</div>
<p><strong>Infinity norm estimates</strong></p>
<p>We first define a function to evaluate the infinity norm, i.e., the maximum pointwise error between the numerical and exact solutions</p>
<div id="475b08f1" class="cell" data-execution_count="252">
<div class="sourceCode" id="cb299"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb299-1"><a href="#cb299-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> error_infinity(u_h, u_ex):</span>
<span id="cb299-2"><a href="#cb299-2" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Interpolate exact solution (UFL or lambda handled separately)</span></span>
<span id="cb299-3"><a href="#cb299-3" aria-hidden="true" tabindex="-1"></a>  u_ex_V <span class="op">=</span> Function(u_h.function_space)</span>
<span id="cb299-4"><a href="#cb299-4" aria-hidden="true" tabindex="-1"></a>  comm <span class="op">=</span> u_h.function_space.mesh.comm</span>
<span id="cb299-5"><a href="#cb299-5" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb299-6"><a href="#cb299-6" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> <span class="bu">isinstance</span>(u_ex, ufl.core.expr.Expr):</span>
<span id="cb299-7"><a href="#cb299-7" aria-hidden="true" tabindex="-1"></a>    u_expr <span class="op">=</span> Expression(u_ex, u_h.function_space.element.interpolation_points())</span>
<span id="cb299-8"><a href="#cb299-8" aria-hidden="true" tabindex="-1"></a>    u_ex_V.interpolate(u_expr)</span>
<span id="cb299-9"><a href="#cb299-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">else</span>:</span>
<span id="cb299-10"><a href="#cb299-10" aria-hidden="true" tabindex="-1"></a>    u_ex_V.interpolate(u_ex)</span>
<span id="cb299-11"><a href="#cb299-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb299-12"><a href="#cb299-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Compute global infinity norm from local maxima  </span></span>
<span id="cb299-13"><a href="#cb299-13" aria-hidden="true" tabindex="-1"></a>  error_max_local <span class="op">=</span> np.<span class="bu">max</span>(np.<span class="bu">abs</span>(u_h.x.array <span class="op">-</span>u_ex_V.x.array))</span>
<span id="cb299-14"><a href="#cb299-14" aria-hidden="true" tabindex="-1"></a>  error_max <span class="op">=</span> comm.allreduce(error_max_local, op<span class="op">=</span>MPI.MAX)</span>
<span id="cb299-15"><a href="#cb299-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb299-16"><a href="#cb299-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> error_max</span></code></pre></div>
</div>
<p>Performing this procedure for various polynomial degrees produces the following results:</p>
<div id="37d56135" class="cell" data-execution_count="253">
<div class="sourceCode" id="cb300"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb300-1"><a href="#cb300-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> degree <span class="kw">in</span> degrees:</span>
<span id="cb300-2"><a href="#cb300-2" aria-hidden="true" tabindex="-1"></a>  hs <span class="op">=</span> np.zeros(<span class="bu">len</span>(Ns), dtype<span class="op">=</span>np.float64)    </span>
<span id="cb300-3"><a href="#cb300-3" aria-hidden="true" tabindex="-1"></a>  Es <span class="op">=</span> np.zeros(<span class="bu">len</span>(Ns), dtype<span class="op">=</span>default_scalar_type)</span>
<span id="cb300-4"><a href="#cb300-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb300-5"><a href="#cb300-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">for</span> i, N <span class="kw">in</span> <span class="bu">enumerate</span>(Ns):</span>
<span id="cb300-6"><a href="#cb300-6" aria-hidden="true" tabindex="-1"></a>    uh, u_ex <span class="op">=</span> solve_poisson(N, degree<span class="op">=</span>degree)</span>
<span id="cb300-7"><a href="#cb300-7" aria-hidden="true" tabindex="-1"></a>    comm <span class="op">=</span> uh.function_space.mesh.comm</span>
<span id="cb300-8"><a href="#cb300-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb300-9"><a href="#cb300-9" aria-hidden="true" tabindex="-1"></a>    hs[i] <span class="op">=</span> <span class="fl">1.</span> <span class="op">/</span>Ns[i]    </span>
<span id="cb300-10"><a href="#cb300-10" aria-hidden="true" tabindex="-1"></a>    Es[i] <span class="op">=</span> error_infinity(uh, u_numpy)</span>
<span id="cb300-11"><a href="#cb300-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb300-12"><a href="#cb300-12" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb300-13"><a href="#cb300-13" aria-hidden="true" tabindex="-1"></a>       <span class="bu">print</span>(<span class="ss">f&quot;h: </span><span class="sc">{</span>hs[i]<span class="sc">:.2e}</span><span class="ss"> Error: </span><span class="sc">{</span>Es[i]<span class="sc">:.2e}</span><span class="ss">&quot;</span>)</span>
<span id="cb300-14"><a href="#cb300-14" aria-hidden="true" tabindex="-1"></a>    </span>
<span id="cb300-15"><a href="#cb300-15" aria-hidden="true" tabindex="-1"></a>  rates <span class="op">=</span> np.log(Es[<span class="dv">1</span>:] <span class="op">/</span>Es[:<span class="op">-</span><span class="dv">1</span>]) <span class="op">/</span>np.log(hs[<span class="dv">1</span>:] <span class="op">/</span>hs[:<span class="op">-</span><span class="dv">1</span>])</span>
<span id="cb300-16"><a href="#cb300-16" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb300-17"><a href="#cb300-17" aria-hidden="true" tabindex="-1"></a>    <span class="bu">print</span>(<span class="ss">f&quot;Polynomial degree </span><span class="sc">{</span>degree<span class="sc">:d}</span><span class="ss">, Rates </span><span class="sc">{</span>rates<span class="sc">}</span><span class="ch">\n</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>h: 2.50e-01 Error: 2.73e-01
h: 1.25e-01 Error: 6.96e-02
h: 6.25e-02 Error: 1.75e-02
h: 3.12e-02 Error: 4.38e-03
h: 1.56e-02 Error: 1.10e-03
Polynomial degree 1, Rates [1.96828918 1.9917697  1.99791282 1.99947611]

h: 2.50e-01 Error: 4.85e-02
h: 1.25e-01 Error: 3.65e-03
h: 6.25e-02 Error: 2.37e-04
h: 3.12e-02 Error: 1.50e-05
h: 1.56e-02 Error: 9.38e-07
Polynomial degree 2, Rates [3.73213705 3.94227924 3.98612529 3.99656575]

h: 2.50e-01 Error: 1.08e-02
h: 1.25e-01 Error: 8.13e-04
h: 6.25e-02 Error: 5.86e-05
h: 3.12e-02 Error: 3.80e-06
h: 1.56e-02 Error: 2.41e-07
Polynomial degree 3, Rates [3.72903577 3.79406598 3.94800701 3.97888408]

h: 2.50e-01 Error: 1.63e-03
h: 1.25e-01 Error: 5.23e-05
h: 6.25e-02 Error: 1.67e-06
h: 3.12e-02 Error: 5.25e-08
h: 1.56e-02 Error: 1.64e-09
Polynomial degree 4, Rates [4.96133103 4.96807694 4.99161588 4.99787562]
</code></pre>
</div>
</div>
<p>We observe superconvergence for second-order polynomials, resulting in an observed fourth-order convergence</p>
</section>
<section id="custom-newton-solvers" class="level3" data-number="K.9.4">
<h3 data-number="K.9.4"><span class="header-section-number">K.9.4</span> Custom Newton solvers</h3>
<p>Author: Jørgen S. Dokken</p>
<p>Newton’s Method, as used in the non-linear Poisson problem, is a technique for solving a non-linear equation by iteratively solving a sequence of linear equations. Given a function <span class="math inline">\(F:\mathbb{R}^M \to \mathbb{R}^M\)</span>, the iterates <span class="math inline">\(u_k, u_{k+1} \in \mathbb{R}^M\)</span> satisfy</p>
<p><span class="math display">\[u_{k+1} = u_k - J_F(u_k)^{-1} F(u_k)\]</span></p>
<p>where <span class="math inline">\(J_F(u_k)\)</span> is the Jacobian matrix of <span class="math inline">\(F\)</span> at <span class="math inline">\(u_k\)</span></p>
<p>Introducing the increment <span class="math inline">\(\delta u_k = u_{k+1} - u_k\)</span>, this can be rewritten as the linear system</p>
<p><span class="math display">\[J_F(u_k) \, \delta u_k = - F(u_k)\]</span></p>
<p>with the update</p>
<p><span class="math display">\[u_{k+1} = u_k + \delta u_k\]</span></p>
<p><strong>Problem specification</strong></p>
<p>We start by importing the required libraries</p>
<div id="9bc5ab83" class="cell" data-execution_count="254">
<div class="sourceCode" id="cb302"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb302-1"><a href="#cb302-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb302-2"><a href="#cb302-2" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> mpi4py <span class="im">import</span> MPI</span>
<span id="cb302-3"><a href="#cb302-3" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> petsc4py <span class="im">import</span> PETSc</span>
<span id="cb302-4"><a href="#cb302-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-5"><a href="#cb302-5" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb302-6"><a href="#cb302-6" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> pyvista</span>
<span id="cb302-7"><a href="#cb302-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-8"><a href="#cb302-8" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dolfinx</span>
<span id="cb302-9"><a href="#cb302-9" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dolfinx.fem.petsc</span>
<span id="cb302-10"><a href="#cb302-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-11"><a href="#cb302-11" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> ufl</span>
<span id="cb302-12"><a href="#cb302-12" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb302-13"><a href="#cb302-13" aria-hidden="true" tabindex="-1"></a>plt.style.use(<span class="st">&#39;default&#39;</span>)</span></code></pre></div>
</div>
<p>We consider the following non-linear problem:</p>
<p><span class="math display">\[u^2 - 2u = x^2 + 4x + 3 \quad \text{for } x \in [0,1]\]</span></p>
<p>This problem has two solutions: <span class="math inline">\(u = -x - 1\)</span> and <span class="math inline">\(u = x + 3\)</span>. We define these roots as Python functions and create an appropriate array of points for plotting the solutions</p>
<div id="3d589e83" class="cell" data-execution_count="255">
<div class="sourceCode" id="cb303"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb303-1"><a href="#cb303-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> root_0(x):</span>
<span id="cb303-2"><a href="#cb303-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">3</span> <span class="op">+</span>x[<span class="dv">0</span>]</span>
<span id="cb303-3"><a href="#cb303-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-4"><a href="#cb303-4" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> root_1(x):</span>
<span id="cb303-5"><a href="#cb303-5" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="op">-</span><span class="dv">1</span> <span class="op">-</span>x[<span class="dv">0</span>]</span>
<span id="cb303-6"><a href="#cb303-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb303-7"><a href="#cb303-7" aria-hidden="true" tabindex="-1"></a>N <span class="op">=</span> <span class="dv">10</span></span>
<span id="cb303-8"><a href="#cb303-8" aria-hidden="true" tabindex="-1"></a>x_spacing <span class="op">=</span> np.linspace(<span class="dv">0</span>, <span class="dv">1</span>, N)</span>
<span id="cb303-9"><a href="#cb303-9" aria-hidden="true" tabindex="-1"></a>roots <span class="op">=</span> [root_0, root_1]</span></code></pre></div>
</div>
<p>Starting with the initial guess <span class="math inline">\(u_0 = 0\)</span>, we then define the mesh, the function space, and the function <code>uh</code> for the numerical solution</p>
<div id="5da53b70" class="cell" data-execution_count="256">
<div class="sourceCode" id="cb304"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb304-1"><a href="#cb304-1" aria-hidden="true" tabindex="-1"></a>mesh <span class="op">=</span> dolfinx.mesh.create_unit_interval(MPI.COMM_WORLD, N)</span>
<span id="cb304-2"><a href="#cb304-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb304-3"><a href="#cb304-3" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> dolfinx.fem.functionspace(mesh, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span>
<span id="cb304-4"><a href="#cb304-4" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> dolfinx.fem.Function(V)</span></code></pre></div>
</div>
<p><strong>Definition of residual and Jacobian</strong></p>
<p>We then formulate the variational problem by multiplying with a test function and integrating over the domain <span class="math inline">\([0,1]\)</span></p>
<div id="298c5e23" class="cell" data-execution_count="257">
<div class="sourceCode" id="cb305"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb305-1"><a href="#cb305-1" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> ufl.TestFunction(V)</span>
<span id="cb305-2"><a href="#cb305-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb305-3"><a href="#cb305-3" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> ufl.SpatialCoordinate(mesh)</span>
<span id="cb305-4"><a href="#cb305-4" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> uh<span class="op">**</span><span class="dv">2</span> <span class="op">*</span>v <span class="op">*</span>ufl.dx <span class="op">-</span><span class="dv">2</span> <span class="op">*</span>uh <span class="op">*</span>v <span class="op">*</span>ufl.dx <span class="op">-</span>(x[<span class="dv">0</span>]<span class="op">**</span><span class="dv">2</span> <span class="op">+</span><span class="dv">4</span> <span class="op">*</span>x[<span class="dv">0</span>] <span class="op">+</span><span class="dv">3</span>) <span class="op">*</span>v <span class="op">*</span>ufl.dx</span>
<span id="cb305-5"><a href="#cb305-5" aria-hidden="true" tabindex="-1"></a>residual <span class="op">=</span> dolfinx.fem.form(F)</span></code></pre></div>
</div>
<p>The Jacobian <span class="math inline">\(J_F\)</span> is then obtained by applying <code>ufl.derivative</code> to the variational form</p>
<div id="bf85b486" class="cell" data-execution_count="258">
<div class="sourceCode" id="cb306"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb306-1"><a href="#cb306-1" aria-hidden="true" tabindex="-1"></a>J <span class="op">=</span> ufl.derivative(F, uh)</span>
<span id="cb306-2"><a href="#cb306-2" aria-hidden="true" tabindex="-1"></a>jacobian <span class="op">=</span> dolfinx.fem.form(J)</span></code></pre></div>
</div>
<p>As the problem will be solved iteratively, the sparse matrix and residual vector are assembled only once</p>
<p><strong>Setup of iteration-independent structures</strong></p>
<div id="35eb9eae" class="cell" data-execution_count="259">
<div class="sourceCode" id="cb307"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb307-1"><a href="#cb307-1" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> dolfinx.fem.petsc.create_matrix(jacobian)</span>
<span id="cb307-2"><a href="#cb307-2" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> dolfinx.fem.petsc.create_vector(residual)</span></code></pre></div>
</div>
<p>We then set up the linear solver together with a vector to hold the update <code>du</code></p>
<div id="033e591d" class="cell" data-execution_count="260">
<div class="sourceCode" id="cb308"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb308-1"><a href="#cb308-1" aria-hidden="true" tabindex="-1"></a>solver <span class="op">=</span> PETSc.KSP().create(mesh.comm)</span>
<span id="cb308-2"><a href="#cb308-2" aria-hidden="true" tabindex="-1"></a>solver.setOperators(A)</span>
<span id="cb308-3"><a href="#cb308-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb308-4"><a href="#cb308-4" aria-hidden="true" tabindex="-1"></a>du <span class="op">=</span> dolfinx.fem.Function(V)</span></code></pre></div>
</div>
<p>To monitor the evolution of <code>uh</code> during the iterations, we obtain the DoF coordinates and sort them in ascending order</p>
<div id="44940fe7" class="cell" data-execution_count="261">
<div class="sourceCode" id="cb309"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb309-1"><a href="#cb309-1" aria-hidden="true" tabindex="-1"></a>coords <span class="op">=</span> V.tabulate_dof_coordinates()[:, <span class="dv">0</span>]</span>
<span id="cb309-2"><a href="#cb309-2" aria-hidden="true" tabindex="-1"></a>sort_order <span class="op">=</span> np.argsort(coords)</span>
<span id="cb309-3"><a href="#cb309-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb309-4"><a href="#cb309-4" aria-hidden="true" tabindex="-1"></a>max_iterations <span class="op">=</span> <span class="dv">25</span></span>
<span id="cb309-5"><a href="#cb309-5" aria-hidden="true" tabindex="-1"></a>solutions <span class="op">=</span> np.zeros((max_iterations <span class="op">+</span><span class="dv">1</span>, <span class="bu">len</span>(coords)))</span>
<span id="cb309-6"><a href="#cb309-6" aria-hidden="true" tabindex="-1"></a>solutions[<span class="dv">0</span>] <span class="op">=</span> uh.x.array[sort_order]</span></code></pre></div>
</div>
<p>At this stage, we are ready to solve the linearized problem. For each iteration, the Jacobian and residual are reassembled, and the norm of the update (<code>dx</code>) is used as the stopping criterion</p>
<div id="8fed54d9" class="cell" data-execution_count="262">
<div class="sourceCode" id="cb310"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb310-1"><a href="#cb310-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb310-2"><a href="#cb310-2" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> i <span class="op">&lt;</span> max_iterations:</span>
<span id="cb310-3"><a href="#cb310-3" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Assemble Jacobian and residual</span></span>
<span id="cb310-4"><a href="#cb310-4" aria-hidden="true" tabindex="-1"></a>  <span class="cf">with</span> L.localForm() <span class="im">as</span> loc_L:</span>
<span id="cb310-5"><a href="#cb310-5" aria-hidden="true" tabindex="-1"></a>    loc_L.<span class="bu">set</span>(<span class="dv">0</span>)</span>
<span id="cb310-6"><a href="#cb310-6" aria-hidden="true" tabindex="-1"></a>  A.zeroEntries()</span>
<span id="cb310-7"><a href="#cb310-7" aria-hidden="true" tabindex="-1"></a>  dolfinx.fem.petsc.assemble_matrix(A, jacobian)</span>
<span id="cb310-8"><a href="#cb310-8" aria-hidden="true" tabindex="-1"></a>  A.assemble()</span>
<span id="cb310-9"><a href="#cb310-9" aria-hidden="true" tabindex="-1"></a>  dolfinx.fem.petsc.assemble_vector(L, residual)</span>
<span id="cb310-10"><a href="#cb310-10" aria-hidden="true" tabindex="-1"></a>  L.ghostUpdate(addv<span class="op">=</span>PETSc.InsertMode.ADD_VALUES, mode<span class="op">=</span>PETSc.ScatterMode.REVERSE)</span>
<span id="cb310-11"><a href="#cb310-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-12"><a href="#cb310-12" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Scale residual by -1</span></span>
<span id="cb310-13"><a href="#cb310-13" aria-hidden="true" tabindex="-1"></a>  L.scale(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb310-14"><a href="#cb310-14" aria-hidden="true" tabindex="-1"></a>  L.ghostUpdate(addv<span class="op">=</span>PETSc.InsertMode.INSERT_VALUES, mode<span class="op">=</span>PETSc.ScatterMode.FORWARD)</span>
<span id="cb310-15"><a href="#cb310-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-16"><a href="#cb310-16" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Solve linear problem</span></span>
<span id="cb310-17"><a href="#cb310-17" aria-hidden="true" tabindex="-1"></a>  solver.solve(L, du.x.petsc_vec)</span>
<span id="cb310-18"><a href="#cb310-18" aria-hidden="true" tabindex="-1"></a>  du.x.scatter_forward()</span>
<span id="cb310-19"><a href="#cb310-19" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb310-20"><a href="#cb310-20" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Update u_{i+1} = u_i + delta u_i</span></span>
<span id="cb310-21"><a href="#cb310-21" aria-hidden="true" tabindex="-1"></a>  uh.x.array[:] <span class="op">+=</span> du.x.array</span>
<span id="cb310-22"><a href="#cb310-22" aria-hidden="true" tabindex="-1"></a>  i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb310-23"><a href="#cb310-23" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb310-24"><a href="#cb310-24" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Compute norm of update</span></span>
<span id="cb310-25"><a href="#cb310-25" aria-hidden="true" tabindex="-1"></a>  correction_norm <span class="op">=</span> du.x.petsc_vec.norm(<span class="dv">0</span>)  <span class="co"># L^2 norm</span></span>
<span id="cb310-26"><a href="#cb310-26" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f&quot;Iteration </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>correction_norm <span class="op">=</span> <span class="sc">:.6e}</span><span class="ss">&quot;</span>)</span>
<span id="cb310-27"><a href="#cb310-27" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> correction_norm <span class="op">&lt;</span> <span class="fl">1e-10</span>:</span>
<span id="cb310-28"><a href="#cb310-28" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span></span>
<span id="cb310-29"><a href="#cb310-29" aria-hidden="true" tabindex="-1"></a>  solutions[i, :] <span class="op">=</span> uh.x.array[sort_order]</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Iteration 1: correction_norm = 2.941583e+01
Iteration 2: correction_norm = 1.077679e+01
Iteration 3: correction_norm = 2.048893e+00
Iteration 4: correction_norm = 8.991947e-02
Iteration 5: correction_norm = 2.277570e-04
Iteration 6: correction_norm = 2.211497e-09
Iteration 7: correction_norm = 1.123544e-15</code></pre>
</div>
</div>
<p>At this point, we compute the residual magnitude to monitor convergence</p>
<div id="e904cff1" class="cell" data-execution_count="263">
<div class="sourceCode" id="cb312"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb312-1"><a href="#cb312-1" aria-hidden="true" tabindex="-1"></a>dolfinx.fem.petsc.assemble_vector(L, residual)</span>
<span id="cb312-2"><a href="#cb312-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="ss">f&quot;Final residual = </span><span class="sc">{</span>L<span class="sc">.</span>norm(<span class="dv">0</span>)<span class="sc">:.6e}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Final residual = 4.859835e-16</code></pre>
</div>
</div>
<p><strong>Visualization of Newton iterations</strong></p>
<p>We now study how the solution evolves and quantify its error with respect to the two exact roots of the problem</p>
<div id="cacafe90" class="cell" data-execution_count="264">
<div class="sourceCode" id="cb314"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb314-1"><a href="#cb314-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot solution for each of the iterations</span></span>
<span id="cb314-2"><a href="#cb314-2" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">8</span>, <span class="dv">6</span>))</span>
<span id="cb314-3"><a href="#cb314-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-4"><a href="#cb314-4" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j, solution <span class="kw">in</span> <span class="bu">enumerate</span>(solutions[:i]):</span>
<span id="cb314-5"><a href="#cb314-5" aria-hidden="true" tabindex="-1"></a>  plt.plot(coords[sort_order], solution, label<span class="op">=</span><span class="ss">f&quot;Iteration </span><span class="sc">{</span>j<span class="sc">}</span><span class="ss">&quot;</span>)</span>
<span id="cb314-6"><a href="#cb314-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-7"><a href="#cb314-7" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot each of the roots of the problem, </span></span>
<span id="cb314-8"><a href="#cb314-8" aria-hidden="true" tabindex="-1"></a><span class="co"># and compare the approximate solution with each of them</span></span>
<span id="cb314-9"><a href="#cb314-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> j, root <span class="kw">in</span> <span class="bu">enumerate</span>(roots):</span>
<span id="cb314-10"><a href="#cb314-10" aria-hidden="true" tabindex="-1"></a>  u_ex <span class="op">=</span> root(x)</span>
<span id="cb314-11"><a href="#cb314-11" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb314-12"><a href="#cb314-12" aria-hidden="true" tabindex="-1"></a>  L2_error <span class="op">=</span> dolfinx.fem.form(ufl.inner(uh <span class="op">-</span>u_ex, uh <span class="op">-</span>u_ex) <span class="op">*</span>ufl.dx)</span>
<span id="cb314-13"><a href="#cb314-13" aria-hidden="true" tabindex="-1"></a>  global_L2 <span class="op">=</span> mesh.comm.allreduce(</span>
<span id="cb314-14"><a href="#cb314-14" aria-hidden="true" tabindex="-1"></a>    dolfinx.fem.assemble_scalar(L2_error), </span>
<span id="cb314-15"><a href="#cb314-15" aria-hidden="true" tabindex="-1"></a>    op<span class="op">=</span>MPI.SUM</span>
<span id="cb314-16"><a href="#cb314-16" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb314-17"><a href="#cb314-17" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f&quot;L2-error (root </span><span class="sc">{</span>j<span class="sc">}</span><span class="ss">) </span><span class="sc">{</span>np<span class="sc">.</span>sqrt(global_L2)<span class="sc">:.6e}</span><span class="ss">&quot;</span>)</span>
<span id="cb314-18"><a href="#cb314-18" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-19"><a href="#cb314-19" aria-hidden="true" tabindex="-1"></a>  plt.plot(x_spacing, root(x_spacing.reshape(<span class="dv">1</span>, <span class="op">-</span><span class="dv">1</span>)), <span class="st">&#39;:o&#39;</span>, label<span class="op">=</span><span class="ss">f&#39;root_</span><span class="sc">{</span>j<span class="sc">}</span><span class="ss">&#39;</span>)</span>
<span id="cb314-20"><a href="#cb314-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb314-21"><a href="#cb314-21" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&#39;x&#39;</span>)</span>
<span id="cb314-22"><a href="#cb314-22" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="st">&#39;u&#39;</span>)</span>
<span id="cb314-23"><a href="#cb314-23" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb314-24"><a href="#cb314-24" aria-hidden="true" tabindex="-1"></a>plt.legend(bbox_to_anchor<span class="op">=</span>(<span class="fl">1.05</span>, <span class="dv">1</span>), loc<span class="op">=</span><span class="st">&#39;upper left&#39;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>L2-error (root 0) 5.033223e+00
L2-error (root 1) 1.110223e-16</code></pre>
</div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img src="x_PDE_FEniCS_files/figure-html/cell-265-output-2.png" width="849" height="525" /></p>
</figure>
</div>
</div>
</div>
<p><strong>Newton’s method with DirichletBC</strong></p>
<p>In the previous example, we did not incorporate Dirichlet boundary conditions. We now extend the formulation to the non-linear Poisson problem, where such boundary conditions play a central role. As a first step, we define the computational mesh, the analytical solution, and the corresponding forcing term <code>f</code></p>
<div id="6fd4277e" class="cell" data-execution_count="265">
<div class="sourceCode" id="cb316"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb316-1"><a href="#cb316-1" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> q(u):</span>
<span id="cb316-2"><a href="#cb316-2" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="dv">1</span> <span class="op">+</span>u<span class="op">**</span><span class="dv">2</span></span>
<span id="cb316-3"><a href="#cb316-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-4"><a href="#cb316-4" aria-hidden="true" tabindex="-1"></a>domain <span class="op">=</span> dolfinx.mesh.create_unit_square(MPI.COMM_WORLD, <span class="dv">10</span>, <span class="dv">10</span>)</span>
<span id="cb316-5"><a href="#cb316-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-6"><a href="#cb316-6" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> ufl.SpatialCoordinate(domain)</span>
<span id="cb316-7"><a href="#cb316-7" aria-hidden="true" tabindex="-1"></a>u_ufl <span class="op">=</span> <span class="dv">1</span> <span class="op">+</span>x[<span class="dv">0</span>] <span class="op">+</span><span class="dv">2</span> <span class="op">*</span>x[<span class="dv">1</span>]</span>
<span id="cb316-8"><a href="#cb316-8" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> <span class="op">-</span> ufl.div(q(u_ufl) <span class="op">*</span>ufl.grad(u_ufl))</span>
<span id="cb316-9"><a href="#cb316-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb316-10"><a href="#cb316-10" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> u_exact(x):</span>
<span id="cb316-11"><a href="#cb316-11" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> <span class="bu">eval</span>(<span class="bu">str</span>(u_ufl))</span></code></pre></div>
</div>
<p>Next, we specify the Dirichlet boundary condition <code>bc</code>, and define the variational residual <code>F</code> together with its Jacobian <code>J</code></p>
<div id="bda69888" class="cell" data-execution_count="266">
<div class="sourceCode" id="cb317"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb317-1"><a href="#cb317-1" aria-hidden="true" tabindex="-1"></a>V <span class="op">=</span> dolfinx.fem.functionspace(domain, (<span class="st">&quot;Lagrange&quot;</span>, <span class="dv">1</span>))</span>
<span id="cb317-2"><a href="#cb317-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-3"><a href="#cb317-3" aria-hidden="true" tabindex="-1"></a>u_D <span class="op">=</span> dolfinx.fem.Function(V)</span>
<span id="cb317-4"><a href="#cb317-4" aria-hidden="true" tabindex="-1"></a>u_D.interpolate(u_exact)</span>
<span id="cb317-5"><a href="#cb317-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-6"><a href="#cb317-6" aria-hidden="true" tabindex="-1"></a>fdim <span class="op">=</span> domain.topology.dim <span class="op">-</span><span class="dv">1</span></span>
<span id="cb317-7"><a href="#cb317-7" aria-hidden="true" tabindex="-1"></a>domain.topology.create_connectivity(fdim, fdim <span class="op">+</span><span class="dv">1</span>)</span>
<span id="cb317-8"><a href="#cb317-8" aria-hidden="true" tabindex="-1"></a>boundary_facets <span class="op">=</span> dolfinx.mesh.exterior_facet_indices(domain.topology)</span>
<span id="cb317-9"><a href="#cb317-9" aria-hidden="true" tabindex="-1"></a>bc <span class="op">=</span> dolfinx.fem.dirichletbc(</span>
<span id="cb317-10"><a href="#cb317-10" aria-hidden="true" tabindex="-1"></a>  u_D, </span>
<span id="cb317-11"><a href="#cb317-11" aria-hidden="true" tabindex="-1"></a>  dolfinx.fem.locate_dofs_topological(V, fdim, boundary_facets)</span>
<span id="cb317-12"><a href="#cb317-12" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb317-13"><a href="#cb317-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-14"><a href="#cb317-14" aria-hidden="true" tabindex="-1"></a>uh <span class="op">=</span> dolfinx.fem.Function(V)</span>
<span id="cb317-15"><a href="#cb317-15" aria-hidden="true" tabindex="-1"></a>v <span class="op">=</span> ufl.TestFunction(V)</span>
<span id="cb317-16"><a href="#cb317-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-17"><a href="#cb317-17" aria-hidden="true" tabindex="-1"></a>F <span class="op">=</span> q(uh) <span class="op">*</span>ufl.dot(ufl.grad(uh), ufl.grad(v)) <span class="op">*</span>ufl.dx <span class="op">-</span>f <span class="op">*</span>v <span class="op">*</span>ufl.dx</span>
<span id="cb317-18"><a href="#cb317-18" aria-hidden="true" tabindex="-1"></a>J <span class="op">=</span> ufl.derivative(F, uh)</span>
<span id="cb317-19"><a href="#cb317-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb317-20"><a href="#cb317-20" aria-hidden="true" tabindex="-1"></a>residual <span class="op">=</span> dolfinx.fem.form(F)</span>
<span id="cb317-21"><a href="#cb317-21" aria-hidden="true" tabindex="-1"></a>jacobian <span class="op">=</span> dolfinx.fem.form(J)</span></code></pre></div>
</div>
<p>We then set up the system matrix <code>A</code>, the right-hand side vector <code>L</code>, and the update function <code>du</code></p>
<div id="fd096df0" class="cell" data-execution_count="267">
<div class="sourceCode" id="cb318"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb318-1"><a href="#cb318-1" aria-hidden="true" tabindex="-1"></a>du <span class="op">=</span> dolfinx.fem.Function(V)</span>
<span id="cb318-2"><a href="#cb318-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb318-3"><a href="#cb318-3" aria-hidden="true" tabindex="-1"></a>A <span class="op">=</span> dolfinx.fem.petsc.create_matrix(jacobian)</span>
<span id="cb318-4"><a href="#cb318-4" aria-hidden="true" tabindex="-1"></a>L <span class="op">=</span> dolfinx.fem.petsc.create_vector(residual)</span>
<span id="cb318-5"><a href="#cb318-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb318-6"><a href="#cb318-6" aria-hidden="true" tabindex="-1"></a>solver <span class="op">=</span> PETSc.KSP().create(mesh.comm)</span>
<span id="cb318-7"><a href="#cb318-7" aria-hidden="true" tabindex="-1"></a>solver.setOperators(A)</span></code></pre></div>
</div>
<p>Since this problem has strong Dirichlet boundary conditions, we need to apply a lifting to the right-hand side of our Newton problem. Recall that our goal is to solve the system</p>
<p><span class="math display">\[\begin{aligned}
J_F(u_k)\,\delta u_k &amp;= - F(u_k),\\
u_{k+1} &amp;= u_k + \delta u_k
\end{aligned}\]</span></p>
<p>We require that</p>
<p><span class="math display">\[u_{k+1}\vert_{\text{bc}} = u_D\]</span></p>
<p>However, we do not know if the current iterate satisfies the boundary condition, i.e., whether</p>
<p><span class="math display">\[u_k\vert_{\text{bc}} = u_D\]</span></p>
<p>To enforce the boundary condition, we therefore apply the following condition on the Newton correction <span class="math inline">\(\delta u_k\)</span>:</p>
<p><span class="math display">\[\delta u_k \vert_{\text{bc}} = u_D - u_k \vert_{\text{bc}}\]</span></p>
<p>This leads to the following Newton scheme with strong Dirichlet conditions:</p>
<p><span class="math display">\[
\begin{aligned}
J_F(u_k)\,\delta u_k &amp;= -F(u_k), &amp; \delta u_k \vert_{\text{bc}} &amp;= u_D - u_k\vert_{\text{bc}},\\
u_{k+1} &amp;= u_k + \delta u_k
\end{aligned}\]</span></p>
<div id="622d3e99" class="cell" data-execution_count="268">
<div class="sourceCode" id="cb319"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb319-1"><a href="#cb319-1" aria-hidden="true" tabindex="-1"></a>i <span class="op">=</span> <span class="dv">0</span></span>
<span id="cb319-2"><a href="#cb319-2" aria-hidden="true" tabindex="-1"></a>error <span class="op">=</span> dolfinx.fem.form(</span>
<span id="cb319-3"><a href="#cb319-3" aria-hidden="true" tabindex="-1"></a>  ufl.inner(uh <span class="op">-</span>u_ufl, uh <span class="op">-</span>u_ufl) <span class="op">*</span>ufl.dx(metadata<span class="op">=</span>{<span class="st">&quot;quadrature_degree&quot;</span>: <span class="dv">4</span>})</span>
<span id="cb319-4"><a href="#cb319-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb319-5"><a href="#cb319-5" aria-hidden="true" tabindex="-1"></a>L2_error <span class="op">=</span> []</span>
<span id="cb319-6"><a href="#cb319-6" aria-hidden="true" tabindex="-1"></a>du_norm <span class="op">=</span> []</span>
<span id="cb319-7"><a href="#cb319-7" aria-hidden="true" tabindex="-1"></a><span class="cf">while</span> i <span class="op">&lt;</span> max_iterations:</span>
<span id="cb319-8"><a href="#cb319-8" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Assemble Jacobian and residual</span></span>
<span id="cb319-9"><a href="#cb319-9" aria-hidden="true" tabindex="-1"></a>  <span class="cf">with</span> L.localForm() <span class="im">as</span> loc_L:</span>
<span id="cb319-10"><a href="#cb319-10" aria-hidden="true" tabindex="-1"></a>    loc_L.<span class="bu">set</span>(<span class="dv">0</span>)</span>
<span id="cb319-11"><a href="#cb319-11" aria-hidden="true" tabindex="-1"></a>  A.zeroEntries()</span>
<span id="cb319-12"><a href="#cb319-12" aria-hidden="true" tabindex="-1"></a>  dolfinx.fem.petsc.assemble_matrix(A, jacobian, bcs<span class="op">=</span>[bc])</span>
<span id="cb319-13"><a href="#cb319-13" aria-hidden="true" tabindex="-1"></a>  A.assemble()</span>
<span id="cb319-14"><a href="#cb319-14" aria-hidden="true" tabindex="-1"></a>  dolfinx.fem.petsc.assemble_vector(L, residual)</span>
<span id="cb319-15"><a href="#cb319-15" aria-hidden="true" tabindex="-1"></a>  L.ghostUpdate(addv<span class="op">=</span>PETSc.InsertMode.ADD, mode<span class="op">=</span>PETSc.ScatterMode.REVERSE)</span>
<span id="cb319-16"><a href="#cb319-16" aria-hidden="true" tabindex="-1"></a>  L.scale(<span class="op">-</span><span class="dv">1</span>)</span>
<span id="cb319-17"><a href="#cb319-17" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-18"><a href="#cb319-18" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Compute b - J(u_D-u_(i-1))</span></span>
<span id="cb319-19"><a href="#cb319-19" aria-hidden="true" tabindex="-1"></a>  dolfinx.fem.petsc.apply_lifting(</span>
<span id="cb319-20"><a href="#cb319-20" aria-hidden="true" tabindex="-1"></a>    L, </span>
<span id="cb319-21"><a href="#cb319-21" aria-hidden="true" tabindex="-1"></a>    [jacobian], </span>
<span id="cb319-22"><a href="#cb319-22" aria-hidden="true" tabindex="-1"></a>    [[bc]], </span>
<span id="cb319-23"><a href="#cb319-23" aria-hidden="true" tabindex="-1"></a>    x0<span class="op">=</span>[uh.x.petsc_vec], </span>
<span id="cb319-24"><a href="#cb319-24" aria-hidden="true" tabindex="-1"></a>    alpha<span class="op">=</span><span class="dv">1</span></span>
<span id="cb319-25"><a href="#cb319-25" aria-hidden="true" tabindex="-1"></a>  )</span>
<span id="cb319-26"><a href="#cb319-26" aria-hidden="true" tabindex="-1"></a>  </span>
<span id="cb319-27"><a href="#cb319-27" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Set du|_bc = u_{i-1}-u_D</span></span>
<span id="cb319-28"><a href="#cb319-28" aria-hidden="true" tabindex="-1"></a>  dolfinx.fem.petsc.set_bc(L, [bc], uh.x.petsc_vec, <span class="fl">1.0</span>)</span>
<span id="cb319-29"><a href="#cb319-29" aria-hidden="true" tabindex="-1"></a>  L.ghostUpdate(addv<span class="op">=</span>PETSc.InsertMode.INSERT_VALUES, mode<span class="op">=</span>PETSc.ScatterMode.FORWARD)</span>
<span id="cb319-30"><a href="#cb319-30" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-31"><a href="#cb319-31" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Solve linear problem</span></span>
<span id="cb319-32"><a href="#cb319-32" aria-hidden="true" tabindex="-1"></a>  solver.solve(L, du.x.petsc_vec)</span>
<span id="cb319-33"><a href="#cb319-33" aria-hidden="true" tabindex="-1"></a>  du.x.scatter_forward()</span>
<span id="cb319-34"><a href="#cb319-34" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-35"><a href="#cb319-35" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Update u_{i+1} = u_i + delta u_i</span></span>
<span id="cb319-36"><a href="#cb319-36" aria-hidden="true" tabindex="-1"></a>  uh.x.array[:] <span class="op">+=</span> du.x.array</span>
<span id="cb319-37"><a href="#cb319-37" aria-hidden="true" tabindex="-1"></a>  i <span class="op">+=</span> <span class="dv">1</span></span>
<span id="cb319-38"><a href="#cb319-38" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-39"><a href="#cb319-39" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Compute norm of update</span></span>
<span id="cb319-40"><a href="#cb319-40" aria-hidden="true" tabindex="-1"></a>  correction_norm <span class="op">=</span> du.x.petsc_vec.norm(<span class="dv">0</span>)</span>
<span id="cb319-41"><a href="#cb319-41" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-42"><a href="#cb319-42" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Compute L2 error comparing to the analytical solution</span></span>
<span id="cb319-43"><a href="#cb319-43" aria-hidden="true" tabindex="-1"></a>  L2_error.append(np.sqrt(mesh.comm.allreduce(dolfinx.fem.assemble_scalar(error), op<span class="op">=</span>MPI.SUM)))</span>
<span id="cb319-44"><a href="#cb319-44" aria-hidden="true" tabindex="-1"></a>  du_norm.append(correction_norm)</span>
<span id="cb319-45"><a href="#cb319-45" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb319-46"><a href="#cb319-46" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f&quot;Iteration </span><span class="sc">{</span>i<span class="sc">}</span><span class="ss">: </span><span class="sc">{</span>correction_norm <span class="op">=</span> <span class="sc">:.6e}</span><span class="ss">, L2_error = </span><span class="sc">{</span>L2_error[<span class="op">-</span><span class="dv">1</span>]<span class="sc">:.6e}</span><span class="ss">&quot;</span>)</span>
<span id="cb319-47"><a href="#cb319-47" aria-hidden="true" tabindex="-1"></a>  <span class="cf">if</span> correction_norm <span class="op">&lt;</span> <span class="fl">1e-10</span>:</span>
<span id="cb319-48"><a href="#cb319-48" aria-hidden="true" tabindex="-1"></a>    <span class="cf">break</span></span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Iteration 1: correction_norm = 2.174258e+02, L2_error = 1.009449e+00
Iteration 2: correction_norm = 1.546085e+02, L2_error = 1.025886e+00
Iteration 3: correction_norm = 4.927247e+01, L2_error = 3.541886e-01
Iteration 4: correction_norm = 1.695612e+01, L2_error = 7.129374e-02
Iteration 5: correction_norm = 3.166798e+00, L2_error = 4.565047e-03
Iteration 6: correction_norm = 1.713648e-01, L2_error = 2.626998e-05
Iteration 7: correction_norm = 8.143265e-04, L2_error = 1.230202e-09
Iteration 8: correction_norm = 3.734667e-08, L2_error = 7.046012e-15
Iteration 9: correction_norm = 5.469294e-13, L2_error = 2.797439e-16</code></pre>
</div>
</div>
<p>We visualize the convergence by plotting the <span class="math inline">\(L^2\)</span>-error and the residual norm (<span class="math inline">\(\delta u\)</span>) across iterations</p>
<div id="36ff2d11" class="cell" data-execution_count="269">
<div class="sourceCode" id="cb321"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb321-1"><a href="#cb321-1" aria-hidden="true" tabindex="-1"></a>fig <span class="op">=</span> plt.figure(figsize<span class="op">=</span>(<span class="dv">12</span>, <span class="dv">4</span>))</span>
<span id="cb321-2"><a href="#cb321-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-3"><a href="#cb321-3" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">121</span>)</span>
<span id="cb321-4"><a href="#cb321-4" aria-hidden="true" tabindex="-1"></a>plt.semilogy(np.arange(i), L2_error, <span class="st">&#39;bo&#39;</span>)</span>
<span id="cb321-5"><a href="#cb321-5" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb321-6"><a href="#cb321-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-7"><a href="#cb321-7" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&quot;Iterations&quot;</span>)</span>
<span id="cb321-8"><a href="#cb321-8" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="vs">r&quot;</span><span class="dv">$</span><span class="vs">L</span><span class="dv">^</span><span class="vs">2</span><span class="dv">$</span><span class="vs"> - error&quot;</span>)</span>
<span id="cb321-9"><a href="#cb321-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-10"><a href="#cb321-10" aria-hidden="true" tabindex="-1"></a>plt.subplot(<span class="dv">122</span>)</span>
<span id="cb321-11"><a href="#cb321-11" aria-hidden="true" tabindex="-1"></a>plt.semilogy(np.arange(i), du_norm, <span class="st">&#39;ro&#39;</span>)</span>
<span id="cb321-12"><a href="#cb321-12" aria-hidden="true" tabindex="-1"></a>plt.grid()</span>
<span id="cb321-13"><a href="#cb321-13" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb321-14"><a href="#cb321-14" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">&quot;Iterations&quot;</span>)</span>
<span id="cb321-15"><a href="#cb321-15" aria-hidden="true" tabindex="-1"></a>plt.ylabel(<span class="vs">r&quot;</span><span class="dv">$</span><span class="ch">\v</span><span class="vs">ert</span><span class="ch">\v</span><span class="vs">ert </span><span class="dv">\d</span><span class="vs">elta u</span><span class="ch">\v</span><span class="vs">ert</span><span class="ch">\v</span><span class="vs">ert</span><span class="dv">$</span><span class="vs">&quot;</span>)<span class="op">;</span></span></code></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure>
<p><img src="x_PDE_FEniCS_files/figure-html/cell-270-output-1.png" width="1018" height="375" /></p>
</figure>
</div>
</div>
</div>
<p>We compute the maximum error and plot the solution</p>
<div id="de673da8" class="cell" data-execution_count="270">
<div class="sourceCode" id="cb322"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb322-1"><a href="#cb322-1" aria-hidden="true" tabindex="-1"></a>error_max <span class="op">=</span> domain.comm.allreduce(</span>
<span id="cb322-2"><a href="#cb322-2" aria-hidden="true" tabindex="-1"></a>  np.<span class="bu">max</span>(np.<span class="bu">abs</span>(uh.x.array <span class="op">-</span>u_D.x.array)), </span>
<span id="cb322-3"><a href="#cb322-3" aria-hidden="true" tabindex="-1"></a>  op<span class="op">=</span>MPI.MAX</span>
<span id="cb322-4"><a href="#cb322-4" aria-hidden="true" tabindex="-1"></a>)</span>
<span id="cb322-5"><a href="#cb322-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb322-6"><a href="#cb322-6" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> domain.comm.rank <span class="op">==</span> <span class="dv">0</span>:</span>
<span id="cb322-7"><a href="#cb322-7" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f&quot;Error_max = </span><span class="sc">{</span>error_max<span class="sc">:.6e}</span><span class="ss">&quot;</span>)</span></code></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Error_max = 8.881784e-16</code></pre>
</div>
</div>
<div id="fa299cc6" class="cell" data-execution_count="271">
<div class="sourceCode" id="cb324"><pre class="sourceCode python cell-code"><code class="sourceCode python"><span id="cb324-1"><a href="#cb324-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> pathlib <span class="im">import</span> Path</span>
<span id="cb324-2"><a href="#cb324-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-3"><a href="#cb324-3" aria-hidden="true" tabindex="-1"></a>results_folder <span class="op">=</span> Path(<span class="st">&quot;fenicsx/best_practices&quot;</span>)</span>
<span id="cb324-4"><a href="#cb324-4" aria-hidden="true" tabindex="-1"></a>results_folder.mkdir(exist_ok<span class="op">=</span><span class="va">True</span>, parents<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb324-5"><a href="#cb324-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-6"><a href="#cb324-6" aria-hidden="true" tabindex="-1"></a>u_topology, u_cell_types, u_geometry <span class="op">=</span> dolfinx.plot.vtk_mesh(V)</span>
<span id="cb324-7"><a href="#cb324-7" aria-hidden="true" tabindex="-1"></a>u_grid <span class="op">=</span> pyvista.UnstructuredGrid(u_topology, u_cell_types, u_geometry)</span>
<span id="cb324-8"><a href="#cb324-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-9"><a href="#cb324-9" aria-hidden="true" tabindex="-1"></a>u_grid.point_data[<span class="st">&quot;u&quot;</span>] <span class="op">=</span> uh.x.array.real</span>
<span id="cb324-10"><a href="#cb324-10" aria-hidden="true" tabindex="-1"></a>u_grid.set_active_scalars(<span class="st">&quot;u&quot;</span>)</span>
<span id="cb324-11"><a href="#cb324-11" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-12"><a href="#cb324-12" aria-hidden="true" tabindex="-1"></a>u_plotter <span class="op">=</span> pyvista.Plotter(off_screen<span class="op">=</span><span class="va">False</span>)</span>
<span id="cb324-13"><a href="#cb324-13" aria-hidden="true" tabindex="-1"></a>u_plotter.add_mesh(u_grid, show_edges<span class="op">=</span><span class="va">True</span>)</span>
<span id="cb324-14"><a href="#cb324-14" aria-hidden="true" tabindex="-1"></a>u_plotter.view_xy()</span>
<span id="cb324-15"><a href="#cb324-15" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb324-16"><a href="#cb324-16" aria-hidden="true" tabindex="-1"></a><span class="cf">if</span> <span class="kw">not</span> pyvista.OFF_SCREEN:</span>
<span id="cb324-17"><a href="#cb324-17" aria-hidden="true" tabindex="-1"></a>  <span class="co">#u_plotter.show()</span></span>
<span id="cb324-18"><a href="#cb324-18" aria-hidden="true" tabindex="-1"></a>  u_plotter.export_html(results_folder<span class="op">/</span><span class="st">&quot;newton_solution.html&quot;</span>)</span></code></pre></div>
</div>
<iframe src="fenicsx/best_practices/newton_solution.html"
        width="100%" height="400px"
        style="border:none;"
        allowfullscreen
        loading="lazy">        
</iframe>
<div id="quarto-navigation-envelope" class="hidden">
<p><span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyLXRpdGxl">Engineering Mathematics</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1uYXZiYXItdGl0bGU=">Engineering Mathematics</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1uZXh0"><span class="chapter-number">L</span>  <span class="chapter-title">Matplotlib: Plotting and Visualization</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1wcmV2"><span class="chapter-number">J</span>  <span class="chapter-title">DEDALUS</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi9pbmRleC5odG1sV2VsY29tZQ==">Welcome</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOnF1YXJ0by1zaWRlYmFyLXNlY3Rpb24tMQ=="><strong>First Semester</strong></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi9jaF8wMV9JbnRyb2R1Y3Rpb25fdG9fRGlmZmVyZW50aWFsX0VxdWF0aW9ucy5odG1sPHNwYW4tY2xhc3M9J2NoYXB0ZXItbnVtYmVyJz4xPC9zcGFuPi0tPHNwYW4tY2xhc3M9J2NoYXB0ZXItdGl0bGUnPkludHJvZHVjdGlvbi10by1EaWZmZXJlbnRpYWwtRXF1YXRpb25zPC9zcGFuPg=="><span class="chapter-number">1</span>  <span class="chapter-title">Introduction to Differential Equations</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi9jaF8wMl9GaXJzdC1PcmRlcl9EaWZmZXJlbnRpYWxfRXF1YXRpb25zLmh0bWw8c3Bhbi1jbGFzcz0nY2hhcHRlci1udW1iZXInPjI8L3NwYW4+LS08c3Bhbi1jbGFzcz0nY2hhcHRlci10aXRsZSc+Rmlyc3QtT3JkZXItRGlmZmVyZW50aWFsLUVxdWF0aW9uczwvc3Bhbj4="><span class="chapter-number">2</span>  <span class="chapter-title">First-Order Differential Equations</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi9jaF8wM19IaWdoZXItT3JkZXJfRGlmZmVyZW50aWFsX0VxdWF0aW9ucy5odG1sPHNwYW4tY2xhc3M9J2NoYXB0ZXItbnVtYmVyJz4zPC9zcGFuPi0tPHNwYW4tY2xhc3M9J2NoYXB0ZXItdGl0bGUnPkhpZ2hlci1PcmRlci1EaWZmZXJlbnRpYWwtRXF1YXRpb25zPC9zcGFuPg=="><span class="chapter-number">3</span>  <span class="chapter-title">Higher-Order Differential Equations</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi9jaF8wNF9UaGVfTGFwbGFjZV9UcmFuc2Zvcm0uaHRtbDxzcGFuLWNsYXNzPSdjaGFwdGVyLW51bWJlcic+NDwvc3Bhbj4tLTxzcGFuLWNsYXNzPSdjaGFwdGVyLXRpdGxlJz5UaGUtTGFwbGFjZS1UcmFuc2Zvcm08L3NwYW4+"><span class="chapter-number">4</span>  <span class="chapter-title">The Laplace Transform</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi9jaF8wNV9TZXJpZXNfU29sdXRpb25zX29mX0xpbmVhcl9EaWZmZXJlbnRpYWxfRXF1YXRpb25zLmh0bWw8c3Bhbi1jbGFzcz0nY2hhcHRlci1udW1iZXInPjU8L3NwYW4+LS08c3Bhbi1jbGFzcz0nY2hhcHRlci10aXRsZSc+U2VyaWVzLVNvbHV0aW9ucy1vZi1MaW5lYXItRGlmZmVyZW50aWFsLUVxdWF0aW9uczwvc3Bhbj4="><span class="chapter-number">5</span>  <span class="chapter-title">Series Solutions of Linear Differential Equations</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi9jaF8wOF9NYXRyaWNlcy5odG1sPHNwYW4tY2xhc3M9J2NoYXB0ZXItbnVtYmVyJz42PC9zcGFuPi0tPHNwYW4tY2xhc3M9J2NoYXB0ZXItdGl0bGUnPk1hdHJpY2VzPC9zcGFuPg=="><span class="chapter-number">6</span>  <span class="chapter-title">Matrices</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi9jaF8xMF9TeXN0ZW1zX29mX0xpbmVhcl9EaWZmZXJlbnRpYWxfRXF1YXRpb25zLmh0bWw8c3Bhbi1jbGFzcz0nY2hhcHRlci1udW1iZXInPjc8L3NwYW4+LS08c3Bhbi1jbGFzcz0nY2hhcHRlci10aXRsZSc+U3lzdGVtcy1vZi1MaW5lYXItRGlmZmVyZW50aWFsLUVxdWF0aW9uczwvc3Bhbj4="><span class="chapter-number">7</span>  <span class="chapter-title">Systems of Linear Differential Equations</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi9jaF8xMV9TeXN0ZW1zX29mX05vbmxpbmVhcl9EaWZmZXJlbnRpYWxfRXF1YXRpb25zLmh0bWw8c3Bhbi1jbGFzcz0nY2hhcHRlci1udW1iZXInPjg8L3NwYW4+LS08c3Bhbi1jbGFzcz0nY2hhcHRlci10aXRsZSc+U3lzdGVtcy1vZi1Ob25saW5lYXItRGlmZmVyZW50aWFsLUVxdWF0aW9uczwvc3Bhbj4="><span class="chapter-number">8</span>  <span class="chapter-title">Systems of Nonlinear Differential Equations</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOnF1YXJ0by1zaWRlYmFyLXNlY3Rpb24tMg=="><strong>Second Semester</strong></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi9jaF8wN19WZWN0b3JzLmh0bWw8c3Bhbi1jbGFzcz0nY2hhcHRlci1udW1iZXInPjk8L3NwYW4+LS08c3Bhbi1jbGFzcz0nY2hhcHRlci10aXRsZSc+VmVjdG9yczwvc3Bhbj4="><span class="chapter-number">9</span>  <span class="chapter-title">Vectors</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi9jaF8wOV9WZWN0b3JfQ2FsY3VsdXMuaHRtbDxzcGFuLWNsYXNzPSdjaGFwdGVyLW51bWJlcic+MTA8L3NwYW4+LS08c3Bhbi1jbGFzcz0nY2hhcHRlci10aXRsZSc+VmVjdG9yLUNhbGN1bHVzPC9zcGFuPg=="><span class="chapter-number">10</span>  <span class="chapter-title">Vector Calculus</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi9jaF8xMl9PcnRob2dvbmFsX0Z1bmN0aW9uc19hbmRfRm91cmllcl9TZXJpZXMuaHRtbDxzcGFuLWNsYXNzPSdjaGFwdGVyLW51bWJlcic+MTE8L3NwYW4+LS08c3Bhbi1jbGFzcz0nY2hhcHRlci10aXRsZSc+T3J0aG9nb25hbC1GdW5jdGlvbnMtYW5kLUZvdXJpZXItU2VyaWVzPC9zcGFuPg=="><span class="chapter-number">11</span>  <span class="chapter-title">Orthogonal Functions and Fourier Series</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi9jaF94MV9QYXJhYm9saWNfUERFcy5odG1sPHNwYW4tY2xhc3M9J2NoYXB0ZXItbnVtYmVyJz4xMjwvc3Bhbj4tLTxzcGFuLWNsYXNzPSdjaGFwdGVyLXRpdGxlJz5QYXJhYm9saWMtUGFydGlhbC1EaWZmZXJlbnRpYWwtRXF1YXRpb25zPC9zcGFuPg=="><span class="chapter-number">12</span>  <span class="chapter-title">Parabolic Partial Differential Equations</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi9jaF94Ml9IeXBlcmJvbGljX1BERXMuaHRtbDxzcGFuLWNsYXNzPSdjaGFwdGVyLW51bWJlcic+MTM8L3NwYW4+LS08c3Bhbi1jbGFzcz0nY2hhcHRlci10aXRsZSc+SHlwZXJib2xpYy1QYXJ0aWFsLURpZmZlcmVudGlhbC1FcXVhdGlvbnM8L3NwYW4+"><span class="chapter-number">13</span>  <span class="chapter-title">Hyperbolic Partial Differential Equations</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi9jaF94M19FbGxpcHRpY19QREVzLmh0bWw8c3Bhbi1jbGFzcz0nY2hhcHRlci1udW1iZXInPjE0PC9zcGFuPi0tPHNwYW4tY2xhc3M9J2NoYXB0ZXItdGl0bGUnPkVsbGlwdGljLVBhcnRpYWwtRGlmZmVyZW50aWFsLUVxdWF0aW9uczwvc3Bhbj4="><span class="chapter-number">14</span>  <span class="chapter-title">Elliptic Partial Differential Equations</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOnF1YXJ0by1zaWRlYmFyLXNlY3Rpb24tMw==">Appendices</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi94X251bXB5X3ZlY3RvcnNfbWF0cmljZXNfYW5kX211bHRpZGltZW5zaW9uYWxfYXJyYXlzLmh0bWw8c3Bhbi1jbGFzcz0nY2hhcHRlci1udW1iZXInPkE8L3NwYW4+LS08c3Bhbi1jbGFzcz0nY2hhcHRlci10aXRsZSc+TnVtcHk6LVZlY3RvcnMsLU1hdHJpY2VzLC1hbmQtTXVsdGlkaW1lbnNpb25hbC1BcnJheXM8L3NwYW4+"><span class="chapter-number">A</span>  <span class="chapter-title">Numpy: Vectors, Matrices, and Multidimensional Arrays</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi94X3N5bXB5X3N5bWJvbGljX2NvbXB1dGluZy5odG1sPHNwYW4tY2xhc3M9J2NoYXB0ZXItbnVtYmVyJz5CPC9zcGFuPi0tPHNwYW4tY2xhc3M9J2NoYXB0ZXItdGl0bGUnPlN5bXB5Oi1TeW1ib2xpYy1Db21wdXRpbmc8L3NwYW4+"><span class="chapter-number">B</span>  <span class="chapter-title">Sympy: Symbolic Computing</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi94X3N5bXB5X0xhcGxhY2VfdHJhbnNmb3JtLmh0bWw8c3Bhbi1jbGFzcz0nY2hhcHRlci1udW1iZXInPkM8L3NwYW4+LS08c3Bhbi1jbGFzcz0nY2hhcHRlci10aXRsZSc+U3ltcHk6LUxhcGxhY2UtVHJhbnNmb3JtPC9zcGFuPg=="><span class="chapter-number">C</span>  <span class="chapter-title">Sympy: Laplace Transform</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi94X2VxdWF0aW9uX3NvbHZpbmcuaHRtbDxzcGFuLWNsYXNzPSdjaGFwdGVyLW51bWJlcic+RDwvc3Bhbj4tLTxzcGFuLWNsYXNzPSdjaGFwdGVyLXRpdGxlJz5FcXVhdGlvbi1Tb2x2aW5nPC9zcGFuPg=="><span class="chapter-number">D</span>  <span class="chapter-title">Equation Solving</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi94X29wdGltaXphdGlvbi5odG1sPHNwYW4tY2xhc3M9J2NoYXB0ZXItbnVtYmVyJz5FPC9zcGFuPi0tPHNwYW4tY2xhc3M9J2NoYXB0ZXItdGl0bGUnPk9wdGltaXphdGlvbjwvc3Bhbj4="><span class="chapter-number">E</span>  <span class="chapter-title">Optimization</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi94X2ludGVycG9sYXRpb24uaHRtbDxzcGFuLWNsYXNzPSdjaGFwdGVyLW51bWJlcic+Rjwvc3Bhbj4tLTxzcGFuLWNsYXNzPSdjaGFwdGVyLXRpdGxlJz5JbnRlcnBvbGF0aW9uPC9zcGFuPg=="><span class="chapter-number">F</span>  <span class="chapter-title">Interpolation</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi94X2ludGVncmF0aW9uLmh0bWw8c3Bhbi1jbGFzcz0nY2hhcHRlci1udW1iZXInPkc8L3NwYW4+LS08c3Bhbi1jbGFzcz0nY2hhcHRlci10aXRsZSc+SW50ZWdyYXRpb248L3NwYW4+"><span class="chapter-number">G</span>  <span class="chapter-title">Integration</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi94X29yZGluYXJ5X2RpZmZlcmVudGlhbF9lcXVhdGlvbnMuaHRtbDxzcGFuLWNsYXNzPSdjaGFwdGVyLW51bWJlcic+SDwvc3Bhbj4tLTxzcGFuLWNsYXNzPSdjaGFwdGVyLXRpdGxlJz5PcmRpbmFyeS1EaWZmZXJlbnRpYWwtRXF1YXRpb25zPC9zcGFuPg=="><span class="chapter-number">H</span>  <span class="chapter-title">Ordinary Differential Equations</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi94X2RvdWJsZV9wZW5kdWx1bS5odG1sPHNwYW4tY2xhc3M9J2NoYXB0ZXItbnVtYmVyJz5JPC9zcGFuPi0tPHNwYW4tY2xhc3M9J2NoYXB0ZXItdGl0bGUnPkRvdWJsZS1QZW5kdWx1bTwvc3Bhbj4="><span class="chapter-number">I</span>  <span class="chapter-title">Double Pendulum</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi94X1BERV9kZWRhbHVzLmh0bWw8c3Bhbi1jbGFzcz0nY2hhcHRlci1udW1iZXInPko8L3NwYW4+LS08c3Bhbi1jbGFzcz0nY2hhcHRlci10aXRsZSc+REVEQUxVUzwvc3Bhbj4="><span class="chapter-number">J</span>  <span class="chapter-title">DEDALUS</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi94X1BERV9GRW5pQ1MuaHRtbDxzcGFuLWNsYXNzPSdjaGFwdGVyLW51bWJlcic+Szwvc3Bhbj4tLTxzcGFuLWNsYXNzPSdjaGFwdGVyLXRpdGxlJz5UaGUtRkVuaUNTLWNvbXB1dGluZy1wbGF0Zm9ybTwvc3Bhbj4="><span class="chapter-number">K</span>  <span class="chapter-title">The FEniCS computing platform</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi94X21hdHBsb3RsaWIuaHRtbDxzcGFuLWNsYXNzPSdjaGFwdGVyLW51bWJlcic+TDwvc3Bhbj4tLTxzcGFuLWNsYXNzPSdjaGFwdGVyLXRpdGxlJz5NYXRwbG90bGliOi1QbG90dGluZy1hbmQtVmlzdWFsaXphdGlvbjwvc3Bhbj4="><span class="chapter-number">L</span>  <span class="chapter-title">Matplotlib: Plotting and Visualization</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi94X01hbmRlbGJyb3Rfc2V0Lmh0bWw8c3Bhbi1jbGFzcz0nY2hhcHRlci1udW1iZXInPk08L3NwYW4+LS08c3Bhbi1jbGFzcz0nY2hhcHRlci10aXRsZSc+TWFuZGVsYnJvdC1TZXQtaW4tUHl0aG9uPC9zcGFuPg=="><span class="chapter-number">M</span>  <span class="chapter-title">Mandelbrot Set in Python</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWludC1zaWRlYmFyOi94X2h5ZHJvZ2VuX29yYml0YWwuaHRtbDxzcGFuLWNsYXNzPSdjaGFwdGVyLW51bWJlcic+Tjwvc3Bhbj4tLTxzcGFuLWNsYXNzPSdjaGFwdGVyLXRpdGxlJz5IeWRyb2dlbi1BdG9taWMtT3JiaXRhbHM8L3NwYW4+"><span class="chapter-number">N</span>  <span class="chapter-title">Hydrogen Atomic Orbitals</span></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWJyZWFkY3J1bWJzLUFwcGVuZGljZXM=">Appendices</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLWJyZWFkY3J1bWJzLTxzcGFuLWNsYXNzPSdjaGFwdGVyLW51bWJlcic+Szwvc3Bhbj4tLTxzcGFuLWNsYXNzPSdjaGFwdGVyLXRpdGxlJz5UaGUtRkVuaUNTLWNvbXB1dGluZy1wbGF0Zm9ybTwvc3Bhbj4="><span class="chapter-number">K</span>  <span class="chapter-title">The FEniCS computing platform</span></span></p>
</div>
<div id="quarto-meta-markdown" class="hidden">
<p><span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLW1ldGF0aXRsZQ=="><span id="sec-fenicsx" class="quarto-section-identifier">Appendix K — The FEniCS computing platform</span> – Engineering Mathematics</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLXR3aXR0ZXJjYXJkdGl0bGU="><span id="sec-fenicsx" class="quarto-section-identifier">Appendix K — The FEniCS computing platform</span> – Engineering Mathematics</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLW9nY2FyZHRpdGxl"><span id="sec-fenicsx" class="quarto-section-identifier">Appendix K — The FEniCS computing platform</span> – Engineering Mathematics</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLW1ldGFzaXRlbmFtZQ==">Engineering Mathematics</span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLXR3aXR0ZXJjYXJkZGVzYw=="></span> <span class="hidden quarto-markdown-envelope-contents" data-render-id="cXVhcnRvLW9nY2FyZGRkZXNj"></span></p>
</div>
</section>
</section>

</main> <!-- /main -->
<script type=application/vnd.jupyter.widget-state+json>
{"state":{"002a17c4bf094c0693370477d301122e":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"ProgressStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"ProgressStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"StyleView","bar_color":null,"description_width":""}},"0ab0afed4cce48608e35184404e5b328":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"203bea65f0d44809a8bf14ffffb4ecfd":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"5d371358d1c14d5fb293795f5ba190bc":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"HTMLView","description":"","description_allow_html":false,"layout":"IPY_MODEL_0ab0afed4cce48608e35184404e5b328","placeholder":"​","style":"IPY_MODEL_eccd6f82d6ff4e698ffa82bc77cc1105","tabbable":null,"tooltip":null,"value":"Time Stepping: 100%"}},"6628550280254c928c4281c4a3ca4482":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HBoxModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HBoxModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"HBoxView","box_style":"","children":["IPY_MODEL_5d371358d1c14d5fb293795f5ba190bc","IPY_MODEL_7df0d0e21e58421697f88386b41a0767","IPY_MODEL_84407e4f1f704663aa987ef9eaab6a03"],"layout":"IPY_MODEL_9435653d893948e49d018a2b57529fd1","tabbable":null,"tooltip":null}},"7df0d0e21e58421697f88386b41a0767":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"FloatProgressModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"FloatProgressModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"ProgressView","bar_style":"success","description":"","description_allow_html":false,"layout":"IPY_MODEL_ee586ed69a11460d89d711604ef058c4","max":12800,"min":0,"orientation":"horizontal","style":"IPY_MODEL_002a17c4bf094c0693370477d301122e","tabbable":null,"tooltip":null,"value":12800}},"84407e4f1f704663aa987ef9eaab6a03":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLModel","state":{"_dom_classes":[],"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLModel","_view_count":null,"_view_module":"@jupyter-widgets/controls","_view_module_version":"2.0.0","_view_name":"HTMLView","description":"","description_allow_html":false,"layout":"IPY_MODEL_203bea65f0d44809a8bf14ffffb4ecfd","placeholder":"​","style":"IPY_MODEL_d53d9f9def534724b424cb03e2d33a23","tabbable":null,"tooltip":null,"value":" 12800/12800 [08:51&lt;00:00, 23.90step/s]"}},"9435653d893948e49d018a2b57529fd1":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}},"d53d9f9def534724b424cb03e2d33a23":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"StyleView","background":null,"description_width":"","font_size":null,"text_color":null}},"eccd6f82d6ff4e698ffa82bc77cc1105":{"model_module":"@jupyter-widgets/controls","model_module_version":"2.0.0","model_name":"HTMLStyleModel","state":{"_model_module":"@jupyter-widgets/controls","_model_module_version":"2.0.0","_model_name":"HTMLStyleModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"StyleView","background":null,"description_width":"","font_size":null,"text_color":null}},"ee586ed69a11460d89d711604ef058c4":{"model_module":"@jupyter-widgets/base","model_module_version":"2.0.0","model_name":"LayoutModel","state":{"_model_module":"@jupyter-widgets/base","_model_module_version":"2.0.0","_model_name":"LayoutModel","_view_count":null,"_view_module":"@jupyter-widgets/base","_view_module_version":"2.0.0","_view_name":"LayoutView","align_content":null,"align_items":null,"align_self":null,"border_bottom":null,"border_left":null,"border_right":null,"border_top":null,"bottom":null,"display":null,"flex":null,"flex_flow":null,"grid_area":null,"grid_auto_columns":null,"grid_auto_flow":null,"grid_auto_rows":null,"grid_column":null,"grid_gap":null,"grid_row":null,"grid_template_areas":null,"grid_template_columns":null,"grid_template_rows":null,"height":null,"justify_content":null,"justify_items":null,"left":null,"margin":null,"max_height":null,"max_width":null,"min_height":null,"min_width":null,"object_fit":null,"object_position":null,"order":null,"overflow":null,"padding":null,"right":null,"top":null,"visibility":null,"width":null}}},"version_major":2,"version_minor":0}
</script>
<script id = "quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
<nav class="page-navigation">
  <div class="nav-page nav-page-previous">
      <a  href="/x_PDE_dedalus.html" class="pagination-link" aria-label="DEDALUS">
        <i class="bi bi-arrow-left-short"></i> <span class="nav-page-text"><span class='chapter-number'>J</span>  <span class='chapter-title'>DEDALUS</span></span>
      </a>          
  </div>
  <div class="nav-page nav-page-next">
      <a  href="/x_matplotlib.html" class="pagination-link" aria-label="Matplotlib: Plotting and Visualization">
        <span class="nav-page-text"><span class='chapter-number'>L</span>  <span class='chapter-title'>Matplotlib: Plotting and Visualization</span></span> <i class="bi bi-arrow-right-short"></i>
      </a>
  </div>
</nav>
</div> <!-- /content -->

</body>

</html>
