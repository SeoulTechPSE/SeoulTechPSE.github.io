---
title: "The Helmholtz equation"
jupyter: fenicsx
---

### The Helmholtz equation {#sec-fenicsx-helmholtz}

Author: Antonio Baiano Svizzero 

The study of computational acoustics is essential in fields such as noise, vibration, and harshness (NVH), noise control, and acoustic design. In this section, we focus on the theoretical foundations of the Helmholtz equation—which is valid for noise problems with harmonic time dependence—and its implementation in `FEniCSx` to compute the sound pressure in arbitrary acoustic systems

**The PDE problem**

The acoustic Helmholtz equation in its general form reads

$$
\begin{aligned}
\nabla^2 p + k^2 p = -j \omega \rho_0 q \quad\text{in } \Omega
\end{aligned}
$$

where $p$ is the complex acoustic pressure, $k$ the wavenumber, $\omega$ the angular frequency, $j$ the imaginary unit, and $q$ the volume velocity ($\mathrm{m^3/s}$) of a generic source field. In the case of a monopole source, $q$ can be written as

$$q = Q \, \delta(x_s, y_s, z_s)$$

where $\delta(x_s, y_s, z_s)$ is the three-dimensional Dirac delta function centered at the monopole location. This formulation allows the computation of the sound pressure field generated by any generic source distribution, while the monopole source provides a simple yet fundamental example for analytical and numerical studies in computational acoustics

In order to solve this problem with real-valued solvers in `FEniCSx`, we split the complex pressure into its real and imaginary parts:

$$p = p_r + j \, p_i$$

with $p_r$ and $p_i$ real-valued functions representing the real and imaginary components, respectively. Substituting this into the original equation and separating real and imaginary parts leads to two coupled real-valued PDEs:

$$\begin{aligned}
\nabla^2 p_r + k^2 p_r &= 0, \\
\nabla^2 p_i + k^2 p_i &= - \omega \, \rho_0 \, q,
\end{aligned}
\quad \text{in } \Omega$$

After splitting the complex pressure $p = p_r + j\, p_i$ into its real and imaginary parts, the boundary conditions are applied separately to $p_r$ and $p_i$:

* Dirichlet BC:

  $$p_r = \Re(\bar{p}), \quad p_i = \Im(\bar{p}) \quad \text{on } \partial\Omega_p$$

* Neumann BC:

  $$\frac{\partial p_r}{\partial n} = 0, \quad
    \frac{\partial p_i}{\partial n} = - \omega \, \rho_0 \, \bar{v}_n \quad \text{on } \partial\Omega_v$$

* Robin BC:

  $$\frac{\partial p_r}{\partial n} = 
      \frac{\omega \, \rho_0}{\bar{Z}} \, p_i, \quad
    \frac{\partial p_i}{\partial n} = -\frac{\omega \, \rho_0}{\bar{Z}} \, p_r \quad \text{on } \partial\Omega_Z$$

where $\bar{p}$ is the complex prescribed acoustic pressure at $\partial\Omega_p$,
$\bar{v}_n$ is the prescribed normal sound particle velocity at $\partial\Omega_v$, and
$\bar{Z}$ is the prescribed acoustic impedance at $\partial\Omega_Z$, with $n$ denoting the outward unit normal. In this context, the overbar notation is used to denote prescribed boundary quantities (known data) in order to distinguish them from the unknown fields. It should be emphasized that the overbar does not indicate a complex conjugate

This formulation allows the use of real-valued solvers while fully accounting for the effect of complex-valued boundary conditions in the Helmholtz problem

**Weak formulation in terms of real and imaginary parts**

\paragraph{Real–Imaginary split with complex impedance and complex normal velocity}
Let the complex source be

$$
q = q_r + j\,q_i,
$$

and let the (possibly complex) surface impedance and the prescribed normal velocity be

$$
\bar Z = Z_r + j\,Z_i,\qquad \bar v_n = v_{n,r} + j\,v_{n,i},
$$

with $Z_r,Z_i,v_{n,r},v_{n,i}\in\mathbb{R}$. Define $\Delta_Z = Z_r^2+Z_i^2$. Then

$$
\frac{j\,\omega\rho_0}{\bar Z}
= \frac{\omega\rho_0}{\Delta_Z}\bigl(Z_i + j\,Z_r\bigr)
$$

Multiplying the complex Helmholtz equation by a real test function $v \in \hat V$  and separating real and imaginary parts yields the following two real variational problems.

* Real part (for $p_r$):

$$
\begin{aligned}
\int_{\Omega} \nabla p_r \cdot \nabla v \,\mathrm{d}x
&- k^2 \int_{\Omega} p_r\,v\,\mathrm{d}x
+ \frac{\omega\rho_0}{\Delta_Z}\int_{\partial\Omega_Z} \bigl(Z_i p_r - Z_r p_i\bigr)\,v\,\mathrm{d}s \\
=& -\,\omega\rho_0\int_{\Omega} q_i\,v\,\mathrm{d}x
\;+\; \omega\rho_0\int_{\partial\Omega_v} v_{n,i}\,v\,\mathrm{d}s
\end{aligned}$$

* Imaginary part (for $p_i$):

$$
\begin{aligned}
\int_{\Omega} \nabla p_i \cdot \nabla v \,\mathrm{d}x
&- k^2 \int_{\Omega} p_i\,v\,\mathrm{d}x
+ \frac{\omega\rho_0}{\Delta_Z}\int_{\partial\Omega_Z} \bigl(Z_r p_r + Z_i p_i\bigr)\,v\,\mathrm{d}s \\
=& \;\omega\rho_0\int_{\Omega} q_r\,v\,\mathrm{d}x
\;-\; \omega\rho_0\int_{\partial\Omega_v} v_{n,r}\,v\,\mathrm{d}s
\end{aligned}$$

After solving these two coupled real systems for $p_r$ and $p_i$, the complex pressure is reconstructed as $p = p_r + \mathrm{i}\,p_i$, from which amplitude $|p|$, phase and derived quantities such as the Sound Pressure Level (SPL) can be computed

In this section, you will learn how to:

* Define acoustic velocity and impedance boundary conditions
* Compute the acoustic sound pressure for multiple frequencies
* Evaluate the SPL at a given microphone position

**Test problem**

As an example, we model a plane wave propagating through a tube.
Although this is a basic test case, the code can be extended to more complex problems requiring velocity and impedance boundary conditions

Finally, we create the mesh with `GMSH`, defining the physical groups for the velocity and impedance boundary conditions along with their respective tags

```{python}
import gmsh

# ---------------------------------
# Create gmsh box and tag facets
# ---------------------------------

if not gmsh.isInitialized():
  gmsh.initialize()

# meshsize settings
meshsize = 0.02
gmsh.option.setNumber("Mesh.MeshSizeMin", meshsize)
gmsh.option.setNumber("Mesh.MeshSizeMax", meshsize)

# create geometry
L = 1.0
W = 0.1
H = 0.1

box = gmsh.model.occ.addBox(0, 0, 0, L, W, H)
gmsh.model.occ.synchronize()

# Remove any existing physical groups with the same (dim, tag)
for dim, tag in gmsh.model.getPhysicalGroups():
  if dim == gdim and tag == physical_tag:
    gmsh.model.removePhysicalGroups([(dim, tag)])

# get surfaces
surfaces = gmsh.model.getEntities(dim=2)

# tolerance for coordinate matching
tol = 1e-6

velocity_surfaces = []
impedance_surfaces = []

for (dim, tag) in surfaces:
  com = gmsh.model.occ.getCenterOfMass(dim, tag)
  x, y, z = com
  if abs(x -0.0) < tol:      # x = 0 face
    velocity_surfaces.append(tag)
  elif abs(x -L) < tol:      # x = L face
    impedance_surfaces.append(tag)

# setup physical groups
vol_tag = gmsh.model.addPhysicalGroup(3, [box], 1)
gmsh.model.setPhysicalName(3, vol_tag, "air_volume")

v_bc_tag = 2
Z_bc_tag = 3

if velocity_surfaces:
  gmsh.model.addPhysicalGroup(2, velocity_surfaces, v_bc_tag)
  gmsh.model.setPhysicalName(2, v_bc_tag, "velocity_BC") 
if impedance_surfaces:
  gmsh.model.addPhysicalGroup(2, impedance_surfaces, Z_bc_tag) 
  gmsh.model.setPhysicalName(2, Z_bc_tag, "impedance_BC")

# mesh generation
gmsh.model.mesh.generate(dim=3)
```

We then import the mesh generated by `GMSH` with the `dolfinx.io.gmshio` function

```{python}
import csv
from pathlib import Path

import numpy as np
import matplotlib.pyplot as plt
import pyvista

from mpi4py import MPI
from dolfinx import (
  fem,
  io,
  default_scalar_type,
  geometry,
  plot,
)
from dolfinx.fem.petsc import LinearProblem
import ufl

comm = MPI.COMM_WORLD
rank = comm.rank

mesh_data = io.gmshio.model_to_mesh(
  gmsh.model, 
  comm, 
  0, 
  gdim=3
)

domain, _, facet_tags = mesh_data

gmsh.finalize()
```

We define the function space for the unknowns $p_r$ and $p_i$. We also specify the boundary integration measure $ds$ using `ufl`

```{python}
V = fem.functionspace(domain, ("Lagrange", 1))
ds = ufl.Measure("ds", domain=domain, subdomain_data=facet_tags)
```

```{python}
results_folder = Path("fenicsx/helmholtz")
results_folder.mkdir(exist_ok=True, parents=True)

# Extract topology from mesh and create pyvista mesh
topology, cell_types, x = plot.vtk_mesh(V)
grid = pyvista.UnstructuredGrid(topology, cell_types, x)

plotter = pyvista.Plotter(off_screen=True)
plotter.add_mesh(grid, show_edges=True)
plotter.add_axes()

# if not pyvista.OFF_SCREEN:
#     plotter.show()

# HTML 저장
plotter.export_html(results_folder/"helmholtz_mesh.html")
```

```{=html}
<iframe src="fenicsx/helmholtz/helmholtz_mesh.html"
        width="100%" height="400px"
        style="border:none;">
</iframe>
```

**Boundary conditions**

We impose a velocity boundary condition of $v_n = 1.0 \times 10^{-5}$ at one end of the tube.
For simplicity, we omit the point source in this example (although it could be included using [`scifem`](https://github.com/scientificcomputing/scifem)).
At the opposite end of the tube, we prescribe an impedance $Z$ computed with the Delaney–Bazley model, assuming a layer of thickness $d = 0.01$ and a flow resistivity $\sigma = 1.5 \times 10^4$.
This choice of impedance—corresponding to a plane wave propagating in free field—produces a solution without reflections

The Delaney–Bazley model is used to compute the characteristic impedance and the wavenumber of the porous layer, which is treated as an equivalent fluid with complex-valued properties:

$$
\begin{aligned}
Z_c(\omega) &= \rho_0 c_0 \left[1 + 0.0571 X^{-0.754} - j\, 0.087 X^{-0.732}\right] \\
k_c(\omega) &= \frac{\omega}{c_0} \left[1 + 0.0978 X^{-0.700} - j\, 0.189 X^{-0.595}\right]
\end{aligned}
$$

where $X = \tfrac{\rho_0 f}{\sigma}$

Using these values, we can compute the surface impedance.
In the case of a rigid passive absorber mounted on a rigid wall, it is given by:

$$
Z_s = -j\, Z_c \cot(k_c d)
$$

Let’s create a function to calculate it

```{python}
# Air parameters
rho0 = 1.225  # kg/m^3
c = 340       # m/s
p_ref = 2e-5

# Wall parameters
sigma = 1.5e4  # ***
d = 0.01       # ***

# Impedance calculation
def delany_bazley_layer(f, rho0, c, sigma, d):
  X = rho0 *f /sigma
  Zc = rho0 *c *(1 +0.0571 *(X**-0.754) -1j *0.087 *(X**-0.732))
  kc = 2 *np.pi *f /c *(1 +0.0978 *(X**-0.700) - 1j *0.189 *(X**-0.595))
  Z_s = -1j *Zc *(1 /np.tan(kc *d))
  return Z_s
```
We define the value of the normal velocity at the first end of the tube.
Since we are going to compute a sound pressure spectrum, all frequency-dependent variables (i.e., $\omega$, $k$, $Z_r$ and $Z_i$) need to be updated within the frequency loop.
To enable this, we initialize them as `DOLFINx` constants

```{python}
# sources (zero in this case)
q_r = fem.Constant(domain, 0.0)
q_i = fem.Constant(domain, 0.0)

# velocity boundary condition (real part only here)
v_nr = 1e-5  #***
v_ni = 0.0

# frequency-dependent variables
omega = fem.Constant(domain, default_scalar_type(0))
k = fem.Constant(domain, default_scalar_type(0))

Z_r = fem.Constant(domain, default_scalar_type(0))
Z_i = fem.Constant(domain, default_scalar_type(0))

# probe point at center
probe_points = np.array(
  [[L/2.0, W/2.0, H/2.0]], 
  dtype=np.float64
)
coords = V.tabulate_dof_coordinates().reshape((-1, domain.geometry.dim))
dof_indices = [
  int(np.argmin(np.linalg.norm(coords -p, axis=1))) for p in probe_points
]
```

**Variational formulation**

We can now write the variational formulation

```{python}
p_r = ufl.TrialFunction(V)
p_i = ufl.TrialFunction(V)
v = ufl.TestFunction(V)

Delta_Z = Z_r**2 +Z_i**2
coef = omega *rho0 /Delta_Z

# bilinear forms
a_r = ( 
  (ufl.inner(ufl.grad(p_r), ufl.grad(v)) -k**2 *p_r *v) *ufl.dx 
  +coef *(Z_i *p_r -Z_r *p_i) *v *ds(3)
)

a_i = (
  (ufl.inner(ufl.grad(p_i), ufl.grad(v)) -k**2 *p_i *v) *ufl.dx
  +coef *(Z_r *p_r +Z_i *p_i) *v *ds(3)
)

# RHS (velocity BC only)
L_r = -omega *rho0 *q_i *v *ufl.dx +omega *rho0 *v_ni *v *ds(2)
L_i =  omega *rho0 *q_r *v *ufl.dx -omega *rho0 *v_nr *v *ds(2)
```

The `LinearProblem` class is used to set up the `PETSc` backend and assemble the system matrix and vector.
The solution is stored in a `dolfinx.fem.Function`, `p_r_fun` and `p_i_fun`

```{python}
p_r_fun = fem.Function(V)
p_r_fun.name = "p_real"

p_i_fun = fem.Function(V)
p_i_fun.name = "p_imag"

problem_r = LinearProblem(
  a_r, L_r, u=p_r_fun,
  petsc_options={"ksp_type": "preonly", "pc_type": "lu"}
)
problem_i = LinearProblem(
  a_i, L_i, u=p_i_fun,
  petsc_options={"ksp_type": "preonly", "pc_type": "lu"}
)
```

**Frequency loop**

Finally, we implement the frequency loop. In this step, the frequency-dependent variables are updated and the system is solved for each frequency

```{python}
# Output files
xdmf_real = io.XDMFFile(comm, results_folder/"p_real.xdmf", "w")
xdmf_imag = io.XDMFFile(comm, results_folder/"p_imag.xdmf", "w")
xdmf_real.write_mesh(domain)
xdmf_imag.write_mesh(domain)

csv_file = results_folder/"SPL_probes.csv"
if rank == 0:
  with open(csv_file, "w", newline="") as f_:
    writer = csv.writer(f_)
    writer.writerow(["freq_Hz", "SPL_probe_center_dB"])

# Discrete frequency range
freq = np.arange(10, 1000, 5)  # Hz
SPL_all = []

for f in freq:
  omega.value = 2 *np.pi *f    
  k.value = omega.value /c

  Zs = delany_bazley_layer(f, rho0, c, sigma, d)
  Z_r.value = Zs.real
  Z_i.value = Zs.imag
  
  Delta_Z = Z_r**2 + Z_i**2
  coef = omega *rho0 /Delta_Z

  problem_r.solve()
  problem_i.solve()

  xdmf_real.write_function(p_r_fun, float(f))
  xdmf_imag.write_function(p_i_fun, float(f))  

  p_r_fun.x.scatter_forward()
  p_i_fun.x.scatter_forward()

  pr_vals = p_r_fun.x.array
  pi_vals = p_i_fun.x.array
  probe_SPLs = []
  for idx in dof_indices:
    pr = pr_vals[idx]
    pi = pi_vals[idx]
    p_complex = pr +1j *pi

    spl_db = 20 *np.log10(np.abs(p_complex) /(np.sqrt(2) *p_ref))
    probe_SPLs.append(spl_db)

  all_probe_SPLs = comm.gather(probe_SPLs, root=0)
  if rank == 0:
    row = [float(f)] +all_probe_SPLs[0]
    with open(csv_file, "a", newline="") as f_:
      csv.writer(f_).writerow(row)

  SPL_all.append(probe_SPLs[0])
  if rank == 0:
    print(
      f"f: {f:.0f} Hz,",
      f"|p|(probe): {10**(SPL_all[-1] /20) *np.sqrt(2) *p_ref:.3e} Pa,",
      f"SPL: {SPL_all[-1]:.2f} dB"
    )

xdmf_real.close()
xdmf_imag.close()  
```

```{python}
if rank == 0:
  plt.figure(figsize=(6, 4))

  plt.plot(freq, SPL_all, marker="o")
  
  plt.xlabel("Frequency [Hz]")
  plt.ylabel("SPL [dB re 20 µPa]")
  plt.title("SPL at domain center (velocity-inlet, DBZ-impedance outlet)")
  plt.grid(True)
  plt.tight_layout()
  plt.savefig(results_folder/"SPL_spectrum.png", dpi=150)
  
  plt.show()
```