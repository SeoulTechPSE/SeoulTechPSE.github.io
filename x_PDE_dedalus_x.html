<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.7.32">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>x_pde_dedalus_x</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
html { -webkit-text-size-adjust: 100%; }
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="x_PDE_dedalus_x_files/libs/clipboard/clipboard.min.js"></script>
<script src="x_PDE_dedalus_x_files/libs/quarto-html/quarto.js" type="module"></script>
<script src="x_PDE_dedalus_x_files/libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="x_PDE_dedalus_x_files/libs/quarto-html/popper.min.js"></script>
<script src="x_PDE_dedalus_x_files/libs/quarto-html/tippy.umd.min.js"></script>
<script src="x_PDE_dedalus_x_files/libs/quarto-html/anchor.min.js"></script>
<link href="x_PDE_dedalus_x_files/libs/quarto-html/tippy.css" rel="stylesheet">
<link href="x_PDE_dedalus_x_files/libs/quarto-html/quarto-syntax-highlighting-37eea08aefeeee20ff55810ff984fec1.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="x_PDE_dedalus_x_files/libs/bootstrap/bootstrap.min.js"></script>
<link href="x_PDE_dedalus_x_files/libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="x_PDE_dedalus_x_files/libs/bootstrap/bootstrap-81267100e462c21b3d6c0d5bf76a3417.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

</head>

<body class="fullcontent quarto-light">

<div id="quarto-content" class="page-columns page-rows-contents page-layout-article">

<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Coordinates</h1>
</div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<section id="sec-dedalus" class="level1">
<h1>DEDALUS</h1>
<p><strong>Dedalus</strong> solves differential equations using spectral methods. It’s open-source, written in Python, and MPI-parallelized</p>
<div class="quarto-figure quarto-figure-center">
<figure class="figure">
<p><a href="https://dedalus-project.org/index.html"><img src="https://dedalus-project.readthedocs.io/en/latest/_static/epic12_4_exp_2_1.25.png" class="img-fluid quarto-figure quarto-figure-center figure-img" style="width:40.0%"></a></p>
</figure>
</div>
<section id="coordinates-distributors-and-bases" class="level2">
<h2 class="anchored" data-anchor-id="coordinates-distributors-and-bases">Coordinates, Distributors, and Bases</h2>
<p>This tutorial walks through the basics of setting up and using coordinate, distributor, and basis objects in <code>Dedalus</code>. In <code>Dedalus</code>, we represent fields and solve PDEs using spectral discretizations. To set these up, we choose spectral bases for the spatial coordinates in the problem. Once the coordinates are defined, they are collected into a distributor object, which takes care of how fields and problems are split up and distributed in parallel</p>
<div id="501c7b50" class="cell" data-execution_count="1">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dedalus.public <span class="im">as</span> d3</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>In <code>Dedalus</code>, the spatial coordinates of a PDE are represented by coordinate objects. For simple 1D problems, you can define a coordinate directly using the <code>Coordinate</code> class. For higher-dimensional problems, you’ll usually combine multiple coordinates into a <code>CoordinateSystem</code>.</p>
<p>Dedalus currently includes several built-in coordinate systems:</p>
<ul>
<li><code>CartesianCoordinates</code>: works in any number of dimensions</li>
<li><code>PolarCoordinates</code>: with azimuth and radius</li>
<li><code>S2Coordinates</code>: with azimuth and colatitude</li>
<li><code>SphericalCoordinates</code>: with azimuth, colatitude, and radius</li>
</ul>
<p>When you create a <code>CoordinateSystem</code>, you just provide the names you’d like to use for each coordinate, in the order shown above. For example, let’s walk through how to set up a problem in 3D Cartesian coordinates</p>
<div id="a4b5ab16" class="cell" data-execution_count="2">
<div class="sourceCode cell-code" id="cb2"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb2-1"><a href="#cb2-1" aria-hidden="true" tabindex="-1"></a>coords <span class="op">=</span> d3.CartesianCoordinates(<span class="st">'x'</span>, <span class="st">'y'</span>, <span class="st">'z'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="distributors" class="level3">
<h3 class="anchored" data-anchor-id="distributors">Distributors</h3>
<p>A distributor object handles the parallel decomposition of fields and problems. Every problem in Dedalus needs a distributor, even if you’re just running in serial.</p>
<p>To create a distributor, you provide the coordinate system for your PDE, specify the datatype of the fields you’ll be working with, and, if needed, supply a process mesh to control parallelization</p>
<div id="259d96ba" class="cell" data-execution_count="3">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a><span class="co"># No mesh for serial / automatic parallelization</span></span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>dist <span class="op">=</span> d3.Distributor(coords, dtype<span class="op">=</span>np.float64) </span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Parallelization &amp; process meshes</strong></p>
<p>When you run <code>Dedalus</code> under <code>MPI</code>, it parallelizes computations using block-distributed domain decompositions. By default, <code>Dedalus</code> spreads the work across a 1-dimensional mesh of all available <code>MPI</code> processes—this is called a “slab” decomposition. If you want more flexibility, you can specify a custom process mesh with the <code>mesh</code> keyword when creating a domain. This allows “pencil” decompositions, where the domain is split along more than one direction. Just keep in mind that the total number of <code>MPI</code> processes must match the product of the mesh shape you provide</p>
<p>There’s also an important restriction: the mesh dimension can’t be larger than the number of separable coordinates in the linear part of your PDE. In practice, this usually means you can parallelize over periodic or angular coordinates. For fully separable problems—like a fully periodic box or a simulation on the sphere—the mesh dimension must be strictly less than the total dimension</p>
<p><strong>Layouts</strong></p>
<p>The distributor object sets up the machinery needed to allocate and transform fields in parallel. A key part of this is an ordered set of <code>Layout</code> objects, which describe how the data should be represented and distributed as it moves between coefficient space and grid space. Moving from one layout to another involves two types of operations: spectral transforms (done locally) and global transposes (which shuffle data across the process mesh to put it in the right place)</p>
<p>The basic algorithm works like this:</p>
<ul>
<li>We start in coefficient space (layout 0), where the last axis is local (not distributed)</li>
<li>Then we transform that last axis into grid space (layout 1)</li>
<li>If needed, we perform a global transpose so that the next axis becomes local, and transform that axis into grid space</li>
<li>This process repeats until all axes have been transformed into grid space (the final layout)</li>
</ul>
<p>Let’s take a look at the layouts for the domain we just built. Since this is a serial computation, no global transposes are required—all axes are already local. So the layout transitions are just coefficient-to-grid transforms, working backwards from the last axis</p>
<div id="c3b10090" class="cell" data-execution_count="4">
<div class="sourceCode cell-code" id="cb4"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb4-1"><a href="#cb4-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> layout <span class="kw">in</span> dist.layouts:</span>
<span id="cb4-2"><a href="#cb4-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f'Layout </span><span class="sc">{</span>layout<span class="sc">.</span>index<span class="sc">}</span><span class="ss">:  Grid space: </span><span class="sc">{</span>layout<span class="sc">.</span>grid_space<span class="sc">}</span><span class="ss">  Local: </span><span class="sc">{</span>layout<span class="sc">.</span>local<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Layout 0:  Grid space: [False False False]  Local: [ True  True  True]
Layout 1:  Grid space: [False False  True]  Local: [ True  True  True]
Layout 2:  Grid space: [False  True  True]  Local: [ True  True  True]
Layout 3:  Grid space: [ True  True  True]  Local: [ True  True  True]</code></pre>
</div>
</div>
<p>To get a sense of how things work in a distributed simulation, we’ll change the process mesh shape and rebuild the layout objects. For this example, we’ll bypass the usual internal checks on the number of available processes and related settings, just so we can see how the layouts are constructed in a parallel setup</p>
<div id="2bb08c36" class="cell" data-execution_count="5">
<div class="sourceCode cell-code" id="cb6"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb6-1"><a href="#cb6-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Don't do this. For illustration only</span></span>
<span id="cb6-2"><a href="#cb6-2" aria-hidden="true" tabindex="-1"></a>dist.mesh <span class="op">=</span> np.array([<span class="dv">4</span>, <span class="dv">2</span>])</span>
<span id="cb6-3"><a href="#cb6-3" aria-hidden="true" tabindex="-1"></a>dist.comm_coords <span class="op">=</span> np.array([<span class="dv">0</span>, <span class="dv">0</span>])</span>
<span id="cb6-4"><a href="#cb6-4" aria-hidden="true" tabindex="-1"></a>dist._build_layouts(dry_run<span class="op">=</span><span class="va">True</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div id="e5daf29f" class="cell" data-execution_count="6">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span> layout <span class="kw">in</span> dist.layouts:</span>
<span id="cb7-2"><a href="#cb7-2" aria-hidden="true" tabindex="-1"></a>  <span class="bu">print</span>(<span class="ss">f'Layout </span><span class="sc">{</span>layout<span class="sc">.</span>index<span class="sc">}</span><span class="ss">:  Grid space: </span><span class="sc">{</span>layout<span class="sc">.</span>grid_space<span class="sc">}</span><span class="ss">  Local: </span><span class="sc">{</span>layout<span class="sc">.</span>local<span class="sc">}</span><span class="ss">'</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Layout 0:  Grid space: [False False False]  Local: [False False  True]
Layout 1:  Grid space: [False False  True]  Local: [False False  True]
Layout 2:  Grid space: [False False  True]  Local: [False  True False]
Layout 3:  Grid space: [False  True  True]  Local: [False  True False]
Layout 4:  Grid space: [False  True  True]  Local: [ True False False]
Layout 5:  Grid space: [ True  True  True]  Local: [ True False False]</code></pre>
</div>
</div>
<p>We can see that there are now two additional layouts, corresponding to the transposed states of the mixed-transform layouts. Two global transposes are necessary here in order for the <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> axes to be stored locally, which is required to perform the respective spectral transforms. Here’s a sketch of the data distribution in the different layouts:</p>
<p><img src="figures/dedalus_fig_layouts_fold.png" class="img-fluid"></p>
<p>In most cases, you won’t need to interact with layout objects directly. However, it’s useful to understand this system, since it controls how data is distributed and transformed. Being aware of it will help when working with field objects, as we’ll see in later sections</p>
</section>
<section id="bases" class="level3">
<h3 class="anchored" data-anchor-id="bases">Bases</h3>
<p><strong>Creating a basis</strong></p>
<p>Each type of basis in <code>Dedalus</code> is represented by a separate class. These classes define the corresponding spectral operators as well as transforms between the “grid space” and “coefficient space” representations of functions in that basis. The most commonly used bases are:</p>
<ul>
<li><p><code>RealFourier</code> for real periodic functions on an interval using cosine &amp; sine modes</p></li>
<li><p><code>ComplexFourier</code> for complex periodic functions on an interval using complex exponentials</p></li>
<li><p><code>Chebyshev</code> for functions on an interval</p></li>
<li><p><code>Jacobi</code> for functions on an interval under a more general inner product (usually <code>Chebyshev</code> is best for performance)</p></li>
<li><p><code>DiskBasis</code> for functions on a full disk in polar coordinates</p></li>
<li><p><code>AnnulusBasis</code> for functions on an annulus in polar coordinates</p></li>
<li><p><code>SphereBasis</code> for functions on the 2-sphere in S2 or spherical coordinates</p></li>
<li><p><code>BallBasis</code> for functions on a full ball in spherical coordinates</p></li>
<li><p><code>ShellBasis</code> for functions on a spherical shell in spherical coordinates</p></li>
</ul>
<p>For one-dimensional or Cartesian bases, you create a basis by specifying:</p>
<ul>
<li>the corresponding coordinate object</li>
<li>the number of modes for the basis</li>
<li>the coordinate bounds of the basis interval</li>
</ul>
<p>For multidimensional or curvilinear bases, you provide:</p>
<ul>
<li>the corresponding coordinate system</li>
<li>the multidimensional mode shape for the basis</li>
<li>the radial extent of the basis</li>
<li>the data type (dtype) for the problem</li>
</ul>
<p>Optionally, for any basis, you can also specify dealiasing scale factors for each axis. These factors control how much to pad the modes when transforming to grid space. For example, to properly dealias quadratic nonlinearities, you would typically use a scaling factor of 3/2</p>
<div id="02f2cf8f" class="cell" data-execution_count="7">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>xbasis <span class="op">=</span> d3.RealFourier(coords[<span class="st">'x'</span>], size<span class="op">=</span><span class="dv">32</span>, bounds<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">1</span>), dealias<span class="op">=</span><span class="dv">3</span><span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>ybasis <span class="op">=</span> d3.RealFourier(coords[<span class="st">'y'</span>], size<span class="op">=</span><span class="dv">32</span>, bounds<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">1</span>), dealias<span class="op">=</span><span class="dv">3</span><span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>zbasis <span class="op">=</span> d3.Chebyshev(coords[<span class="st">'z'</span>], size<span class="op">=</span><span class="dv">32</span>, bounds<span class="op">=</span>(<span class="dv">0</span>,<span class="dv">1</span>), dealias<span class="op">=</span><span class="dv">3</span><span class="op">/</span><span class="dv">2</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Some bases also accept additional arguments that let you tweak their internal behavior. For more details, check <a href="https://dedalus-project.readthedocs.io/en/latest/autoapi/dedalus/core/basis/index.html">the <code>basis.py</code> API documentation</a></p>
<p><strong>Basis grids and scale factors</strong></p>
<p>Each basis comes with a corresponding coordinate or collocation grid—or multiple grids for multidimensional bases. These grids are useful for tasks like initializing and plotting fields</p>
<p>You can access the global (non-distributed) grids using the basis object’s <code>global_grid</code> method (or <code>global_grids</code> for multidimensional bases). These methods also allow you to provide scale factors, which control how many points are included in the grid relative to the number of basis modes</p>
<p>For example, let’s take a look at Chebyshev grids with scaling factors of 1 and 3/2</p>
<div id="c73fbdd2" class="cell" data-execution_count="8">
<div class="sourceCode cell-code" id="cb10"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb10-1"><a href="#cb10-1" aria-hidden="true" tabindex="-1"></a>grid_normal <span class="op">=</span> zbasis.global_grid(dist, scale<span class="op">=</span><span class="dv">1</span>).ravel()</span>
<span id="cb10-2"><a href="#cb10-2" aria-hidden="true" tabindex="-1"></a>grid_dealias <span class="op">=</span> zbasis.global_grid(dist, scale<span class="op">=</span><span class="dv">3</span><span class="op">/</span><span class="dv">2</span>).ravel()</span>
<span id="cb10-3"><a href="#cb10-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-4"><a href="#cb10-4" aria-hidden="true" tabindex="-1"></a>plt.figure(figsize<span class="op">=</span>(<span class="dv">6</span>, <span class="fl">1.5</span>), dpi<span class="op">=</span><span class="dv">100</span>)</span>
<span id="cb10-5"><a href="#cb10-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-6"><a href="#cb10-6" aria-hidden="true" tabindex="-1"></a>plt.plot(grid_normal, <span class="dv">0</span><span class="op">*</span>grid_normal <span class="op">+</span><span class="dv">1</span>, <span class="st">'o'</span>, markersize<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb10-7"><a href="#cb10-7" aria-hidden="true" tabindex="-1"></a>plt.plot(grid_dealias, <span class="dv">0</span><span class="op">*</span>grid_dealias <span class="op">-</span><span class="dv">1</span>, <span class="st">'o'</span>, markersize<span class="op">=</span><span class="dv">5</span>)</span>
<span id="cb10-8"><a href="#cb10-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb10-9"><a href="#cb10-9" aria-hidden="true" tabindex="-1"></a>plt.xlabel(<span class="st">'z'</span>)</span>
<span id="cb10-10"><a href="#cb10-10" aria-hidden="true" tabindex="-1"></a>plt.title(<span class="st">'Chebyshev grid with scales 1 and 3/2'</span>)</span>
<span id="cb10-11"><a href="#cb10-11" aria-hidden="true" tabindex="-1"></a>plt.ylim([<span class="op">-</span><span class="dv">2</span>, <span class="dv">2</span>])</span>
<span id="cb10-12"><a href="#cb10-12" aria-hidden="true" tabindex="-1"></a>plt.gca().yaxis.set_ticks([])<span class="op">;</span></span>
<span id="cb10-13"><a href="#cb10-13" aria-hidden="true" tabindex="-1"></a>plt.tight_layout()</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="x_PDE_dedalus_x_files/figure-html/cell-9-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Note that Chebyshev grids are non-equispaced: the points cluster quadratically near the ends of the interval. This behavior is especially useful for resolving sharp features, such as boundary layers</p>
<p><strong>Distributed grid and element arrays</strong></p>
<p>To make it easier to create field data, the distributor provides the local portions of the coordinate grids and mode numbers (wavenumbers or polynomial degrees). You can access the local grids—which are distributed according to the last layout or the full “grid space”—using the dist.<code>local_grid</code> method (or <code>dist.local_grids</code> for multidimensional bases)</p>
<p>When calling these methods, you need to specify the basis and optionally a scale factor (which defaults to 1)</p>
<div id="d88e0c7a" class="cell" data-execution_count="9">
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a>local_x <span class="op">=</span> dist.local_grid(xbasis)</span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a>local_y <span class="op">=</span> dist.local_grid(ybasis)</span>
<span id="cb11-3"><a href="#cb11-3" aria-hidden="true" tabindex="-1"></a>local_z <span class="op">=</span> dist.local_grid(zbasis)</span>
<span id="cb11-4"><a href="#cb11-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb11-5"><a href="#cb11-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Local x shape:'</span>, local_x.shape)</span>
<span id="cb11-6"><a href="#cb11-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Local y shape:'</span>, local_y.shape)</span>
<span id="cb11-7"><a href="#cb11-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Local z shape:'</span>, local_z.shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Local x shape: (32, 1, 1)
Local y shape: (1, 8, 1)
Local z shape: (1, 1, 16)</code></pre>
</div>
</div>
<p>The local x grid corresponds to the full Fourier grid for the x-basis and is the same on all processes, because the first axis is local in grid space</p>
<p>The local y and local z grids, on the other hand, usually differ across processes. These grids contain only the local portions of the y and z basis grids, distributed according to the process mesh—for example, 4 blocks in y and 2 blocks in z</p>
<p>You can access the local modes—which are distributed according to layout 0 (the full “coefficient space”)—using the <code>dist.local_modes</code> method. When calling this method, you just need to specify the basis</p>
<div id="e6bf03c8" class="cell" data-execution_count="10">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a>local_kx <span class="op">=</span> dist.local_modes(xbasis)</span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a>local_ky <span class="op">=</span> dist.local_modes(ybasis)</span>
<span id="cb13-3"><a href="#cb13-3" aria-hidden="true" tabindex="-1"></a>local_nz <span class="op">=</span> dist.local_modes(zbasis)</span>
<span id="cb13-4"><a href="#cb13-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb13-5"><a href="#cb13-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Local kx shape:'</span>, local_kx.shape)</span>
<span id="cb13-6"><a href="#cb13-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Local ky shape:'</span>, local_ky.shape)</span>
<span id="cb13-7"><a href="#cb13-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Local nz shape:'</span>, local_nz.shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Local kx shape: (8, 1, 1)
Local ky shape: (1, 16, 1)
Local nz shape: (1, 1, 32)</code></pre>
</div>
</div>
<p>The local kx and local ky arrays now differ across processes, because they contain only the local portions of the x and y wavenumbers, which are distributed in coefficient space</p>
<p>The local nz array, on the other hand, includes the full set of Chebyshev modes, which are always local in coefficient space</p>
<p>These local arrays can be used to create parallel-safe initial conditions for fields, either in grid space or coefficient space, as we’ll explore in the next section</p>
</section>
</section>
<section id="fields-and-operators" class="level2">
<h2 class="anchored" data-anchor-id="fields-and-operators">Fields and Operators</h2>
<p>This tutorial covers the basics of setting up and working with field and operator objects in <code>Dedalus</code>. <code>Dedalus</code> uses these abstractions to implement a symbolic algebra system, which allows us to represent mathematical expressions and PDEs in a convenient and flexible way</p>
<div id="170d64e0" class="cell" data-execution_count="11">
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> numpy <span class="im">as</span> np</span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> matplotlib.pyplot <span class="im">as</span> plt</span>
<span id="cb15-3"><a href="#cb15-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-4"><a href="#cb15-4" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> dedalus.public <span class="im">as</span> d3</span>
<span id="cb15-5"><a href="#cb15-5" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dedalus.extras.plot_tools <span class="im">import</span> plot_bot_2d</span>
<span id="cb15-6"><a href="#cb15-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb15-7"><a href="#cb15-7" aria-hidden="true" tabindex="-1"></a>figkw <span class="op">=</span> {<span class="st">'figsize'</span>: (<span class="dv">6</span>, <span class="dv">4</span>), <span class="st">'dpi'</span>: <span class="dv">150</span>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<section id="fields" class="level3">
<h3 class="anchored" data-anchor-id="fields">Fields</h3>
<p><strong>Creating a field</strong></p>
<p>In <code>Dedalus</code>, field objects represent scalar-valued fields defined over a set of bases (or a “domain”). You can create a field directly from the <code>Field</code> class by providing a distributor, a list of bases, and, optionally, a name</p>
<p>Alternatively, you can create a field using the <code>dist.Field</code> method</p>
<p>Let’s try setting up a 2D domain and building a field</p>
<div id="265e9fdd" class="cell" data-execution_count="12">
<div class="sourceCode cell-code" id="cb16"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb16-1"><a href="#cb16-1" aria-hidden="true" tabindex="-1"></a>coords <span class="op">=</span> d3.CartesianCoordinates(<span class="st">'x'</span>, <span class="st">'y'</span>)</span>
<span id="cb16-2"><a href="#cb16-2" aria-hidden="true" tabindex="-1"></a>dist <span class="op">=</span> d3.Distributor(coords, dtype<span class="op">=</span>np.float64)</span>
<span id="cb16-3"><a href="#cb16-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-4"><a href="#cb16-4" aria-hidden="true" tabindex="-1"></a>xbasis <span class="op">=</span> d3.RealFourier(coords[<span class="st">'x'</span>], <span class="dv">64</span>, bounds<span class="op">=</span>(<span class="op">-</span>np.pi, np.pi), dealias<span class="op">=</span><span class="dv">3</span><span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb16-5"><a href="#cb16-5" aria-hidden="true" tabindex="-1"></a>ybasis <span class="op">=</span> d3.Chebyshev(coords[<span class="st">'y'</span>], <span class="dv">64</span>, bounds<span class="op">=</span>(<span class="op">-</span><span class="dv">1</span>, <span class="dv">1</span>), dealias<span class="op">=</span><span class="dv">3</span><span class="op">/</span><span class="dv">2</span>)</span>
<span id="cb16-6"><a href="#cb16-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb16-7"><a href="#cb16-7" aria-hidden="true" tabindex="-1"></a>f <span class="op">=</span> dist.Field(name<span class="op">=</span><span class="st">'f'</span>, bases<span class="op">=</span>(xbasis, ybasis))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>This field <span class="math inline">\(f\)</span> depends on both <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span>, since it is defined using both <code>xbasis</code> and <code>ybasis</code></p>
<p>If you want to create a field that depends on only <span class="math inline">\(x\)</span> or only <span class="math inline">\(y\)</span>, you can pass <code>bases=xbasis</code> or <code>bases=ybasis</code>, respectively.</p>
<p>To create a spatially constant field—one that does not vary with <span class="math inline">\(x\)</span> or <span class="math inline">\(y\)</span>—simply do not provide any bases</p>
<p><strong>Vector and tensor fields</strong></p>
<p>By default, the <code>Field</code> class creates a scalar-valued field, which can also be instantiated using the <code>ScalarField</code> constructor</p>
<p>If you want a vector-valued field, use the <code>VectorField</code> constructor and provide the coordinate system corresponding to the components of the vector. Technically, this is specifying the vector bundle of the field to be the tangent bundle on the chosen coordinate system</p>
<p>Similarly, you can create arbitrary-order tensor fields using the <code>TensorField</code> constructor by passing a tuple of coordinate systems. This defines the tensor bundle of the field</p>
<p>Note: the bases of a field describe its spatial variation, while the vector/tensor bundle describes the components of the field. For example, you could have a 2D vector with <span class="math inline">\(x\)</span> and <span class="math inline">\(y\)</span> components that varies only along the <span class="math inline">\(x\)</span> direction—so it would only need an <span class="math inline">\(x\)</span> basis</p>
<p>Let’s go ahead and build such a vector field on our domain</p>
<div id="fe624136" class="cell" data-execution_count="13">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>u <span class="op">=</span> dist.VectorField(coords, name<span class="op">=</span><span class="st">'u'</span>, bases<span class="op">=</span>xbasis)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Manipulating field data</strong></p>
<p><code>Field</code> objects provide several methods for transforming their data between different layouts—this includes grid space, coefficient space, and all intermediate layouts</p>
<p>Each field has a layout attribute, which points to the layout object describing its current transform and distribution state</p>
<p>By default, fields are instantiated in coefficient space</p>
<div id="a48e466c" class="cell" data-execution_count="14">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>f.layout.grid_space</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="169">
<pre><code>array([False, False])</code></pre>
</div>
</div>
<p>You can assign and retrieve field data in any layout by indexing a field with that layout object. In most cases, you won’t need the mixed layouts—the full grid and full coefficient layouts are usually enough. You can also use the shortcuts ‘g’ and ‘c’ to access these layouts easily</p>
<p>When working in parallel, each process only manipulates its local portion of the globally distributed data. This means you can safely set a field’s grid data in a parallel-safe way using the local grids provided by the domain</p>
<div id="73df266c" class="cell" data-execution_count="15">
<div class="sourceCode cell-code" id="cb20"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb20-1"><a href="#cb20-1" aria-hidden="true" tabindex="-1"></a>x <span class="op">=</span> dist.local_grid(xbasis)</span>
<span id="cb20-2"><a href="#cb20-2" aria-hidden="true" tabindex="-1"></a>y <span class="op">=</span> dist.local_grid(ybasis)</span>
<span id="cb20-3"><a href="#cb20-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-4"><a href="#cb20-4" aria-hidden="true" tabindex="-1"></a>f[<span class="st">'g'</span>] <span class="op">=</span> np.exp((<span class="dv">1</span> <span class="op">-</span>y<span class="op">**</span><span class="dv">2</span>) <span class="op">*</span>np.cos(x <span class="op">+</span>np.cos(x) <span class="op">*</span>y<span class="op">**</span><span class="dv">2</span>)) <span class="op">*</span>(<span class="dv">1</span> <span class="op">+</span><span class="fl">0.05</span> <span class="op">*</span>np.cos(<span class="dv">10</span> <span class="op">*</span>(x <span class="op">+</span><span class="dv">2</span> <span class="op">*</span>y)))  </span>
<span id="cb20-5"><a href="#cb20-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb20-6"><a href="#cb20-6" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot grid values</span></span>
<span id="cb20-7"><a href="#cb20-7" aria-hidden="true" tabindex="-1"></a>plot_bot_2d(f, figkw<span class="op">=</span>figkw, title<span class="op">=</span><span class="st">"f['g']"</span>)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="x_PDE_dedalus_x_files/figure-html/cell-16-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>You can convert a field to spectral coefficients by accessing its data in coefficient space. Internally, this triggers an in-place multidimensional spectral transform on the field’s data</p>
<div id="4f9d0938" class="cell" data-execution_count="16">
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a>f[<span class="st">'c'</span>]</span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb21-3"><a href="#cb21-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot log magnitude of spectral coefficients</span></span>
<span id="cb21-4"><a href="#cb21-4" aria-hidden="true" tabindex="-1"></a>log_mag <span class="op">=</span> <span class="kw">lambda</span> xmesh, ymesh, data: (xmesh, ymesh, np.log10(np.<span class="bu">abs</span>(data) <span class="op">+</span><span class="fl">1.e-20</span>))</span>
<span id="cb21-5"><a href="#cb21-5" aria-hidden="true" tabindex="-1"></a>plot_bot_2d(f, func<span class="op">=</span>log_mag, clim<span class="op">=</span>(<span class="op">-</span><span class="dv">20</span>, <span class="dv">0</span>), cmap<span class="op">=</span><span class="st">'viridis'</span>, title<span class="op">=</span><span class="st">"log10(abs(f['c'])"</span>, figkw<span class="op">=</span>figkw)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="x_PDE_dedalus_x_files/figure-html/cell-17-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p>Examining the spectral coefficients of a field is very useful, because the amplitude of the highest modes indicates the truncation errors in the spectral discretization</p>
<p>If the amplitudes of these modes are small, as in this example, we can conclude that the field is well-resolved</p>
<p><strong>Vector and tensor components</strong></p>
<p>In <code>Dedalus</code>, when you build a <code>VectorField</code> or <code>TensorField</code>, the first axes of the data array always correspond to the field’s components, and the remaining axes correspond to the bases (spatial discretization)</p>
<div id="fa85635e" class="cell" data-execution_count="17">
<div class="sourceCode cell-code" id="cb22"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb22-1"><a href="#cb22-1" aria-hidden="true" tabindex="-1"></a>u[<span class="st">'g'</span>].shape</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display" data-execution_count="172">
<pre><code>(2, 64, 1)</code></pre>
</div>
</div>
<p><em>Vector and Tensor Field Data Shapes</em></p>
<ul>
<li>The first axis of the data array corresponds to the field’s components</li>
<li>For example, in a 2D Cartesian vector field, this axis has size 2, representing the <span class="math inline">\(x\)</span>- and <span class="math inline">\(y\)</span>-components</li>
<li>The remaining axes correspond to the physical shape of the domain</li>
<li>In our example, the field is constant along the <span class="math inline">\(y\)</span>-direction, since it was only defined with an <span class="math inline">\(x\)</span>-basis</li>
</ul>
<p><em>Grid Space vs.&nbsp;Coefficient Space</em></p>
<ul>
<li>In grid space, vector and tensor components align with the unit vectors of the tangent space (e.g., <span class="math inline">\(\hat{x}\)</span>, <span class="math inline">\(\hat{y}\)</span> in Cartesian coordinates)</li>
<li>In coefficient space, the same is true for Cartesian domains</li>
<li>However, in curvilinear domains (polar, spherical, etc.), the components may be recombined during spectral transforms, making the coefficient-space data harder to interpret component-wise</li>
</ul>
<p><em>Practical Tip</em></p>
<p>Because of this, it’s generally recommended to initialize vector and tensor fields in grid space, where the components correspond directly to the familiar unit vectors</p>
<p><strong>Field scale factors</strong></p>
<p><em>Changing Field Resolution with change_scales</em></p>
<ul>
<li>The <code>change_scales</code> method on a field lets you modify the scaling factors used when transforming the field’s data into grid space</li>
<li>If you set field data using grid arrays, make sure the field and grid use the same scale factors, otherwise you’ll get shape errors</li>
</ul>
<p><em>Practical Uses</em></p>
<ul>
<li>Large scale factors ($ &gt; 1$): Interpolate the field data onto a higher-resolution grid</li>
<li>Small scale factors ($ &lt; 1$): View the field on a lower-resolution grid</li>
<li>But beware: if the scale factor is less than 1, you’ll actually lose data during the transform to grid space</li>
</ul>
<p><em>High-Resolution Sampling with change_scales</em></p>
<p>We can sample a field on a higher-resolution grid by increasing its scale factors using the <code>change_scales</code> method. This effectively interpolates the field data, giving us a finer view of its structure in grid space</p>
<div id="5fc850cb" class="cell" data-execution_count="18">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a>f.change_scales(<span class="dv">4</span>)</span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb24-3"><a href="#cb24-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot grid values</span></span>
<span id="cb24-4"><a href="#cb24-4" aria-hidden="true" tabindex="-1"></a>f[<span class="st">'g'</span>]</span>
<span id="cb24-5"><a href="#cb24-5" aria-hidden="true" tabindex="-1"></a>plot_bot_2d(f, title<span class="op">=</span><span class="st">"f['g']"</span>, figkw<span class="op">=</span>figkw)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="x_PDE_dedalus_x_files/figure-html/cell-19-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p><em>Scale Factors in Data Access</em></p>
<p>Scale factors can also be passed as a second argument when setting or retrieving field data through the <code>__getitem__ / __setitem__</code> interface:</p>
<ul>
<li><code>field['g', 2]</code> → get the grid-space data at 2× resolution</li>
<li><code>field['g', 0.5]</code> → get the grid-space data at half resolution</li>
<li><code>field['g', 2]</code> = … → set the grid-space data at 2× resolution</li>
</ul>
<p>This provides a convenient way to work with data at different resolutions without calling <code>change_scales</code> explicitly</p>
<div id="0e2d355a" class="cell" data-execution_count="19">
<div class="sourceCode cell-code" id="cb25"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb25-1"><a href="#cb25-1" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(f[<span class="st">'g'</span>, <span class="dv">1</span>].shape)</span>
<span id="cb25-2"><a href="#cb25-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(f[<span class="st">'g'</span>, <span class="dv">2</span>].shape)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>(64, 64)
(128, 128)</code></pre>
</div>
</div>
</section>
<section id="operators" class="level3">
<h3 class="anchored" data-anchor-id="operators">Operators</h3>
<p><strong>Arithmetic with fields</strong></p>
<p><em>Operator Classes</em></p>
<ul>
<li>In <code>Dedalus</code>, mathematical operations on fields—such as arithmetic, differentiation, integration, and interpolation—are represented by <code>Operator</code> classes</li>
<li>An operator instance corresponds to a specific mathematical expression</li>
<li>Operators provide an interface for deferred evaluation, meaning the expression is stored symbolically and can be evaluated later, even if its arguments evolve over time</li>
</ul>
<p><em>Arithmetic Operators</em></p>
<ul>
<li><code>Dedalus</code> lets you write arithmetic operations between fields (or between fields and scalars) using Python’s infix operators (+, -, *, /, **)</li>
<li>This makes expressions look natural, just like standard math notation</li>
</ul>
<div id="cafd4be4" class="cell" data-execution_count="20">
<div class="sourceCode cell-code" id="cb27"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb27-1"><a href="#cb27-1" aria-hidden="true" tabindex="-1"></a>g_op <span class="op">=</span> <span class="dv">1</span> <span class="op">-</span><span class="dv">2</span> <span class="op">*</span>f</span>
<span id="cb27-2"><a href="#cb27-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(g_op)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>C(C(1)) + -1*2*f</code></pre>
</div>
</div>
<p><em>Operator Objects and Evaluation</em></p>
<ul>
<li>When we perform arithmetic with fields, the result is not a field, but an operator object</li>
<li>For example, the expression might symbolically represent “add 1 to the product of -1, 2, and our field”</li>
<li>To actually compute the operation, we call the operator’s <code>.evaluate()</code> method</li>
<li>This returns a new field containing the numerical result</li>
<li>Important: the dealiasing scale factors set when the basis was instantiated are always applied during operator evaluation</li>
</ul>
<div id="63edeac4" class="cell" data-execution_count="21">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a>g <span class="op">=</span> g_op.evaluate()</span>
<span id="cb29-2"><a href="#cb29-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb29-3"><a href="#cb29-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot grid values</span></span>
<span id="cb29-4"><a href="#cb29-4" aria-hidden="true" tabindex="-1"></a>g[<span class="st">'g'</span>]</span>
<span id="cb29-5"><a href="#cb29-5" aria-hidden="true" tabindex="-1"></a>plot_bot_2d(g, title<span class="op">=</span><span class="st">"g['g']"</span>, figkw<span class="op">=</span>figkw)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="x_PDE_dedalus_x_files/figure-html/cell-22-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>Building expressions</strong></p>
<p><em>Building Expression Trees</em></p>
<ul>
<li><code>Operator</code> instances can themselves be passed as arguments to other operators</li>
<li>This allows us to build expression trees that represent more complicated mathematical formulas in a natural, symbolic way</li>
</ul>
<div id="539f7125" class="cell" data-execution_count="22">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>h_op <span class="op">=</span> <span class="dv">1</span> <span class="op">/</span>np.cosh(g_op <span class="op">+</span><span class="fl">2.5</span>)</span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(h_op)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>Pow(cosh(C(C(1)) + -1*2*f + C(C(2.5))), -1)</code></pre>
</div>
</div>
<p><em>Visualizing Operator Structures</em></p>
<ul>
<li><code>Operator</code> signatures can become hard to read when expressions get complicated</li>
<li>To make this easier, <code>Dedalus</code> provides a helper in <code>dedalus.tools</code> that lets us plot the operator’s structure</li>
<li>This visualization shows the tree of operations (e.g.&nbsp;additions, multiplications, derivatives), making it clear how the overall expression is built</li>
</ul>
<div id="0575855e" class="cell" data-execution_count="23">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="im">from</span> dedalus.tools.plot_op <span class="im">import</span> plot_operator</span>
<span id="cb32-2"><a href="#cb32-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb32-3"><a href="#cb32-3" aria-hidden="true" tabindex="-1"></a>plot_operator(h_op, figsize<span class="op">=</span><span class="dv">6</span>, fontsize<span class="op">=</span><span class="dv">14</span>, opsize<span class="op">=</span><span class="fl">0.4</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="x_PDE_dedalus_x_files/figure-html/cell-24-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p><em>Evaluating Operators</em></p>
<ul>
<li>Once an operator is constructed (even a complex expression tree), you can evaluate it to get a field containing the result</li>
<li>This is done using the <code>.evaluate()</code> method of the operator</li>
</ul>
<div id="ce176fee" class="cell" data-execution_count="24">
<div class="sourceCode cell-code" id="cb33"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb33-1"><a href="#cb33-1" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> h_op.evaluate()</span>
<span id="cb33-2"><a href="#cb33-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb33-3"><a href="#cb33-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot grid values</span></span>
<span id="cb33-4"><a href="#cb33-4" aria-hidden="true" tabindex="-1"></a>h[<span class="st">'g'</span>]</span>
<span id="cb33-5"><a href="#cb33-5" aria-hidden="true" tabindex="-1"></a>plot_bot_2d(h, title<span class="op">=</span><span class="st">"h['g']"</span>, figkw<span class="op">=</span>figkw)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="x_PDE_dedalus_x_files/figure-html/cell-25-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>Deferred evaluation</strong></p>
<p><em>Deferred Evaluation with Operators</em></p>
<ul>
<li><code>Operator</code> objects in <code>Dedalus</code> symbolically represent an operation on their field arguments</li>
<li>They use deferred evaluation, meaning the operation is not computed immediately</li>
<li>If the data of the field arguments changes, re-evaluating the operator with <code>.evaluate()</code> produces a new result that reflects the updated field data</li>
</ul>
<p><em>💡 Key insight:</em> This allows you to reuse the same operator object on different field states, which is especially useful in time-dependent simulations where fields evolve over time</p>
<div id="0bfe0648" class="cell" data-execution_count="25">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Change scales back to 1 to build new grid data</span></span>
<span id="cb34-2"><a href="#cb34-2" aria-hidden="true" tabindex="-1"></a>f.change_scales(<span class="dv">1</span>)</span>
<span id="cb34-3"><a href="#cb34-3" aria-hidden="true" tabindex="-1"></a>f[<span class="st">'g'</span>] <span class="op">=</span> <span class="dv">3</span> <span class="op">*</span>np.cos(<span class="fl">1.5</span> <span class="op">*</span>np.pi <span class="op">*</span>y)<span class="op">**</span><span class="dv">2</span> <span class="op">*</span>np.cos(x <span class="op">/</span><span class="dv">2</span>)<span class="op">**</span><span class="dv">4</span> <span class="op">+</span><span class="dv">3</span> <span class="op">*</span>np.exp(<span class="op">-</span>((<span class="dv">2</span> <span class="op">*</span>x <span class="op">+</span><span class="dv">2</span>)<span class="op">**</span><span class="dv">2</span> <span class="op">+</span>(<span class="dv">4</span> <span class="op">*</span>y <span class="op">+</span><span class="dv">4</span> <span class="op">/</span><span class="dv">3</span>)<span class="op">**</span><span class="dv">2</span>)) <span class="op">+</span><span class="dv">3</span> <span class="op">*</span>np.exp(<span class="op">-</span>((<span class="dv">2</span> <span class="op">*</span>x <span class="op">+</span><span class="dv">2</span>)<span class="op">**</span><span class="dv">2</span> <span class="op">+</span> (<span class="dv">4</span> <span class="op">*</span>y <span class="op">-</span><span class="dv">4</span> <span class="op">/</span><span class="dv">3</span>)<span class="op">**</span><span class="dv">2</span>))</span>
<span id="cb34-4"><a href="#cb34-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb34-5"><a href="#cb34-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot grid values</span></span>
<span id="cb34-6"><a href="#cb34-6" aria-hidden="true" tabindex="-1"></a>f[<span class="st">'g'</span>]</span>
<span id="cb34-7"><a href="#cb34-7" aria-hidden="true" tabindex="-1"></a>plot_bot_2d(f, title<span class="op">=</span><span class="st">"f['g']"</span>, figkw<span class="op">=</span>figkw)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="x_PDE_dedalus_x_files/figure-html/cell-26-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<div id="bdc50219" class="cell" data-execution_count="26">
<div class="sourceCode cell-code" id="cb35"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb35-1"><a href="#cb35-1" aria-hidden="true" tabindex="-1"></a>h <span class="op">=</span> h_op.evaluate()</span>
<span id="cb35-2"><a href="#cb35-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb35-3"><a href="#cb35-3" aria-hidden="true" tabindex="-1"></a><span class="co"># Plot grid values</span></span>
<span id="cb35-4"><a href="#cb35-4" aria-hidden="true" tabindex="-1"></a>h[<span class="st">'g'</span>]</span>
<span id="cb35-5"><a href="#cb35-5" aria-hidden="true" tabindex="-1"></a>plot_bot_2d(h, title<span class="op">=</span><span class="st">"h['g']"</span>, figkw<span class="op">=</span>figkw)<span class="op">;</span></span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-display">
<div>
<figure class="figure">
<p><img src="x_PDE_dedalus_x_files/figure-html/cell-27-output-1.png" class="img-fluid figure-img"></p>
</figure>
</div>
</div>
</div>
<p><strong>Differential operators</strong></p>
<ul>
<li>In <code>Dedalus</code>, operators are also used to compute derivatives of fields</li>
<li>For one-dimensional bases, partial derivatives are implemented using the <code>Differentiate</code> operator</li>
<li>To compute a derivative, you specify the coordinate with respect to which you want to differentiate</li>
</ul>
<div id="c5f50fcc" class="cell" data-execution_count="27">
<div class="sourceCode cell-code" id="cb36"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb36-1"><a href="#cb36-1" aria-hidden="true" tabindex="-1"></a>fx <span class="op">=</span> d3.Differentiate(f, coords[<span class="st">'x'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><em>Vector Calculus Operators in Dedalus</em></p>
<p>For multidimensional problems, <code>Dedalus</code> provides built-in vector calculus operators:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 14%">
<col style="width: 25%">
<col style="width: 60%">
</colgroup>
<thead>
<tr class="header">
<th>Operator</th>
<th>Applicable Fields</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Gradient</code></td>
<td>Arbitrary fields</td>
<td>Computes the gradient of a scalar or vector field</td>
</tr>
<tr class="even">
<td><code>Divergence</code></td>
<td>Vector or tensor fields</td>
<td>Computes the divergence</td>
</tr>
<tr class="odd">
<td><code>Curl</code></td>
<td>Vector fields</td>
<td>Computes the curl</td>
</tr>
<tr class="even">
<td><code>Laplacian</code></td>
<td>Arbitrary fields</td>
<td>Computes the Laplacian, defined as the divergence of the gradient</td>
</tr>
</tbody>
</table>
<ul>
<li>These operators return <strong>operator objects</strong> that can be <strong>evaluated</strong> to produce fields with the computed results<br>
</li>
<li>They provide a <strong>high-level, symbolic interface</strong> for common PDE operations, simplifying multidimensional derivations</li>
</ul>
<p><em>Optional Arguments for Vector Calculus Operators</em></p>
<ul>
<li>A <strong>coordinate system</strong> can optionally be specified as the <strong>tangent bundle</strong> for the <code>Gradient</code> and <code>Laplacian</code> operators.
<ul>
<li>If not provided, they <strong>default to the distributor’s coordinate system</strong></li>
</ul></li>
<li>A <strong>tensor index</strong> can optionally be specified for the <code>Divergence</code> operator
<ul>
<li>Defaults to <code>0</code> if not provided.</li>
</ul></li>
<li>Tensor ranks propagate naturally:
<ul>
<li>The gradient of a <strong>rank-0 (scalar) field</strong> is <strong>rank-1 (vector)</strong></li>
<li>The gradient of a <strong>rank-1 (vector) field</strong> is <strong>rank-2 (tensor)</strong>, and so on</li>
</ul></li>
</ul>
<div id="e196eec5" class="cell" data-execution_count="28">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>lap_f <span class="op">=</span> d3.Laplacian(f).evaluate()</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a>grad_f <span class="op">=</span> d3.Gradient(f).evaluate()</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'f shape:'</span>, f[<span class="st">'g'</span>].shape)</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Grad(f) shape:'</span>, grad_f[<span class="st">'g'</span>].shape)</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Lap(f) shape:'</span>, lap_f[<span class="st">'g'</span>].shape)</span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a>div_grad_f <span class="op">=</span> d3.Divergence(d3.Gradient(f)).evaluate()</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'Lap(f) is Div(Grad(f)):'</span>, np.allclose(lap_f[<span class="st">'g'</span>], div_grad_f[<span class="st">'g'</span>]))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>f shape: (96, 96)
Grad(f) shape: (2, 96, 96)
Lap(f) shape: (96, 96)
Lap(f) is Div(Grad(f)): True</code></pre>
</div>
</div>
<p><strong>Tensor operators</strong></p>
<p><em>Operators for Tensor Field Components</em></p>
<p><code>Dedalus</code> provides several operators specifically for manipulating <strong>components of tensor fields</strong>:</p>
<table class="caption-top table">
<colgroup>
<col style="width: 67%">
<col style="width: 32%">
</colgroup>
<thead>
<tr class="header">
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Trace</code></td>
<td>Contracts two specified indices of a tensor (defaults to indices 0 and 1)</td>
</tr>
<tr class="even">
<td><code>TransposeComponents</code></td>
<td>Swaps two specified indices of a tensor (defaults to indices 0 and 1)</td>
</tr>
<tr class="odd">
<td><code>Skew</code></td>
<td>Applies a 90-degree positive rotation to 2D vector fields</td>
</tr>
</tbody>
</table>
<div id="3f17d899" class="cell" data-execution_count="29">
<div class="sourceCode cell-code" id="cb39"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb39-1"><a href="#cb39-1" aria-hidden="true" tabindex="-1"></a>grad_u <span class="op">=</span> d3.Gradient(u)</span>
<span id="cb39-2"><a href="#cb39-2" aria-hidden="true" tabindex="-1"></a>transpose_grad_u <span class="op">=</span> d3.TransposeComponents(grad_u)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p><strong>Integrals and acerage</strong></p>
<p><em>Integrals and Averages</em></p>
<ul>
<li><code>Dedalus</code> provides operators for computing <strong>integrals</strong> and <strong>averages</strong> of scalar fields:</li>
</ul>
<table class="caption-top table">
<colgroup>
<col style="width: 50%">
<col style="width: 50%">
</colgroup>
<thead>
<tr class="header">
<th>Operator</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td><code>Integrate</code></td>
<td>Computes the integral of a scalar field over specified coordinates or a coordinate system</td>
</tr>
<tr class="even">
<td><code>Average</code></td>
<td>Computes the average of a scalar field over specified coordinates or a coordinate system</td>
</tr>
</tbody>
</table>
<div id="1261f2e5" class="cell" data-execution_count="30">
<div class="sourceCode cell-code" id="cb40"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb40-1"><a href="#cb40-1" aria-hidden="true" tabindex="-1"></a><span class="co"># Total integral of the field</span></span>
<span id="cb40-2"><a href="#cb40-2" aria-hidden="true" tabindex="-1"></a>f_int <span class="op">=</span> d3.Integrate(f, (<span class="st">'x'</span>, <span class="st">'y'</span>))</span>
<span id="cb40-3"><a href="#cb40-3" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'f integral:'</span>, f_int.evaluate()[<span class="st">'g'</span>])</span>
<span id="cb40-4"><a href="#cb40-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb40-5"><a href="#cb40-5" aria-hidden="true" tabindex="-1"></a><span class="co"># Average of the field</span></span>
<span id="cb40-6"><a href="#cb40-6" aria-hidden="true" tabindex="-1"></a>f_ave <span class="op">=</span> d3.Average(f, (<span class="st">'x'</span>, <span class="st">'y'</span>))</span>
<span id="cb40-7"><a href="#cb40-7" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'f average:'</span>, f_ave.evaluate()[<span class="st">'g'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>f integral: [[9.42458659]]
f average: [[0.74998477]]</code></pre>
</div>
</div>
<p><strong>Interpolation</strong></p>
<p><em>Interpolation</em></p>
<ul>
<li><p><code>Dedalus</code> provides the <strong><code>Interpolate</code> operator</strong> for interpolating field data along a coordinate</p></li>
<li><p>Interpolation can also be done using the <strong><code>__call__</code> method</strong> on fields or operators, with keywords specifying the <strong>coordinate</strong> and <strong>position</strong></p></li>
<li><p>For convenience, the strings <code>'left'</code>, <code>'right'</code>, and <code>'center'</code> can be used to refer to the <strong>endpoints</strong> and <strong>middle</strong> of 1D intervals</p></li>
</ul>
<div id="250370c7" class="cell" data-execution_count="31">
<div class="sourceCode cell-code" id="cb42"><pre class="sourceCode python code-with-copy"><code class="sourceCode python"><span id="cb42-1"><a href="#cb42-1" aria-hidden="true" tabindex="-1"></a>f00 <span class="op">=</span> f(x<span class="op">=</span><span class="dv">0</span>, y<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb42-2"><a href="#cb42-2" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(<span class="st">'f(0,0):'</span>, f00.evaluate()[<span class="st">'g'</span>])</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>f(0,0): [[3.01857352]]</code></pre>
</div>
</div>
</section>
</section>
</section>

</main>
<!-- /main column -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
        const codeEl = trigger.previousElementSibling.cloneNode(true);
        for (const childEl of codeEl.children) {
          if (isCodeAnnotation(childEl)) {
            childEl.remove();
          }
        }
        return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp('/' + window.location.host + '/');
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>