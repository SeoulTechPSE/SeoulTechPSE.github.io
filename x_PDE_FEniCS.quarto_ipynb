{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "jupyter: fenicsx\n",
        "---\n",
        "\n",
        "# The FEniCS computing platform {#sec-fenicsx}\n",
        "\n",
        "**FEniCS** is a popular open-source computing platform for solving partial differential equations (PDEs) with the finite element method (FEM). FEniCS enables users to quickly translate scientific models into efficient finite element code. With the high-level Python and C++ interfaces to FEniCS, it is easy to get started, but FEniCS offers also powerful capabilities for more experienced programmers. FEniCS runs on a multitude of platforms ranging from laptops to high-performance computers\n",
        "\n",
        "[![](https://fenicsproject.org/assets/logo/fenics_logo.png){width=\"25%\" fig-align=\"center\"}](https://fenicsproject.org)\n",
        "\n",
        "## Getting started {#sec-fenicsx-getting-started}\n",
        "\n",
        "The latest stable release of FEniCSx is version 0.9, which was released in October 2024. The easiest way to start using `FEniCSx` on MacOS and other systems is to install it using `conda`:\n",
        "\n",
        "``` bash\n",
        "$ conda create -n fenicsx\n",
        "$ conda activate fenicsx\n",
        "$ conda install -c conda-forge fenics-dolfinx mpich pyvista \n",
        "$ conda install -c conda-forge petsc petsc4py\n",
        "$ conda install ipykernel\n",
        "$ python -m ipykernel install \\\n",
        ">       --user --name fenicsx --display-name \"FEniCSx\"\n",
        "```"
      ],
      "id": "c8e1da97"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import dolfinx\n",
        "print(f'DOLFINx version: {dolfinx.__version__}')"
      ],
      "id": "ad1d283e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## An Overview of the FEniCS Project {#sec-fenicsx-overview}\n",
        "\n",
        "* The `FEniCS` Project is a research and software initiative focused on developing mathematical methods and software for solving partial differential equations (PDEs). Its goal is to provide intuitive, efficient, and flexible tools for scientific computing. Launched in 2003, the project is the result of collaboration among researchers from universities and research institutes worldwide. For the latest updates and more information, visit the [FEniCS Project](https://fenicsproject.org/)\n",
        "\n",
        "* The latest version of the `FEniCS` project, `FEniCSx`, consists of several building blocks, namely `DOLFINx`, `UFL`, `FFCx`, and `Basix`. We will now go through the main objectives of each of these building blocks\n",
        "\n",
        "  * `DOLFINx` is the high performance `C++` backend of `FEniCSx`, where structures such as meshes, function spaces and functions are implemented. Additionally, `DOLFINx` also contains compute intensive functions such as finite element assembly and mesh refinement algorithms. It also provides an interface to linear algebra solvers and data-structures, such as `PETSc`\n",
        "  * `UFL` is a high-level form language for describing variational formulations with a high-level mathematical syntax\n",
        "  * `FFCx` is the form compiler of `FEniCSx`; given variational formulations written with `UFL`, it generates efficient `C` code\n",
        "  * `Basix` is the finite element backend of `FEniCSx`, responsible for generating finite element basis functions\n",
        "\n",
        "## What you will learn\n",
        "\n",
        "The goal of this tutorial is to demonstrate how to apply the finite element to solve PDEs using `FEniCS`. Through a series of examples, we will demonstrate how to:\n",
        "\n",
        "* Solve linear PDEs (such as the Poisson equation)\n",
        "* Solve time-dependent PDEs (such as the heat equation)\n",
        "* Solve non-linear PDEs\n",
        "* Solve systems of time-dependent non-linear PDEs\n",
        "\n",
        "Important topics include: how to set boundary conditions of various types (Dirichlet, Neumann, Robin), how to create meshes, how to define variable coefficients, how to interact with linear and non-linear solvers, and how to post-process and visualize solutions\n",
        "\n",
        "## Solving the Poisson equation {#sec-fenicsx-Poisson}\n",
        "\n",
        "Authors: Hans Petter Langtangen, Anders Logg, Jørgen S. Dokken\n",
        "\n",
        "The goal of this section is to solve one of the most basic PDEs, the Poisson equation, with a few lines of code in `FEniCSx`. We start by introducing some fundamental `FEniCSx` objects, such as `functionspace`,`Function`,  `TrialFunction` and `TestFunction`, and learn how to write a basic PDE solver. This will include:\n",
        "\n",
        "* How to formulate a mathematical variational problem\n",
        "* How to apply boundary conditions\n",
        "* How to solve the discrete linear system\n",
        "* How to visualize the solution\n",
        "\n",
        "The Poisson equation is the following boundary-value problem:\n",
        "\n",
        "$$\\begin{aligned}\n",
        "  -\\nabla^2 u(\\mathbf{x}) &= f(\\mathbf{x})&&\\mathbf{x} \\in \\Omega\\\\\n",
        "  u(\\mathbf{x}) &= u_D(\\mathbf{x})&& \\mathbf{x} \\in \\partial\\Omega\n",
        "\\end{aligned}$$\n",
        " \n",
        "Here, $u=u(\\mathbf{x})$ is the unknown function, $f=f(\\mathbf{x})$\n",
        "is a prescribed function, \n",
        "$\\nabla^2$ (often written as $\\Delta$) is the Laplace operator, $\\Omega$\n",
        "is the spatial domain, and $\\partial\\Omega$ is its boundary. The Poisson problem  — consisting of the PDE $-\\nabla^2 u = f$ together with the boundary condition $u=u_D$ on $\\partial\\Omega$ — is a boundary value problem that must be precisely defined before we can solve it numerically with `FEniCSx`\n",
        "\n",
        " * In the two-dimensional space with coordinates $x$ and $y$, we can expand the Poisson equation as\n",
        "\n",
        "  $$-\\frac{\\partial^2 u}{\\partial x^2} - \\frac{\\partial^2 u}{\\partial y^2} = f(x,y)$$\n",
        "\n",
        "  The unknown $u$ is now a function of two variables, $u=u(x,y)$, defined over the two-dimensional domain $\\Omega$\n",
        "\n",
        "  * The Poisson equation arises in numerous physical contexts, including heat conduction, electrostatics, diffusion of substances, twisting of elastic rods, inviscid fluid flow, and water waves. Moreover, the equation appears in numerical splitting strategies for more complicated systems of PDEs, in particular the Navier–Stokes equations\n",
        "\n",
        "Solving a boundary value problem in `FEniCSx` consists of the following steps:\n",
        "\n",
        "1. Identify the computational domain $\\Omega$, the PDE, and its corresponding boundary conditions and source terms $f$\n",
        "2. Reformulate the PDE as a finite element variational problem\n",
        "3. Write a Python program defining the computational domain, the boundary conditions, the variational problem, and the source terms, using `FEniCSx`\n",
        "4. Run the Python program to solve the boundary-value problem. Optionally, you can extend the program to derive quantities such as fluxes and averages,\n",
        "   and visualize the results\n",
        "\n",
        "As we have already covered step 1, we shall now cover steps 2-4\n",
        "\n",
        "### Finite element variational formulation\n",
        "\n",
        "`FEniCSx` is based on the finite element method, which is a general and\n",
        "efficient mathematical technique for the numerical solution of\n",
        "PDEs. The starting point for finite element methods is a PDE\n",
        "expressed in _variational form_\n",
        "\n",
        "The basic recipe for turning a PDE into a variational problem is:\n",
        "\n",
        "- Multiply the PDE by a function $v$\n",
        "- Integrate the resulting equation over the domain $\\Omega$\n",
        "- Perform integration by parts of those terms with second order derivatives\n",
        "\n",
        "The function $v$ that multiplies the PDE is called a *test function*, while the unknown function $u$ to be approximated is referred to as a *trial function*.\n",
        "The terms *trial function* and *test function* are also used in `FEniCSx`. Both test and trial functions belong to certain *specific function spaces* that define their properties\n",
        "\n",
        "* In the present case, we multiply the Poisson equation by a test function $v$ and integrate over $\\Omega$:\n",
        "\n",
        "  $$\\int_\\Omega (-\\nabla^2 u) v~\\mathrm{d} x = \\int_\\Omega f v~\\mathrm{d} x$$\n",
        "\n",
        "  Here $\\mathrm{d} x$ denotes the differential element for integration over the domain $\\Omega$. We will later let $\\mathrm{d} s$ denote the differential element for integration over $\\partial\\Omega$, the boundary of $\\Omega$\n",
        "\n",
        "* A rule of thumb when deriving variational formulations is that one tries to keep the order of derivatives of $u$ and $v$ as small as possible.\n",
        "Here, we have a second-order differential of $u$, which can be transformed to a first derivative by employing the technique of\n",
        "[integration by parts](https://en.wikipedia.org/wiki/Integration_by_parts).\n",
        "The formula reads\n",
        "\n",
        "  $$-\\int_\\Omega (\\nabla^2 u)v~\\mathrm{d}x\n",
        "  = \\int_\\Omega\\nabla u\\cdot\\nabla v~\\mathrm{d}x - \n",
        "  \\underbrace{\\int_\\Omega \\nabla u \\cdot v ~\\mathrm{d}x}_{\\displaystyle \\scriptsize\\int_{\\partial\\Omega}\\frac{\\partial u}{\\partial n}v~\\mathrm{d}s}$$\n",
        "\n",
        "  where $\\frac{\\partial u}{\\partial n}=\\nabla u \\cdot \\mathbf{n}$ is the derivative of $u$ in the outward normal direction $\\mathbf{n}$ on the boundary\n",
        "\n",
        "* Another feature of variational formulations is that the test function $v$ must vanish on the parts of the boundary where the solution $u$ is prescribed\n",
        "\n",
        "* In the present problem, this means that $v = 0$ on the entire boundary $\\partial\\Omega$. Consequently, the second term in the integration by parts formula vanishes, and we obtain\n",
        "\n",
        "  $$\\int_\\Omega \\nabla u \\cdot \\nabla v~\\mathrm{d} x = \\int_\\Omega f v~\\mathrm{d} x$$\n",
        "  \n",
        "* If we require that this equation holds for all test functions $v$ in some suitable space $\\hat{V}$, the so-called _test space_, we obtain a well-defined mathematical problem that uniquely determines the solution $u$, which lies in some function space $V$. Note that $V$ does not necessarily coincide with $\\hat{V}$. We call the space $V$ the _trial space_. The equation above is referred to as the _weak form_(or *variational form*) of the original boundary-value problem. We can now  state our variational problem more precisely: $~$\n",
        "Find $u\\in V$ such that\n",
        "\n",
        "  $$\\int_\\Omega \\nabla u \\cdot \\nabla v~\\mathrm{d} x = \\int_\\Omega f v~\\mathrm{d} x\\qquad \\forall v \\in \\hat{V}$$\n",
        "\n",
        "* For the present problem, the trial and test spaces, $V$ and $\\hat{V}$, are defined as follows\n",
        "\n",
        "  $$\\color{red}{\\begin{aligned}\n",
        "     V&=\\{v\\in H^1(\\Omega) \\,\\vert\\, v=u_D \\;\\text{on } \\partial \\Omega \\}\\\\\n",
        "     \\hat{V}&=\\{v\\in H^1(\\Omega) \\,\\vert\\, v=0 \\;\\text{on } \\partial \\Omega \\}\n",
        "  \\end{aligned}}$$\n",
        "\n",
        "  In short, $H^1(\\Omega)$ is the Sobolev space consisting of functions $v$ for which both $v^2$ and $\\lvert \\nabla v \\rvert^2$ have finite integrals over $\\Omega$. The solution of the underlying PDE must belong to a function space in which derivatives are continuous. However, the Sobolev space $H^1(\\Omega)$ also admits functions with discontinuous derivatives\n",
        "\n",
        "  This weaker continuity requirement in the weak formulation (arising from the integration by parts) is crucial for constructing finite element function spaces. In particular, it permits the use of piecewise polynomial function spaces. Such spaces are built by stitching together polynomial functions over simple domains, such as intervals, triangles, quadrilaterals, tetrahedra, and hexahedra\n",
        "\n",
        "* The variational problem is a _continuous problem_: it defines the solution $u$ in the infinite-dimensional function space $V$.\n",
        "The finite element method for the Poisson equation approximates this solution by replacing the infinite-dimensional function spaces $V$ and $\\hat{V}$, with _discrete_ (finite-dimensional) spaces $V_h\\subset V$ and $\\hat{V}_h \\subset \\hat{V}$. The resulting discrete\n",
        "variational problem is then stated as: $~$ <font color=\"red\">Find $u_h\\in V_h$ such that</font>\n",
        "\n",
        "  $$\\color{red}{\n",
        "  \\begin{aligned}\n",
        "     \\int_\\Omega \\nabla u_h \\cdot \\nabla v~\\mathrm{d} x &= \\int_\\Omega fv~\\mathrm{d} x && \\forall v \\in \\hat{V}_h\n",
        "  \\end{aligned}}\n",
        "  $$\n",
        "\n",
        "* This variational problem, together with appropriate definitions of $V_h$ and $\\hat{V}_h$, uniquely determines our approximate numerical solution to the Poisson equation.\n",
        "Note that the boundary condition is incorporated into the trial and test spaces. While this may appear complicated at first,\n",
        "it ensures that the finite element variational problem has the same form as the continuous variational problem\n",
        "\n",
        "### Abstract finite element variational formulation\n",
        "\n",
        "We will introduce the following notation for variational problems:\n",
        "$\\,$ Find $u\\in V$ such that\n",
        "\n",
        "$$\\begin{aligned}\n",
        "  a(u,v)&=L(v)&& \\forall v \\in \\hat{V}\n",
        "\\end{aligned}$$\n",
        "\n",
        "For the Poisson equation, we have:\n",
        "\n",
        "$$\\begin{aligned}\n",
        "a(u,v) &= \\int_{\\Omega} \\nabla u \\cdot \\nabla v~\\mathrm{d} x\\\\\n",
        "L(v) &= \\int_{\\Omega} fv~\\mathrm{d} x\n",
        "\\end{aligned}$$\n",
        "\n",
        "In the literature $a(u,v)$ is known as the _bilinear form_ and $L(v)$ as a _linear form_.\n",
        "For every linear problem, we will identify all terms with the unknown $u$ and collect them in $a(u,v)$, and collect all terms with only known functions in $L(v)$.\n",
        "\n",
        "To solve a linear PDE in `FEniCSx`, such as the Poisson equation, a user thus needs to perform two steps:\n",
        "\n",
        "1. Choose the finite element spaces $V$ and $\\hat{V}$ by specifying the domain (the mesh) and the type of function space (polynomial degree and type)\n",
        "2. Express the PDE as a (discrete) variational problem: $\\,$ Find $u\\in V$ such that $a(u,v)=L(v)$ for all $v \\in \\hat{V}$\n",
        "\n",
        "### Implementation\n",
        "\n",
        "In this section, you will learn:\n",
        "\n",
        "- How to use the *built-in meshes* in `DOLFINx`\n",
        "- How to create *a spatially varying Dirichlet boundary conditions* on the whole domain boundary\n",
        "- How to define a weak formulation of your PDE\n",
        "- How *to solve the resulting system of linear equations*\n",
        "- How *to visualize the solution using a variety of tools*\n",
        "- How *to compute the $L^2(\\Omega)$ error and the error at mesh vertices*\n",
        "\n",
        "Up to this point, we’ve looked at the Poisson problem in very general terms: the domain $\\Omega$, the boundary condition $u_D$, and the right-hand side $f$ were all left unspecified. To actually solve something, we now need to pick concrete choices for $\\Omega$, $u_D$, and $f$\n",
        "\n",
        "A good strategy is to set up the problem in a way that we already know the exact solution. That way, we can easily check whether our numerical solution is correct. Polynomials of low degree are usually the best choice here, because continuous Galerkin finite element spaces of degree $r$ can reproduce any polynomial of degree $r$ exactly\n",
        "\n",
        "* To test our solver, we’ll construct a problem where we already know the exact solution. This approach is known as the method of manufactured solutions. The idea is simple:\n",
        "\n",
        "\t1.\tStart by picking a function $u_e(x,y)$ that looks nice and simple\n",
        "\t2.\tPlug $u_e$ into the PDE to figure out what the right-hand side $f(x,y)$ should be\n",
        "\t3.\tUse $u_e$ as the boundary condition $u_D$\n",
        "\t4.\tFinally, solve the problem numerically and compare the computed solution with $u_e$\n",
        "\n",
        "**Step 1:** Choosing the exact solution\n",
        "\n",
        "Let’s take a quadratic function in 2D:\n",
        "\n",
        "$$ u_e(x,y) = 1 + x^2 + 2y^2 $$\n",
        "\n",
        "**Step 2:** Computing the source term\n",
        "\n",
        "If we insert $u_e$ into the Poisson equation, we obtain\n",
        "\n",
        "$$f(x,y) = -6,\n",
        "\\;\\;\n",
        "u_D(x,y) = u_e(x,y) = 1 + x^2 + 2y^2$$\n",
        "\n",
        "Notice that this holds regardless of the domain shape, as long as we prescribe $u_e$ on the boundary\n",
        "\n",
        "**Step 3:** Choosing the domain\n",
        "\n",
        "For simplicity, let’s use the unit square:\n",
        "\n",
        "$$\\Omega = [0,1] \\times [0,1]$$\n",
        "\n",
        "**Step 4:** Summary\n",
        "\n",
        "This small example illustrates a very powerful strategy:\n",
        "\n",
        "* Pick an exact solution\n",
        "* Plug it into the PDE to generate the corresponding source term\n",
        "* Solve the PDE with these inputs\n",
        "* Verify that the numerical solution reproduces the exact solution\n",
        "\n",
        "This workflow is at the heart of *the method of manufactured solutions*, and it provides a simple but rigorous way to validate our solver\n",
        "\n",
        "**Generating simple meshes**\n",
        "\n",
        "The next step is to define the discrete domain, called the mesh.\n",
        "We do this using one of `FEniCSx`’s built-in mesh generators\n",
        "\n",
        "Here, we create a unit square mesh spanning $[0,1]\\times[0,1]$.\n",
        "The cells of the mesh can be either triangles or quadrilaterals:"
      ],
      "id": "d47a2d7b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "from mpi4py import MPI\n",
        "from dolfinx import mesh\n",
        "\n",
        "N = 8\n",
        "domain = mesh.create_unit_square(\n",
        "  MPI.COMM_WORLD, \n",
        "  nx=N, \n",
        "  ny=N, \n",
        "  cell_type=mesh.CellType.quadrilateral\n",
        ")"
      ],
      "id": "9e2b2f55",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Notice that we need to provide an MPI communicator.\n",
        "This determines how the program behaves in parallel:\n",
        "\n",
        "* If we pass `MPI.COMM_WORLD`, a single mesh is created and distributed across the number of processors we specify.\n",
        "For example, to run the program on two processors, we can use:\n",
        "\n",
        "``` bash\n",
        "$ mpirun -n 2 python tutorial_poisson.py\n",
        "```\n",
        "\n",
        "* If instead we use `MPI.COMM_SELF`, each processor will create its own independent copy of the mesh.\n",
        "This can be useful when running many small problems in parallel, for example when sweeping over different parameters\n",
        "\n",
        "**Defining the finite element function space**\n",
        "\n",
        "Once the mesh is created, the next step is to define the finite element function space $V$.\n",
        "`DOLFINx` supports a wide variety of finite element spaces of arbitrary order.\n",
        "For a full overview, see the list of\n",
        "[Supported elements in DOLFINx](https://defelement.org/lists/implementations/basix.ufl.html)\n",
        "\n",
        "When creating a function space, we need to specify:\n",
        "\n",
        "1.\tThe mesh on which the space is defined\n",
        "2.\tThe element family (e.g., Lagrange, Raviart–Thomas, etc.)\n",
        "3.\tThe polynomial degree of the element\n",
        "\n",
        "In `DOLFINx`, this can be done by passing a tuple of the form `(\"family\", degree)`, as shown below:"
      ],
      "id": "eef0ed45"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from dolfinx import fem\n",
        "\n",
        "V = fem.functionspace(domain, (\"Lagrange\", 1))"
      ],
      "id": "5fa773cb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "See [Degree 1 Lagrange on a quadrilateral](https://defelement.org/elements/examples/quadrilateral-lagrange-equispaced-1.html)\n",
        "\n",
        "The next step is to create a function that stores the Dirichlet boundary condition.\n",
        "We then use interpolation to fill this function with the prescribed values"
      ],
      "id": "ea96c0d4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "uD = fem.Function(V)\n",
        "uD.interpolate(lambda x: 1 +x[0]**2 +2 *x[1]**2)"
      ],
      "id": "bea55daa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "With the boundary data defined (which, in this case, coincides with the exact solution of our finite element problem), we now need to enforce it along the boundary of the mesh\n",
        "\n",
        "The first step is to identify which parts of the mesh correspond to the outer boundary. In `DOLFINx`, the boundary is represented by facets (that is, the line segments making up the outer edges in 2D or surfaces in 3D).\n",
        "\n",
        "We can extract the indices of all exterior facets using:"
      ],
      "id": "61ca8b94"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "tdim = domain.topology.dim\n",
        "fdim = tdim -1\n",
        "\n",
        "domain.topology.create_connectivity(fdim, tdim)\n",
        "boundary_facets = mesh.exterior_facet_indices(domain.topology)"
      ],
      "id": "39d06e75",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This gives us the set of facets lying on the boundary of our discrete domain.\n",
        "Once we know where the boundary is, we can proceed to apply the Dirichlet boundary conditions to all degrees of freedom (DoFs) located on these facets\n",
        "\n",
        "For our current problem, we are using the \"Lagrange\" degree-1 function space.\n",
        "In this case, the degrees of freedom (DoFs) are located at the vertices of each cell, so every boundary facet contains exactly two DoFs\n",
        "\n",
        "To identify the local indices of these boundary DoFs, we use `dolfinx.fem.locate_dofs_topological`.\n",
        "This function takes three arguments:\n",
        "\n",
        "1.\tthe function space\n",
        "2.\tthe dimension of the mesh entities we want to target, and\n",
        "3.\tthe list of entities (in our case, the boundary facets)\n",
        "\n",
        "Once we have the boundary DoFs, we can create the Dirichlet boundary condition as follows:"
      ],
      "id": "937e6544"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "boundary_dofs = fem.locate_dofs_topological(V, fdim, boundary_facets)\n",
        "bc = fem.dirichletbc(uD, boundary_dofs)"
      ],
      "id": "c806f733",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Defining the trial and test function**\n",
        "\n",
        "In mathematics, we usually distinguish between the trial space $V$ and the test space $\\hat{V}$.\n",
        "For the present problem, the only difference between the two would be the treatment of boundary conditions\n",
        "\n",
        "In `FEniCSx`, however, boundary conditions are not built directly into the function space.\n",
        "This means we can simply use the same space for both the trial and test functions\n",
        "\n",
        "To express the variational formulation, we make use of the [Unified Form Language](https://github.com/FEniCS/ufl/) (UFL)"
      ],
      "id": "5cb8149a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import ufl\n",
        "\n",
        "u = ufl.TrialFunction(V)\n",
        "v = ufl.TestFunction(V)"
      ],
      "id": "4743d728",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Defining the source term**\n",
        "\n",
        "Since the source term is constant throughout the domain, we can represent it using `dolfinx.fem.Constant`:"
      ],
      "id": "c3a98bc6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from dolfinx import default_scalar_type\n",
        "\n",
        "f = fem.Constant(domain, default_scalar_type(-6))"
      ],
      "id": "6ee02987",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "While we could simply define the source term as `f = -6`, this has a limitation: if we later want to change its value, we would need to redefine the entire variational problem.\n",
        "By using `dolfinx.fem.Constant`, we can easily update the value during the simulation, for example with `f.value = 5`\n",
        "\n",
        "Another advantage is performance: declaring `f` as a constant allows the compiler to optimize the variational formulation, leading to faster assembly of the resulting linear system\n",
        "\n",
        "**Defining the variational problem**\n",
        "\n",
        "Now that we have defined all the components of our variational problem, we can write down the weak formulation:"
      ],
      "id": "a542036e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "a = ufl.dot(ufl.grad(u), ufl.grad(v)) *ufl.dx\n",
        "L = f *v *ufl.dx"
      ],
      "id": "3c391b95",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Notice how closely the Python syntax mirrors the mathematical expressions:\n",
        "\n",
        "$$a(u,v) = \\int_{\\Omega} \\nabla u \\cdot \\nabla v \\,\\mathrm{d}x,\n",
        "\\;\\;\n",
        "L(v) = \\int_{\\Omega} f v \\,\\mathrm{d}x$$\n",
        "\n",
        "Here, `ufl.dx` represents integration over the domain $\\Omega$, i.e. over all cells of the mesh.\n",
        "This illustrates one of the major strengths of `FEniCSx`: $\\,$ variational formulations can be written in Python in a way that almost directly matches their mathematical form, making it both natural and convenient to specify and solve complex PDE problems\n",
        "\n",
        "**Expressing inner products**\n",
        "\n",
        "The inner product\n",
        "\n",
        "$$\\int_\\Omega \\nabla u \\cdot \\nabla v \\,\\mathrm{d}x$$\n",
        "\n",
        "can be expressed in different ways in `UFL`.\n",
        "In our example, we wrote it as: `ufl.dot(ufl.grad(u), ufl.grad(v)) *ufl.dx`. In UFL, the dot operator performs a contraction: it sums over the last index of the first argument and the first index of the second argument.\n",
        "Since both $\\nabla u$ and $\\nabla v$ are rank-1 tensors (vectors), this reduces to a simple dot product.\n",
        "\n",
        "For higher-rank tensors, such as matrices (rank-2 tensors), the appropriate operator is `ufl.inner`, which computes the full Frobenius inner product.\n",
        "For vectors, however, `ufl.dot` and `ufl.inner` are equivalent\n",
        "\n",
        "**Forming and solving the linear system**\n",
        "\n",
        "Having defined the finite element variational problem and boundary conditions, we can now create a `dolfinx.fem.petsc.LinearProblem`. This class provides a convenient interface for solving\n",
        "\n",
        "  Find $u_h\\in V$ such that $a(u_h, v)=L(v), \\;\\; \\forall v \\in \\hat{V}$\n",
        "  \n",
        "In this example, we will use `PETSc` as the linear algebra backend, together with a direct solver (LU factorization)\n",
        "\n",
        "For more details on Krylov subspace(KSP) solvers and preconditioners, see the [PETSc-documentation](https://petsc.org/main/docs/manual/ksp/?highlight=ksp#ksp-linear-system-solvers). Note that\n",
        "`PETSc` is not a required dependency of `DOLFINx`, so we explicitly import the `DOLFINx` wrapper to interface with `PETSc`.\n",
        "Finally, to ensure that the solver options passed to the `LinearProblem` apply only to this specific KSP solver, we assign a **unique** option prefix"
      ],
      "id": "5cf5892d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from dolfinx.fem.petsc import LinearProblem\n",
        "\n",
        "problem = LinearProblem(\n",
        "    a, L, bcs=[bc],\n",
        "    petsc_options={\n",
        "        # Direct solver using LU factorization\n",
        "        \"ksp_type\": \"preonly\",\n",
        "        \"pc_type\": \"lu\"\n",
        "    }\n",
        ")\n",
        "\n",
        "# Solve the system\n",
        "uh = problem.solve()\n",
        "\n",
        "# Optionally, view solver information\n",
        "#ksp = problem.solver\n",
        "#ksp.view()"
      ],
      "id": "839cf03e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The `ksp_type` option in `PETSc` KSP solver specifies which algorithm to use for solving the linear system, while `pc_type` specifies the type of preconditioner. For most FEM problems, Symmetric Positive Definite(SPD) systems typically use `cg` with `ilu` or `amg`, and if a direct LU solver is desired, one can use `ksp_type=\"preonly\"` with `pc_type=\"lu\"`\n",
        "\n",
        "Using `problem.solve()`,\n",
        "we solve the linear system of equations and return a `dolfinx.fem.Function` containing the solution\n",
        "\n",
        "**Computing the error**\n",
        "\n",
        "Finally, we want to compute the error to check the accuracy of the solution. We do this by comparing the finite element solution `uh` with the exact solution.\n",
        "We do this by interpolating the exact solution into the the $P_2$-function space"
      ],
      "id": "12829fab"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "V2 = fem.functionspace(domain, (\"Lagrange\", 2))\n",
        "uex = fem.Function(V2)\n",
        "uex.interpolate(lambda x: 1 +x[0]**2 +2 *x[1]**2)"
      ],
      "id": "6a60fc8e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We compute the error in two different ways. First, we compute the $L^2$ norm of the error, defined by \n",
        "\n",
        "$$E=\\sqrt{\\int_\\Omega (u_D-u_h)^2 \\,\\mathrm{d} x}$$\n",
        "\n",
        "We use `UFL` to express the $L^2$ error, and use `dolfinx.fem.assemble_scalar` to compute the scalar value.\n",
        "In `DOLFINx`, `assemble_scalar` only assembles over the cells on the local process. This means that if we use 2 processes to solve our problem, we need to gather the solution to one.\n",
        "We can do this with the `MPI.allreduce` function"
      ],
      "id": "5b92bf37"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "L2_error = fem.form(ufl.inner(uh -uex, uh -uex) *ufl.dx)\n",
        "error_local = fem.assemble_scalar(L2_error)\n",
        "error_L2 = np.sqrt(domain.comm.allreduce(error_local, op=MPI.SUM))"
      ],
      "id": "d6c689d4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Secondly, we compute the maximum error at any degree of freedom (dof).\n",
        "The finite element solution `uh` can be expressed as a linear combination of the basis functions $\\phi_j$ spanning the space $V$:\n",
        "\n",
        "$$u = \\sum_{j=1}^N U_j \\phi_j$$\n",
        "\n",
        "When we call `problem.solve()`, we obtain all coefficients $U_1$, $\\dots$, $U_N$. These coefficients are the degrees of freedom (dofs).\n",
        "We can access the dofs by retrieving the underlying vector from `uh`\n",
        "\n",
        "However, note that a second-order function space contains more dofs than a first-order space, so the corresponding arrays cannot be compared directly.\n",
        "Fortunately, since we have already interpolated the exact solution into the first-order space when defining the boundary condition, we can compare the maximum values at the dofs of the approximation space"
      ],
      "id": "452eaa75"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "error_max = np.max(np.abs(uD.x.array -uh.x.array))\n",
        "\n",
        "# Only print the error on one process\n",
        "if domain.comm.rank == 0:\n",
        "    print(f\"Error_L2 : {error_L2:.2e}\")\n",
        "    print(f\"Error_max : {error_max:.2e}\")"
      ],
      "id": "43b7d4a3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Plotting the mesh using pyvista**\n",
        "\n",
        "We will visualize the mesh using [pyvista](https://docs.pyvista.org/), a Python interface to the VTK toolkit.\n",
        "To begin, We convert the mesh into a format compatible with `pyvista` using the function `dolfinx.plot.vtk_mesh`. The first step is to create an unstructured grid that `pyvista` can work with\n",
        "\n",
        "You can check the current plotting backend with:"
      ],
      "id": "5d4a32f2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pyvista\n",
        "from dolfinx import plot\n",
        "\n",
        "topology, cell_types, geometry = plot.vtk_mesh(domain, tdim)\n",
        "grid = pyvista.UnstructuredGrid(topology, cell_types, geometry)"
      ],
      "id": "7254a956",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "`PyVista` supports several backends, each with its own advantages and limitations.\n",
        "For more information and installation instructions, see the [pyvista documentation](https://docs.pyvista.org/user-guide/jupyter/index.html#state-of-3d-interactive-jupyterlab-plotting)\n",
        "\n",
        "We can now use the `pyvista.Plotter` to visualize the mesh. We will show it both as a 2D and as a 3D warped representation.\n",
        "\n",
        "In the jupyter notebook, we use the default setting `pyvista.OFF_SCREEN=False`, which will renders the plots directly within the notebook"
      ],
      "id": "06faabf1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from pathlib import Path\n",
        "\n",
        "results_folder = Path(\"fenicsx/fundamentals\")\n",
        "results_folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "plotter = pyvista.Plotter(off_screen=True)\n",
        "plotter.add_mesh(grid, show_edges=True)\n",
        "plotter.add_axes()\n",
        "plotter.view_xy()\n",
        "\n",
        "# if not pyvista.OFF_SCREEN:\n",
        "#     plotter.show()\n",
        "\n",
        "# HTML 저장\n",
        "plotter.export_html(\"fenicsx/fundamentals/unit_square_mesh.html\")"
      ],
      "id": "94c740bc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/fundamentals/unit_square_mesh.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">\n",
        "</iframe>\n",
        "```\n",
        "\n",
        "**Plotting a function using pyvista**\n",
        "\n",
        "We want to plot the solution `uh`. Since the function space used to define `uh` is disconnected from the one used to define the mesh, we first create a mesh based on the DOF coordinates of the function space `V`. We then use `dolfinx.plot.vtk_mesh`, passing the function space as input, to generate a mesh whose geometry is based on these DOF coordinates"
      ],
      "id": "25c283f9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u_topology, u_cell_types, u_geometry = plot.vtk_mesh(V)"
      ],
      "id": "679e8b3c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we create the `pyvista.UnstructuredGrid` and add the DOF-values to the mesh"
      ],
      "id": "380d7398"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u_grid = pyvista.UnstructuredGrid(u_topology, u_cell_types, u_geometry)\n",
        "u_grid.point_data[\"u\"] = uh.x.array.real\n",
        "u_grid.set_active_scalars(\"u\")\n",
        "\n",
        "u_plotter = pyvista.Plotter(off_screen=True)\n",
        "u_plotter.add_mesh(\n",
        "    u_grid, \n",
        "    show_edges=True,\n",
        "    scalar_bar_args={\n",
        "        \"title\": \"u\",\n",
        "        \"fmt\": \"%.1f\",\n",
        "        \"color\": \"black\",\n",
        "        \"label_font_size\": 12,\n",
        "        # \"vertical\": True,\n",
        "        \"n_labels\": 7,\n",
        "    },\n",
        ")\n",
        "u_plotter.add_axes()\n",
        "u_plotter.view_xy()\n",
        "\n",
        "# if not pyvista.OFF_SCREEN:\n",
        "#     u_plotter.show()\n",
        "\n",
        "# HTML 저장\n",
        "u_plotter.export_html(\"fenicsx/fundamentals/poisson_solution_2D.html\")"
      ],
      "id": "30a76ead",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/fundamentals/poisson_solution_2D.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">\n",
        "</iframe>\n",
        "```\n",
        "\n",
        "**External post-processing**\n",
        "\n",
        "For post-processing outside Python, it is recommended to save the solution to a file using either `dolfinx.io.VTXWriter` or `dolfinx.io.XDMFFile`, and then visualize it in [ParaView](https://www.paraview.org/). This approach is especially useful for 3D visualization"
      ],
      "id": "f2430455"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from dolfinx import io\n",
        "\n",
        "filename = results_folder/\"poisson\"\n",
        "\n",
        "with io.VTXWriter(domain.comm, filename.with_suffix(\".bp\"), [uh]) as vtx:\n",
        "    vtx.write(0.0)\n",
        "    \n",
        "with io.XDMFFile(domain.comm, filename.with_suffix(\".xdmf\"), \"w\") as xdmf:\n",
        "    xdmf.write_mesh(domain)\n",
        "    xdmf.write_function(uh)"
      ],
      "id": "59ec1e82",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Weak imposition of Dirichlet conditions for the Poisson problem\n",
        "\n",
        "Author: Jørgen S. Dokken\n",
        "\n",
        "This section shows how to solve the previous Poisson problem using Nitsche’s method.\n",
        "Weak imposition works by adding terms to the variational formulation to enforce the boundary condition, instead of altering the matrix system via strong imposition (lifting).\n",
        "\n",
        "First, we import the necessary modules and set up the mesh and function space for the solution"
      ],
      "id": "c247cce7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from mpi4py import MPI\n",
        "\n",
        "from dolfinx import fem, mesh, plot, default_scalar_type\n",
        "from dolfinx.fem.petsc import LinearProblem\n",
        "\n",
        "from ufl import (Circumradius, FacetNormal, \n",
        "                 SpatialCoordinate, \n",
        "                 TrialFunction, TestFunction,\n",
        "                 dx, ds, div, grad, inner)\n",
        "\n",
        "N = 8\n",
        "domain = mesh.create_unit_square(MPI.COMM_WORLD, N, N)\n",
        "V = fem.functionspace(domain, (\"Lagrange\", 1))"
      ],
      "id": "a3f2d3c5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we create a function for the exact solution (also used in the Dirichlet boundary condition) and the corresponding source function for the right-hand side.\n",
        "The exact solution is defined using `ufl.SpatialCoordinate`, then interpolated into `uD` and used to generate the source function `f`"
      ],
      "id": "5e0b92e0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "x = SpatialCoordinate(domain)\n",
        "u_ex = 1 +x[0]**2 +2 *x[1]**2\n",
        "\n",
        "uD = fem.Function(V)\n",
        "uD.interpolate(fem.Expression(u_ex, V.element.interpolation_points()))\n",
        "f = -div(grad(u_ex))"
      ],
      "id": "f3f1233d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Unlike the first tutorial, we now need to revisit the variational form.\n",
        "We begin by integrating the problem by parts to obtain\n",
        "\n",
        "$$\\begin{aligned}\n",
        "    \\int_{\\Omega} \\nabla u \\cdot \\nabla v~\\mathrm{d}x - \\int_{\\partial\\Omega}\\nabla u \\cdot n v~\\mathrm{d}s = \\int_{\\Omega} f v~\\mathrm{d}x\n",
        "\\end{aligned}$$\n",
        "\n",
        "As we are not enforcing the boundary condition strongly, the trace of the test function is not set to zero on the boundary.\n",
        "We instead add the following two terms to the variational formulation:\n",
        "\n",
        "$$\\begin{aligned}\n",
        "    -\\int_{\\partial\\Omega} \\nabla  v \\cdot n (u-u_D)~\\mathrm{d}s + \\frac{\\alpha}{h} \\int_{\\partial\\Omega} (u-u_D)v~\\mathrm{d}s\n",
        "\\end{aligned}$$\n",
        "\n",
        "The first term enforces symmetry in the bilinear form, and the second term ensures coercivity.\n",
        "`u_D` denotes the known Dirichlet condition, and `h` is the diameter of the circumscribed sphere of the mesh element.\n",
        "The bilinear and linear forms, `a` and `L`, are then defined as\n",
        "\n",
        "$$\\begin{aligned}\n",
        "    a(u, v) &= \\int_{\\Omega} \\nabla u \\cdot \\nabla v ~\\mathrm{d}x + \\int_{\\partial\\Omega} -(n \\cdot\\nabla u) v - (n \\cdot \\nabla v) u + \\frac{\\alpha}{h} uv ~\\mathrm{d}s \\\\\n",
        "    L(v) &= \\int_{\\Omega} fv ~\\mathrm{d}x + \\int_{\\partial\\Omega} -(n \\cdot \\nabla v) u_D + \\frac{\\alpha}{h} u_D v ~\\mathrm{d}s\n",
        "\\end{aligned}$$"
      ],
      "id": "1aa261c7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u = TrialFunction(V)\n",
        "v = TestFunction(V)\n",
        "\n",
        "n = FacetNormal(domain)\n",
        "h = 2 *Circumradius(domain)\n",
        "alpha = fem.Constant(domain, default_scalar_type(10))\n",
        "\n",
        "a = inner(grad(u), grad(v)) *dx -inner(n, grad(u)) *v *ds\n",
        "a += -inner(n, grad(v)) *u *ds +alpha /h *inner(u, v) *ds\n",
        "L = inner(f, v) *dx \n",
        "L += -inner(n, grad(v)) *uD *ds +alpha /h *inner(uD, v) *ds"
      ],
      "id": "59eebc59",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "With the variational form in place, we can solve the linear problem"
      ],
      "id": "eec83482"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "problem = LinearProblem(a, L)\n",
        "uh = problem.solve()"
      ],
      "id": "85130d13",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We compute the error by comparing the numerical solution with the analytical solution"
      ],
      "id": "d8c6fa77"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "error_form = fem.form(inner(uh -uD, uh -uD) *dx)\n",
        "error_local = fem.assemble_scalar(error_form)\n",
        "error_L2 = np.sqrt(domain.comm.allreduce(error_local, op=MPI.SUM))\n",
        "if domain.comm.rank == 0:\n",
        "    print(f\"Error_L2: {error_L2:.2e}\")"
      ],
      "id": "ddf77474",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The $L^2$-error has the same order of magnitude as in the first tutorial, and we also compute the maximum error over all degrees of freedom"
      ],
      "id": "85c47c19"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "error_max = domain.comm.allreduce(\n",
        "  np.max(np.abs(uD.x.array -uh.x.array)), \n",
        "  op=MPI.MAX)\n",
        "if domain.comm.rank == 0:\n",
        "    print(f\"Error_max : {error_max:.2e}\")"
      ],
      "id": "a0aa4b75",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We observe that, due to the weak imposition of the boundary condition, the equation is not satisfied to machine precision at the mesh vertices. The solution is subsequently visualized using `pyvista`"
      ],
      "id": "29f60502"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pyvista\n",
        "\n",
        "u_grid = pyvista.UnstructuredGrid(*plot.vtk_mesh(V))\n",
        "u_grid.point_data[\"u\"] = uh.x.array.real\n",
        "u_grid.set_active_scalars(\"u\")\n",
        "\n",
        "u_plotter = pyvista.Plotter(off_screen=True)\n",
        "u_plotter.add_mesh(\n",
        "  u_grid, \n",
        "  show_edges=True, \n",
        "  scalar_bar_args={\n",
        "        \"title\": \"u\",\n",
        "        \"fmt\": \"%.1f\",\n",
        "        \"color\": \"black\",\n",
        "        \"label_font_size\": 12,\n",
        "        # \"vertical\": True,\n",
        "        \"n_labels\": 7,\n",
        "  },  \n",
        "  show_scalar_bar=True\n",
        ")\n",
        "\n",
        "u_plotter.add_axes()\n",
        "u_plotter.view_xy()\n",
        "\n",
        "# if not pyvista.OFF_SCREEN:\n",
        "#     u_plotter.show()\n",
        "\n",
        "# HTML 저장\n",
        "u_plotter.export_html(\n",
        "  \"fenicsx/fundamentals/poisson_nitsche_solution_2D.html\"\n",
        ")"
      ],
      "id": "d3b2624c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/fundamentals/poisson_nitsche_solution_2D.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "## Deflection of a membrane\n",
        "\n",
        "Authors: Hans Petter Langtangen, Anders Logg, Jørgen S. Dokken\n",
        "\n",
        "In the first `FEniCSx` example, we addressed a simple, easily verifiable problem.\n",
        "In this section, we consider a more physically relevant case that produces solutions with richer structure.\n",
        "In particular, we compute the deflection $D(x,y)$ of a two-dimensional circular membrane of radius $R$, under a load distribution $p(x,y)$. The governing PDE is:\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "     -T \\nabla^2D&=p \\quad\\text{in }\\; \\Omega=\\{(x,y)\\,\\vert\\, x^2+y^2\\leq R^2 \\}\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "Here, $T$ denotes the constant membrane tension, and $p$ represents the external pressure load.\n",
        "The boundary of the membrane is fixed, implying the boundary condition $D=0$.\n",
        "We model a localized load using a Gaussian function:\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "     p(x,y)&=\\frac{A}{2\\pi\\sigma}\\exp\\left(-\\frac{1}{2}\\left[\\left(\\frac{x-x_0}{\\sigma}\\right)^2 +\\left(\\frac{y-y_0}{\\sigma}\\right)^2\\right] \\right)\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "where $A$ is the load amplitude, $(x_0, y_0)$ is the location of the load maximum, and $\\sigma$ characterizes the *width* of $p$.\n",
        "We place the load center at $(x_0, y_0) = (0, R_0)$, with $0 < R_0 < R$.\n",
        "The resulting expression becomes\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "     p(x,y)&=\\frac{A}{2\\pi\\sigma}\\exp\\left(-\\frac{1}{2}\\left[\\left(\\frac{x}{\\sigma}\\right)^2\n",
        "     +\\left(\\frac{y-R_0}{\\sigma}\\right)^2\\right]\\right)\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "### Scaling the equation\n",
        "\n",
        "This problem involves several physical parameters, and it is useful to simplify the formulation by introducing dimensionless variables.\n",
        "We define the scaled coordinates $\\bar{x} = \\tfrac{x}{R}$, $\\bar{y} = \\tfrac{y}{R}$, and the dimensionless deflection $w = \\tfrac{D}{D_e}$, where $D_e$ is a characteristic deflection.\n",
        "Introducing $\\bar{R}_0 = \\tfrac{R_0}{R}$, we obtain\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "    -\\frac{\\partial^2 w}{\\partial \\bar{x}^2} -\\frac{\\partial^2 w}{\\partial \\bar{y}^2}\n",
        "    &=\\frac{R^2A}{2\\pi\\sigma TD_e} \\exp\\left(-\\frac{R^2}{2\\sigma^2}\\left[\\bar{x}^2+(\\bar{y}-\\bar{R}_0)^2\\right]\\right)\\\\\n",
        "    &=\\alpha \\exp(-\\beta^2 \\left[\\bar{x}^2+(\\bar{y}-\\bar{R}_0)^2\\right])\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "valid for $\\bar{x}^2+\\bar{y}^2<1$, where $\\alpha = \\frac{R^2A}{2\\pi\\sigma TD_e}$ and $\\beta=\\frac{R}{\\sqrt{2}\\sigma}$\n",
        "\n",
        "With an appropriate scaling, both $w$ and its derivatives are of order unity. Consequently, the left-hand side of the scaled PDE is also of order unity, while the right-hand side is governed by the parameter $\\alpha$. This motivates choosing $\\alpha$ to be of order one; in this case, we set $\\alpha = 4$.\n",
        "(Alternatively, one can derive the analytical solution in scaled coordinates and verify that the maximum deflection equals $D_e$ when $\\alpha = 4$, which provides the definition of $D_e$)\n",
        "\n",
        "With $D_e = \\tfrac{R^2 A}{8 \\pi \\sigma T}$ and omitting the overbars, the scaled problem becomes\n",
        "\n",
        "$$-\\nabla^2 w = 4 \\exp\\left(-\\beta^2 \\left[x^2 + (y-R_0)^2\\right]\\right)$$\n",
        "\n",
        "to be solved over the unit disk, with $w=0$ on the boundary\n",
        "\n",
        "In the nondimensional formulation, the problem depends only on two parameters: the dimensionless width of the pressure distribution $\\beta$ and the location of the pressure maximum $R_0 \\in [0,1]$.\n",
        "In the limit $\\beta \\to 0$, the solution converges to the special case $w = 1 - x^2 - y^2$\n",
        "\n",
        "Given a computed scaled solution $w$, the corresponding physical deflection is recovered as\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "    D=\\frac{AR^2}{8\\pi\\sigma T}w\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "### Implementation\n",
        "\n",
        "Author: Jørgen S. Dokken\n",
        "\n",
        "In this section, we will solve the membrane deflection problem.\n",
        "By the end of this section, you should be able to:\n",
        "\n",
        "* Construct a simple mesh using the `GMSH` Python API and import it into `DOLFINx`\n",
        "* Specify constant boundary conditions via a geometrical identifier\n",
        "* Employ `ufl.SpatialCoordinate` to define a spatially varying function\n",
        "* Interpolate a `ufl.Expression` into an suitable function space\n",
        "* Evaluate a `dolfinx.Function` at arbitrary points\n",
        "\n",
        "**Creating the mesh**\n",
        "\n",
        "To construct the computational geometry, we use the Python API of [GMSH](https://gmsh.info/).\n",
        "We begin by importing the gmsh module and initializing it"
      ],
      "id": "59c82b21"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# $ conda install -c conda-forge python-gmsh\n",
        "import gmsh\n",
        "\n",
        "if not gmsh.isInitialized():\n",
        "    gmsh.initialize()"
      ],
      "id": "996b12dc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we define the membrane geometry and begin the setup using the `GMSH` CAD kernel, which automatically generates the required data structures in the background.\n",
        "When calling `addDisk`, the first three arguments specify the $x,$ $y,$ and $z$ coordinates of the circle’s center, while the final two define the radii in the $x$- and $y$-directions"
      ],
      "id": "8fc1da87"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# gmsh.model.occ.addDisk(xc, yc, zc, rx, ry)\n",
        "#   xc, yc, zc : center coordinates\n",
        "#   rx, ry     : radii in x- and y-directions\n",
        "membrane = gmsh.model.occ.addDisk(0.0, 0.0, 0.0, 1, 1)\n",
        "\n",
        "# Synchronize the CAD kernel with the gmsh model\n",
        "gmsh.model.occ.synchronize()"
      ],
      "id": "dc095c57",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we define the membrane as a physical surface so that `GMSH` will recognize it during mesh generation.\n",
        "Because a surface is a two-dimensional entity, we pass `2` as the first argument, the membrane’s entity tag as the second, and the physical tag as the last.\n",
        "In a later example, we will explain in more detail when and why this physical tag becomes important"
      ],
      "id": "8f8ae323"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "gdim = 2\n",
        "physical_tag = 1\n",
        "\n",
        "# Remove any existing physical groups with the same (dim, tag)\n",
        "for dim, tag in gmsh.model.getPhysicalGroups():\n",
        "    if dim == gdim and tag == physical_tag:\n",
        "        gmsh.model.removePhysicalGroups([(dim, tag)])\n",
        "\n",
        "# Now safely add the new physical group\n",
        "pg = gmsh.model.addPhysicalGroup(gdim, [membrane], physical_tag)\n",
        "gmsh.model.setPhysicalName(gdim, pg, \"Circular Membrane\")"
      ],
      "id": "032ecd14",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Finally, we generate the two-dimensional mesh, setting a uniform element size by adjusting the `GMSH` options"
      ],
      "id": "17d830e3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "gmsh.option.setNumber(\"Mesh.CharacteristicLengthMin\", 0.05)\n",
        "gmsh.option.setNumber(\"Mesh.CharacteristicLengthMax\", 0.05)\n",
        "gmsh.model.mesh.generate(gdim)"
      ],
      "id": "8ae8b2bc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Interfacing with GMSH in DOLFINx**\n",
        "\n",
        "We import the `GMSH`-generated mesh directly into `DOLFINx` using the `dolfinx.io.gmshio` interface.\n",
        "In this example, we did not specify which process created the `GMSH` model, so a copy of the model is created on each MPI process. However, our goal is to work with a single mesh distributed across all processes. To accomplish this, we take the model generated on rank `0` of `MPI.COMM_WORLD` and distribute it to all available ranks\n",
        "\n",
        "The import also provides two sets of mesh tags: one for cells defined by physical groups and one for facets defined by physical groups. Since we did not add any physical groups of dimension `gdim -1`, the `facet_tags` object will be empty"
      ],
      "id": "cab1e3a5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from mpi4py import MPI\n",
        "from dolfinx.io import gmshio\n",
        "from dolfinx.fem.petsc import LinearProblem\n",
        "\n",
        "domain, cell_tags, facet_tags = gmshio.model_to_mesh(\n",
        "  gmsh.model, \n",
        "  MPI.COMM_WORLD, \n",
        "  rank=0, \n",
        "  gdim=gdim\n",
        ")\n",
        "\n",
        "gmsh.finalize()"
      ],
      "id": "97bbcd7e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We define the function space as in the previous tutorial"
      ],
      "id": "9b961946"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from dolfinx import fem, plot\n",
        "\n",
        "V = fem.functionspace(domain, (\"Lagrange\", 1))"
      ],
      "id": "f65fc72d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import pyvista\n",
        "\n",
        "# Extract topology from mesh and create pyvista mesh\n",
        "topology, cell_types, x = plot.vtk_mesh(V)\n",
        "grid = pyvista.UnstructuredGrid(topology, cell_types, x)\n",
        "\n",
        "plotter = pyvista.Plotter(off_screen=True)\n",
        "plotter.add_mesh(grid, show_edges=True)\n",
        "plotter.add_axes()\n",
        "plotter.view_xy()\n",
        "\n",
        "# if not pyvista.OFF_SCREEN:\n",
        "#     plotter.show()\n",
        "\n",
        "# HTML 저장\n",
        "plotter.export_html(\"fenicsx/fundamentals/membrane_mesh.html\")"
      ],
      "id": "b4d30cd2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/fundamentals/membrane_mesh.html\"\n",
        "        width=\"100%\" height=\"450px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "**Defining a spatially varying load**\n",
        "\n",
        "The pressure function on the right-hand side is defined with `ufl.SpatialCoordinate` and two constants, $\\beta$ and $R_0$"
      ],
      "id": "ee0034c7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from dolfinx import default_scalar_type\n",
        "import ufl\n",
        "\n",
        "x = ufl.SpatialCoordinate(domain)\n",
        "\n",
        "beta = fem.Constant(domain, default_scalar_type(12))\n",
        "R0 = fem.Constant(domain, default_scalar_type(0.3))\n",
        "\n",
        "p = 4 *ufl.exp(-beta**2 *(x[0]**2 +(x[1] -R0)**2))"
      ],
      "id": "1b7e7562",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Interpolation of a `ufl` expression**\n",
        "\n",
        "Since the load `p` is defined as a spatially varying function, we interpolate it into an appropriate function space for visualization. To do this, we use `dolfinx.Expression`, which accepts any `ufl` expression together with a set of points on the reference element. In practice, we provide the interpolation points of the target space. Because `p` exhibits rapid spatial variation, we select a high-order function space to represent it"
      ],
      "id": "9b27f81e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "Q = fem.functionspace(domain, (\"Lagrange\", 5))\n",
        "expr = fem.Expression(p, Q.element.interpolation_points())\n",
        "\n",
        "pressure = fem.Function(Q)\n",
        "pressure.interpolate(expr)"
      ],
      "id": "1daa80f7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We next plot the load on the domain"
      ],
      "id": "860d6e80"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "p_grid = pyvista.UnstructuredGrid(*plot.vtk_mesh(Q))\n",
        "p_grid.point_data[\"p\"] = pressure.x.array.real\n",
        "\n",
        "warped_p = p_grid.warp_by_scalar(\"p\", factor=0.5)\n",
        "warped_p.set_active_scalars(\"p\")\n",
        "\n",
        "load_plotter = pyvista.Plotter(off_screen=True)\n",
        "load_plotter.add_mesh(\n",
        "  warped_p,\n",
        "  show_edges=True, \n",
        "  show_scalar_bar=True,\n",
        "  cmap=\"jet\"\n",
        ")\n",
        "load_plotter.add_axes() \n",
        "\n",
        "# if not pyvista.OFF_SCREEN:\n",
        "#     load_plotter.show()\n",
        "\n",
        "# HTML 저장\n",
        "load_plotter.export_html(\"fenicsx/fundamentals/membrane_load.html\")"
      ],
      "id": "6535b22b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/fundamentals/membrane_load.html\"\n",
        "        width=\"100%\" height=\"500px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "**Create a Dirichlet boundary condition using geometrical conditions**\n",
        "\n",
        "The next step is to define the homogeneous boundary condition. Unlike in the first tutorial,  we use `dolfinx.fem.locate_dofs_geometrical` to identify the degrees of freedom on the boundary. Since our domain is the unit circle, these degrees of freedom correspond to coordinates $(x, y)$ such that $\\sqrt{x^2 + y^2} = 1$"
      ],
      "id": "fcd44fdc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "def on_boundary(x):\n",
        "    return np.isclose(np.sqrt(x[0]**2 +x[1]**2), 1)\n",
        "\n",
        "boundary_dofs = fem.locate_dofs_geometrical(V, on_boundary)"
      ],
      "id": "4b8c4d4a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Since our Dirichlet condition is homogeneous (`u=0` on the entire boundary), we can define it using `dolfinx.fem.dirichletbc` by specifying a constant value, the boundary degrees of freedom and the function space on which it should be applied"
      ],
      "id": "c520678f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "bc = fem.dirichletbc(default_scalar_type(0), boundary_dofs, V)"
      ],
      "id": "bcb7a6d4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Defining and solving the variational problem**\n",
        "\n",
        "The variational problem is identical to our first Poisson problem, with `p` replacing `f`"
      ],
      "id": "2237b5b7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u = ufl.TrialFunction(V)\n",
        "v = ufl.TestFunction(V)\n",
        "\n",
        "a = ufl.dot(ufl.grad(u), ufl.grad(v)) *ufl.dx\n",
        "L = p *v *ufl.dx\n",
        "\n",
        "problem = LinearProblem(\n",
        "  a, \n",
        "  L, \n",
        "  bcs=[bc], \n",
        "  petsc_options={\"ksp_type\": \"preonly\", \"pc_type\": \"lu\"}\n",
        ")\n",
        "uh = problem.solve()"
      ],
      "id": "2995d3be",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We plot the deflection `uh` over the domain $\\Omega$"
      ],
      "id": "0484c84f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Set deflection values and add it to plotter\n",
        "grid.point_data[\"u\"] = uh.x.array\n",
        "warped = grid.warp_by_scalar(\"u\", factor=25)\n",
        "\n",
        "u_plotter = pyvista.Plotter(off_screen=True)\n",
        "u_plotter.add_mesh(\n",
        "  warped, \n",
        "  show_edges=True, \n",
        "  show_scalar_bar=True, \n",
        "  scalars=\"u\",\n",
        "  cmap='jet'\n",
        ")\n",
        "u_plotter.add_axes() \n",
        "\n",
        "# if not pyvista.OFF_SCREEN:\n",
        "#     u_plotter.show()\n",
        "\n",
        "# HTML 저장\n",
        "u_plotter.export_html(\"fenicsx/fundamentals/membrane_u.html\")"
      ],
      "id": "8606d83d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/fundamentals/membrane_u.html\"\n",
        "        width=\"100%\" height=\"350px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "**Plotting along a line in the domain**\n",
        "\n",
        "A convenient way to compare the deflection and load is by plotting them along $x=0$, using a set of points along the $y$-axis to evaluate the finite element functions $u$ and $p$"
      ],
      "id": "84d98cf5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "tol = 0.001  # Avoid hitting the outside of the domain\n",
        "y = np.linspace(-1 +tol, 1 -tol, 101)\n",
        "\n",
        "points = np.zeros((3, 101))\n",
        "points[1] = y\n",
        "u_values = []\n",
        "p_values = []"
      ],
      "id": "4e9484c5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "A finite element function can be expressed as a linear combination of all its degrees of freedom:\n",
        "\n",
        "$$u_h(x) = \\sum_{i=1}^N c_i \\, \\phi_i(x)$$\n",
        "\n",
        "where $c_i$ are the coefficients of $u_h$ and $\\phi_i$ are the basis functions. In principle, this allows us to evaluate the solution at any point in $\\Omega$\n",
        "\n",
        "However, since a mesh typically contains a large number of degrees of freedom (i.e., $N$ is large), evaluating every basis function at each point would be inefficient.\n",
        "Instead, we first identify which mesh cell contains the point $x$. This can be done efficiently using a *bounding box tree*, which enables a fast recursive search through the mesh cells"
      ],
      "id": "51edec77"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from dolfinx import geometry\n",
        "\n",
        "bb_tree = geometry.bb_tree(domain, domain.topology.dim)"
      ],
      "id": "b7657108",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can now determine which cells each point intersects by using `dolfinx.geometry.compute_collisions_points`. This function returns, for every input point, a list of cells whose bounding boxes overlap with that point. Since different points may correspond to a varying number of cells, the results are stored in a `dolfinx.cpp.graph.AdjacencyList_int32`. The cells associated with the $i$-th point can be accessed with `links(i)`\n",
        "\n",
        "Because a cell’s bounding box generally extends beyond the cell itself in $\\mathbb{R}^n$, we must verify whether the point actually inside the cell. This is done with `dolfinx.geometry.compute_colliding_cells`, which computes the exact distance between the point and the cell (approximating higher-order cells as convex hulls). Like the previous function, it also  returns an adjacency list, since a point may lie on a facet, edge, or vertex shared by multiple cells\n",
        "\n",
        "Finally, to ensure that the code runs correctly in parallel when the mesh is distributed across multiple processors, we create a subset, `points_on_proc`, that includes only the points located on the current processor"
      ],
      "id": "6934e475"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "cells = []\n",
        "points_on_proc = []\n",
        "\n",
        "# Find cells whose bounding-box collide with the the points\n",
        "cell_candidates = geometry.compute_collisions_points(\n",
        "  bb_tree, \n",
        "  points.T\n",
        ")\n",
        "\n",
        "# Choose one of the cells that contains the point\n",
        "colliding_cells = geometry.compute_colliding_cells(\n",
        "  domain, \n",
        "  cell_candidates, \n",
        "  points.T\n",
        ")\n",
        "\n",
        "for i, point in enumerate(points.T):\n",
        "    if len(colliding_cells.links(i)) > 0:\n",
        "        points_on_proc.append(point)\n",
        "        cells.append(colliding_cells.links(i)[0])"
      ],
      "id": "f5361cc6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We now have a list of points associated with the processor and the cell each point belongs to. This allows us to use `uh.eval` and `pressure.eval` to compute the function values at these points"
      ],
      "id": "4a6fff93"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "points_on_proc = np.array(points_on_proc, dtype=np.float64)\n",
        "\n",
        "u_values = uh.eval(points_on_proc, cells)\n",
        "p_values = pressure.eval(points_on_proc, cells)"
      ],
      "id": "123a686d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "With the coordinates and the corresponding function values, we can now plot the results using `matplotlib`"
      ],
      "id": "2e073c6a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import matplotlib.pyplot as plt\n",
        "\n",
        "fig = plt.figure()\n",
        "\n",
        "plt.plot(points_on_proc[:, 1], 50 *u_values, \n",
        "  \"k\", lw=2, label=\"Deflection ($\\\\times 50$)\")\n",
        "plt.plot(points_on_proc[:, 1], p_values, \n",
        "  \"b--\", lw=2, label=\"Load\")\n",
        "\n",
        "plt.grid(True)\n",
        "plt.legend()\n",
        "plt.xlabel(\"y\")\n",
        "plt.show()"
      ],
      "id": "4367cbdb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Saving functions to file**\n",
        "\n",
        "To visualize the solution in [`ParaView`](https://www.paraview.org/), we can save it to a file as follows:"
      ],
      "id": "66d0f871"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from pathlib import Path\n",
        "import dolfinx.io\n",
        "\n",
        "results_folder = Path(\"fenicsx/fundamentals\")\n",
        "results_folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "filename = results_folder/\"membrane\"\n",
        "\n",
        "pressure.name = \"Load\"\n",
        "uh.name = \"Deflection\"\n",
        "\n",
        "with dolfinx.io.VTXWriter(\n",
        "  MPI.COMM_WORLD, results_folder/\"membrane_pressure.bp\", \n",
        "  [pressure], engine=\"BP4\") as vtx:\n",
        "    vtx.write(0.0)\n",
        "\n",
        "with dolfinx.io.VTXWriter(\n",
        "  MPI.COMM_WORLD, results_folder/\"membrane_deflection.bp\", \n",
        "  [uh], engine=\"BP4\") as vtx:\n",
        "    vtx.write(0.0)"
      ],
      "id": "610d1a90",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## A Gallery of finite element solvers\n",
        "\n",
        "The aim of this chapter is to demonstrate how a variety of important PDEs from science and engineering can be solved using just a few lines of `DOLFINx` code. We start with the heat equation, then proceed to the nonlinear Poisson equation, the equations of linear elasticity, and the Navier–Stokes equations. Finally, we consider systems of nonlinear advection–diffusion–reaction equations. These examples illustrate how to handle time-dependent problems, nonlinear problems, vector-valued problems, and systems of PDEs. For each case, we derive the variational formulation and implement the problem in Python in a way that closely mirrors the underlying mathematics\n",
        "\n",
        "### The heat equation\n",
        "\n",
        "Authors: Hans Petter Langtangen, Anders Logg, Jørgen S. Dokken\n",
        "\n",
        "As a first extension of the Poisson problem introduced in the previous chapter, we now turn to the time-dependent heat equation (also known as the time-dependent diffusion equation). This equation can be viewed as the natural generalization of the Poisson equation, which describes the stationary distribution of heat in a body, to the case where the distribution evolves over time. By discretizing time into small intervals and applying standard time-stepping methods, we can solve the heat equation as a sequence of variational problems, in much the same way as we solved the Poisson equation\n",
        "\n",
        "**The PDE problem**\n",
        "\n",
        "The model problem for the time-dependent PDE is given by\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "\\frac{\\partial u}{\\partial t}&=\\nabla^2 u + f && \\text{in } \\Omega \\times (0, T] \\\\\n",
        "u &= u_D && \\text{on } \\partial\\Omega \\times (0,T] \\\\\n",
        "u &= u_0 && \\text{at } t=0\n",
        "\\end{aligned}$$\n",
        "\n",
        "Here, $u$ depends on both space and time; for example, $u = u(x,y,t)$ if the spatial domain $\\Omega$ is two-dimensional. The source term $f$ and the boundary condition $u_D$ may also vary with space and time, while the initial condition $u_0$ is a function of space alone\n",
        "\n",
        "**The variational formulation**\n",
        "\n",
        "A simple approach to solving time-dependent PDEs with the finite element method is to first discretize the time derivative using a finite difference approximation. This reduces the problem to a sequence of stationary equations, each of which can then be written in variational form. We use the superscript $n$ to denote a quantity at time $t_n$, where $n$ indexes the discrete time levels. For example, $u^n$ represents the value of $u$ at time level $n$. The first step in a finite difference discretization of time is to evaluate the PDE at a chosen time level, such as $t_{n+1}$\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "    \\left(\\frac{\\partial u }{\\partial t}\\right)^{n+1}= \\nabla^2 u^{n+1}+ f^{n+1}\n",
        "\\end{aligned}$$\n",
        "\n",
        "The time derivative can be approximated by a difference quotient. For reasons of both simplicity and stability, we adopt the backward difference scheme:\n",
        "\n",
        "$$\\begin{aligned}\n",
        "\\left(\\frac{\\partial u }{\\partial t}\\right)^{n+1}\\approx \\frac{u^{n+1}-u^n}{\\Delta t}\n",
        "\\end{aligned}$$\n",
        "\n",
        "where $\\Delta t$ denotes the time-step size. Substituting this expression into the equation at time level $n +1$ gives\n",
        "\n",
        "$$\\begin{aligned}\n",
        "\\frac{u^{n+1}-u^n}{\\Delta t}= \\nabla^2 u^{n+1}+ f^{n+1}\n",
        "\\end{aligned}$$\n",
        "\n",
        "This is the time-discrete form of the heat equation, known as the backward Euler or implicit Euler scheme\n",
        "\n",
        "We rearrange the equation so that the left-hand side contains only the unknown $u^{n+1}$, while the right-hand side contains terms that are already known. This yields a sequence of stationary problems for $u^{n+1}$, given that $u^{n}$ is available from the previous time step:\n",
        "\n",
        "$$\\begin{aligned}\n",
        "u^0 &= u_0\\\\\n",
        "u^{n+1} - \\Delta t \\nabla^2 u^{n+1} &= u^{n} + \\Delta t f^{n+1}, \\quad n = 0,1,2,\\dots\n",
        "\\end{aligned}$$\n",
        "\n",
        "Starting from the initial condition $u_0$, we can then compute $u^0$, $u^1$, $u^2$, and so forth\n",
        "\n",
        "Next, we apply the finite element method. To do this, we first derive the weak formulation of the equation: we multiply by a test function $v \\in \\hat{V}$ and integrate the second-order derivatives by parts. For simplicity, we now denote $u^{n+1}$ by $u$. The resulting weak formulation can be written as\n",
        "\n",
        "$$\\begin{aligned}\n",
        "a(u,v) &= L_{n+1}(v)\n",
        "\\end{aligned}$$\n",
        "\n",
        "where\n",
        "\n",
        "$$\\begin{aligned}\n",
        "a(u,v) &= \\int_{\\Omega} \\big( u v + \\Delta t \\nabla u \\cdot \\nabla v \\big)\\,\\mathrm{d}x \\\\\n",
        "L_{n+1}(v) &= \\int_{\\Omega} \\big(u^n + \\Delta t f^{n+1}\\big)\\, v \\,\\mathrm{d}x\n",
        "\\end{aligned}$$\n",
        "\n",
        "**Projection or interpolation of the initial condition**\n",
        "\n",
        "In addition to the variational problem solved at each time step, we also need to approximate the initial condition. This can likewise be expressed as a variational problem:\n",
        "\n",
        "$$\\begin{aligned}\n",
        "a_0(u,v) &= L_0(v)\n",
        "\\end{aligned}$$\n",
        "\n",
        "with\n",
        "\n",
        "$$\\begin{aligned}\n",
        "a_0(u,v) &= \\int_{\\Omega} u v \\,\\mathrm{d}x\\\\\n",
        "L_0(v) &= \\int_{\\Omega} u_0 v \\,\\mathrm{d}x\n",
        "\\end{aligned}$$\n",
        "\n",
        "Solving this variational problem gives $u^0$, which is the $L^2$ projection of the prescribed initial condition $u_0$ onto the finite element space\n",
        "\n",
        "An alternative way to construct $u^0$ is by directly interpolating the initial value $u_0$. We discussed the use of interpolation in `DOLFINx` in the membrane deflection\n",
        "\n",
        "In `DOLFINx`, the initial condition can be obtained either by projection or by interpolation. The most common approach is projection, which provides an approximation of $u_0$. However, in applications where we want to verify the implementation against exact solutions, interpolation must be used. In this chapter, we will consider such a case\n",
        "\n",
        "#### Diffusion of a Gaussian function\n",
        "\n",
        "Author: Jørgen S. Dokken\n",
        "\n",
        "Let us now consider a more interesting problem: the diffusion of a Gaussian hill. We take the initial condition to be\n",
        "\n",
        "$$\\begin{aligned}\n",
        "u_0(x,y) &= e^{-a (x^2 +y^2)}\n",
        "\\end{aligned}$$\n",
        "\n",
        "with $a = 5$ on the domain $[-2,2]\\times[-2,2]$. For this problem, we impose homogeneous Dirichlet boundary conditions ($u_D = 0$)\n",
        "\n",
        "The first difference from the previous problem is that the domain is no longer the unit square. We create the rectangular domain using `dolfinx.mesh.create_rectangle`"
      ],
      "id": "672b5b01"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import matplotlib as mpl\n",
        "\n",
        "from mpi4py import MPI\n",
        "from petsc4py import PETSc\n",
        "import pyvista\n",
        "\n",
        "from dolfinx import fem, mesh, io, plot\n",
        "from dolfinx.fem.petsc import (\n",
        "  assemble_vector, assemble_matrix,\n",
        "  create_vector, apply_lifting, set_bc\n",
        ")\n",
        "import ufl\n",
        "\n",
        "# Define temporal parameters\n",
        "t = 0.0            # Start time\n",
        "T = 1.0            # Final time\n",
        "num_steps = 50\n",
        "dt = T /num_steps  # time step size\n",
        "\n",
        "# Define mesh\n",
        "nx, ny = 50, 50\n",
        "domain = mesh.create_rectangle(\n",
        "  MPI.COMM_WORLD, \n",
        "  [np.array([-2, -2]), np.array([2, 2])],\n",
        "  [nx, ny], \n",
        "  mesh.CellType.triangle\n",
        ")\n",
        "\n",
        "V = fem.functionspace(domain, (\"Lagrange\", 1))"
      ],
      "id": "7b5d4221",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "results_folder = Path(\"fenicsx/heat\")\n",
        "results_folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "tdim = domain.topology.dim\n",
        "grid = pyvista.UnstructuredGrid(*plot.vtk_mesh(domain, tdim))\n",
        "\n",
        "plotter = pyvista.Plotter(off_screen=True)\n",
        "plotter.add_mesh(grid, show_edges=True)\n",
        "plotter.add_axes()\n",
        "plotter.view_xy()\n",
        "\n",
        "# if not pyvista.OFF_SCREEN:\n",
        "#     plotter.show()\n",
        "\n",
        "# HTML 저장\n",
        "plotter.export_html(results_folder/\"heat_mesh.html\")"
      ],
      "id": "be230560",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/heat/heat_mesh.html\"\n",
        "        width=\"100%\" height=\"350px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "Note that we have used a much higher resolution than before to better capture the features of the solution.\n",
        "We can also easily update the initial and boundary conditions. Instead of defining the initial condition using a class, we simply use a function"
      ],
      "id": "0a52b5bc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Create initial condition\n",
        "def initial_condition(x, a=5):\n",
        "    return np.exp(-a *(x[0]**2 +x[1]**2))\n",
        "\n",
        "u_n = fem.Function(V)\n",
        "u_n.name = \"u_n\"\n",
        "u_n.interpolate(initial_condition)\n",
        "\n",
        "# Create boundary condition\n",
        "fdim = tdim -1\n",
        "\n",
        "# Select all boundary facets\n",
        "boundary_facets = mesh.locate_entities_boundary(\n",
        "  domain, \n",
        "  fdim, \n",
        "  lambda x: np.full(x.shape[1], True, dtype=bool)\n",
        ")\n",
        "\n",
        "# Extract boundary DOFs\n",
        "boundary_dofs = fem.locate_dofs_topological(\n",
        "  V, \n",
        "  fdim, \n",
        "  boundary_facets\n",
        ")\n",
        "\n",
        "# Define boundary condition (u = 0 on the entire boundary)\n",
        "# For scalar constants, \n",
        "#   also pass V to specify the function space\n",
        "bc = fem.dirichletbc(\n",
        "  PETSc.ScalarType(0), \n",
        "  boundary_dofs, \n",
        "  V\n",
        ")"
      ],
      "id": "789fbe54",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Variational formulation**\n",
        "\n",
        "As in the previous example, we set up the necessary objects for the time-dependent problem so that we do not need to recreate the data structures"
      ],
      "id": "4c0b60d4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u = ufl.TrialFunction(V)\n",
        "v = ufl.TestFunction(V)\n",
        "\n",
        "f = fem.Constant(domain, PETSc.ScalarType(0))\n",
        "\n",
        "a = (u *v +dt *ufl.dot(ufl.grad(u), ufl.grad(v))) *ufl.dx\n",
        "L = (u_n +dt *f) *v *ufl.dx"
      ],
      "id": "0b1963d2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Preparing linear algebra structures for time dependent problems**\n",
        "\n",
        "Even though `u_n` depends on time, we use the same function for both `f` and `u_n` at each time step. We then call `dolfinx.fem.form` to create the assembly kernels for the matrix and vector"
      ],
      "id": "1031798c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "bilinear_form = fem.form(a)\n",
        "linear_form = fem.form(L)"
      ],
      "id": "5dc1dd5e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The left-hand side of the system, the matrix `A`, does not change between time steps, so it only needs to be assembled once. The right-hand side, however, depends on the previous solution `u_n` and must be assembled at every time step. For this reason, we create the vector `b` from `L` and reuse it at each step"
      ],
      "id": "12889d40"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "A = assemble_matrix(bilinear_form, bcs=[bc])\n",
        "A.assemble()\n",
        "b = create_vector(linear_form)"
      ],
      "id": "837372d7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Using `petsc4py` to create a linear solver**\n",
        "\n",
        "Since we have already assembled `a` into the matrix `A`, we cannot use the `dolfinx.fem.petsc.LinearProblem` class. Instead, we create a  `PETSc` linear solver, assign the matrix `A` to it, and select a solution strategy"
      ],
      "id": "664f2293"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "solver = PETSc.KSP().create(domain.comm)\n",
        "solver.setOperators(A)\n",
        "solver.setType(PETSc.KSP.Type.PREONLY)\n",
        "solver.getPC().setType(PETSc.PC.Type.LU)"
      ],
      "id": "1d133cee",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Saving time-dependent solutions with XDMFFile**\n",
        "\n",
        "To visualize the solution in an external program such as `Paraview`, we create an `XDMFFile`, which can store multiple solutions. The main advantage of using an XDMFFile is that the mesh only needs to be stored once, and multiple solutions can be appended to the same grid, thereby reducing the storage requirements\n",
        "\n",
        "The first argument to `XDMFFile` specifies the communicator used to store the data. Since we want a single output file regardless of the number of processors, we use the `COMM_WORLD`. The second argument is the name of the output file, and the third argument specifies the file mode, which can be read (`\"r\"`), write (`\"w\"`) or append (`\"a\"`)"
      ],
      "id": "4f7bf640"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "xdmf = io.XDMFFile(\n",
        "  domain.comm, \n",
        "  results_folder/\"heat.xdmf\", \n",
        "  \"w\"\n",
        ")\n",
        "xdmf.write_mesh(domain)\n",
        "\n",
        "# Define solution variable, \n",
        "#  and interpolate initial solution for visualization\n",
        "uh = fem.Function(V)\n",
        "uh.name = \"uh\"\n",
        "uh.interpolate(initial_condition)\n",
        "\n",
        "xdmf.write_function(uh, t)"
      ],
      "id": "03624ac4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Visualizing time-dependent solutions with PyVista**\n",
        "\n",
        "We use the `DOLFINx` plotting tools, based on `PyVista`, to plot the solution at every time step. We also display a colorbar showing the initial maximum values of `u`. For this, we use the convenience function `renderer`:"
      ],
      "id": "2733eff6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from functools import partial\n",
        "\n",
        "viridis = mpl.colormaps.get_cmap(\"viridis\").resampled(25)\n",
        "sargs = dict(\n",
        "  title_font_size=25, \n",
        "  label_font_size=20, \n",
        "  fmt=\"%.2f\", \n",
        "  color=\"black\",\n",
        "  position_x=0.1, \n",
        "  position_y=0.8, \n",
        "  width=0.8, \n",
        "  height=0.1\n",
        ")\n",
        "\n",
        "plotter = pyvista.Plotter()\n",
        "# conda install -c conda-forge imageio\n",
        "plotter.open_gif(results_folder/\"heat_animation.gif\", fps=10) \n",
        "\n",
        "renderer = partial(\n",
        "  plotter.add_mesh,\n",
        "  show_edges=True, \n",
        "  lighting=False,\n",
        "  cmap=viridis, \n",
        "  scalar_bar_args=sargs,\n",
        "  clim=[0, max(uh.x.array)]\n",
        ")"
      ],
      "id": "5a4f627a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "grid.point_data[\"uh\"] = uh.x.array\n",
        "warped = grid.warp_by_scalar(\"uh\", factor=3)\n",
        "\n",
        "renderer(warped);"
      ],
      "id": "755608ae",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Updating the right hand side and solution per time step**\n",
        "\n",
        "To solve the variational problem at each time step, we must assemble the right-hand side and apply the boundary conditions before calling `solver.solve(b, uh.x.petsc_vec)`. We begin by resetting the values in `b`, since the vector is reused at every step. Next, we assemble the vector with `dolfinx.fem.petsc.assemble_vector(b, L)`, which inserts the linear form `L(v)` into `b`\n",
        "\n",
        "Note that boundary conditions are not supplied during this assembly, unlike for the left-hand side. Instead, we apply them later using lifting, which preserves the symmetry of the matrix in the bilinear form without Dirichlet conditions. After applying the boundary conditions, we solve the linear system and update any values that may be shared across processors. Finally, before advancing to the next step, we update the previous solution with the current one"
      ],
      "id": "aa9751ea"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "for i in range(num_steps):\n",
        "    t += dt\n",
        "\n",
        "    # Update the right hand side reusing the initial vector\n",
        "    with b.localForm() as loc_b:\n",
        "        loc_b.set(0)\n",
        "    assemble_vector(b, linear_form)\n",
        "\n",
        "    # Apply Dirichlet boundary condition to the vector\n",
        "    apply_lifting(b, [bilinear_form], [[bc]])\n",
        "    b.ghostUpdate(\n",
        "      addv=PETSc.InsertMode.ADD_VALUES, \n",
        "      mode=PETSc.ScatterMode.REVERSE\n",
        "    )\n",
        "    set_bc(b, [bc])\n",
        "\n",
        "    # Solve linear problem\n",
        "    solver.solve(b, uh.x.petsc_vec)\n",
        "    uh.x.scatter_forward()\n",
        "\n",
        "    # Update solution at previous time step (u_n)\n",
        "    u_n.x.array[:] = uh.x.array\n",
        "\n",
        "    # Write solution to file\n",
        "    xdmf.write_function(uh, t)\n",
        "\n",
        "    # Update plot\n",
        "    new_warped = grid.warp_by_scalar(\"uh\", factor=3)\n",
        "    warped.points[:, :] = new_warped.points\n",
        "    warped.point_data[\"uh\"][:] = uh.x.array\n",
        "    \n",
        "    renderer(warped)\n",
        "    plotter.write_frame()\n",
        "\n",
        "plotter.close()\n",
        "xdmf.close()"
      ],
      "id": "deae39ec",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![](fenicsx/heat/heat_animation.gif)\n",
        "\n",
        "#### A known analytical solution\n",
        "\n",
        "Author: Jørgen S. Dokken\n",
        "\n",
        "Just as in the Poisson problem, we construct a test case that makes it straightforward to verify the correctness of the computations\n",
        "\n",
        "Since our first-order time-stepping scheme is exact for linear functions in time, we design a problem with linear temporal variation combined with  quadratic spatial variation. Accordingly, we choose the analytical solution \n",
        "\n",
        "$$\\begin{aligned}\n",
        "u = 1 + x^2+\\alpha y^2 + \\beta t\n",
        "\\end{aligned}$$\n",
        "\n",
        "which ensures that the computed values at the degrees of freedom are exact, regardless of the mesh size or time step $\\Delta t$, provided that the mesh is uniformly partitioned\n",
        "\n",
        "Substituting this expression into the original PDE yields the right hand side $f = \\beta -2 -2\\alpha$. The corresponding boundary condition is $u_D(x,y,t)= 1 +x^2 +\\alpha y^2 +\\beta t$ and the initial condition is $u_0(x,y)=1+x^2+\\alpha y^2$\n",
        "\n",
        "We start by defining the temporal discretization parameters, along with the parameters for $\\alpha$ and $\\beta$"
      ],
      "id": "6d754114"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from mpi4py import MPI\n",
        "from petsc4py import PETSc\n",
        "\n",
        "from dolfinx import mesh, fem\n",
        "from dolfinx.fem.petsc import (\n",
        "  assemble_matrix, assemble_vector, \n",
        "  apply_lifting, create_vector, set_bc\n",
        ")\n",
        "\n",
        "import ufl\n",
        "\n",
        "t = 0  # Start time\n",
        "T = 2  # End time\n",
        "\n",
        "num_steps = 20          # Number of time steps\n",
        "dt = (T -t) /num_steps  # Time step size\n",
        "\n",
        "alpha = 3\n",
        "beta = 1.2"
      ],
      "id": "05887612",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "As in the previous problem, we define the mesh and the appropriate function spaces"
      ],
      "id": "09617517"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "nx, ny = 5, 5\n",
        "domain = mesh.create_unit_square(\n",
        "  MPI.COMM_WORLD, \n",
        "  nx, ny, \n",
        "  mesh.CellType.triangle\n",
        ")\n",
        "\n",
        "V = fem.functionspace(domain, (\"Lagrange\", 1))"
      ],
      "id": "853846a7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Defining the exact solution**\n",
        "\n",
        "We implement a Python class to represent the exact solution"
      ],
      "id": "3f726ea5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class exact_solution():\n",
        "    def __init__(self, alpha, beta, t):\n",
        "        self.alpha = alpha\n",
        "        self.beta = beta\n",
        "        self.t = t\n",
        "\n",
        "    def __call__(self, x):\n",
        "        return 1 +x[0]**2 +self.alpha *x[1]**2 +self.beta *self.t\n",
        "\n",
        "u_exact = exact_solution(alpha, beta, t)"
      ],
      "id": "88dfdbc0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Defining the boundary condition**\n",
        "\n",
        "As in the previous sections, we define a Dirichlet boundary condition over the whole boundary"
      ],
      "id": "9fad76d2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u_D = fem.Function(V)\n",
        "u_D.interpolate(u_exact)\n",
        "\n",
        "tdim = domain.topology.dim\n",
        "fdim = tdim -1\n",
        "\n",
        "domain.topology.create_connectivity(fdim, tdim)\n",
        "boundary_facets = mesh.exterior_facet_indices(domain.topology)\n",
        "\n",
        "bc = fem.dirichletbc(\n",
        "  u_D, \n",
        "  fem.locate_dofs_topological(V, fdim, boundary_facets)\n",
        ")"
      ],
      "id": "9a312e84",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![FEniCSx mesh connectivity](figures/fenicsx_mesh_conectivity.png){width=70%}\n",
        "\n",
        "**Defining the variational formualation**\n",
        "\n",
        "Since we set $t=0$ in `u_exact`, we can reuse this variable to obtain $u_n$ for the first time step"
      ],
      "id": "7054b7b9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u_n = fem.Function(V)\n",
        "u_n.interpolate(u_exact)"
      ],
      "id": "af756cc3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Because $f$ is time-independent, we can treat it as a constant"
      ],
      "id": "7b2053d4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f = fem.Constant(domain, beta -2 -2 *alpha)"
      ],
      "id": "ea429b97",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can now create our variational formulation, with the bilinear form `a` and  linear form `L`"
      ],
      "id": "c779326d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u = ufl.TrialFunction(V)\n",
        "v = ufl.TestFunction(V)\n",
        "\n",
        "F = u *v *ufl.dx +dt *ufl.dot(ufl.grad(u), ufl.grad(v)) *ufl.dx -(u_n +dt *f) *v *ufl.dx\n",
        "\n",
        "a = fem.form(ufl.lhs(F))\n",
        "L = fem.form(ufl.rhs(F))"
      ],
      "id": "d5d03c62",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Create the matrix and vector for the linear problem**\n",
        "\n",
        "To ensure that the variational problem is solved efficiently, we construct  several structures that allow data reuse, such as matrix sparisty patterns. In particular, since the bilinear form `a` is independent of time, the matrix only needs to be assembled once"
      ],
      "id": "7034784d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "A = assemble_matrix(a, bcs=[bc])\n",
        "A.assemble()\n",
        "b = create_vector(L)\n",
        "\n",
        "uh = fem.Function(V)"
      ],
      "id": "cab61bb4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Define a linear variational solver**\n",
        "\n",
        "The resulting linear algebra problem is solved with [PETSc](https://www.mcs.anl.gov/petsc/), using the Python API `petsc4py` to define a linear solver"
      ],
      "id": "cc694410"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "solver = PETSc.KSP().create(domain.comm)\n",
        "solver.setOperators(A)\n",
        "solver.setType(PETSc.KSP.Type.PREONLY)\n",
        "solver.getPC().setType(PETSc.PC.Type.LU)"
      ],
      "id": "77ac1e5f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Solving the time-dependent problem**\n",
        "\n",
        "With these structures in place, we construct our time-stepping loop.\n",
        "Within this loop, we first update the Dirichlet boundary condition by interpolating the updated expression `u_exact` into `V`.\n",
        "Next, we reassemble the vector `b` using the current solution `u_n`.\n",
        "The boundary condition is then applied to this vector via a lifting operation, which preserves the symmetry of the matrix.\n",
        "Finally, we solve the problem using `PETSc` and update `u_n` with the values from `uh`"
      ],
      "id": "2d3f8688"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "for n in range(num_steps):\n",
        "\n",
        "    # Update Diriclet boundary condition\n",
        "    u_exact.t += dt\n",
        "    u_D.interpolate(u_exact)\n",
        "\n",
        "    # Update the right hand side reusing the initial vector\n",
        "    with b.localForm() as loc_b:\n",
        "        loc_b.set(0)\n",
        "    assemble_vector(b, L)\n",
        "\n",
        "    # Apply Dirichlet boundary condition to the vector\n",
        "    apply_lifting(b, [a], [[bc]])\n",
        "    b.ghostUpdate(\n",
        "      addv=PETSc.InsertMode.ADD_VALUES, \n",
        "      mode=PETSc.ScatterMode.REVERSE\n",
        "    )\n",
        "    set_bc(b, [bc])\n",
        "\n",
        "    # Solve linear problem\n",
        "    solver.solve(b, uh.x.petsc_vec)\n",
        "    uh.x.scatter_forward()\n",
        "\n",
        "    # Update solution at previous time step (u_n)\n",
        "    u_n.x.array[:] = uh.x.array"
      ],
      "id": "83df7806",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Verifying the numerical solution**\n",
        "\n",
        "we compute the $L^2$-error and the maximum error at the mesh vertices for the final time step. This allows us to verify the correctness of our implementation"
      ],
      "id": "8e69de33"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Compute L2 error and error at nodes\n",
        "V_ex = fem.functionspace(domain, (\"Lagrange\", 2))\n",
        "u_ex = fem.Function(V_ex)\n",
        "u_ex.interpolate(u_exact)\n",
        "\n",
        "error_L2 = np.sqrt(\n",
        "  domain.comm.allreduce(\n",
        "    fem.assemble_scalar(fem.form((uh -u_ex)**2 *ufl.dx)), \n",
        "      op=MPI.SUM)\n",
        ")\n",
        "if domain.comm.rank == 0:\n",
        "    print(f\"Error_L2: {error_L2:.2e}\")\n",
        "\n",
        "# Compute values at mesh vertices\n",
        "error_max = domain.comm.allreduce(\n",
        "  np.max(np.abs(uh.x.array -u_D.x.array)), op=MPI.MAX\n",
        ")\n",
        "if domain.comm.rank == 0:\n",
        "    print(f\"Error_max: {error_max:.2e}\")"
      ],
      "id": "0c5e7917",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Singular Poisson problem\n",
        "\n",
        "Author: Jørgen S. Dokken\n",
        "\n",
        "In this example, we solve the singular Poisson problem by incorporating information about the nullspace of the discretized system into the matrix formulation\n",
        "\n",
        "The problem is defined as\n",
        "\n",
        "$$\\begin{aligned}\n",
        "   -\\Delta u &= f &&\\text{in } \\Omega\\\\\n",
        "   -\\nabla u \\cdot \\mathbf{n} &= g &&\\text{on } \\partial\\Omega\n",
        "\\end{aligned}$$\n",
        "\n",
        "This problem possesses a nullspace: if $\\tilde u$ is a solution, then for any constant $c$, $u_c = \\tilde u + c$ is also a solution\n",
        "\n",
        "To investigate this problem, we consider a manufactured solution on the unit square, given by\n",
        "\n",
        "$$\\begin{aligned}\n",
        " u(x, y) &= \\sin(2\\pi x)\\\\\n",
        " f(x, y) &= -4\\pi^2\\sin(2\\pi x)\\\\\n",
        " g(x, y) &=\n",
        " \\begin{cases}\n",
        "   -2\\pi  & \\text{if } x=0,\\\\\n",
        "   \\phantom{-}2\\pi & \\text{if } x=1,\\\\\n",
        "   \\phantom{-}0 & \\text{otherwise}\n",
        " \\end{cases}\n",
        "\\end{aligned}$$\n",
        "\n",
        "Here we define a simple wrapper function to set up the variational problem for a given manufactured solution"
      ],
      "id": "78e62540"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import typing\n",
        "import numpy as np\n",
        "\n",
        "from mpi4py import MPI\n",
        "\n",
        "from dolfinx import fem, mesh\n",
        "import dolfinx.fem.petsc\n",
        "import ufl\n",
        "\n",
        "def u_ex(mod, x):\n",
        "  return mod.sin(2 *mod.pi *x[0])\n",
        "\n",
        "def setup_problem(N: int) \\\n",
        "  -> typing.Tuple[fem.FunctionSpace, fem.Form, fem.Form]:\n",
        "  \"\"\"\n",
        "  Set up bilinear and linear form of \n",
        "    the singular Poisson problem\n",
        "  Args: \n",
        "    N, number of elements in each direction of the mesh   \n",
        "  Returns:\n",
        "    The function space, the bilinear form \n",
        "      and the linear form of the problem\n",
        "  \"\"\"\n",
        "\n",
        "  domain = dolfinx.mesh.create_unit_square(\n",
        "    MPI.COMM_WORLD, \n",
        "    N, N, \n",
        "    cell_type=mesh.CellType.quadrilateral\n",
        "  )\n",
        "  V = fem.functionspace(domain, (\"Lagrange\", 1))\n",
        "    \n",
        "  u = ufl.TrialFunction(V)\n",
        "  v = ufl.TestFunction(V)\n",
        "\n",
        "  x = ufl.SpatialCoordinate(domain)\n",
        "\n",
        "  u_exact = u_ex(ufl, x)\n",
        "    \n",
        "  f = -ufl.div(ufl.grad(u_exact))\n",
        "  n = ufl.FacetNormal(domain)\n",
        "  g = -ufl.dot(ufl.grad(u_exact), n)\n",
        "\n",
        "  F = ufl.dot(ufl.grad(u), ufl.grad(v)) *ufl.dx\n",
        "  F += ufl.inner(g, v) *ufl.ds\n",
        "  F -= f *v *ufl.dx\n",
        "\n",
        "  return V, *fem.form(ufl.system(F))"
      ],
      "id": "efea0be0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Using the convenience function defined above, we can now handle the nullspace. To do this, we employ `PETSc`, attaching additional information to the assembled matrices. Here, we make use of `PETSc`’s built-in function for creating constant nullspaces"
      ],
      "id": "3798fa7c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from petsc4py import PETSc\n",
        "\n",
        "nullspace = PETSc.NullSpace().create(\n",
        "  constant=True, \n",
        "  comm=MPI.COMM_WORLD\n",
        ")"
      ],
      "id": "a48ca223",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Direct solver**\n",
        "\n",
        "We begin by solving the singular problem using a direct solver (`MUMPS`). `MUMPS` provides additional options to handle singular matrices, which we utilize here"
      ],
      "id": "2b562a35"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "petsc_options = {\n",
        "  \"ksp_error_if_not_converged\": True,\n",
        "  \"ksp_type\": \"preonly\",\n",
        "  \"pc_type\": \"lu\",\n",
        "  \"pc_factor_mat_solver_type\": \"mumps\",\n",
        "  \"ksp_monitor\": None,\n",
        "}"
      ],
      "id": "089fd2d5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we configure the KSP solver"
      ],
      "id": "dd6d2dfc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "ksp = PETSc.KSP().create(MPI.COMM_WORLD)\n",
        "ksp.setOptionsPrefix(\"singular_direct\")\n",
        "opts = PETSc.Options()\n",
        "opts.prefixPush(ksp.getOptionsPrefix())\n",
        "\n",
        "for key, value in petsc_options.items():\n",
        "  opts[key] = value\n",
        "ksp.setFromOptions()\n",
        "\n",
        "for key, value in petsc_options.items():\n",
        "  del opts[key]\n",
        "opts.prefixPop()"
      ],
      "id": "83bd9a04",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We then assemble the bilinear and linear forms and construct the matrix `A` and the right-hand side vector `b`"
      ],
      "id": "84bdee4f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "V, a, L = setup_problem(40)\n",
        "\n",
        "A = fem.petsc.assemble_matrix(a)\n",
        "A.assemble()\n",
        "b = fem.petsc.assemble_vector(L)\n",
        "b.ghostUpdate(\n",
        "  addv=PETSc.InsertMode.ADD_VALUES, \n",
        "  mode=PETSc.ScatterMode.REVERSE\n",
        ")\n",
        "ksp.setOperators(A)"
      ],
      "id": "6f8ce5ec",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We begin by verifying that this is indeed the nullspace of `A`, after which we attach it to the matrix"
      ],
      "id": "2c67509a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "assert nullspace.test(A)\n",
        "A.setNullSpace(nullspace)"
      ],
      "id": "3c905f1a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can then solve the linear system of equations"
      ],
      "id": "c232ed5f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "uh = fem.Function(V)\n",
        "ksp.solve(b, uh.x.petsc_vec)\n",
        "uh.x.scatter_forward()\n",
        "\n",
        "ksp.destroy()"
      ],
      "id": "8642ecc4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The $L^2$-error can now be evaluated against the analytical solution"
      ],
      "id": "2d4477d2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def compute_L2_error(uh: fem.Function) -> float:\n",
        "  mesh = uh.function_space.mesh\n",
        "  u_exact = u_ex(ufl, ufl.SpatialCoordinate(mesh))\n",
        "    \n",
        "  error_L2 = fem.form(\n",
        "    ufl.inner(uh -u_exact, uh -u_exact) *ufl.dx\n",
        "  )\n",
        "  error_local = fem.assemble_scalar(error_L2)\n",
        "  return np.sqrt(\n",
        "    mesh.comm.allreduce(error_local, op=MPI.SUM)\n",
        "  )\n",
        "\n",
        "print(\"Direct solver L2 error: \"\n",
        "     f\"{compute_L2_error(uh):.5e}\")    "
      ],
      "id": "6ad9afc9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We additionally confirm that the solution’s mean value coincides with that of the manufactured solution"
      ],
      "id": "8a2273e1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u_exact = u_ex(ufl, ufl.SpatialCoordinate(V.mesh))\n",
        "ex_mean = V.mesh.comm.allreduce(\n",
        "  fem.assemble_scalar(fem.form(u_exact *ufl.dx)), \n",
        "  op=MPI.SUM\n",
        ")\n",
        "approx_mean = V.mesh.comm.allreduce(\n",
        "  fem.assemble_scalar(fem.form(uh *ufl.dx)), \n",
        "  op=MPI.SUM\n",
        ")\n",
        "\n",
        "print(\"Mean value of manufactured solution: \"\n",
        "     f\"{ex_mean:.5e}\")\n",
        "print(\"Mean value of computed solution (direct solver): \"\n",
        "     f\"{approx_mean:.5e}\")\n",
        "\n",
        "assert np.isclose(ex_mean, approx_mean), \"Mean values do not match!\""
      ],
      "id": "0e4fb38b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Iterative solver**\n",
        "\n",
        "We can also solve the problem using an iterative solver, such as `GMRES` with `AMG` preconditioning. To do this, we select a new set of `PETSc` options and create a new `KSP` solver"
      ],
      "id": "e502e640"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "ksp_iterative = PETSc.KSP().create(MPI.COMM_WORLD)\n",
        "ksp_iterative.setOptionsPrefix(\"singular_iterative\")\n",
        "\n",
        "petsc_options_iterative = {\n",
        "  \"ksp_error_if_not_converged\": True,\n",
        "  \"ksp_monitor\": None,\n",
        "  \"ksp_type\": \"gmres\",\n",
        "  \"pc_type\": \"hypre\",\n",
        "  \"pc_hypre_type\": \"boomeramg\",\n",
        "  \"pc_hypre_boomeramg_max_iter\": 1,\n",
        "  \"pc_hypre_boomeramg_cycle_type\": \"v\",\n",
        "  \"ksp_rtol\": 1.0e-13,\n",
        "}\n",
        "\n",
        "opts.prefixPush(ksp_iterative.getOptionsPrefix())\n",
        "for key, value in petsc_options_iterative.items():\n",
        "  opts[key] = value\n",
        "ksp_iterative.setFromOptions()\n",
        "\n",
        "for key, value in petsc_options_iterative.items():\n",
        "  del opts[key]\n",
        "opts.prefixPop()"
      ],
      "id": "1b703ab3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Rather than defining the nullspace explicitly, we provide it as a near-nullspace to the multigrid preconditioner"
      ],
      "id": "7057a7c6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "A_iterative = fem.petsc.assemble_matrix(a)\n",
        "A_iterative.assemble()\n",
        "A_iterative.setNearNullSpace(nullspace)\n",
        "\n",
        "ksp_iterative.setOperators(A_iterative)"
      ],
      "id": "b8a42d15",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "uh_iterative = fem.Function(V)"
      ],
      "id": "64233700",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "ksp_iterative.solve(b, uh_iterative.x.petsc_vec)\n",
        "uh_iterative.x.scatter_forward()"
      ],
      "id": "2a4976b2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        " When using the iterative solver, we correct the solution by subtracting its mean value and adding the mean value of the manufactured solution before evaluating the error"
      ],
      "id": "a5da2e44"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "approx_mean = V.mesh.comm.allreduce(\n",
        "  fem.assemble_scalar(fem.form(uh_iterative *ufl.dx)), \n",
        "  op=MPI.SUM\n",
        ")\n",
        "print(\n",
        "  \"Mean value of computed solution (iterative solver):\", \n",
        "  approx_mean\n",
        ")\n",
        "\n",
        "uh_iterative.x.array[:] += ex_mean -approx_mean\n",
        "\n",
        "approx_mean = V.mesh.comm.allreduce(\n",
        "  fem.assemble_scalar(fem.form(uh_iterative *ufl.dx)), \n",
        "  op=MPI.SUM\n",
        ")\n",
        "print(\n",
        "  \"Mean value of computed solution (iterative solver) post normalization:\",\n",
        "  approx_mean\n",
        ")\n",
        "print(\"Iterative solver L2 error: \"\n",
        "     f\"{compute_L2_error(uh_iterative):.5e}\")\n",
        "\n",
        "np.testing.assert_allclose(\n",
        "  uh.x.array, \n",
        "  uh_iterative.x.array, \n",
        "  rtol=1e-10, atol=1e-12\n",
        ")"
      ],
      "id": "fc756e99",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### A nonlinear Poisson equation\n",
        "\n",
        "Authors: Anders Logg and Hans Petter Langtangen\n",
        "\n",
        "We next address the solution of nonlinear PDEs. In contrast to linear problems, nonlinear equations lead to subtle but important differences in the definition of the variational form\n",
        "\n",
        "**PDE problem**\n",
        "\n",
        "To illustrate, we consider the nonlinear Poisson equation\n",
        "\n",
        "$$\\begin{aligned}\n",
        " -\\nabla \\cdot (q(u) \\nabla u) &=f &&\\text{in } \\Omega \\\\\n",
        "  u&=u_D  &&\\text{on } \\partial \\Omega\n",
        "  \\end{aligned}$$\n",
        "\n",
        "The nonlinearity arises from the coefficient $q(u)$, which depends on the solution $u$ itself (the problem reduces to the linear case when $q(u)$ is constant)\n",
        "\n",
        "**Variational  formulation**\n",
        "\n",
        "As usual, we multiply the PDE by a test function $v \\in \\hat{V}$, integrate over the domain, and apply integration by parts to reduce the order of derivatives. The boundary terms vanish under the Dirichlet conditions. The variational formulation of our model problem then takes the form\n",
        "\n",
        "Find $u\\in V$ such that\n",
        "\n",
        "$$\\begin{aligned}\n",
        "    F(u; v)&=0 && \\forall v \\in \\hat{V}\n",
        "\\end{aligned}$$\n",
        "where\n",
        "$$\\begin{aligned}\n",
        "    F(u; v)&=\\int_{\\Omega}(q(u)\\nabla u \\cdot \\nabla v - fv)\\,\\mathrm{d}x\n",
        "\\end{aligned}$$\n",
        "and \n",
        "$$\\begin{aligned}\n",
        "    V&=\\left\\{v\\in H^1(\\Omega)\\,\\vert\\, v=u_D \\text{ on } \\partial \\Omega \\right\\}\\\\\n",
        "    \\hat{V}&=\\left\\{v\\in H^1(\\Omega)\\,\\vert\\, v=0 \\text{ on } \\partial \\Omega \\right\\}\n",
        "\\end{aligned}$$\n",
        "\n",
        "As usual, the discrete problem is obtained by restricting $V$ and $\\hat{V}$ to corresponding finite-dimensional spaces. The resulting discrete nonlinear problem can then be written as:\n",
        "\n",
        "Find $u_h \\in V_h$ such that\n",
        "\n",
        "$$F(u_h; v) = 0 \\quad \\forall v \\in \\hat{V}_h$$\n",
        "with\n",
        "$$u_h = \\sum_{j=1}^N U_j \\phi_j$$\n",
        "\n",
        "Since $F$ is nonlinear in $u$, this variational formulation leads to a system of nonlinear algebraic equations for the unknown coefficients $U_1, \\dots, U_N$\n",
        "\n",
        "**Test problem**\n",
        "\n",
        "To set up a test problem, it is necessary to prescribe the right-hand side $f$, the coefficient $q(u)$, and the boundary condition $u_D$. In earlier cases, we employed manufactured solutions that can be exactly reproduced, thereby avoiding approximation errors. For nonlinear problems this construction is more difficult, as the algebra becomes significantly more tedious. To address this, we employ the differentiation capabilities of `UFL` to derive a manufactured solution\n",
        "\n",
        "Specifically, we select $q(u) = 1 + u^2$ and define a two-dimensional manufactured solution that is linear in both $x$ and $y$"
      ],
      "id": "094aaac0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "from mpi4py import MPI\n",
        "from petsc4py import PETSc\n",
        "\n",
        "from dolfinx import mesh, fem, io, nls, log\n",
        "from dolfinx.fem.petsc import NonlinearProblem\n",
        "from dolfinx.nls.petsc import NewtonSolver\n",
        "import ufl\n",
        "\n",
        "log.set_log_level(log.LogLevel.WARNING)\n",
        "\n",
        "def q(u):\n",
        "  return 1 +u**2\n",
        "\n",
        "domain = mesh.create_unit_square(MPI.COMM_WORLD, 10, 10)\n",
        "\n",
        "x = ufl.SpatialCoordinate(domain)\n",
        "\n",
        "# manufactured solution and the source term\n",
        "u_ufl = 1 +x[0] +2 *x[1]\n",
        "f = - ufl.div(q(u_ufl) *ufl.grad(u_ufl))"
      ],
      "id": "844d506a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note that since `x` is a 2D vector, the first component (index 0) represents the $x$-coordinate, while the second component (index 1) represents the $y$-coordinate. The resulting function `f` can be directly used in variational formulations in `DOLFINx`\n",
        "\n",
        "Having defined both the source term and an exact solution, we can now construct the corresponding function space and boundary conditions. Since the exact solution is already specified, we only need to convert it into a Python function that can be evaluated for interpolation. This is accomplished using Python’s `eval` function"
      ],
      "id": "5909f304"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "V = fem.functionspace(domain, (\"Lagrange\", 1))\n",
        "def u_exact(x): return eval(str(u_ufl))"
      ],
      "id": "b96df524",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u_D = fem.Function(V)\n",
        "u_D.interpolate(u_exact)\n",
        "\n",
        "fdim = domain.topology.dim -1\n",
        "boundary_facets = mesh.locate_entities_boundary(\n",
        "  domain, \n",
        "  fdim, \n",
        "  lambda x: np.full(x.shape[1], True, dtype=bool)\n",
        ")\n",
        "bc = fem.dirichletbc(\n",
        "  u_D, \n",
        "  fem.locate_dofs_topological(V, fdim, boundary_facets)\n",
        ")"
      ],
      "id": "711c3991",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We are now ready to define the variational formulation. Since the problem is nonlinear, we replace the `TrialFunction` with a `Function`, which acts as the unknown of the problem"
      ],
      "id": "0e00e7bc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "uh = fem.Function(V)\n",
        "v = ufl.TestFunction(V)\n",
        "F = q(uh) *ufl.dot(ufl.grad(uh), ufl.grad(v)) *ufl.dx -f *v *ufl.dx"
      ],
      "id": "4798c62a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Newton's method**\n",
        "\n",
        "The next step is to define the nonlinear problem. Since the problem is nonlinear, we will use Newton’s method. Newton’s method requires routines for evaluating the residual `F` (including the enforcement of boundary conditions), as well as for computing the Jacobian matrix. `DOLFINx` provides the `NonlinearProblem` class, which implements these routines. In addition to the boundary conditions, you can specify the variational form of the Jacobian (automatically computed if not provided), along with form and JIT parameters"
      ],
      "id": "5f22fb77"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "problem = NonlinearProblem(F, uh, bcs=[bc])"
      ],
      "id": "fbe7df12",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we use the `DOLFINx` Newton solver. The convergence criteria can be adjusted by setting the absolute tolerance (`atol`), the relative tolerance (`rtol`), or the convergence criterion type (`residual` or `incremental`)"
      ],
      "id": "919273e6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "solver = NewtonSolver(MPI.COMM_WORLD, problem)\n",
        "solver.convergence_criterion = \"incremental\"\n",
        "solver.rtol = 1e-6\n",
        "solver.report = True"
      ],
      "id": "09a240a8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can adjust the linear solver used in each Newton iteration by accessing the underlying `PETSc` object"
      ],
      "id": "00373734"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "ksp = solver.krylov_solver\n",
        "\n",
        "opts = PETSc.Options()\n",
        "option_prefix = ksp.getOptionsPrefix()\n",
        "\n",
        "opts[f\"{option_prefix}ksp_type\"] = \"gmres\"\n",
        "opts[f\"{option_prefix}ksp_rtol\"] = 1.0e-8\n",
        "opts[f\"{option_prefix}pc_type\"] = \"hypre\"\n",
        "opts[f\"{option_prefix}pc_hypre_type\"] = \"boomeramg\"\n",
        "opts[f\"{option_prefix}pc_hypre_boomeramg_max_iter\"] = 1\n",
        "opts[f\"{option_prefix}pc_hypre_boomeramg_cycle_type\"] = \"v\"\n",
        "\n",
        "ksp.setFromOptions()"
      ],
      "id": "38b881b3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We are now ready to solve the nonlinear problem. After solving, we verify that the solver has converged and print the number of iterations"
      ],
      "id": "e7daddff"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "log.set_log_level(log.LogLevel.INFO)\n",
        "\n",
        "n, converged = solver.solve(uh)\n",
        "assert (converged)\n",
        "print(f\"Number of interations: {n:d}\")"
      ],
      "id": "cf04ef82",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We observe that the solver converges after $8$ iterations.\n",
        "If we view the problem in terms of finite differences on a uniform mesh, $\\mathcal{P}_1$ elements mimic standard second-order finite differences, which compute derivatives of linear or quadratic functions exactly. In this case, $\\nabla u$ is a constant vector, multiplied by $1+u^2$, resulting in a second-order polynomial in $x$ and $y$. Such terms would also be computed exactly by the finite difference operator. Therefore, even with $\\mathcal{P}_1$ elements, we can expect the manufactured solution to be reproduced by the numerical method. However, if we had chosen a different nonlinearity, such as $1+u^4$, this would no longer hold, and we would need to verify convergence rates"
      ],
      "id": "fe8fea92"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "log.set_log_level(log.LogLevel.WARNING)\n",
        "\n",
        "# Compute L2 error and error at nodes\n",
        "V_ex = fem.functionspace(domain, (\"Lagrange\", 2))\n",
        "u_ex = fem.Function(V_ex)\n",
        "u_ex.interpolate(u_exact)\n",
        "\n",
        "error_local = fem.assemble_scalar(\n",
        "  fem.form((uh -u_ex)**2 *ufl.dx)\n",
        ")\n",
        "error_L2 = np.sqrt(\n",
        "  domain.comm.allreduce(error_local, op=MPI.SUM)\n",
        ")\n",
        "if domain.comm.rank == 0:\n",
        "    print(f\"L2-error: {error_L2:.2e}\")\n",
        "\n",
        "# Compute values at mesh vertices\n",
        "error_max = domain.comm.allreduce(\n",
        "  np.max(np.abs(uh.x.array -u_D.x.array)), \n",
        "  op=MPI.MAX\n",
        ")\n",
        "if domain.comm.rank == 0:\n",
        "    print(f\"Error_max: {error_max:.2e}\")"
      ],
      "id": "f318225b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### The equations of linear elasticity\n",
        "\n",
        "Authors: Anders Logg and Hans Petter Langtangen\n",
        "\n",
        "Analysis of structures is one of the central tasks in modern engineering, which likely makes the PDE governing the deformation of elastic bodies the most widely used PDE in practice. With `DOLFINx`, the equations of 2D or 3D elasticity can be solved in just a single page of code, as demonstrated in this section\n",
        "\n",
        "**The PDE problem**\n",
        "\n",
        "The equations governing small elastic deformations of a body $\\Omega$ can be written as\n",
        "\n",
        "$$\\begin{aligned}\n",
        "    -\\nabla \\cdot \\sigma (u) &= f && \\text{in } \\Omega\\\\\n",
        "    \\sigma(u)&= \\lambda \\mathrm{tr}(\\epsilon(u))I + 2 \\mu \\epsilon(u)\\\\\n",
        "    \\epsilon(u) &= \\frac{1}{2}\\left(\\nabla u + (\\nabla u )^T\\right)\n",
        "\\end{aligned}$$\n",
        "\n",
        "where $\\sigma$ is the stress tensor, $f$ is the body force per unit volume, $\\lambda$ and $\\mu$ are Lamé’s elasticity parameters for the material in $\\Omega$, $I$ is the identity tensor, $\\mathrm{tr}$ denotes the trace operator on a tensor, $\\epsilon$ is the symmetric strain tensor (the symmetric gradient of $u$), and $u$ is the displacement vector field. Here, we assume isotropic elastic conditions\n",
        "\n",
        "Substituting $\\epsilon(u)$ into the expression for $\\sigma$, we obtain\n",
        "\n",
        "$$\\begin{aligned}\n",
        "\\sigma(u) &= \\lambda(\\nabla \\cdot u)I + \\mu\\big(\\nabla u + (\\nabla u)^T\\big)\n",
        "\\end{aligned}$$\n",
        "\n",
        "Note that the PDE above could alternatively be written as a single vector equation for $u$, known as Navier’s equation, which governs the displacement field. However, it is often more convenient to keep the present representation when deriving the variational formulation\n",
        "\n",
        "**The variational formulation**\n",
        "\n",
        "The variational formulation is obtained by taking the inner product of the elasticity PDE with a *vector-valued* test function $v\\in\\hat{V}$, where $\\hat{V}$ denotes the corresponding test function space, and integrating over the domain $\\Omega$:\n",
        "\n",
        "$$ -\\int_{\\Omega}(\\nabla \\cdot \\sigma)\\cdot v ~\\mathrm{d} x = \\int_{\\Omega} f\\cdot v \\,\\mathrm{d}x $$\n",
        "\n",
        "Since $\\nabla \\cdot \\sigma$ contains second-order derivatives of the unknown $u$, we integrate this term by parts:\n",
        "\n",
        "$$-\\int_{\\Omega} (\\nabla \\cdot \\sigma)\\cdot v \\,\\mathrm{d}x\n",
        "= \\int_{\\Omega} \\sigma : \\nabla v \\,\\mathrm{d}x\n",
        "\t-\t\\int_{\\partial \\Omega} (\\sigma \\cdot n)\\cdot v \\,\\mathrm{d}s$$\n",
        "\n",
        "where the colon operator denotes the inner product between tensors (the sum of pairwise products of all components), and $n$ is the outward unit normal to the boundary. The quantity $\\sigma \\cdot n$ is known as the traction or stress vector at the boundary, and it is often prescribed as a boundary condition. Here, we assume that the traction is prescribed on a portion $\\partial \\Omega_T$ of the boundary as $\\sigma \\cdot n = T$. On the remaining part of the boundary, we impose Dirichlet conditions on the displacement, which eliminates the corresponding boundary integral. Thus we obtain\n",
        "\n",
        "$$\\int_{\\Omega} \\sigma : \\nabla v \\,\\mathrm{d}x\n",
        "= \\int_{\\Omega} f \\cdot v \\,\\mathrm{d}x\n",
        "\t+\t\\int_{\\partial \\Omega_T} T \\cdot v \\,\\mathrm{d}s$$\n",
        "\n",
        "If we now substitute the expression for $\\sigma$ in terms of the unknown $u$, the variational formulation can be stated as:\n",
        "\n",
        "Find $u \\in V$ such that\n",
        "\n",
        "$$a(u, v) = L(v) \\qquad \\forall v \\in \\hat{V}$$\n",
        "\n",
        "where\n",
        "\n",
        "$$\\begin{aligned}\n",
        "a(u, v) &= \\int_{\\Omega} \\sigma(u) : \\nabla v \\,\\mathrm{d}x \\\\\n",
        "\\sigma(u) &= \\lambda (\\nabla \\cdot u) I + \\mu \\big(\\nabla u + (\\nabla u)^T\\big)\\\\\n",
        "L(v) &= \\int_{\\Omega} f \\cdot v \\,\\mathrm{d}x\n",
        "\t+\t\\int_{\\partial \\Omega_T} T \\cdot v \\,\\mathrm{d}s\n",
        "\\end{aligned}$$\n",
        "\n",
        "It can be shown that the inner product of a symmetric tensor $A$ and an antisymmetric tensor $B$ vanishes. Decomposing $\\nabla v$ into its symmetric and antisymmetric parts therefore implies that only the symmetric part contributes to the product $\\sigma : \\nabla v$, since $\\sigma$ is symmetric. Replacing $\\nabla v$ by the symmetric gradient $\\epsilon(v)$ leads to a slightly different, but equivalent, variational formulation:\n",
        "\n",
        "$$a(u, v) = \\int_{\\Omega} \\sigma(u) : \\epsilon(v) \\,\\mathrm{d}x$$\n",
        "\n",
        "where the symmetric gradient of $v$ is defined as\n",
        "\n",
        "$$\\epsilon(v) = \\tfrac{1}{2}\\big(\\nabla v + (\\nabla v)^T\\big)$$\n",
        "\n",
        "This formulation naturally arises from the minimization of elastic potential energy and is more commonly used than the earlier form based on $\\sigma : \\nabla v$\n",
        "\n",
        "**Scaling**\n",
        "\n",
        "It is often advantageous to scale a problem, as this reduces the need to specify physical parameters and produces dimensionless numbers that capture the relative influence of different parameters and physical effects. We first develop the code for the original dimensional model and then run the scaled problem by appropriately adjusting the parameters. For the present application, scaling reduces the number of active parameters from six to two\n",
        "\n",
        "In Navier’s equation for $u$, obtained by substituting $\\sigma(u)$ into elasticity PDE, we have:\n",
        "\n",
        "$$ -(\\lambda + \\mu)\\nabla (\\nabla \\cdot u) - \\mu \\nabla^2 u = f $$\n",
        "\n",
        "We introduce dimensionless coordinates by scaling with $L$, and define $\\bar{u} = \\frac{u}{U}$. This leads to the dimensionless governing equations:\n",
        "\n",
        "$$-\\beta\\,\\bar{\\nabla}(\\bar{\\nabla}\\cdot \\bar{u}) -\\bar{\\nabla}^2 \\bar{u} = \\bar{f}, \\quad \\bar{f} = (0,0,\\gamma)$$\n",
        "\n",
        "where $\\beta = 1 +\\frac{\\lambda}{\\mu}$ is a dimensionless elasticity parameter and\n",
        "\n",
        "$$ \\gamma = \\frac{\\rho g L^2}{\\mu U} $$\n",
        "\n",
        "is a dimensionless number representing the ratio of the applied load $\\rho g$ to the shear stress term $\\mu \\nabla^2 u \\sim \\mu \\frac{U}{L^2}$ in the PDE\n",
        "\n",
        "One option for scaling is to choose $U$ such that $\\gamma$ is of order one, i.e., $U = \\frac{\\rho g L^2}{\\mu}$. However, in elasticity, this choice leads to displacements comparable to the size of the geometry. A more practical approach is to set $U$ equal to the maximum deflection of a clamped beam, for which a formula exists:\n",
        "\n",
        "$$U = \\frac{3}{2} \\, \\rho g L^2 \\frac{\\delta^2}{E}$$\n",
        "\n",
        "where $\\delta = \\frac{L}{W}$ reflects the beam’s slenderness, and $E$ is the modulus of elasticity. The dimensionless parameter $\\delta$ is therefore very important in this problem (as expected, $\\delta \\gg 1$ is what justifies beam theory). Taking $E$ to be of the same order as $\\mu$, which is typical for many materials, we find that $\\gamma \\sim \\delta^{-2}$ is an appropriate choice. By experimenting with the code to obtain displacements that “look right” in plots of the deformed geometry, we select $\\gamma = 0.4 \\, \\delta^{-2}$ as our final value\n",
        "\n",
        "The simulation code handles the dimensional problem with parameters $\\lambda,$ $\\mu,$ $\\rho,$ $g,$ $L,$ $W$. For the scaled problem, we simply set $\\mu = \\rho = L = 1,$ $W = \\delta^{-1},$ $g = \\gamma,$ and $\\lambda = \\beta$\n",
        "\n",
        "#### Implementation\n",
        "\n",
        "Author: Jørgen S. Dokken\n",
        "\n",
        "In this section, you will learn how to:\n",
        "\n",
        "- Work with vector function spaces\n",
        "- Define constant boundary conditions on vector spaces\n",
        "- Visualize cell wise constant functions\n",
        "- Compute Von Mises stresses\n",
        "\n",
        "**Test problem**\n",
        "\n",
        "As a test case, we consider a clamped beam in 3D that deforms under its own weight.\n",
        "This is modeled by prescribing the body force per unit volume as\n",
        "$f = (0, 0, -\\rho g)$,\n",
        "where $\\rho$ is the density of the beam and $g$ is the gravitational acceleration\n",
        "\n",
        "The beam has a box shape with length $L$ and a square cross-section of width $W$.\n",
        "At the clamped end ($x = 0$), we impose the displacement condition $u = u_D = (0,0,0)$.\n",
        "The remaining boundaries are traction-free, i.e., we set $T = 0$\n",
        "\n",
        "We begin by defining the physical variables that will be used in the program"
      ],
      "id": "1bdee1ca"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from mpi4py import MPI\n",
        "import pyvista\n",
        "\n",
        "from dolfinx import mesh, fem, plot, io, default_scalar_type\n",
        "from dolfinx.fem.petsc import LinearProblem\n",
        "\n",
        "import ufl\n",
        "\n",
        "# Scaled variable\n",
        "L = 1\n",
        "W = 0.2\n",
        "\n",
        "rho = 1\n",
        "\n",
        "delta = W /L\n",
        "gamma = 0.4 *delta**2\n",
        "g = gamma\n",
        "\n",
        "mu = 1\n",
        "\n",
        "beta = 1.25\n",
        "lambda_ = beta"
      ],
      "id": "4f91b345",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We next create the mesh, which will be composed of hexahedral elements, together with the assoicated function space.\n",
        "Since we require a vector element with three components, we add `(3, )` or (or more generally `(domain.geometry.dim, )`) to the element tuple to obtain a triplet"
      ],
      "id": "f810015a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "domain = mesh.create_box(\n",
        "  MPI.COMM_WORLD, \n",
        "  [np.array([0, 0, 0]), np.array([L, W, W])],\n",
        "  [20, 6, 6], \n",
        "  cell_type=mesh.CellType.hexahedron\n",
        ")\n",
        "V = fem.functionspace(domain, (\"Lagrange\", 1, (domain.geometry.dim, )))"
      ],
      "id": "73c93a93",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Alternatively, we can take advantage of `basix.ufl` to construct the vector element directly:"
      ],
      "id": "683bfc3d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "#| eval: false\n",
        "import basix\n",
        "\n",
        "element = basix.ufl.element(\n",
        "  \"Lagrange\", \n",
        "  domain.topology.cell_name(), \n",
        "  1,\n",
        "  shape=(domain.geometry.dim,)\n",
        ")\n",
        "V = fem.functionspace(domain, element)"
      ],
      "id": "74ebbaf6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Boundary conditions**\n",
        "\n",
        "Since we want to clamp the boundary at $x = 0$, we achieve this by using a marker function, which identifies the facets where $x$ is (within machine precision) close to zero"
      ],
      "id": "e4a6098a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def clamped_boundary(x):\n",
        "  return np.isclose(x[0], 0)\n",
        "\n",
        "fdim = domain.topology.dim -1\n",
        "boundary_facets = mesh.locate_entities_boundary(\n",
        "  domain, \n",
        "  fdim, \n",
        "  clamped_boundary\n",
        ")\n",
        "\n",
        "u_D = np.array([0, 0, 0], dtype=default_scalar_type)\n",
        "bc = fem.dirichletbc(\n",
        "  u_D, \n",
        "  fem.locate_dofs_topological(V, fdim, boundary_facets), \n",
        "  V\n",
        ")"
      ],
      "id": "1ad4fad5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Since the traction $T$ should vanish on the remaining boundary, we introduce a `dolfinx.Constant`"
      ],
      "id": "ae5ac790"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "T = fem.Constant(domain, default_scalar_type((0, 0, 0)))"
      ],
      "id": "eb9090df",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We specify the integration measure $\\mathrm{d}s$, corresponding to integration over the domain boundary, using `ufl`’s built-in measures"
      ],
      "id": "93592fb7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "ds = ufl.Measure(\"ds\", domain=domain)"
      ],
      "id": "b0d605b9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Variational formulation**\n",
        "\n",
        "We are now ready to formulate the variational problem in a syntax that closely resembles the mathematical notation, as in the previous examples"
      ],
      "id": "5714847b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def epsilon(u):\n",
        "  # Equivalent to 0.5 *(ufl.nabla_grad(u) +ufl.nabla_grad(u).T)  \n",
        "  return ufl.sym(ufl.grad(u))  \n",
        "\n",
        "def sigma(u):\n",
        "  return (lambda_ *ufl.nabla_div(u) *ufl.Identity(len(u)) \n",
        "    +2 *mu *epsilon(u))\n",
        "\n",
        "u = ufl.TrialFunction(V)\n",
        "v = ufl.TestFunction(V)\n",
        "\n",
        "f = fem.Constant(domain, default_scalar_type((0, 0, -rho * g)))\n",
        "a = ufl.inner(sigma(u), epsilon(v)) *ufl.dx\n",
        "L = ufl.dot(f, v) *ufl.dx +ufl.dot(T, v) *ds"
      ],
      "id": "3976117b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: callout-note\n",
        "In DOLFINx, `grad(u)` uses the $\\partial u_i / \\partial x_j$ convention, but since continuum mechanics often prefers the opposite, `ufl` offers `nabla_grad` to support that usage\n",
        ":::\n",
        "\n",
        "**Solve the linear variational problem**\n",
        "\n",
        "As in the previous examples, we assemble the system matrix and right-hand side vector, and solve the variational problem using `PETSc`"
      ],
      "id": "b117dc68"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "problem = LinearProblem(\n",
        "  a, \n",
        "  L, \n",
        "  bcs=[bc], \n",
        "  petsc_options={\"ksp_type\": \"preonly\", \"pc_type\": \"lu\"}\n",
        ")\n",
        "uh = problem.solve()"
      ],
      "id": "cc3944d9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Visualization**\n",
        "\n",
        "As in earlier demos, visualization can be done with `PyVista` or `ParaView`. We first use `PyVista`, adding vectors to the grid rather than scalars"
      ],
      "id": "408c88a9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "results_folder = Path(\"fenicsx/linear_elasticity\")\n",
        "results_folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "# Create plotter and pyvista grid\n",
        "p = pyvista.Plotter(off_screen=True)\n",
        "topology, cell_types, geometry = plot.vtk_mesh(V)\n",
        "grid = pyvista.UnstructuredGrid(topology, cell_types, geometry)\n",
        "\n",
        "# Attach vector values to grid and warp grid by vector\n",
        "grid[\"u\"] = uh.x.array.reshape((geometry.shape[0], 3))\n",
        "actor_0 = p.add_mesh(grid, style=\"wireframe\", color=\"k\")\n",
        "\n",
        "warped = grid.warp_by_vector(\"u\", factor=1.5)\n",
        "actor_1 = p.add_mesh(warped, show_edges=True)\n",
        "\n",
        "p.show_axes()\n",
        "\n",
        "# if not pyvista.OFF_SCREEN:\n",
        "#   p.show()\n",
        "# else:\n",
        "#   p.screenshot(results_folder/\"deflection.png\")\n",
        "\n",
        "# HTML 저장\n",
        "p.export_html(results_folder/\"deflection.html\")"
      ],
      "id": "440e99a6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/linear_elasticity/deflection.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "We can also use `ParaView` for visualization.\n",
        "As explained in previous sections, the solution is saved using `XDMFFile`"
      ],
      "id": "493295f9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "with io.XDMFFile(\n",
        "  domain.comm, \n",
        "  results_folder/\"deformation.xdmf\", \n",
        "  \"w\"\n",
        ") as xdmf:\n",
        "  xdmf.write_mesh(domain)\n",
        "  uh.name = \"Deformation\"\n",
        "  xdmf.write_function(uh)"
      ],
      "id": "e9a223f1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Stress computation**\n",
        "\n",
        "Once the displacement has been computed, we can evaluate various stress measures. In particular, we compute the von Mises stress, defined as\n",
        "\n",
        "$$\\sigma_m = \\sqrt{\\tfrac{3}{2}\\, s : s}$$\n",
        "\n",
        "where $s$ is the deviatoric stress tensor, given by\n",
        "\n",
        "$$s(u) = \\sigma(u) - \\tfrac{1}{3}\\,\\mathrm{tr}(\\sigma(u))\\, I$$"
      ],
      "id": "582a7d01"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "s = sigma(uh) -1. /3 *ufl.tr(sigma(uh)) *ufl.Identity(len(uh))\n",
        "von_Mises = ufl.sqrt(3. /2 *ufl.inner(s, s))"
      ],
      "id": "42bc132a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "`von_Mises` is an expression that needs to be projected onto a suitable function space for visualization. Because `uh` consists of first-order piecewise continuous functions, the resulting von Mises stress is cell-wise constant"
      ],
      "id": "3e07e2b6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# This is suitable for representing \n",
        "#  cell-wise constant quantities like the von Mises stress\n",
        "# DG = Discontinuous Galerkin, 0 = cell-wise constant\n",
        "V_von_mises = fem.functionspace(domain, (\"DG\", 0))\n",
        "stress_expr = fem.Expression(\n",
        "  von_Mises, \n",
        "  V_von_mises.element.interpolation_points()\n",
        ")\n",
        "\n",
        "stresses = fem.Function(V_von_mises)\n",
        "stresses.interpolate(stress_expr)"
      ],
      "id": "a1f99d09",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Previously, we visualized only first-order Lagrange functions. Since the von Mises stress is piecewise constant per cell, we slightly adjust the plotting routine, setting values for each cell, which corresponds directly to the degrees of freedom in the function space"
      ],
      "id": "35cc547e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "warped.cell_data[\"VonMises\"] = stresses.x.petsc_vec.array\n",
        "warped.set_active_scalars(\"VonMises\")\n",
        "\n",
        "p = pyvista.Plotter(off_screen=True)\n",
        "p.add_mesh(warped)\n",
        "p.show_axes()\n",
        "\n",
        "# if not pyvista.OFF_SCREEN:\n",
        "#   p.show()\n",
        "# else:\n",
        "#   p.screenshot(results_folder/\"stresses.png\")\n",
        "\n",
        "# HTML 저장\n",
        "p.export_html(results_folder/\"stresses.html\")"
      ],
      "id": "70477b99",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/linear_elasticity/stresses.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "### The Navier-Stokes equations\n",
        "\n",
        "In this section, we address the incompressible Navier–Stokes equations, which combine time dependence, nonlinearity, and vector-valued variables—challenges seen in earlier problems\n",
        "\n",
        "**The PDE problem**\n",
        "\n",
        "The incompressible Navier–Stokes equations form a system of equations governing the velocity $u$ and pressure $p$ of an incompressible fluid:\n",
        "\n",
        "$$\\begin{aligned}\n",
        "\\rho \\left( \\frac{\\partial u }{\\partial t} + u \\cdot \\nabla u \\right) &= \\nabla \\cdot \\sigma (u, p) + f\\\\\n",
        "\\nabla \\cdot u &= 0\n",
        "\\end{aligned}\\tag{NS}\\label{eq:NS}$$ \n",
        "\n",
        "The right-hand side $f$ represents a given force per unit volume. As in the equations of linear elasticity, $\\sigma(u,p)$ denotes the stress tensor, which for a Newtonian fluid is given by:\n",
        "\n",
        "$$\\sigma(u, p) = 2 \\mu \\epsilon(u) - p I$$\n",
        "\n",
        "where $\\epsilon(u)$ is the strain-rate tensor:\n",
        "\n",
        "$$\\epsilon(u) = \\frac{1}{2}\\left(\\nabla u + (\\nabla u)^T\\right)$$\n",
        "\n",
        "The parameter $\\mu$ is the dynamic viscosity. Note that the momentum equation  is very similar to the elasticity equation . The difference lies in the two additional terms, $\\rho\\left(\\frac{\\partial u}{\\partial t} + u \\cdot \\nabla u\\right)$, and in the different form of the stress tensor. These extra terms represent the acceleration of the fluid, balanced by the force $F = \\nabla \\cdot \\sigma + f$ per unit volume according to Newton’s second law of motion\n",
        "\n",
        "**Variational formulation**\n",
        "\n",
        "The Navier–Stokes equations are more challenging than the time-dependent heat equation because they form a system of equations, rather than a single equation, and the system has a special structure\n",
        "\n",
        "If we use the same approach as for the heat equation—replacing the time derivative with a simple difference quotient—we end up with a nonlinear system. Nonlinearity itself is not a problem, as we have already seen in the nonlinear Poisson equation\n",
        "\n",
        "The main difficulty comes from the saddle point structure of the system. Intuitively, a saddle point system has competing constraints: in this case, the velocity and pressure fields are linked through the incompressibility condition $\\nabla \\cdot u = 0$. This coupling makes standard solvers inefficient or unstable. To handle this efficiently, we need specialized iterative methods and preconditioners that respect the saddle point structure\n",
        "\n",
        "Instead, we will apply a simpler and often highly efficient approach known as a *splitting method*. The idea is to treat the two equations in \\eqref{eq:NS} separately. There are many splitting strategies for the incompressible Navier-Stokes equations. One of the earliest is Chorin’s method. Here, we will use a modified version of Chorin’s method, the so-called incremental pressure correction scheme (IPCS), which provides improved accuracy compared to the original scheme at little additional cost\n",
        "\n",
        "The IPCS scheme involves three steps. First, we compute a tentative velocity $u^*$ by advancing the momentum equation using a midpoint finite difference scheme in time, but with the pressure $p^n$ from the previous time step. The nonlinear convective term is linearized by using the known velocity $u^n$ from the previous step: $u^n \\cdot \\nabla u^n$. Note that several alternative methods exist to linearize this term, such as the Adams-Bashforth method. The variational problem for the first step reads: for the $(n+1)$-th step, find $u^*$ such that\n",
        "\n",
        "$$\\begin{aligned}\n",
        "\\left\\langle \\rho \\frac{u^*-u^n}{\\Delta t}, v\\right\\rangle\n",
        "    &+ \\left\\langle \\rho u^n\\cdot \\nabla u^n, v \\right\\rangle\n",
        "    +\\left\\langle \\sigma(u^{n+\\frac{1}{2}}, p^n), \\epsilon(v)\\right\\rangle\\\\\n",
        "    &+ \\left\\langle p^n n, v \\right\\rangle_{\\partial\\Omega}\n",
        "    -\\left\\langle \\mu \\nabla u^{n+\\frac{1}{2}}\\cdot n, v \\right \\rangle_{\\partial\\Omega}=\n",
        "    \\left\\langle f^{n+1}, v \\right\\rangle\n",
        "\\end{aligned}\\tag{V1}\\label{eq:NS-v1}$$ \n",
        "\n",
        "This notation, which is particularly useful for problems involving many terms in the variational formulation, requires some explanation. First, we introduce the shorthand notation\n",
        "\n",
        "$$\\begin{aligned}\n",
        "\\langle v, w \\rangle = \\int_{\\Omega} v w \\, \\mathrm{d}x, \\quad\n",
        "\\langle v, w \\rangle_{\\partial\\Omega} = \\int_{\\partial\\Omega} v w \\, \\mathrm{d}s\n",
        "\\end{aligned}$$\n",
        "\n",
        "This allows us to express the variational problem in a more compact form. Second, we introduce the notation $u^{n+\\frac{1}{2}}$, which refers to the value of $u$ at the midpoint of the time interval. This is usually approximated by the arithmetic mean:\n",
        "\n",
        "$$u^{n+\\frac{1}{2}} \\approx \\frac{u^{n} + u^{n+1}}{2}$$\n",
        "\n",
        "Third, we note that the variational problem \\eqref{eq:NS-v1} arises from the integration by parts of the term\n",
        "$\\langle -\\nabla \\cdot \\sigma, v\\rangle$. As in the linear elasticity problem, this yields\n",
        "\n",
        "$$\\langle -\\nabla \\cdot \\sigma, v\\rangle =\n",
        "    \\langle \\sigma, \\epsilon(v) \\rangle \n",
        "    - \\langle T, v\\rangle_{\\partial \\Omega}$$\n",
        "\n",
        "where $T = \\sigma \\cdot n$ denotes the boundary traction. If we solve a problem with a free boundary, we may set $T=0$ on the boundary. However, in the case of flow through a channel or pipe, where we wish to model the continuation of the flow into an “imaginary channel” at the outflow, this term requires more careful treatment.\n",
        "In such situations, a common assumption is that the derivative of the velocity in the streamwise direction vanishes at the outflow. This corresponds to the flow being fully developed, meaning it does not change significantly downstream. Under this assumption, the remaining boundary term at the outflow becomes\n",
        "\n",
        "$$pn - \\mu \\nabla u \\cdot n$$\n",
        "\n",
        "which is precisely the term appearing in the variational problem \\eqref{eq:NS-v1} \n",
        "\n",
        "It is important to note that both this argument and its implementation depend on the exact definition of $\\nabla u$: whether it is taken as the matrix with components $\\frac{\\partial u_i}{\\partial x_j}$ or with components $\\frac{\\partial u_j}{\\partial x_i}$. In this work, we adopt the latter convention, $\\frac{\\partial u_j}{\\partial x_i}$, which corresponds to using the `UFL` operator `nabla_grad`. If, instead, we use the operator `grad` (with the definition $\\frac{\\partial u_i}{\\partial x_j}$), then the boundary term must be written as\n",
        "\n",
        "$$pn - \\mu (\\nabla u)^T \\cdot n$$\n",
        "\n",
        "::: callout-note\n",
        "As noted in Linear elasticity implementation, the use of `nabla_grad` and `grad` must be interpreted with care. For the Navier–Stokes equations, it is particularly important to consider the convective term $u \\cdot \\nabla u$, which should be understood as the vector $w$ with components\n",
        "\n",
        "$$w_i = \\sum_{j} \\left(u_j \\frac{\\partial}{\\partial x_j}\\right) u_i = \\sum_j u_j \\frac{\\partial u_i}{\\partial x_j}$$\n",
        "\n",
        "In `FEniCSx`, this term can be implemented either as\n",
        "`grad(u) *u`, which corresponds to $\\sum_j \\frac{\\partial u_i}{\\partial x_j} u_j$,\n",
        "or as `dot(u, nabla_grad(u))`, which corresponds to $\\sum_i u_i \\frac{\\partial u_j}{\\partial x_i}$\n",
        "\n",
        "In what follows, we adopt the notation `dot(u, nabla_grad(u))`, since it most closely matches the standard mathematical form $u \\cdot \\nabla u$\n",
        ":::\n",
        "\n",
        "We now proceed to the second step of our splitting scheme for the incompressible Navier–Stokes equations. In the first step, we computed the tentative velocity $u^*$ using the pressure from the previous time step. We now use this tentative velocity to compute the updated pressure $p^{n+1}$:\n",
        "\n",
        "$$\\langle \\nabla p^{n+1}, \\nabla q \\rangle\n",
        "    = \\langle \\nabla p^n, \\nabla q \\rangle\n",
        "    - \\frac{\\rho}{\\Delta t} \\langle \\nabla \\cdot u^*, q \\rangle\n",
        "    \\tag{V2}\\label{eq:NS-v2}$$\n",
        "\n",
        "Here, $q$ denotes a scalar-valued test function from the pressure space, whereas the test function $v$ in \\eqref{eq:NS-v1} is vector-valued and belongs to the velocity space\n",
        "\n",
        "One way to interpret this step is as follows: subtract the Navier–Stokes momentum equation \\eqref{eq:NS} expressed in terms of the tentative velocity $u^*$ and the pressure $p^n$ from the same equation expressed in terms of the updated velocity $u^{n+1}$ and pressure $p^{n+1}$. This yields\n",
        "\n",
        "$$\\frac{\\rho (u^{n+1}-u^*)}{\\Delta t} + \\nabla p^{n+1} - \\nabla p^n = 0$$\n",
        "\n",
        "Taking the divergence and imposing the incompressibility condition $\\nabla \\cdot u^{n+1} = 0$ from the Navier–Stokes continuity equation, we obtain\n",
        "\n",
        "$$\n",
        " - \\frac{\\rho \\nabla \\cdot u^*}{\\Delta t} + \\nabla^2 p^{n+1} - \\nabla^2 p^n = 0\n",
        " \\tag{VT}\\label{eq:NS-vT}$$\n",
        "\n",
        "which is a Poisson problem for the pressure $p^{n+1}$ and leads directly to the variational formulation \\eqref{eq:NS-v2}\n",
        "\n",
        "Finally, the corrected velocity $u^{n+1}$ is computed from \\eqref{eq:NS-vT}. Multiplying this equation by a test function $v$, we obtain\n",
        "\n",
        "$$\\rho \\langle (u^{n+1} - u^*), v \\rangle\n",
        "    = - \\Delta t \\langle \\nabla(p^{n+1} - p^n), v \\rangle\n",
        "     \\tag{V3}\\label{eq:NS-v3}$$\n",
        "\n",
        "In summary, the incompressible Navier–Stokes equations can be solved efficiently by computing, at each time step, a sequence of three linear variational problems\n",
        "\n",
        "#### Channel flow (Poiseuille flow)\n",
        "\n",
        "In this section, you will learn how to:\n",
        "\n",
        "* Solve the Navier–Stokes problem using a splitting scheme\n",
        "* Visualize functions from higher-order Lagrangian spaces\n",
        "\n",
        "We will consider the flow between two infinite parallel plates, known as channel flow or Poiseuille flow. As we shall see, this problem admits an analytical solution. Let $H$ denote the distance between the plates and $L$ the length of the channel. We assume that no body forces are present\n",
        "\n",
        "We first scale the problem to eliminate seemingly independent physical parameters. Since the physics of this flow is governed solely by viscous effects in the direction perpendicular to the flow, the natural time scale is based on diffusion across the channel: $t_v = H^2 / \\nu$. We choose $U$ (a characteristic inflow velocity) as the velocity scale and $H$ as the spatial scale. For the pressure scale, we take the characteristic shear stress, $\\mu U / H$, since this problem is a canonical example of shear-driven flow\n",
        "\n",
        "Introducing the nondimensional variables\n",
        "\n",
        "$$\\begin{aligned}\n",
        "  \\bar{t} &= \\frac{t}{t_v} = \\frac{\\nu t}{H^2} \\\\\n",
        "  \\bar{x} &= \\frac{x}{H}, \\;\n",
        "  \\bar{y} = \\frac{y}{H}, \\;\n",
        "  \\bar{z} = \\frac{z}{H} \\\\\n",
        "  \\bar{u} &= \\frac{u}{U}, \\;\n",
        "  \\bar{p} = \\frac{H p}{\\mu U}\n",
        "\\end{aligned}$$\n",
        "\n",
        "and substituting into the governing equations, we obtain the nondimensional Navier–Stokes equations (where we drop the bars for simplicity):\n",
        "\n",
        "$$\\begin{aligned}\n",
        "\\frac{\\partial u}{\\partial t} + \\mathrm{Re}\\, u \\cdot \\nabla u\n",
        "&= -\\nabla p + \\nabla^2 u\\\\\n",
        "\\nabla \\cdot u &= 0\n",
        "\\end{aligned}$$\n",
        "\n",
        "Here, $\\mathrm{Re} = \\rho U H / \\mu$ is the Reynolds number. Because the time and pressure scales differ from those in convection-dominated flows, the Reynolds number appears in association with the convective term rather than the viscous term\n",
        "\n",
        "The exact solution can be derived by assuming $u = (u_x(x,y,z), 0, 0)$, with the $x$-axis aligned with the channel. Since $\\nabla \\cdot u = 0$, the velocity cannot depend on $x$ ($u=(u_x(y, z), 0, 0)$)\n",
        "\n",
        "The physics of channel flow is two-dimensional, so we may omit the $z$-coordinate (more precisely, we set $\\partial/\\partial z = 0$). Substituting $u = (u_x, 0, 0)$ into the scaled governing equations gives\n",
        "\n",
        "$$\\frac{\\partial^2 u_x}{\\partial y^2 } = \\frac{\\partial p}{\\partial x}$$\n",
        "\n",
        "Differentiating this equation with respect to $x$ yields\n",
        "\n",
        "$$\\frac{\\partial^2 p}{\\partial x^2} = 0$$\n",
        "\n",
        "so $\\partial p / \\partial x$ is constant. We denote this constant by $-\\beta$, which represents the driving force of the flow and can be specified as a parameter in the problem\n",
        "\n",
        "Integrating $\\partial^2 u_x(y) / \\partial y^2 = -\\beta$ across the channel width $[0,1]$ and imposing the no-slip condition $u = (0,0,0)$ at the channel walls gives\n",
        "\n",
        "$$u_x(y) = \\tfrac{1}{2} \\beta y(1-y)$$\n",
        "\n",
        "The characteristic velocity $U$ can be defined as the maximum inflow at $y = 0.5$, which implies $\\beta = 8$. The channel length, $L/H$ in the scaled model, does not affect the solution, so for simplicity we restrict the computation to the unit square\n",
        "\n",
        "From a mathematical perspective, the pressure must be prescribed at a point for uniqueness. However, since $p$ is independent of $y$, we can set it to a known value (e.g., zero) along the outlet boundary $x = 1$. The resulting solution is\n",
        "\n",
        "$$p(x) = 8(1-x), \\quad u_x(y) = 4y(1-y)$$\n",
        "\n",
        "The boundary conditions can be prescribed as $p = 8$ at $x = 0$, $p = 0$ at $x = 1$, and $u = (0,0,0)$ on the walls $y = 0,1$. This setup defines the pressure drop and yields a unit maximum velocity at both the inlet and outlet, along with a parabolic velocity profile, without requiring any further specifications\n",
        "\n",
        "It is worth noting that the Navier–Stokes equations are only meaningful to solve in two- or three-dimensional geometries, even though in this case the underlying mathematical problem reduces to two one-dimensional problems: one for $u_x(y)$ and one for $p(x)$\n",
        "\n",
        "The scaled model is not straightforward to simulate using a standard dimensional Navier–Stokes solver. However, since the convection term vanishes, the Reynolds number coefficient in front of this term in the scaled PDEs is irrelevant and can be set to unity. In that case, setting $\\rho=\\mu=1$ in the original Navier–Stokes equations reproduces the scaled model\n",
        "\n",
        "For a specific engineering problem, one typically wants to simulate a particular fluid with its corresponding physical parameters. A general-purpose solver is therefore most naturally implemented in dimensional form, using the original physical parameters. However, nondimensionalization can greatly simplify numerical simulations. First, it reveals that all fluids behave in the same way: it does not matter whether oil, gas, or water flows between two plates, nor does the absolute flow speed matter—at least up to a critical Reynolds number beyond which the flow becomes unstable and transitions to turbulence of an entirely different nature. This means that a single simulation can effectively represent all types of channel flow. In other applications, nondimensionalization shows that it may be sufficient to prescribe only certain parameter ratios (dimensionless numbers) rather than the parameters themselves. This approach simplifies exploration of the input parameter space, which is often the main purpose of simulation. In practice, the nondimensional problem is frequently solved by fixing some dimensional input parameters to convenient values (often unity)\n",
        "\n",
        "**Implementation**\n",
        "\n",
        "As in the previous example, we load the `DOLFINx` module together with the `mpi4py` module, create the unit square mesh, and specify the simulation time and temporal discretization"
      ],
      "id": "eaa4428b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "import pyvista\n",
        "\n",
        "from mpi4py import MPI\n",
        "from petsc4py import PETSc\n",
        "\n",
        "from dolfinx.fem import (Constant, Function, functionspace,\n",
        "  assemble_scalar, dirichletbc, form, locate_dofs_geometrical)\n",
        "from dolfinx.fem.petsc import (assemble_matrix, assemble_vector, \n",
        "  apply_lifting, create_vector, set_bc)\n",
        "from dolfinx.io import VTXWriter\n",
        "from dolfinx.mesh import create_unit_square\n",
        "from dolfinx.plot import vtk_mesh\n",
        "from basix.ufl import element\n",
        "from ufl import (FacetNormal, Identity, TestFunction, TrialFunction,\n",
        "  div, dot, ds, dx, inner, lhs, nabla_grad, rhs, sym)\n",
        "\n",
        "mesh = create_unit_square(MPI.COMM_WORLD, 10, 10)\n",
        "\n",
        "t = 0\n",
        "T = 10\n",
        "num_steps = 500\n",
        "dt = T /num_steps"
      ],
      "id": "e36362eb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Unlike in the previous demos, we will define our two function spaces using `ufl` element definitions as input"
      ],
      "id": "c8fc3dd0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "v_cg2 = element(\n",
        "  \"Lagrange\", \n",
        "  mesh.topology.cell_name(), \n",
        "  2, \n",
        "  shape=(mesh.geometry.dim, )\n",
        ")\n",
        "s_cg1 = element(\n",
        "  \"Lagrange\", \n",
        "  mesh.topology.cell_name(), \n",
        "  1\n",
        ")\n",
        "\n",
        "V = functionspace(mesh, v_cg2)\n",
        "Q = functionspace(mesh, s_cg1)"
      ],
      "id": "3d321501",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The first space, `V`, is a vector-valued function space for the velocity, while `Q` is a scalar-valued function space for the pressure. We use piecewise quadratic elements for the velocity and piecewise linear elements for the pressure. When creating the vector finite element, the dimension of the vector is set to the geometric dimension of the mesh\n",
        "\n",
        "::: callout-note\n",
        "It is well known that certain finite element spaces are unstable for the Navier–Stokes equations, and even for the simpler Stokes equation. A prime example of an unstable pair is the use of continuous piecewise linear polynomials (first-order) for both velocity and pressure. Such an unstable choice typically produces solutions with spurious, non-physical oscillations in the pressure field. A simple remedy is to use continuous piecewise quadratic elements for the velocity and continuous piecewise linear elements for the pressure. This combination is known as the Taylor–Hood element. Note that spurious oscillations may also arise when using splitting methods with an unstable element pair\n",
        ":::\n",
        "\n",
        "Since we are working with two different function spaces, we need to define two corresponding sets of trial and test functions:"
      ],
      "id": "31cad937"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u = TrialFunction(V)\n",
        "v = TestFunction(V)\n",
        "p = TrialFunction(Q)\n",
        "q = TestFunction(Q)"
      ],
      "id": "e891dac3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "As we saw in the Linear Elasticity Problem, we can use Python functions to define the different Dirichlet boundary conditions. For this problem, we impose three Dirichlet conditions. First, we set $u=0$ at the channel walls, i.e., at $y=0$ and $y=1$. In this case, we use `dolfinx.fem.locate_dofs_geometrical`"
      ],
      "id": "caf4d113"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def walls(x):\n",
        "  return np.logical_or(\n",
        "    np.isclose(x[1], 0), \n",
        "    np.isclose(x[1], 1)\n",
        "  )"
      ],
      "id": "4f5aa4c6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "wall_dofs = locate_dofs_geometrical(V, walls)\n",
        "u_noslip = np.array((0,) *mesh.geometry.dim, dtype=PETSc.ScalarType)\n",
        "bc_noslip = dirichletbc(u_noslip, wall_dofs, V)"
      ],
      "id": "c5a31636",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Second, we will impose $p=8$ at the inflow boundary ($x=0$)"
      ],
      "id": "751b0bfa"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def inflow(x):\n",
        "  return np.isclose(x[0], 0)"
      ],
      "id": "04f855d3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "inflow_dofs = locate_dofs_geometrical(Q, inflow)\n",
        "bc_inflow = dirichletbc(PETSc.ScalarType(8), inflow_dofs, Q)"
      ],
      "id": "351b8822",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Finally, we set $p=0$ at the outflow ($x=1$). This creates a pressure gradient that accelerates the flow from the initial state of zero velocity. We then collect the velocity and pressure boundary conditions in Python lists, so they can be easily accessed in the subsequent computations"
      ],
      "id": "8dd7cab3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def outflow(x):\n",
        "  return np.isclose(x[0], 1)"
      ],
      "id": "e891a039",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "outflow_dofs = locate_dofs_geometrical(Q, outflow)\n",
        "bc_outflow = dirichletbc(PETSc.ScalarType(0), outflow_dofs, Q)\n",
        "bcu = [bc_noslip]\n",
        "bcp = [bc_inflow, bc_outflow]"
      ],
      "id": "9c5ca1f4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We now turn to the definition of the three variational forms, one for each step in the IPCS scheme. Let us first consider the formulation of the initial variational problem and the associated parameters"
      ],
      "id": "7a545499"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u_n = Function(V)\n",
        "u_n.name = \"u_n\"\n",
        "U = 0.5 *(u_n +u)\n",
        "\n",
        "k = Constant(mesh, PETSc.ScalarType(dt))\n",
        "\n",
        "rho = Constant(mesh, PETSc.ScalarType(1))\n",
        "mu = Constant(mesh, PETSc.ScalarType(1))\n",
        "\n",
        "n = FacetNormal(mesh)\n",
        "f = Constant(mesh, PETSc.ScalarType((0, 0)))"
      ],
      "id": "cff39bc5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: callout-note\n",
        "Note that we have wrapped several parameters as constants. This reduces the compilation time of the variational formulations. By wrapping them as constants, we can later modify their values without requiring recompilation\n",
        ":::\n",
        "\n",
        "The next step is to set up the variational form for the first stage.\n",
        "Since the variational problem contains a mix of known and unknown quantities, we adopt the following naming convention:\n",
        "\n",
        "* `u` (mathematically $u^{n+1}$) denotes the trial function in the variational form\n",
        "* `u_` represents the most recently computed approximation ($u^{n+1}$ available as a Function object)\n",
        "* `u_n` corresponds to $u^n$\n",
        "* The same convention applies to `p`, `p_` ($p^{n+1}$), and `p_n` ($p^n$)"
      ],
      "id": "a7247da9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Define strain-rate tensor\n",
        "def epsilon(u):\n",
        "  return sym(nabla_grad(u))\n",
        "\n",
        "# Define stress tensor\n",
        "def sigma(u, p):\n",
        "  return 2 *mu *epsilon(u) -p *Identity(len(u))\n",
        "\n",
        "# Define the variational problem for the first step\n",
        "p_n = Function(Q)\n",
        "p_n.name = \"p_n\"\n",
        "\n",
        "F1 = rho *dot((u -u_n) /k, v) *dx\n",
        "F1 += rho *dot(dot(u_n, nabla_grad(u_n)), v) *dx\n",
        "F1 += inner(sigma(U, p_n), epsilon(v)) *dx\n",
        "F1 += dot(p_n *n, v) *ds -dot(mu *nabla_grad(U) *n, v) *ds\n",
        "F1 -= dot(f, v) *dx\n",
        "\n",
        "a1 = form(lhs(F1))\n",
        "L1 = form(rhs(F1))"
      ],
      "id": "9bee1c33",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note that we have used the `ufl` functions `lhs` and `rhs` to extract the bilinear form $a(u,v)$ and the linear form $L(v)$. This is particularly convenient for longer and more complex variational formulations. With our chosen discretization, $a(u,v)$ (`a1`) is not time-dependent and therefore needs to be assembled only once, whereas the right-hand side depends on the solution from the previous time step (`u_n`). Consequently, as in the heat equation example, we create the matrix outside the time loop"
      ],
      "id": "47465219"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "A1 = assemble_matrix(a1, bcs=bcu)\n",
        "A1.assemble()\n",
        "b1 = create_vector(L1)"
      ],
      "id": "a5be67bc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we set up the variational formulations and data structures for the second and third steps of the IPCS scheme, following the same approach as in the first step"
      ],
      "id": "93d72afc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Define variational problem for step 2\n",
        "u_ = Function(V)\n",
        "a2 = form(dot(nabla_grad(p), nabla_grad(q)) *dx)\n",
        "L2 = form(dot(nabla_grad(p_n), nabla_grad(q)) *dx -(rho /k) *div(u_) *q *dx)\n",
        "\n",
        "A2 = assemble_matrix(a2, bcs=bcp)\n",
        "A2.assemble()\n",
        "b2 = create_vector(L2)\n",
        "\n",
        "# Define variational problem for step 3\n",
        "p_ = Function(Q)\n",
        "a3 = form(rho *dot(u, v) *dx)\n",
        "L3 = form(rho *dot(u_, v) *dx -k *dot(nabla_grad(p_ -p_n), v) *dx)\n",
        "\n",
        "A3 = assemble_matrix(a3)\n",
        "A3.assemble()\n",
        "b3 = create_vector(L3)"
      ],
      "id": "1945a27f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now that the linear systems are ready, we can attach solvers to them using `PETSc`. Each step can have its own solution strategy. For the tentative velocity and pressure correction steps, we’ll go with the `BiCGStab` method and algebraic multigrid as a preconditioner. For the velocity update step, we’ll switch to the `CG `method with `SOR` (Gauss–Seidel) preconditioning"
      ],
      "id": "daf7aff7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Solver for step 1\n",
        "solver1 = PETSc.KSP().create(mesh.comm)\n",
        "solver1.setOperators(A1)\n",
        "solver1.setType(PETSc.KSP.Type.BCGS)\n",
        "pc1 = solver1.getPC()\n",
        "pc1.setType(PETSc.PC.Type.HYPRE)\n",
        "pc1.setHYPREType(\"boomeramg\")\n",
        "\n",
        "# Solver for step 2\n",
        "solver2 = PETSc.KSP().create(mesh.comm)\n",
        "solver2.setOperators(A2)\n",
        "solver2.setType(PETSc.KSP.Type.BCGS)\n",
        "pc2 = solver2.getPC()\n",
        "pc2.setType(PETSc.PC.Type.HYPRE)\n",
        "pc2.setHYPREType(\"boomeramg\")\n",
        "\n",
        "# Solver for step 3\n",
        "solver3 = PETSc.KSP().create(mesh.comm)\n",
        "solver3.setOperators(A3)\n",
        "solver3.setType(PETSc.KSP.Type.CG)\n",
        "pc3 = solver3.getPC()\n",
        "pc3.setType(PETSc.PC.Type.SOR)"
      ],
      "id": "ff82628a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We prepare output files for the velocity and pressure and write the mesh along with the initial conditions to file"
      ],
      "id": "8aed89ec"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from pathlib import Path\n",
        "\n",
        "folder = Path(\"fenicsx/ns\")\n",
        "folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "vtx_u = VTXWriter(mesh.comm, folder/\"poiseuille_u.bp\", u_n, engine=\"BP4\")\n",
        "vtx_p = VTXWriter(mesh.comm, folder/\"poiseuille_p.bp\", p_n, engine=\"BP4\")\n",
        "vtx_u.write(t)\n",
        "vtx_p.write(t)"
      ],
      "id": "8436c465",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We also interpolate the analytical solution into our function space and set up a variational formulation to compute the $L^2$ error"
      ],
      "id": "816b4665"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def u_exact(x):\n",
        "  values = np.zeros((2, x.shape[1]), dtype=PETSc.ScalarType)\n",
        "  values[0] = 4 *x[1] *(1.0 -x[1])\n",
        "  return values\n",
        "\n",
        "u_ex = Function(V)\n",
        "u_ex.interpolate(u_exact)\n",
        "\n",
        "L2_error = form(dot(u_ -u_ex, u_ -u_ex) *dx)"
      ],
      "id": "93251869",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The next step is to set up the time-stepping loop. For all three steps, we only need to assemble the right-hand side and apply the boundary conditions using lifting, so that the solvers can use them at each time step"
      ],
      "id": "e36993bd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "for i in range(num_steps):\n",
        "  # Update current time step\n",
        "  t += dt\n",
        "\n",
        "  # Step 1: Tentative veolcity step\n",
        "  with b1.localForm() as loc_1:\n",
        "    loc_1.set(0)\n",
        "  assemble_vector(b1, L1)\n",
        "  apply_lifting(b1, [a1], [bcu])\n",
        "  b1.ghostUpdate(\n",
        "    addv=PETSc.InsertMode.ADD_VALUES, \n",
        "    mode=PETSc.ScatterMode.REVERSE\n",
        "  )\n",
        "  set_bc(b1, bcu)\n",
        "    \n",
        "  solver1.solve(b1, u_.x.petsc_vec)\n",
        "  u_.x.scatter_forward()\n",
        "\n",
        "  # Step 2: Pressure corrrection step\n",
        "  with b2.localForm() as loc_2:\n",
        "    loc_2.set(0)\n",
        "  assemble_vector(b2, L2)\n",
        "  apply_lifting(b2, [a2], [bcp])\n",
        "  b2.ghostUpdate(\n",
        "    addv=PETSc.InsertMode.ADD_VALUES, \n",
        "    mode=PETSc.ScatterMode.REVERSE\n",
        "  )\n",
        "  set_bc(b2, bcp)\n",
        "\n",
        "  solver2.solve(b2, p_.x.petsc_vec)\n",
        "  p_.x.scatter_forward()\n",
        "\n",
        "  # Step 3: Velocity correction step\n",
        "  with b3.localForm() as loc_3:\n",
        "    loc_3.set(0)\n",
        "  assemble_vector(b3, L3)\n",
        "  b3.ghostUpdate(\n",
        "    addv=PETSc.InsertMode.ADD_VALUES, \n",
        "    mode=PETSc.ScatterMode.REVERSE\n",
        "  )\n",
        "\n",
        "  solver3.solve(b3, u_.x.petsc_vec)\n",
        "  u_.x.scatter_forward()\n",
        "    \n",
        "  # Update variable with solution form this time step\n",
        "  u_n.x.array[:] = u_.x.array[:]\n",
        "  p_n.x.array[:] = p_.x.array[:]\n",
        "\n",
        "  # Write solutions to file\n",
        "  vtx_u.write(t)\n",
        "  vtx_p.write(t)\n",
        "\n",
        "  # Compute error at current time-step\n",
        "  error_L2 = np.sqrt(\n",
        "    mesh.comm.allreduce(assemble_scalar(L2_error), \n",
        "    op=MPI.SUM)\n",
        "  )\n",
        "  error_max = mesh.comm.allreduce(\n",
        "    np.max(u_.x.petsc_vec.array -u_ex.x.petsc_vec.array), \n",
        "    op=MPI.MAX\n",
        "  )\n",
        "  \n",
        "  # Print error only every 20th step and at the last step\n",
        "  if (i % 20 == 0) or (i == num_steps -1):\n",
        "    print(f\"Time {t:.2f}, L2-error {error_L2:.2e}, Max error {error_max:.2e}\")\n",
        "\n",
        "# Close xmdf file\n",
        "vtx_u.close()\n",
        "vtx_p.close()\n",
        "\n",
        "b1.destroy()\n",
        "b2.destroy()\n",
        "b3.destroy()\n",
        "\n",
        "solver1.destroy()\n",
        "solver2.destroy()\n",
        "solver3.destroy()"
      ],
      "id": "259ee61b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Verification**\n",
        "\n",
        "As in the previous problems, we compute the error at each degree of freedom as well as the $L^2(\\Omega)$ error. We start from the initial condition $u=(0,0)$. Although we have not explicitly specified the initial condition, `FEniCSx` initializes all Functions—including `u_n` and `u_`—to zero. Since the exact solution is quadratic, we expect the error to reach machine precision in a finite time. In our implementation, we observe that the error quickly approaches zero and is around $10^{-6}$ at $T=10$, which means the solution is basically exact by this time\n",
        "\n",
        "**Visualization of vectors**\n",
        "\n",
        "We have already seen how to plot higher-order functions and vector functions. In this section, we’ll focus on visualizing vector functions using glyphs, rather than by warping the mesh"
      ],
      "id": "6d1ae09c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "topology, cell_types, geometry = vtk_mesh(V)\n",
        "values = np.zeros((geometry.shape[0], 3), dtype=np.float64)\n",
        "values[:, :len(u_n)] = u_n.x.array.real.reshape((geometry.shape[0], len(u_n)))\n",
        "\n",
        "# Create a point cloud of glyphs\n",
        "function_grid = pyvista.UnstructuredGrid(topology, cell_types, geometry)\n",
        "function_grid[\"u\"] = values\n",
        "glyphs = function_grid.glyph(orient=\"u\", factor=0.2)\n",
        "\n",
        "# Create a pyvista-grid for the mesh\n",
        "mesh.topology.create_connectivity(mesh.topology.dim, mesh.topology.dim)\n",
        "grid = pyvista.UnstructuredGrid(*vtk_mesh(mesh, mesh.topology.dim))\n",
        "\n",
        "# Create plotter\n",
        "plotter = pyvista.Plotter(off_screen=True)\n",
        "plotter.add_mesh(grid, style=\"wireframe\", color=\"k\")\n",
        "plotter.add_mesh(glyphs, scalar_bar_args={\"title\": \"u_x\"})\n",
        "plotter.view_xy()\n",
        "\n",
        "# if not pyvista.OFF_SCREEN:\n",
        "#   plotter.show()\n",
        "# else:\n",
        "#   plotter.screenshot(folder/\"glyphs.png\")\n",
        "\n",
        "# HTML 저장\n",
        "plotter.export_html(folder/\"glyphs.html\")"
      ],
      "id": "7188fb4c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/ns/glyphs.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "<!-- #### Flow past a cylinder (@sec-fenicsx-flow-past-a-cylinder) -->\n",
        "\n",
        "---\n",
        "jupyter: fenicsx\n",
        "---\n",
        "\n",
        "#### Flow past a cylinder {#sec-fenicsx-flow-past-a-cylinder}\n",
        "\n",
        "Author: Jørgen S. Dokken — Modifications by Kee-Youn Yoo\n",
        "\n",
        "In this section, we consider a slightly more challenging problem: flow past a cylinder. The geometry and parameters are taken from the [DFG 2D-3 benchmark](https://wwwold.mathematik.tu-dortmund.de/~featflow/en/benchmarks/cfdbenchmarking/flow/dfg_benchmark3_re100.html) in FeatFlow\n",
        "\n",
        "To solve this problem efficiently and ensure numerical stability, we replace the first-order backward difference scheme with a Crank–Nicolson time discretization, combined with a semi-implicit Adams–Bashforth approximation of the nonlinear term\n",
        "\n",
        "::: callout-note\n",
        "This demo is computationally demanding, with a run time of up to 15 minutes, as it uses parameters from the DFG 2D-3 benchmark, which consists of 12,800 time steps.\n",
        "It is advised to download this demo rather than running it in a browser.\n",
        "The run time can be reduced by using 2 or 3 MPI processes\n",
        ":::\n",
        "\n",
        "The computational geometry chosen for this example is \n",
        "![Fluid channel with a circular obstacle](figures/turek.png)\n",
        "\n",
        "The kinematic viscosity is given by $\\nu = 0.001 = \\frac{\\mu}{\\rho}$, and the inflow velocity profile is specified as\n",
        "\n",
        "$$\n",
        "u(x,y,t) = \\left( \\frac{4U(t)y(0.41-y)}{0.41^2}, 0 \\right)\n",
        "$$\n",
        "\n",
        "where\n",
        "$$\n",
        "U(t) = 1.5 \\sin\\left(\\tfrac{\\pi t}{8}\\right)\n",
        "$$\n",
        "\n",
        "This profile attains a maximum value of $1.5$ at $y = 0.41/2$. No scaling is applied in this problem, since all parameters are given explicitly\n",
        "\n",
        "**Mesh generation**\n",
        "\n",
        "As in the Deflection of a Membrane example, we use `GMSH` to generate the mesh. We first create the rectangle and the obstacle"
      ],
      "id": "79aa6aa6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import sys\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "from tqdm.notebook import tqdm\n",
        "\n",
        "from mpi4py import MPI\n",
        "from petsc4py import PETSc\n",
        "import gmsh\n",
        "\n",
        "from dolfinx.cpp.mesh import to_type, cell_entity_type\n",
        "from dolfinx.fem import (Constant, Function, functionspace,\n",
        "  assemble_scalar, dirichletbc, form, locate_dofs_topological, set_bc)\n",
        "from dolfinx.fem.petsc import (apply_lifting, assemble_matrix, \n",
        "  assemble_vector, create_vector, create_matrix, set_bc)\n",
        "from dolfinx.mesh import create_mesh, meshtags_from_entities\n",
        "from dolfinx.graph import adjacencylist\n",
        "from dolfinx.geometry import (bb_tree, compute_collisions_points, \n",
        "  compute_colliding_cells)\n",
        "from dolfinx.io import VTXWriter, distribute_entity_data, gmshio\n",
        "\n",
        "from basix.ufl import element\n",
        "from ufl import (FacetNormal, Identity, Measure, \n",
        "  TestFunction, TrialFunction, as_vector, \n",
        "  div, dot, ds, dx, inner, lhs, grad, nabla_grad, rhs, sym, system)\n",
        "\n",
        "mesh_comm = MPI.COMM_WORLD\n",
        "model_rank = 0\n",
        "\n",
        "if not gmsh.isInitialized():\n",
        "    gmsh.initialize()\n",
        "\n",
        "gdim = 2\n",
        "L = 2.2\n",
        "H = 0.41\n",
        "c_x = c_y = 0.2\n",
        "r = 0.05\n",
        "\n",
        "# Ensure that mesh generation is performed only on\n",
        "#  the specified process (model_rank) in parallel runs,\n",
        "#  since Gmsh is not parallel-safe\n",
        "if mesh_comm.rank == model_rank:\n",
        "\n",
        "  for dim, tag in gmsh.model.occ.getEntities(gdim):\n",
        "    gmsh.model.occ.remove([(dim, tag)])\n",
        "\n",
        "  rectangle = gmsh.model.occ.addRectangle(0, 0, 0, L, H, tag=1)\n",
        "  obstacle = gmsh.model.occ.addDisk(c_x, c_y, 0, r, r)"
      ],
      "id": "12206896",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The next step is to subtract the obstacle from the channel, so that the interior of the circle is not meshed"
      ],
      "id": "166c4d8d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "if mesh_comm.rank == model_rank:\n",
        "  fluid = gmsh.model.occ.cut([(gdim, rectangle)], [(gdim, obstacle)])\n",
        "  gmsh.model.occ.synchronize()"
      ],
      "id": "82f78ba3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To make GMSH mesh the fluid domain, we add a physical volume marker"
      ],
      "id": "93e60fe9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# ID for the fluid domain\n",
        "fluid_marker = 1\n",
        "\n",
        "# Remove any existing physical groups with the same (dim, tag)\n",
        "for dim, tag in gmsh.model.getPhysicalGroups():\n",
        "    if dim == gdim and tag == fluid_marker:\n",
        "        gmsh.model.removePhysicalGroups([(dim, tag)])\n",
        "\n",
        "if mesh_comm.rank == model_rank:\n",
        "  # get all volume entities (2D: surfaces, 3D: volumes)\n",
        "  volumes = gmsh.model.getEntities(dim=gdim)\n",
        "\n",
        "  # ensure there is exactly one fluid region\n",
        "  assert (len(volumes) == 1)\n",
        "\n",
        "  # Register the volume as a physical group with marker = fluid_marker\n",
        "  gmsh.model.addPhysicalGroup(\n",
        "    volumes[0][0], \n",
        "    [volumes[0][1]], \n",
        "    fluid_marker\n",
        "  )\n",
        "\n",
        "  # Assign a human-readable name (\"Fluid\") to this physical group\n",
        "  gmsh.model.setPhysicalName(\n",
        "    volumes[0][0], \n",
        "    fluid_marker, \n",
        "    \"Fluid\"\n",
        "  )"
      ],
      "id": "f957c4c0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To label the different surfaces of the mesh, we proceed as follows:\n",
        "\t\n",
        "1.\tAssign marker 2 to the inflow (left-hand side)\n",
        "2.\tAssign marker 3 to the outflow (right-hand side)\n",
        "3.\tAssign marker 4 to the fluid walls\n",
        "4.\tAssign marker 5 to the obstacle\n",
        "\n",
        "We determine the correct marker for each surface by computing the center of mass of each geometric entity. This way, we can automatically identify and label each boundary in the mesh"
      ],
      "id": "7a88031e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Define boundary markers (unique IDs)\n",
        "inlet_marker, outlet_marker, wall_marker, obstacle_marker = 2, 3, 4, 5\n",
        "inflow, outflow, walls, obstacle = [], [], [], []\n",
        "\n",
        "if mesh_comm.rank == model_rank:\n",
        "  # Extract all 1D boundary entities of the fluid volume\n",
        "  boundaries = gmsh.model.getBoundary(volumes, oriented=False)\n",
        "  \n",
        "  # Identify each boundary by its center of mass\n",
        "  for boundary in boundaries:\n",
        "    center_of_mass = gmsh.model.occ.getCenterOfMass(\n",
        "      boundary[0], \n",
        "      boundary[1]\n",
        "    )\n",
        "    \n",
        "    # Left boundary → Inlet\n",
        "    if np.allclose(center_of_mass, [0, H /2, 0]):\n",
        "      inflow.append(boundary[1])\n",
        "    # Right boundary → Outlet\n",
        "    elif np.allclose(center_of_mass, [L, H /2, 0]):\n",
        "      outflow.append(boundary[1])\n",
        "    # Top/bottom → Walls\n",
        "    elif np.allclose(center_of_mass, [L /2, H, 0]) or \\\n",
        "         np.allclose(center_of_mass, [L /2, 0, 0]):\n",
        "      walls.append(boundary[1])\n",
        "    # Remaining boundary → Obstacle\n",
        "    else:\n",
        "      obstacle.append(boundary[1])\n",
        "  \n",
        "  # Register boundaries as physical groups with human-readable names\n",
        "  gmsh.model.addPhysicalGroup(1, walls, wall_marker)\n",
        "  gmsh.model.setPhysicalName(1, wall_marker, \"Walls\")\n",
        "  \n",
        "  gmsh.model.addPhysicalGroup(1, inflow, inlet_marker)\n",
        "  gmsh.model.setPhysicalName(1, inlet_marker, \"Inlet\")\n",
        "  \n",
        "  gmsh.model.addPhysicalGroup(1, outflow, outlet_marker)\n",
        "  gmsh.model.setPhysicalName(1, outlet_marker, \"Outlet\")\n",
        "    \n",
        "  gmsh.model.addPhysicalGroup(1, obstacle, obstacle_marker)\n",
        "  gmsh.model.setPhysicalName(1, obstacle_marker, \"Obstacle\")"
      ],
      "id": "27738aca",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "In previous meshes, uniform element sizes were employed. In this example, variable mesh sizes are used to better capture the flow in the region of interest, particularly around the circular obstacle. This is accomplished using `GMSH` fields"
      ],
      "id": "1d505190"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Define minimum element size near obstacle (1/3 of radius)\n",
        "res_min = r /3\n",
        "\n",
        "if mesh_comm.rank == model_rank:\n",
        "  # Distance field: measure distance from obstacle edges\n",
        "  distance_field = gmsh.model.mesh.field.add(\"Distance\")\n",
        "  gmsh.model.mesh.field.setNumbers(distance_field, \"EdgesList\", obstacle)\n",
        "  \n",
        "  # Threshold field: refine mesh based on distance\n",
        "  threshold_field = gmsh.model.mesh.field.add(\"Threshold\")\n",
        "  gmsh.model.mesh.field.setNumber(threshold_field, \"IField\", distance_field)\n",
        "  # fine near obstacle\n",
        "  gmsh.model.mesh.field.setNumber(threshold_field, \"LcMin\", res_min)\n",
        "  # coarse far away\n",
        "  gmsh.model.mesh.field.setNumber(threshold_field, \"LcMax\", 0.25 *H)\n",
        "  # within radius → LcMin\n",
        "  gmsh.model.mesh.field.setNumber(threshold_field, \"DistMin\", r)\n",
        "  # beyond 2H → LcMax\n",
        "  gmsh.model.mesh.field.setNumber(threshold_field, \"DistMax\", 2 *H)\n",
        "  \n",
        "  # Min field: apply the smallest size rule if multiple fields exist\n",
        "  min_field = gmsh.model.mesh.field.add(\"Min\")\n",
        "  gmsh.model.mesh.field.setNumbers(min_field, \"FieldsList\", [threshold_field])\n",
        "\n",
        "  # Set background mesh: controls final mesh refinement\n",
        "  gmsh.model.mesh.field.setAsBackgroundMesh(min_field)"
      ],
      "id": "0d6fe606",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Generating mesh**\n",
        "\n",
        "We are now ready to generate the mesh. At this stage, we need to decide whether the mesh should consist of triangles or quadrilaterals. In this demo, to match the DFG 2D-3 benchmark, we use second-order quadrilateral elements"
      ],
      "id": "5eb87982"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "if mesh_comm.rank == model_rank:\n",
        "  # Set mesh algorithm for quadrilaterals (Delquad/Delaunay)\n",
        "  gmsh.option.setNumber(\"Mesh.Algorithm\", 8)\n",
        "\n",
        "  # Choose recombination algorithm (Blossom)\n",
        "  gmsh.option.setNumber(\"Mesh.RecombinationAlgorithm\", 2)\n",
        "\n",
        "  # Apply recombination to all elements (triangles → quads)\n",
        "  gmsh.option.setNumber(\"Mesh.RecombineAll\", 1)\n",
        "  \n",
        "  # Set subdivision algorithm for recombined quads\n",
        "  gmsh.option.setNumber(\"Mesh.SubdivisionAlgorithm\", 1)\n",
        "\n",
        "  # Generate the mesh for the given dimension\n",
        "  gmsh.model.mesh.generate(gdim)\n",
        "\n",
        "  # Upgrade mesh to second-order (quadratic) elements\n",
        "  gmsh.model.mesh.setOrder(2)\n",
        "\n",
        "  # Optimize mesh quality using Netgen optimizer\n",
        "  gmsh.model.mesh.optimize(\"Netgen\")"
      ],
      "id": "d517fd90",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Loading mesh and boundary markers**\n",
        "\n",
        "Having generated the mesh, we now need to load it together with the corresponding facet markers into `DOLFINx`.\n",
        "We follow the same structure as in Deflection of a membrane, with the difference that facet markers are also loaded.\n",
        "For more details about the function used below, see [A GMSH tutorial for DOLFINx](https://jsdokken.com/src/tutorial_gmsh.html)"
      ],
      "id": "4f6501ce"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Convert GMSH model to DOLFINx mesh and facet markers\n",
        "mesh, _, ft = gmshio.model_to_mesh(\n",
        "  gmsh.model, \n",
        "  mesh_comm, \n",
        "  model_rank, \n",
        "  gdim=gdim\n",
        ")\n",
        "\n",
        "# Assign a human-readable name to the facet markers\n",
        "ft.name = \"Facet markers\"\n",
        "\n",
        "gmsh.finalize()"
      ],
      "id": "ffdc320f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# For notebook only\n",
        "if \"ipykernel\" in sys.modules:\n",
        "\n",
        "  import pyvista\n",
        "  from dolfinx import plot\n",
        "\n",
        "  V = functionspace(mesh, (\"Lagrange\", 2))\n",
        "\n",
        "  # Extract topology from mesh and create pyvista mesh\n",
        "  topology, cell_types, x = plot.vtk_mesh(V)\n",
        "  grid = pyvista.UnstructuredGrid(topology, cell_types, x)\n",
        "\n",
        "  plotter = pyvista.Plotter(off_screen=True)\n",
        "  plotter.add_mesh(grid, show_edges=True)\n",
        "  plotter.add_axes()\n",
        "  plotter.view_xy()\n",
        "\n",
        "  # if not pyvista.OFF_SCREEN:\n",
        "  #   plotter.show()\n",
        "\n",
        "  # HTML 저장\n",
        "  plotter.export_html(\"fenicsx/ns/flow_past_a_cylinder_mesh.html\")"
      ],
      "id": "7ca10ae0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/ns/flow_past_a_cylinder_mesh.html\"\n",
        "        width=\"100%\" height=\"350px\"\n",
        "        style=\"border:none;\">\n",
        "</iframe>\n",
        "```\n",
        "\n",
        "**Physical and discretization parameters**\n",
        "\n",
        "In accordance with the DGF-2 benchmark, the problem-specific parameters are defined"
      ],
      "id": "81e818f4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "t = 0\n",
        "T = 8                        # Final time\n",
        "dt = 1 /1600                 # Time step size\n",
        "num_steps = int(T /dt)\n",
        "\n",
        "k = Constant(mesh, PETSc.ScalarType(dt))\n",
        "mu = Constant(mesh, PETSc.ScalarType(0.001))  # Dynamic viscosity\n",
        "rho = Constant(mesh, PETSc.ScalarType(1))     # Density"
      ],
      "id": "e329bd65",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: callout-note\n",
        "Converting the notebook to a Python script and running it with `mpirun` considerably decreases the runtime\n",
        ":::\n",
        "\n",
        "**Boundary conditions**\n",
        "\n",
        "After creating the mesh and the corresponding mesh tags, we can define the function spaces V and Q together with the boundary conditions. Since ft contains the facet markers, we use it to identify the facets corresponding to the inlet and the walls"
      ],
      "id": "70ef111e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "v_cg2 = element(\n",
        "  \"Lagrange\", \n",
        "  mesh.topology.cell_name(), \n",
        "  2, \n",
        "  shape=(mesh.geometry.dim, )\n",
        ")\n",
        "s_cg1 = element(\n",
        "  \"Lagrange\", \n",
        "  mesh.topology.cell_name(), \n",
        "  1\n",
        ")\n",
        "V = functionspace(mesh, v_cg2)\n",
        "Q = functionspace(mesh, s_cg1)\n",
        "\n",
        "fdim = mesh.topology.dim -1\n",
        "\n",
        "# Define boundary conditions\n",
        "class InletVelocity():\n",
        "  def __init__(self, t):\n",
        "    self.t = t\n",
        "\n",
        "  def __call__(self, x):\n",
        "    values = np.zeros((gdim, x.shape[1]), dtype=PETSc.ScalarType)\n",
        "    values[0] = 4 *1.5 *np.sin(self.t *np.pi /8) *x[1] *(0.41 -x[1]) /(0.41**2)\n",
        "    return values\n",
        "\n",
        "# Inlet\n",
        "u_inlet = Function(V)\n",
        "inlet_velocity = InletVelocity(t)\n",
        "u_inlet.interpolate(inlet_velocity)\n",
        "bcu_inflow = dirichletbc(\n",
        "  u_inlet, \n",
        "  locate_dofs_topological(V, fdim, ft.find(inlet_marker))\n",
        ")\n",
        "\n",
        "# Walls\n",
        "u_nonslip = np.array((0,) *mesh.geometry.dim, dtype=PETSc.ScalarType)\n",
        "bcu_walls = dirichletbc(\n",
        "  u_nonslip, \n",
        "  locate_dofs_topological(V, fdim, ft.find(wall_marker)), \n",
        "  V\n",
        ")\n",
        "\n",
        "# Obstacle\n",
        "bcu_obstacle = dirichletbc(\n",
        "  u_nonslip, \n",
        "  locate_dofs_topological(V, fdim, ft.find(obstacle_marker)), \n",
        "  V\n",
        ")\n",
        "\n",
        "bcu = [bcu_inflow, bcu_obstacle, bcu_walls]\n",
        "\n",
        "# Outlet\n",
        "bcp_outlet = dirichletbc(\n",
        "  PETSc.ScalarType(0), \n",
        "  locate_dofs_topological(Q, fdim, ft.find(outlet_marker)), \n",
        "  Q\n",
        ")\n",
        "bcp = [bcp_outlet]"
      ],
      "id": "3fdf5143",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Variational form**\n",
        "\n",
        "In contrast to Poiseuille flow, we employ a Crank–Nicolson discretization together with a semi-implicit Adams–Bashforth approximation\n",
        "\n",
        "The first step can be written as\n",
        "\n",
        "$$\n",
        "\\rho\\left(\\frac{u^* -u^n}{\\delta t} +\\left(\\frac{3}{2}u^{n} -\\frac{1}{2} u^{n-1}\\right)\\cdot \\frac{1}{2}\\nabla (u^* +u^n) \\right) - \\frac{1}{2}\\mu \\Delta( u^* + u^n )+ \\nabla p^{n-\\tfrac{1}{2}} = f^{n+\\tfrac{1}{2}} \\;\\, \\text{ in } \\Omega\n",
        "$$\n",
        "\n",
        "$$\n",
        "u^{*}=g(\\cdot, t^{n+1}) \\;\\, \\text{ on } \\partial \\Omega_{D}\n",
        "$$\n",
        "\n",
        "$$\n",
        "\\tfrac{1}{2}\\nu \\nabla (u^*+u^n) \\cdot n = p^{n-\\tfrac{1}{2}} \\;\\, \\text{ on } \\partial \\Omega_{N}\n",
        "$$\n",
        "\n",
        "where the temporal derivative of the velocity uses the two previous time steps, and the pressure is computed in a staggered manner, at the midpoint between the previous and the current solution\n",
        "\n",
        "The second step is\n",
        "\n",
        "$$\n",
        "\\nabla^2 \\phi = \\frac{\\rho}{\\delta t} \\nabla \\cdot u^* \\;\\,\\text{in } \\Omega\n",
        "$$\n",
        "\n",
        "$$\n",
        "\\nabla \\phi \\cdot n = 0 \\;\\, \\text{on } \\partial \\Omega_D\n",
        "$$\n",
        "\n",
        "$$\n",
        "\\phi = 0 \\;\\,\\text{on } \\partial\\Omega_N\n",
        "$$\n",
        "\n",
        "where $p^{n+\\tfrac{1}{2}}=p^{n-\\tfrac{1}{2}} + \\phi$\n",
        "\n",
        "Finally, the third step is\n",
        "\n",
        "$$\n",
        "\\rho (u^{n+1}-u^{*}) = -\\delta t \\nabla\\phi\n",
        "$$\n",
        "\n",
        "We begin by defining all the variables required in the variational formulations"
      ],
      "id": "a5adeb49"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u = TrialFunction(V)\n",
        "v = TestFunction(V)\n",
        "\n",
        "u_ = Function(V)\n",
        "u_.name = \"u\"\n",
        "\n",
        "u_s = Function(V)\n",
        "u_n = Function(V)\n",
        "u_n1 = Function(V)\n",
        "\n",
        "p = TrialFunction(Q)\n",
        "q = TestFunction(Q)\n",
        "\n",
        "p_ = Function(Q)\n",
        "p_.name = \"p\"\n",
        "\n",
        "phi = Function(Q)"
      ],
      "id": "2aebc39a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we define the variational formulation for the first step, where the diffusion and pressure terms are integrated by parts"
      ],
      "id": "98f7f956"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f = Constant(mesh, PETSc.ScalarType((0, 0)))\n",
        "\n",
        "F1 = rho /k *dot(u -u_n, v) *dx\n",
        "F1 += inner(dot(1.5 *u_n -0.5 *u_n1, 0.5 *nabla_grad(u +u_n)), v) *dx\n",
        "F1 += 0.5 *mu *inner(grad(u +u_n), grad(v)) *dx -dot(p_, div(v)) *dx\n",
        "F1 += dot(f, v) *dx\n",
        "\n",
        "a1 = form(lhs(F1))\n",
        "L1 = form(rhs(F1))\n",
        "\n",
        "A1 = create_matrix(a1)\n",
        "b1 = create_vector(L1)"
      ],
      "id": "b3986495",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we set up the second step"
      ],
      "id": "a8cdd495"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "a2 = form(dot(grad(p), grad(q)) *dx)\n",
        "L2 = form(-rho /k *dot(div(u_s), q) *dx)\n",
        "\n",
        "A2 = assemble_matrix(a2, bcs=bcp)\n",
        "A2.assemble()\n",
        "b2 = create_vector(L2)"
      ],
      "id": "17dd04be",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We finally complete the last step"
      ],
      "id": "73360b3c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "a3 = form(rho *dot(u, v) *dx)\n",
        "L3 = form(rho *dot(u_s, v) *dx -k *dot(nabla_grad(phi), v) *dx)\n",
        "\n",
        "A3 = assemble_matrix(a3)\n",
        "A3.assemble()\n",
        "b3 = create_vector(L3)"
      ],
      "id": "c1aa3edc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "As in the previous tutorials, we use PETSc as the linear algebra backend"
      ],
      "id": "3721e85d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Solver for step 1\n",
        "solver1 = PETSc.KSP().create(mesh.comm)\n",
        "solver1.setOperators(A1)\n",
        "solver1.setType(PETSc.KSP.Type.BCGS)\n",
        "pc1 = solver1.getPC()\n",
        "pc1.setType(PETSc.PC.Type.JACOBI)\n",
        "\n",
        "# Solver for step 2\n",
        "solver2 = PETSc.KSP().create(mesh.comm)\n",
        "solver2.setOperators(A2)\n",
        "solver2.setType(PETSc.KSP.Type.MINRES)\n",
        "pc2 = solver2.getPC()\n",
        "pc2.setType(PETSc.PC.Type.HYPRE)\n",
        "pc2.setHYPREType(\"boomeramg\")\n",
        "\n",
        "# Solver for step 3\n",
        "solver3 = PETSc.KSP().create(mesh.comm)\n",
        "solver3.setOperators(A3)\n",
        "solver3.setType(PETSc.KSP.Type.CG)\n",
        "pc3 = solver3.getPC()\n",
        "pc3.setType(PETSc.PC.Type.SOR)"
      ],
      "id": "9742b2ea",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Verification of the implementation by computing known physical quantities**\n",
        "\n",
        "As a further verification of our implementation, we compute the drag and lift coefficients over the obstacle, defined as\n",
        "\n",
        "$$\n",
        "C_{\\text{D}}(u,p,t,\\partial\\Omega_S) = \\frac{2}{\\rho L U_{\\text{mean}}^2}\\int_{\\partial\\Omega_S}\\rho \\nu n \\cdot \\nabla u_{t_S}(t)n_y - p(t)n_x\\,\\mathrm{d} s\n",
        "$$\n",
        "\n",
        "$$\n",
        "C_{\\text{L}}(u,p,t,\\partial\\Omega_S) = -\\frac{2}{\\rho L U_{\\text{mean}}^2}\\int_{\\partial\\Omega_S}\\rho \\nu n \\cdot \\nabla u_{t_S}(t)n_x + p(t)n_y\\,\\mathrm{d} s\n",
        "$$\n",
        "\n",
        "where $u_{t_S}$ is the tangential velocity component at the obstacle interface $\\partial\\Omega_S$, defined as $u_{t_S}=u\\cdot (n_y,-n_x)$, $U_{\\text{mean}}=1$ is the average inflow velocity, and $L$ is the channel length. We use UFL to define the relevant integrals and assemble them at each time step"
      ],
      "id": "1a4db82f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "n = -FacetNormal(mesh)  # Normal pointing out of obstacle\n",
        "dObs = Measure(\n",
        "  \"ds\", \n",
        "  domain=mesh, \n",
        "  subdomain_data=ft, \n",
        "  subdomain_id=obstacle_marker\n",
        ")\n",
        "\n",
        "u_t = inner(as_vector((n[1], -n[0])), u_)\n",
        "\n",
        "drag = form(2 /0.1 *(mu /rho *inner(grad(u_t), n) *n[1] -p_ *n[0]) *dObs)\n",
        "lift = form(-2 /0.1 *(mu /rho *inner(grad(u_t), n) *n[0] +p_ *n[1]) *dObs)\n",
        "\n",
        "if mesh.comm.rank == 0:\n",
        "  C_D = np.zeros(num_steps, dtype=PETSc.ScalarType)\n",
        "  C_L = np.zeros(num_steps, dtype=PETSc.ScalarType)\n",
        "  t_u = np.zeros(num_steps, dtype=np.float64)\n",
        "  t_p = np.zeros(num_steps, dtype=np.float64)"
      ],
      "id": "a669c1cb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We will also evaluate the pressure at two points: one in front of the obstacle, $(0.15, 0.2)$, and one behind it, $(0.25, 0.2)$. To do this, we first need to determine which cell contains each point, so that we can construct a linear combination of the local basis functions and their coefficients"
      ],
      "id": "1c76135b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "tree = bb_tree(mesh, mesh.geometry.dim)\n",
        "points = np.array([[0.15, 0.2, 0], [0.25, 0.2, 0]])\n",
        "\n",
        "cell_candidates = compute_collisions_points(tree, points)\n",
        "colliding_cells = compute_colliding_cells(mesh, cell_candidates, points)\n",
        "\n",
        "front_cells = colliding_cells.links(0)\n",
        "back_cells = colliding_cells.links(1)\n",
        "\n",
        "if mesh.comm.rank == 0:\n",
        "  p_diff = np.zeros(num_steps, dtype=PETSc.ScalarType)"
      ],
      "id": "39298dfb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Solving the time-dependent problem**\n",
        "\n",
        "As in the previous example, we create output files for the velocity and pressure and solve the time-dependent problem. Since the problem involves many time steps, we use the tqdm package to visualize the progress"
      ],
      "id": "672129f2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from pathlib import Path\n",
        "\n",
        "folder = Path(\"fenicsx/ns\")\n",
        "folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "vtx_u = VTXWriter(mesh.comm, folder/\"dfg2D-3-u.bp\", [u_], engine=\"BP4\")\n",
        "vtx_p = VTXWriter(mesh.comm, folder/\"dfg2D-3-p.bp\", [p_], engine=\"BP4\")\n",
        "vtx_u.write(t)\n",
        "vtx_p.write(t)\n",
        "\n",
        "for i in tqdm(range(num_steps), desc=\"Time Stepping\", unit='step'):\n",
        "\n",
        "  # Update current time step\n",
        "  t += dt\n",
        "  \n",
        "  # Update inlet velocity\n",
        "  inlet_velocity.t = t\n",
        "  u_inlet.interpolate(inlet_velocity)\n",
        "\n",
        "  # Step 1: Tentative velocity step\n",
        "  A1.zeroEntries()\n",
        "  assemble_matrix(A1, a1, bcs=bcu)\n",
        "  A1.assemble()\n",
        "  \n",
        "  with b1.localForm() as loc:\n",
        "    loc.set(0)\n",
        "  assemble_vector(b1, L1)\n",
        "  apply_lifting(b1, [a1], [bcu])\n",
        "  \n",
        "  b1.ghostUpdate(\n",
        "    addv=PETSc.InsertMode.ADD_VALUES, \n",
        "    mode=PETSc.ScatterMode.REVERSE\n",
        "  )\n",
        "  \n",
        "  set_bc(b1, bcu)\n",
        "  \n",
        "  solver1.solve(b1, u_s.x.petsc_vec)\n",
        "  u_s.x.scatter_forward()\n",
        "\n",
        "  # Step 2: Pressure corrrection step\n",
        "  with b2.localForm() as loc:\n",
        "    loc.set(0)\n",
        "  assemble_vector(b2, L2)\n",
        "  apply_lifting(b2, [a2], [bcp])\n",
        "\n",
        "  b2.ghostUpdate(\n",
        "    addv=PETSc.InsertMode.ADD_VALUES, \n",
        "    mode=PETSc.ScatterMode.REVERSE\n",
        "  )\n",
        "\n",
        "  set_bc(b2, bcp)\n",
        "\n",
        "  solver2.solve(b2, phi.x.petsc_vec)\n",
        "  phi.x.scatter_forward()\n",
        "\n",
        "  p_.x.petsc_vec.axpy(1, phi.x.petsc_vec)\n",
        "  p_.x.scatter_forward()\n",
        "\n",
        "  # Step 3: Velocity correction step\n",
        "  with b3.localForm() as loc:\n",
        "    loc.set(0)\n",
        "  assemble_vector(b3, L3)\n",
        "\n",
        "  b3.ghostUpdate(\n",
        "    addv=PETSc.InsertMode.ADD_VALUES, \n",
        "    mode=PETSc.ScatterMode.REVERSE\n",
        "  )\n",
        "  \n",
        "  solver3.solve(b3, u_.x.petsc_vec)\n",
        "  u_.x.scatter_forward()\n",
        "\n",
        "  # Write solutions to file\n",
        "  vtx_u.write(t)\n",
        "  vtx_p.write(t)\n",
        "\n",
        "  # Update variable with solution form this time step\n",
        "  with (\n",
        "    u_.x.petsc_vec.localForm() as loc_, \n",
        "    u_n.x.petsc_vec.localForm() as loc_n, \n",
        "    u_n1.x.petsc_vec.localForm() as loc_n1\n",
        "  ):\n",
        "    loc_n.copy(loc_n1)\n",
        "    loc_.copy(loc_n)\n",
        "\n",
        "  # Compute physical quantities\n",
        "  # For this to work in paralell, we gather contributions from all processors\n",
        "  # to processor zero and sum the contributions\n",
        "  drag_coeff = mesh.comm.gather(assemble_scalar(drag), root=0)\n",
        "  lift_coeff = mesh.comm.gather(assemble_scalar(lift), root=0)\n",
        "  \n",
        "  p_front = None\n",
        "  if len(front_cells) > 0:\n",
        "    p_front = p_.eval(points[0], front_cells[:1])\n",
        "  p_front = mesh.comm.gather(p_front, root=0)\n",
        "  \n",
        "  p_back = None\n",
        "  if len(back_cells) > 0:\n",
        "    p_back = p_.eval(points[1], back_cells[:1])\n",
        "  p_back = mesh.comm.gather(p_back, root=0)\n",
        "  \n",
        "  if mesh.comm.rank == 0:\n",
        "    t_u[i] = t\n",
        "    t_p[i] = t -dt /2\n",
        "    C_D[i] = sum(drag_coeff)\n",
        "    C_L[i] = sum(lift_coeff)\n",
        "    \n",
        "    # Choose first pressure that is found from the different processors\n",
        "    for pressure in p_front:\n",
        "      if pressure is not None:\n",
        "        p_diff[i] = pressure[0]\n",
        "        break\n",
        "    for pressure in p_back:\n",
        "      if pressure is not None:\n",
        "        p_diff[i] -= pressure[0]\n",
        "        break\n",
        "\n",
        "vtx_u.close()\n",
        "vtx_p.close()"
      ],
      "id": "19e9e535",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: {.video}\n",
        "![](fenicsx/ns/dfg2D-3-u.mp4)\n",
        ":::\n",
        "\n",
        "::: {.video}\n",
        "![](fenicsx/ns/dfg2D-3-p.mp4)\n",
        ":::\n",
        "\n",
        "**Verification using data from `FEATFLOW`**\n",
        "\n",
        "We use `matplotlib` to compare our numerical results with the reference data provided by `FEATFLOW` for different discretization levels"
      ],
      "id": "7dc67cfe"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "if mesh.comm.rank == 0:\n",
        "  # Compute the total number of velocity degrees of freedom (DOFs)\n",
        "  # - V.dofmap.index_map.size_global : global number of scalar DOFs\n",
        "  # - V.dofmap.index_map_bs          : block size (e.g., 2 in 2D, 3 in 3D for vector spaces)\n",
        "  #   → Total number of velocity DOFs = block size × scalar DOFs  \n",
        "  num_velocity_dofs = V.dofmap.index_map_bs *V.dofmap.index_map.size_global\n",
        "\n",
        "  # Compute the total number of pressure degrees of freedom (DOFs)\n",
        "  # - Typically: Q.dofmap.index_map.size_global × Q.dofmap.index_map_bs\n",
        "  #   (for scalar pressure spaces, block size = 1)\n",
        "  num_pressure_dofs = Q.dofmap.index_map_bs *Q.dofmap.index_map.size_global\n",
        "\n",
        "  turek = np.loadtxt(folder/\"bdforces_lv4\")\n",
        "  turek_p = np.loadtxt(folder/\"pointvalues_lv4\")\n",
        "  \n",
        "  fig = plt.figure(figsize=(25, 8))\n",
        "\n",
        "  l1 = plt.plot(\n",
        "    t_u, C_D, \n",
        "    label=f\"FEniCSx ({num_velocity_dofs +num_pressure_dofs:d} dofs)\", linewidth=2\n",
        "  )\n",
        "  l2 = plt.plot(\n",
        "    turek[1:, 1], turek[1:, 3], \n",
        "    marker=\"x\", markevery=50, linestyle=\"\", markersize=4, \n",
        "    label=\"FEATFLOW (42016 dofs)\")\n",
        "\n",
        "  plt.title(\"Drag Coefficient\")\n",
        "  plt.grid()\n",
        "  plt.legend()\n",
        "  plt.savefig(folder/\"drag_comparison.png\")\n",
        "  plt.show()\n",
        "\n",
        "  fig = plt.figure(figsize=(25, 8))\n",
        "\n",
        "  l1 = plt.plot(\n",
        "    t_u, C_L, \n",
        "    label=f\"FEniCSx ({num_velocity_dofs +num_pressure_dofs:d} dofs)\", linewidth=2\n",
        "  )\n",
        "  l2 = plt.plot(\n",
        "    turek[1:, 1], turek[1:, 4], \n",
        "    marker=\"x\", markevery=50, linestyle=\"\", markersize=4, \n",
        "    label=\"FEATFLOW (42016 dofs)\"\n",
        "  )\n",
        "  \n",
        "  plt.title(\"Lift Coefficient\")\n",
        "  plt.grid()\n",
        "  plt.legend()\n",
        "  plt.savefig(folder/\"lift_comparison.png\")\n",
        "  plt.show()  \n",
        "\n",
        "  fig = plt.figure(figsize=(25, 8))\n",
        "\n",
        "  l1 = plt.plot(\n",
        "    t_p, p_diff, \n",
        "    label=f\"FEniCSx ({num_velocity_dofs + num_pressure_dofs:d} dofs)\", linewidth=2\n",
        "  )\n",
        "  l2 = plt.plot(\n",
        "    turek[1:, 1], turek_p[1:, 6] -turek_p[1:, -1], \n",
        "    marker=\"x\", markevery=50, linestyle=\"\", markersize=4, \n",
        "    label=\"FEATFLOW (42016 dofs)\"\n",
        "  )\n",
        "  \n",
        "  plt.title(\"Pressure difference\")\n",
        "  plt.grid()\n",
        "  plt.legend()\n",
        "  plt.savefig(folder/\"pressure_comparison.png\")\n",
        "  plt.show()"
      ],
      "id": "044f11f8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Hyperelasticity\n",
        "\n",
        "Author: Jørgen S. Dokken and Garth N. Wells\n",
        "\n",
        "This section demonstrates how to solve the hyperelasticity problem for the deformation of a beam.\n",
        "We also illustrate how to define a constant boundary condition for a vector function space\n",
        "\n",
        "We begin by importing `DOLFINx` along with additional dependencies.\n",
        "Next, we construct a slender cantilever composed of hexahedral elements and define the function space `V` for the unknown field"
      ],
      "id": "06c1c306"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "from mpi4py import MPI\n",
        "import pyvista\n",
        "\n",
        "from dolfinx import fem, mesh, plot\n",
        "from dolfinx import log, default_scalar_type\n",
        "from dolfinx.fem.petsc import NonlinearProblem\n",
        "from dolfinx.nls.petsc import NewtonSolver\n",
        "\n",
        "import ufl\n",
        "\n",
        "L = 20.0\n",
        "domain = mesh.create_box(\n",
        "  MPI.COMM_WORLD, \n",
        "  [[0.0, 0.0, 0.0], [L, 1, 1]], \n",
        "  [20, 5, 5], \n",
        "  mesh.CellType.hexahedron\n",
        ")\n",
        "V = fem.functionspace(domain, (\"Lagrange\", 2, (domain.geometry.dim, )))"
      ],
      "id": "8a2ba501",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We define two Python functions to identify the facets where boundary conditions should be applied"
      ],
      "id": "b43bbbc0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def left(x):\n",
        "  return np.isclose(x[0], 0)\n",
        "\n",
        "def right(x):\n",
        "   return np.isclose(x[0], L)\n",
        "\n",
        "fdim = domain.topology.dim -1\n",
        "left_facets = mesh.locate_entities_boundary(domain, fdim, left)\n",
        "right_facets = mesh.locate_entities_boundary(domain, fdim, right)"
      ],
      "id": "cc0faf7d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we create a marker using these two functions"
      ],
      "id": "9b8d2a01"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Concatenate and sort the arrays based on facet indices\n",
        "# Left facets are marked with ID 1, right facets with ID 2\n",
        "\n",
        "# Combine the facet indices from the left and right boundary\n",
        "marked_facets = np.hstack([left_facets, right_facets])\n",
        "\n",
        "# Assign marker values: 1 for left facets, 2 for right facets\n",
        "marked_values = np.hstack([\n",
        "    np.full_like(left_facets, 1), \n",
        "    np.full_like(right_facets, 2)\n",
        "])\n",
        "\n",
        "# Sort facets (and corresponding marker values) by facet index\n",
        "sorted_facets = np.argsort(marked_facets)\n",
        "\n",
        "# Create a MeshTags object that stores the facet markers\n",
        "# This will allow us to apply different boundary conditions\n",
        "# depending on whether the facet belongs to the left or right boundary\n",
        "facet_tag = mesh.meshtags(\n",
        "    domain, fdim, \n",
        "    marked_facets[sorted_facets], \n",
        "    marked_values[sorted_facets]\n",
        ")"
      ],
      "id": "7b661769",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We then create a function to prescribe the fixed boundary condition on the left side"
      ],
      "id": "c3d0fc17"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u_bc = np.array((0,) *domain.geometry.dim, dtype=default_scalar_type)"
      ],
      "id": "25dcb2f6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To apply the boundary condition, we identify the degrees of freedom (dofs) associated with the facets marked by the `MeshTag`"
      ],
      "id": "2b0dc215"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "left_dofs = fem.locate_dofs_topological(\n",
        "  V, \n",
        "  facet_tag.dim, \n",
        "  facet_tag.find(1)\n",
        ")\n",
        "bcs = [fem.dirichletbc(u_bc, left_dofs, V)]"
      ],
      "id": "0263cd7d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we define the body force `B` on the reference configuration and the nominal (first Piola-Kirchhoff) traction `T`"
      ],
      "id": "6da5301b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "B = fem.Constant(domain, default_scalar_type((0, 0, 0)))\n",
        "T = fem.Constant(domain, default_scalar_type((0, 0, 0)))"
      ],
      "id": "9e965e20",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We define the test and solution functions in the space $V$"
      ],
      "id": "88e7aad9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "v = ufl.TestFunction(V)\n",
        "u = fem.Function(V)"
      ],
      "id": "d4dab4e8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We define the kinematic quantities relevant to the problem"
      ],
      "id": "e9612864"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Spatial dimension\n",
        "d = len(u)\n",
        "\n",
        "# Identity tensor\n",
        "I = ufl.variable(ufl.Identity(d))\n",
        "\n",
        "# Deformation gradient\n",
        "F = ufl.variable(I +ufl.grad(u))\n",
        "\n",
        "# Right Cauchy-Green tensor\n",
        "C = ufl.variable(F.T *F)\n",
        "\n",
        "# Invariants of deformation tensors\n",
        "Ic = ufl.variable(ufl.tr(C))\n",
        "J = ufl.variable(ufl.det(F))"
      ],
      "id": "50209619",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We define the elasticity model using the stored strain energy density function $\\psi$, and derive the corresponding first Piola-Kirchhoff stress expression:"
      ],
      "id": "44cba7e5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Elasticity parameters\n",
        "E = default_scalar_type(1.0e4)\n",
        "nu = default_scalar_type(0.3)\n",
        "mu = fem.Constant(domain, E /(2 *(1 +nu)))\n",
        "\n",
        "lmbda = fem.Constant(domain, E *nu /((1 +nu) *(1 -2 *nu)))\n",
        "\n",
        "# Stored strain energy density (compressible neo-Hookean model)\n",
        "psi = (mu /2) *(Ic -3) -mu *ufl.ln(J) +(lmbda /2) *(ufl.ln(J))**2\n",
        "\n",
        "# Stress - Hyper-elasticity\n",
        "P = ufl.diff(psi, F)"
      ],
      "id": "5648ea77",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: callout-note\n",
        "To illustrate the difference between linear elasticity and hyperelasticity, the following lines can be uncommented to solve the linear elasticity problem\n",
        ":::"
      ],
      "id": "3f99f889"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# P = 2.0 *mu *ufl.sym(ufl.grad(u)) +lmbda *ufl.tr(ufl.sym(ufl.grad(u))) *I"
      ],
      "id": "7d09db64",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Define the variational form, including the traction integral over all facets marked with value 2. The quadrature degree for the integrals is set to 4"
      ],
      "id": "d37da0d8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "metadata = {\"quadrature_degree\": 4}\n",
        "ds = ufl.Measure(\n",
        "  \"ds\", \n",
        "  domain=domain, \n",
        "  subdomain_data=facet_tag, \n",
        "  metadata=metadata\n",
        ")\n",
        "\n",
        "dx = ufl.Measure(\n",
        "  \"dx\", \n",
        "  domain=domain, \n",
        "  metadata=metadata\n",
        ")\n",
        "\n",
        "# Define form F (we want to find u such that F(u) = 0)\n",
        "F = ufl.inner(ufl.grad(v), P) *dx -ufl.inner(v, B) *dx -ufl.inner(v, T) *ds(2)"
      ],
      "id": "89a4b1ea",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "As the variational form is nonlinear and written in residual form, we use the nonlinear problem class from `DOLFINx` to set up the structures required for a Newton solver"
      ],
      "id": "97e5bd5a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "problem = NonlinearProblem(F, u, bcs)"
      ],
      "id": "d14468d2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "and then create and configure the Newton solver"
      ],
      "id": "123187b7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "solver = NewtonSolver(domain.comm, problem)\n",
        "\n",
        "# Set Newton solver options\n",
        "solver.atol = 1e-8\n",
        "solver.rtol = 1e-8\n",
        "solver.convergence_criterion = \"incremental\""
      ],
      "id": "8c0a273c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We define a function to plot the solution at each time step"
      ],
      "id": "fa77d223"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "results_folder = Path(\"fenicsx/hyperelasticity\")\n",
        "results_folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "plotter = pyvista.Plotter(off_screen=True)\n",
        "plotter.open_gif(results_folder/\"deformation.gif\", fps=3)\n",
        "\n",
        "topology, cells, geometry = plot.vtk_mesh(u.function_space)\n",
        "function_grid = pyvista.UnstructuredGrid(topology, cells, geometry)\n",
        "\n",
        "values = np.zeros((geometry.shape[0], 3))\n",
        "values[:, :len(u)] = u.x.array.reshape(geometry.shape[0], len(u))\n",
        "function_grid[\"u\"] = values\n",
        "function_grid.set_active_vectors(\"u\")\n",
        "\n",
        "# Warp mesh by deformation\n",
        "warped = function_grid.warp_by_vector(\"u\", factor=1)\n",
        "warped.set_active_vectors(\"u\")\n",
        "\n",
        "# Add mesh to plotter and visualize\n",
        "actor = plotter.add_mesh(\n",
        "  warped, \n",
        "  show_edges=True, \n",
        "  lighting=False, \n",
        "  clim=[0, 10],\n",
        "  scalar_bar_args={\"vertical\": True},\n",
        ")\n",
        "\n",
        "# Compute magnitude of displacement to visualize in GIF\n",
        "Vs = fem.functionspace(domain, (\"Lagrange\", 2))\n",
        "magnitude = fem.Function(Vs)\n",
        "\n",
        "us = fem.Expression(\n",
        "  ufl.sqrt(sum([u[i]**2 for i in range(len(u))])), \n",
        "  Vs.element.interpolation_points()\n",
        ")\n",
        "magnitude.interpolate(us)\n",
        "warped[\"mag\"] = magnitude.x.array"
      ],
      "id": "f5788678",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Finally, we solve the problem over multiple time steps, updating the traction in the z-direction"
      ],
      "id": "d3d6a08d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "log.set_log_level(log.LogLevel.INFO)\n",
        "\n",
        "tval0 = -1.5\n",
        "for n in range(1, 10):\n",
        "    T.value[2] = n *tval0\n",
        "    \n",
        "    num_its, converged = solver.solve(u)\n",
        "    assert (converged)\n",
        "    u.x.scatter_forward()\n",
        "    print(f\"Time step {n}, Number of iterations {num_its}, Load {T.value}\")\n",
        "    function_grid[\"u\"][:, :len(u)] = u.x.array.reshape(geometry.shape[0], len(u))\n",
        "    \n",
        "    magnitude.interpolate(us)\n",
        "    \n",
        "    warped.set_active_scalars(\"mag\")\n",
        "    warped_n = function_grid.warp_by_vector(factor=1)\n",
        "    warped.points[:, :] = warped_n.points\n",
        "    warped.point_data[\"mag\"][:] = magnitude.x.array\n",
        "    \n",
        "    plotter.update_scalar_bar_range([0, 10])\n",
        "    plotter.write_frame()\n",
        "\n",
        "plotter.close()\n",
        "\n",
        "log.set_log_level(log.LogLevel.WARNING)"
      ],
      "id": "74d1289c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![](fenicsx/hyperelasticity/deformation.gif)\n",
        "\n",
        "---\n",
        "jupyter: fenicsx\n",
        "---\n",
        "\n",
        "### The Helmholtz equation {#sec-fenicsx-helmholtz}\n",
        "\n",
        "Author: Antonio Baiano Svizzero \n",
        "\n",
        "The study of computational acoustics is essential in fields such as noise, vibration, and harshness (NVH), noise control, and acoustic design. In this section, we focus on the theoretical foundations of the Helmholtz equation—which is valid for noise problems with harmonic time dependence—and its implementation in `FEniCSx` to compute the sound pressure in arbitrary acoustic systems\n",
        "\n",
        "**The PDE problem**\n",
        "\n",
        "The acoustic Helmholtz equation in its general form reads\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "\\nabla^2 p + k^2 p = -j \\omega \\rho_0 q \\quad\\text{in } \\Omega\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "where $p$ is the complex acoustic pressure, $k$ the wavenumber, $\\omega$ the angular frequency, $j$ the imaginary unit, and $q$ the volume velocity ($\\mathrm{m^3/s}$) of a generic source field. In the case of a monopole source, $q$ can be written as\n",
        "\n",
        "$$q = Q \\, \\delta(x_s, y_s, z_s)$$\n",
        "\n",
        "where $\\delta(x_s, y_s, z_s)$ is the three-dimensional Dirac delta function centered at the monopole location. This formulation allows the computation of the sound pressure field generated by any generic source distribution, while the monopole source provides a simple yet fundamental example for analytical and numerical studies in computational acoustics\n",
        "\n",
        "In order to solve this problem with real-valued solvers in `FEniCSx`, we split the complex pressure into its real and imaginary parts:\n",
        "\n",
        "$$p = p_r + j \\, p_i$$\n",
        "\n",
        "with $p_r$ and $p_i$ real-valued functions representing the real and imaginary components, respectively. Substituting this into the original equation and separating real and imaginary parts leads to two coupled real-valued PDEs:\n",
        "\n",
        "$$\\begin{aligned}\n",
        "\\nabla^2 p_r + k^2 p_r &= 0, \\\\\n",
        "\\nabla^2 p_i + k^2 p_i &= - \\omega \\, \\rho_0 \\, q,\n",
        "\\end{aligned}\n",
        "\\quad \\text{in } \\Omega$$\n",
        "\n",
        "After splitting the complex pressure $p = p_r + j\\, p_i$ into its real and imaginary parts, the boundary conditions are applied separately to $p_r$ and $p_i$:\n",
        "\n",
        "* Dirichlet BC:\n",
        "\n",
        "  $$p_r = \\Re(\\bar{p}), \\quad p_i = \\Im(\\bar{p}) \\quad \\text{on } \\partial\\Omega_p$$\n",
        "\n",
        "* Neumann BC:\n",
        "\n",
        "  $$\\frac{\\partial p_r}{\\partial n} = 0, \\quad\n",
        "    \\frac{\\partial p_i}{\\partial n} = - \\omega \\, \\rho_0 \\, \\bar{v}_n \\quad \\text{on } \\partial\\Omega_v$$\n",
        "\n",
        "* Robin BC:\n",
        "\n",
        "  $$\\frac{\\partial p_r}{\\partial n} = \n",
        "      \\frac{\\omega \\, \\rho_0}{\\bar{Z}} \\, p_i, \\quad\n",
        "    \\frac{\\partial p_i}{\\partial n} = -\\frac{\\omega \\, \\rho_0}{\\bar{Z}} \\, p_r \\quad \\text{on } \\partial\\Omega_Z$$\n",
        "\n",
        "where $\\bar{p}$ is the complex prescribed acoustic pressure at $\\partial\\Omega_p$,\n",
        "$\\bar{v}_n$ is the prescribed normal sound particle velocity at $\\partial\\Omega_v$, and\n",
        "$\\bar{Z}$ is the prescribed acoustic impedance at $\\partial\\Omega_Z$, with $n$ denoting the outward unit normal. In this context, the overbar notation is used to denote prescribed boundary quantities (known data) in order to distinguish them from the unknown fields. It should be emphasized that the overbar does not indicate a complex conjugate\n",
        "\n",
        "This formulation allows the use of real-valued solvers while fully accounting for the effect of complex-valued boundary conditions in the Helmholtz problem\n",
        "\n",
        "**Weak formulation in terms of real and imaginary parts**\n",
        "\n",
        "\\paragraph{Real–Imaginary split with complex impedance and complex normal velocity}\n",
        "Let the complex source be\n",
        "\n",
        "$$\n",
        "q = q_r + j\\,q_i,\n",
        "$$\n",
        "\n",
        "and let the (possibly complex) surface impedance and the prescribed normal velocity be\n",
        "\n",
        "$$\n",
        "\\bar Z = Z_r + j\\,Z_i,\\qquad \\bar v_n = v_{n,r} + j\\,v_{n,i},\n",
        "$$\n",
        "\n",
        "with $Z_r,Z_i,v_{n,r},v_{n,i}\\in\\mathbb{R}$. Define $\\Delta_Z = Z_r^2+Z_i^2$. Then\n",
        "\n",
        "$$\n",
        "\\frac{j\\,\\omega\\rho_0}{\\bar Z}\n",
        "= \\frac{\\omega\\rho_0}{\\Delta_Z}\\bigl(Z_i + j\\,Z_r\\bigr)\n",
        "$$\n",
        "\n",
        "Multiplying the complex Helmholtz equation by a real test function $v \\in \\hat V$  and separating real and imaginary parts yields the following two real variational problems.\n",
        "\n",
        "* Real part (for $p_r$):\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "\\int_{\\Omega} \\nabla p_r \\cdot \\nabla v \\,\\mathrm{d}x\n",
        "&- k^2 \\int_{\\Omega} p_r\\,v\\,\\mathrm{d}x\n",
        "+ \\frac{\\omega\\rho_0}{\\Delta_Z}\\int_{\\partial\\Omega_Z} \\bigl(Z_i p_r - Z_r p_i\\bigr)\\,v\\,\\mathrm{d}s \\\\\n",
        "=& -\\,\\omega\\rho_0\\int_{\\Omega} q_i\\,v\\,\\mathrm{d}x\n",
        "\\;+\\; \\omega\\rho_0\\int_{\\partial\\Omega_v} v_{n,i}\\,v\\,\\mathrm{d}s\n",
        "\\end{aligned}$$\n",
        "\n",
        "* Imaginary part (for $p_i$):\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "\\int_{\\Omega} \\nabla p_i \\cdot \\nabla v \\,\\mathrm{d}x\n",
        "&- k^2 \\int_{\\Omega} p_i\\,v\\,\\mathrm{d}x\n",
        "+ \\frac{\\omega\\rho_0}{\\Delta_Z}\\int_{\\partial\\Omega_Z} \\bigl(Z_r p_r + Z_i p_i\\bigr)\\,v\\,\\mathrm{d}s \\\\\n",
        "=& \\;\\omega\\rho_0\\int_{\\Omega} q_r\\,v\\,\\mathrm{d}x\n",
        "\\;-\\; \\omega\\rho_0\\int_{\\partial\\Omega_v} v_{n,r}\\,v\\,\\mathrm{d}s\n",
        "\\end{aligned}$$\n",
        "\n",
        "After solving these two coupled real systems for $p_r$ and $p_i$, the complex pressure is reconstructed as $p = p_r + \\mathrm{i}\\,p_i$, from which amplitude $|p|$, phase and derived quantities such as the Sound Pressure Level (SPL) can be computed\n",
        "\n",
        "In this section, you will learn how to:\n",
        "\n",
        "* Define acoustic velocity and impedance boundary conditions\n",
        "* Compute the acoustic sound pressure for multiple frequencies\n",
        "* Evaluate the SPL at a given microphone position\n",
        "\n",
        "**Test problem**\n",
        "\n",
        "As an example, we model a plane wave propagating through a tube.\n",
        "Although this is a basic test case, the code can be extended to more complex problems requiring velocity and impedance boundary conditions\n",
        "\n",
        "Finally, we create the mesh with `GMSH`, defining the physical groups for the velocity and impedance boundary conditions along with their respective tags"
      ],
      "id": "5722c227"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import gmsh\n",
        "\n",
        "# ---------------------------------\n",
        "# Create gmsh box and tag facets\n",
        "# ---------------------------------\n",
        "\n",
        "if not gmsh.isInitialized():\n",
        "  gmsh.initialize()\n",
        "\n",
        "# meshsize settings\n",
        "meshsize = 0.02\n",
        "gmsh.option.setNumber(\"Mesh.MeshSizeMin\", meshsize)\n",
        "gmsh.option.setNumber(\"Mesh.MeshSizeMax\", meshsize)\n",
        "\n",
        "# create geometry\n",
        "L = 1.0\n",
        "W = 0.1\n",
        "H = 0.1\n",
        "\n",
        "box = gmsh.model.occ.addBox(0, 0, 0, L, W, H)\n",
        "gmsh.model.occ.synchronize()\n",
        "\n",
        "# Remove any existing physical groups with the same (dim, tag)\n",
        "for dim, tag in gmsh.model.getPhysicalGroups():\n",
        "  if dim == gdim and tag == physical_tag:\n",
        "    gmsh.model.removePhysicalGroups([(dim, tag)])\n",
        "\n",
        "# get surfaces\n",
        "surfaces = gmsh.model.getEntities(dim=2)\n",
        "\n",
        "# tolerance for coordinate matching\n",
        "tol = 1e-6\n",
        "\n",
        "velocity_surfaces = []\n",
        "impedance_surfaces = []\n",
        "\n",
        "for (dim, tag) in surfaces:\n",
        "  com = gmsh.model.occ.getCenterOfMass(dim, tag)\n",
        "  x, y, z = com\n",
        "  if abs(x -0.0) < tol:      # x = 0 face\n",
        "    velocity_surfaces.append(tag)\n",
        "  elif abs(x -L) < tol:      # x = L face\n",
        "    impedance_surfaces.append(tag)\n",
        "\n",
        "# setup physical groups\n",
        "vol_tag = gmsh.model.addPhysicalGroup(3, [box], 1)\n",
        "gmsh.model.setPhysicalName(3, vol_tag, \"air_volume\")\n",
        "\n",
        "v_bc_tag = 2\n",
        "Z_bc_tag = 3\n",
        "\n",
        "if velocity_surfaces:\n",
        "  gmsh.model.addPhysicalGroup(2, velocity_surfaces, v_bc_tag)\n",
        "  gmsh.model.setPhysicalName(2, v_bc_tag, \"velocity_BC\") \n",
        "if impedance_surfaces:\n",
        "  gmsh.model.addPhysicalGroup(2, impedance_surfaces, Z_bc_tag) \n",
        "  gmsh.model.setPhysicalName(2, Z_bc_tag, \"impedance_BC\")\n",
        "\n",
        "# mesh generation\n",
        "gmsh.model.mesh.generate(dim=3)"
      ],
      "id": "ff7dc040",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We then import the mesh generated by `GMSH` with the `dolfinx.io.gmshio` function"
      ],
      "id": "ba748a52"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import csv\n",
        "from pathlib import Path\n",
        "\n",
        "import numpy as np\n",
        "import matplotlib.pyplot as plt\n",
        "import pyvista\n",
        "\n",
        "from mpi4py import MPI\n",
        "from dolfinx import (\n",
        "  fem,\n",
        "  io,\n",
        "  default_scalar_type,\n",
        "  geometry,\n",
        "  plot,\n",
        ")\n",
        "from dolfinx.fem.petsc import LinearProblem\n",
        "import ufl\n",
        "\n",
        "comm = MPI.COMM_WORLD\n",
        "rank = comm.rank\n",
        "\n",
        "mesh_data = io.gmshio.model_to_mesh(\n",
        "  gmsh.model, \n",
        "  comm, \n",
        "  0, \n",
        "  gdim=3\n",
        ")\n",
        "\n",
        "domain, _, facet_tags = mesh_data\n",
        "\n",
        "gmsh.finalize()"
      ],
      "id": "1b25b23b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We define the function space for the unknowns $p_r$ and $p_i$. We also specify the boundary integration measure $ds$ using `ufl`"
      ],
      "id": "a1dc379c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "V = fem.functionspace(domain, (\"Lagrange\", 1))\n",
        "ds = ufl.Measure(\"ds\", domain=domain, subdomain_data=facet_tags)"
      ],
      "id": "58b68a5a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "results_folder = Path(\"fenicsx/helmholtz\")\n",
        "results_folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "# Extract topology from mesh and create pyvista mesh\n",
        "topology, cell_types, x = plot.vtk_mesh(V)\n",
        "grid = pyvista.UnstructuredGrid(topology, cell_types, x)\n",
        "\n",
        "plotter = pyvista.Plotter(off_screen=True)\n",
        "plotter.add_mesh(grid, show_edges=True)\n",
        "plotter.add_axes()\n",
        "\n",
        "# if not pyvista.OFF_SCREEN:\n",
        "#     plotter.show()\n",
        "\n",
        "# HTML 저장\n",
        "plotter.export_html(results_folder/\"helmholtz_mesh.html\")"
      ],
      "id": "264a7ca9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/helmholtz/helmholtz_mesh.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\">\n",
        "</iframe>\n",
        "```\n",
        "\n",
        "**Boundary conditions**\n",
        "\n",
        "We impose a velocity boundary condition of $v_n = 1.0 \\times 10^{-5}$ at one end of the tube.\n",
        "For simplicity, we omit the point source in this example (although it could be included using [`scifem`](https://github.com/scientificcomputing/scifem)).\n",
        "At the opposite end of the tube, we prescribe an impedance $Z$ computed with the Delaney–Bazley model, assuming a layer of thickness $d = 0.01$ and a flow resistivity $\\sigma = 1.5 \\times 10^4$.\n",
        "This choice of impedance—corresponding to a plane wave propagating in free field—produces a solution without reflections\n",
        "\n",
        "The Delaney–Bazley model is used to compute the characteristic impedance and the wavenumber of the porous layer, which is treated as an equivalent fluid with complex-valued properties:\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "Z_c(\\omega) &= \\rho_0 c_0 \\left[1 + 0.0571 X^{-0.754} - j\\, 0.087 X^{-0.732}\\right] \\\\\n",
        "k_c(\\omega) &= \\frac{\\omega}{c_0} \\left[1 + 0.0978 X^{-0.700} - j\\, 0.189 X^{-0.595}\\right]\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "where $X = \\tfrac{\\rho_0 f}{\\sigma}$\n",
        "\n",
        "Using these values, we can compute the surface impedance.\n",
        "In the case of a rigid passive absorber mounted on a rigid wall, it is given by:\n",
        "\n",
        "$$\n",
        "Z_s = -j\\, Z_c \\cot(k_c d)\n",
        "$$\n",
        "\n",
        "Let’s create a function to calculate it"
      ],
      "id": "7f588328"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Air parameters\n",
        "rho0 = 1.225  # kg/m^3\n",
        "c = 340       # m/s\n",
        "p_ref = 2e-5\n",
        "\n",
        "# Wall parameters\n",
        "sigma = 1.5e4  # ***\n",
        "d = 0.01       # ***\n",
        "\n",
        "# Impedance calculation\n",
        "def delany_bazley_layer(f, rho0, c, sigma, d):\n",
        "  X = rho0 *f /sigma\n",
        "  Zc = rho0 *c *(1 +0.0571 *(X**-0.754) -1j *0.087 *(X**-0.732))\n",
        "  kc = 2 *np.pi *f /c *(1 +0.0978 *(X**-0.700) - 1j *0.189 *(X**-0.595))\n",
        "  Z_s = -1j *Zc *(1 /np.tan(kc *d))\n",
        "  return Z_s"
      ],
      "id": "3241d75d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We define the value of the normal velocity at the first end of the tube.\n",
        "Since we are going to compute a sound pressure spectrum, all frequency-dependent variables (i.e., $\\omega$, $k$, $Z_r$ and $Z_i$) need to be updated within the frequency loop.\n",
        "To enable this, we initialize them as `DOLFINx` constants"
      ],
      "id": "288ec7ae"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# sources (zero in this case)\n",
        "q_r = fem.Constant(domain, 0.0)\n",
        "q_i = fem.Constant(domain, 0.0)\n",
        "\n",
        "# velocity boundary condition (real part only here)\n",
        "v_nr = 1e-5  #***\n",
        "v_ni = 0.0\n",
        "\n",
        "# frequency-dependent variables\n",
        "omega = fem.Constant(domain, default_scalar_type(0))\n",
        "k = fem.Constant(domain, default_scalar_type(0))\n",
        "\n",
        "Z_r = fem.Constant(domain, default_scalar_type(0))\n",
        "Z_i = fem.Constant(domain, default_scalar_type(0))\n",
        "\n",
        "# probe point at center\n",
        "probe_points = np.array(\n",
        "  [[L/2.0, W/2.0, H/2.0]], \n",
        "  dtype=np.float64\n",
        ")\n",
        "coords = V.tabulate_dof_coordinates().reshape((-1, domain.geometry.dim))\n",
        "dof_indices = [\n",
        "  int(np.argmin(np.linalg.norm(coords -p, axis=1))) for p in probe_points\n",
        "]"
      ],
      "id": "2b111356",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Variational formulation**\n",
        "\n",
        "We can now write the variational formulation"
      ],
      "id": "196726ad"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "p_r = ufl.TrialFunction(V)\n",
        "p_i = ufl.TrialFunction(V)\n",
        "v = ufl.TestFunction(V)\n",
        "\n",
        "Delta_Z = Z_r**2 +Z_i**2\n",
        "coef = omega *rho0 /Delta_Z\n",
        "\n",
        "# bilinear forms\n",
        "a_r = ( \n",
        "  (ufl.inner(ufl.grad(p_r), ufl.grad(v)) -k**2 *p_r *v) *ufl.dx \n",
        "  +coef *(Z_i *p_r -Z_r *p_i) *v *ds(3)\n",
        ")\n",
        "\n",
        "a_i = (\n",
        "  (ufl.inner(ufl.grad(p_i), ufl.grad(v)) -k**2 *p_i *v) *ufl.dx\n",
        "  +coef *(Z_r *p_r +Z_i *p_i) *v *ds(3)\n",
        ")\n",
        "\n",
        "# RHS (velocity BC only)\n",
        "L_r = -omega *rho0 *q_i *v *ufl.dx +omega *rho0 *v_ni *v *ds(2)\n",
        "L_i =  omega *rho0 *q_r *v *ufl.dx -omega *rho0 *v_nr *v *ds(2)"
      ],
      "id": "719dbe80",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The `LinearProblem` class is used to set up the `PETSc` backend and assemble the system matrix and vector.\n",
        "The solution is stored in a `dolfinx.fem.Function`, `p_r_fun` and `p_i_fun`"
      ],
      "id": "ce7c096b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "p_r_fun = fem.Function(V)\n",
        "p_r_fun.name = \"p_real\"\n",
        "\n",
        "p_i_fun = fem.Function(V)\n",
        "p_i_fun.name = \"p_imag\"\n",
        "\n",
        "problem_r = LinearProblem(\n",
        "  a_r, L_r, u=p_r_fun,\n",
        "  petsc_options={\"ksp_type\": \"preonly\", \"pc_type\": \"lu\"}\n",
        ")\n",
        "problem_i = LinearProblem(\n",
        "  a_i, L_i, u=p_i_fun,\n",
        "  petsc_options={\"ksp_type\": \"preonly\", \"pc_type\": \"lu\"}\n",
        ")"
      ],
      "id": "7e357ff2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Frequency loop**\n",
        "\n",
        "Finally, we implement the frequency loop. In this step, the frequency-dependent variables are updated and the system is solved for each frequency"
      ],
      "id": "cd618250"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Output files\n",
        "xdmf_real = io.XDMFFile(comm, results_folder/\"p_real.xdmf\", \"w\")\n",
        "xdmf_imag = io.XDMFFile(comm, results_folder/\"p_imag.xdmf\", \"w\")\n",
        "xdmf_real.write_mesh(domain)\n",
        "xdmf_imag.write_mesh(domain)\n",
        "\n",
        "csv_file = results_folder/\"SPL_probes.csv\"\n",
        "if rank == 0:\n",
        "  with open(csv_file, \"w\", newline=\"\") as f_:\n",
        "    writer = csv.writer(f_)\n",
        "    writer.writerow([\"freq_Hz\", \"SPL_probe_center_dB\"])\n",
        "\n",
        "# Discrete frequency range\n",
        "freq = np.arange(10, 1000, 5)  # Hz\n",
        "SPL_all = []\n",
        "\n",
        "for f in freq:\n",
        "  omega.value = 2 *np.pi *f    \n",
        "  k.value = omega.value /c\n",
        "\n",
        "  Zs = delany_bazley_layer(f, rho0, c, sigma, d)\n",
        "  Z_r.value = Zs.real\n",
        "  Z_i.value = Zs.imag\n",
        "  \n",
        "  Delta_Z = Z_r**2 + Z_i**2\n",
        "  coef = omega *rho0 /Delta_Z\n",
        "\n",
        "  problem_r.solve()\n",
        "  problem_i.solve()\n",
        "\n",
        "  xdmf_real.write_function(p_r_fun, float(f))\n",
        "  xdmf_imag.write_function(p_i_fun, float(f))  \n",
        "\n",
        "  p_r_fun.x.scatter_forward()\n",
        "  p_i_fun.x.scatter_forward()\n",
        "\n",
        "  pr_vals = p_r_fun.x.array\n",
        "  pi_vals = p_i_fun.x.array\n",
        "  probe_SPLs = []\n",
        "  for idx in dof_indices:\n",
        "    pr = pr_vals[idx]\n",
        "    pi = pi_vals[idx]\n",
        "    p_complex = pr +1j *pi\n",
        "\n",
        "    spl_db = 20 *np.log10(np.abs(p_complex) /(np.sqrt(2) *p_ref))\n",
        "    probe_SPLs.append(spl_db)\n",
        "\n",
        "  all_probe_SPLs = comm.gather(probe_SPLs, root=0)\n",
        "  if rank == 0:\n",
        "    row = [float(f)] +all_probe_SPLs[0]\n",
        "    with open(csv_file, \"a\", newline=\"\") as f_:\n",
        "      csv.writer(f_).writerow(row)\n",
        "\n",
        "  SPL_all.append(probe_SPLs[0])\n",
        "  if rank == 0:\n",
        "    print(\n",
        "      f\"f: {f:.0f} Hz,\",\n",
        "      f\"|p|(probe): {10**(SPL_all[-1] /20) *np.sqrt(2) *p_ref:.3e} Pa,\",\n",
        "      f\"SPL: {SPL_all[-1]:.2f} dB\"\n",
        "    )\n",
        "\n",
        "xdmf_real.close()\n",
        "xdmf_imag.close()  "
      ],
      "id": "81746007",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "if rank == 0:\n",
        "  plt.figure(figsize=(6, 4))\n",
        "\n",
        "  plt.plot(freq, SPL_all, marker=\"o\")\n",
        "  \n",
        "  plt.xlabel(\"Frequency [Hz]\")\n",
        "  plt.ylabel(\"SPL [dB re 20 µPa]\")\n",
        "  plt.title(\"SPL at domain center (velocity-inlet, DBZ-impedance outlet)\")\n",
        "  plt.grid(True)\n",
        "  plt.tight_layout()\n",
        "  plt.savefig(results_folder/\"SPL_spectrum.png\", dpi=150)\n",
        "  \n",
        "  plt.show()"
      ],
      "id": "5c2dd6fa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "jupyter: fenicsx\n",
        "---\n",
        "\n",
        "### Adaptive mesh refinement with GMSH/FEniCSx {#sec-fenicsx-adaptive-mesh}\n",
        "\n",
        "In this section, we consider an adaptive mesh refinement method applied to the Laplace eigenvalue problem \n",
        "\n",
        "#### Solving the eigenvalue problem\n",
        "\n",
        "We consider the Laplace eigenvalue problem with adaptive mesh refinement. The finite element discretization is performed using `dolfinx`, while `PETSc/SLEPc` are used for the linear algebra and eigenvalue solver. The geometry is generated with `GMSH`\n",
        "\n",
        "**Problem definition**\n",
        "\n",
        "We study the Laplace eigenvalue problem:\n",
        "\n",
        "$$\n",
        "-\\Delta u = \\lambda u \\quad \\text{in } \\Omega,\n",
        "\\quad u = 0 \\quad \\text{on } \\partial\\Omega\n",
        "$$\n",
        "\n",
        "We use a variational formulation: find $(\\lambda, u) \\in \\mathbb{R} \\times V_h$ such that\n",
        "\n",
        "$$\n",
        "a(u, v) = \\lambda m(u, v), \\quad \\forall v \\in V_h\n",
        "$$\n",
        "\n",
        "with\n",
        "\n",
        "$$\n",
        "a(u, v) = \\int_\\Omega \\nabla u \\cdot \\nabla v \\, dx,\n",
        "\\quad\n",
        "m(u, v) = \\int_\\Omega u v \\, dx\n",
        "$$\n",
        "\n",
        "#### Adaptive mesh refinement\n",
        "\n",
        "Adaptive mesh refinement improves solution accuracy by selectively refining elements where errors are largest. Two common approaches for eigenvalue problems are gradient-based and residual-based error estimation\n",
        "\n",
        "**Gradient-based refinement**\n",
        "\n",
        "Uses the magnitude of the solution gradient as an error indicator:\n",
        "\n",
        "$$ \\eta_K = \\int_K |\\nabla u_h| \\, dx $$\n",
        "\n",
        "* Advantages\n",
        "\n",
        "  * Simple and computationally cheap\n",
        "  * Works well for smooth solutions\n",
        "  * Intuitive: large gradients suggest refinement needs\n",
        "\n",
        "* Limitations\n",
        "\n",
        "  * May over-refine in regions with naturally large gradients\n",
        "  * Doesn't account for actual PDE residual\n",
        "  * Less theoretically rigorous\n",
        "\n",
        "**Residual-based refinement**\n",
        "\n",
        "Uses the PDE residual and flux jumps across element boundaries:\n",
        "\n",
        "$$\\eta_K^2 = h_K^2 \\|R_K\\|_{L^2(K)}^2 + \\frac{1}{2} \\sum_{e \\in \\partial K} h_e \\|J_e\\|_{L^2(e)}^2$$​\n",
        "\n",
        "where $R_K = \\lambda_h u_h$  (interior residual) and $J_e = [\\nabla u_h \\cdot n]$ (flux jump) \n",
        "\n",
        "* Advantages\n",
        "\n",
        "  * Theoretically rigorous error bound\n",
        "  * Accounts for both interior and boundary contributions\n",
        "  * Better handles singularities and discontinuities\n",
        "  * More efficient refinement strategy\n",
        "\n",
        "* Limitations\n",
        "\n",
        "  * More complex implementation\n",
        "  * Higher computational cost\n",
        "  * Requires careful treatment of jumps\n",
        "\n",
        "**Implementation tips**\n",
        "\n",
        "  * Threshold selection: Use percentile-based marking (e.g., top 25%)\n",
        "  * Scaling: Residual estimator naturally scales with mesh size\n",
        "  * Stability: Ensure non-negative error indicators\n",
        "  * Convergence: Monitor eigenvalue changes across refinement levels\n",
        "\n",
        "Both methods provide effective adaptive strategies, with residual-based estimation offering superior theoretical foundations at the cost of implementation complexity\n",
        "\n",
        "#### Implementation\n",
        "\n",
        "We begin by importing the necessary packages:"
      ],
      "id": "95c0bad3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from pathlib import Path\n",
        "from mpi4py import MPI\n",
        "from petsc4py import PETSc\n",
        "from slepc4py import SLEPc\n",
        "import pyvista\n",
        "import gmsh\n",
        "\n",
        "from dolfinx import fem, mesh, plot, default_scalar_type\n",
        "from dolfinx.fem.petsc import assemble_matrix, assemble_vector  # fenicsx 0.9.0\n",
        "from dolfinx.mesh import create_unit_square, locate_entities_boundary, refine\n",
        "from dolfinx.io import gmshio, XDMFFile\n",
        "import ufl"
      ],
      "id": "9a579fe7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "In this section, we’ll go through a complete workflow for generating, converting, and visualizing 2D meshes—specifically a square, an L-shaped domain, and a Pac-Man shape—using GMSH, FEniCSx, and PyVista.\n",
        "\n",
        "Once the meshes are ready, we’ll set up a helper function that solves the eigenvalue problem with `SLEPc` on a discretized domain.\n",
        "\n",
        "Next, we’ll run the adaptive mesh refinement (AMR) algorithm. To make visualization easier, we’ll also add a helper function that attaches the relevant data to the plotter at each refinement step.\n",
        "\n",
        "Finally, we’ll set up some parameters to check the convergence of the algorithm"
      ],
      "id": "c4ed081b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class AdaptiveLaplaceEigenSolver:\n",
        "    \"\"\"\n",
        "    Adaptive Laplace eigenvalue solver with visualization\n",
        "    \"\"\"\n",
        "    \n",
        "    def __init__(self, domain_type=\"unit_square\", initial_mesh_size=0.1):\n",
        "        self.domain_type = domain_type\n",
        "        self.initial_mesh_size = initial_mesh_size\n",
        "        self.mesh = None\n",
        "        self.V = None\n",
        "\n",
        "        self.eigenvalues = []\n",
        "        self.eigenfunctions = []\n",
        "\n",
        "        self.results_folder = Path(\"fenicsx/adaptive_mesh_refinement\")\n",
        "        self.results_folder.mkdir(exist_ok=True, parents=True)\n",
        "        \n",
        "        print(f\"Initialized solver for {domain_type} domain\")\n",
        "        \n",
        "    def create_domain(self):\n",
        "        \"\"\"Create computational domain\"\"\"\n",
        "        if self.domain_type == \"unit_square\":\n",
        "            self.mesh = create_unit_square(MPI.COMM_WORLD, 20, 20, mesh.CellType.triangle)\n",
        "            print(f\"Created unit square: {self._count_n_cells()} cells\")\n",
        "            \n",
        "        elif self.domain_type == \"l_shape\":\n",
        "            self._create_l_shape_domain()\n",
        "            \n",
        "        elif self.domain_type == \"pacman\":\n",
        "            self._create_pacman_domain()\n",
        "            \n",
        "        else:\n",
        "            raise ValueError(f\"Unknown domain type: {self.domain_type}\")\n",
        "\n",
        "    def _count_n_cells(self):\n",
        "        return self.mesh.topology.index_map(2).size_global\n",
        "    \n",
        "    def _create_l_shape_domain(self):\n",
        "        \"\"\"Create L-shaped domain using GMSH\"\"\"\n",
        "        gmsh.initialize()\n",
        "        gmsh.model.add(\"l_shape\")\n",
        "        \n",
        "        try:\n",
        "            # Create L-shape\n",
        "            rect1 = gmsh.model.occ.addRectangle(0, 0, 0, 1, 1)\n",
        "            rect2 = gmsh.model.occ.addRectangle(0, 1, 0, 1, 1)\n",
        "            rect3 = gmsh.model.occ.addRectangle(1, 0, 0, 1, 1)\n",
        "            \n",
        "            # Fuse rectangles\n",
        "            fused1, _ = gmsh.model.occ.fuse([(2, rect1)], [(2, rect2)])\n",
        "            fused2, _ = gmsh.model.occ.fuse(fused1, [(2, rect3)])\n",
        "            \n",
        "            gmsh.model.occ.synchronize()\n",
        "            \n",
        "            # Add physical groups\n",
        "            surfaces = gmsh.model.getEntities(2)\n",
        "            if surfaces:\n",
        "                gmsh.model.addPhysicalGroup(2, [s[1] for s in surfaces], 1)\n",
        "                gmsh.model.setPhysicalName(2, 1, \"LDomain\")\n",
        "            \n",
        "            # Set mesh size\n",
        "            gmsh.option.setNumber(\"Mesh.CharacteristicLengthMin\", self.initial_mesh_size * 0.5)\n",
        "            gmsh.option.setNumber(\"Mesh.CharacteristicLengthMax\", self.initial_mesh_size * 2.0)\n",
        "            gmsh.model.mesh.generate(2)\n",
        "            \n",
        "            # Convert to dolfinx\n",
        "            self.mesh, ct, ft = gmshio.model_to_mesh(gmsh.model, MPI.COMM_WORLD, 0, gdim=2)\n",
        "            \n",
        "        finally:\n",
        "            gmsh.finalize()\n",
        "            \n",
        "        print(f\"Created L-shape: {self._count_n_cells()} cells\")\n",
        "    \n",
        "    def _create_pacman_domain(self):\n",
        "        \"\"\"Create Pac-Man domain using GMSH\"\"\"\n",
        "        gmsh.initialize()\n",
        "        gmsh.model.add(\"pacman\")\n",
        "        \n",
        "        try:\n",
        "            # Create Pac-Man shape\n",
        "            disk = gmsh.model.occ.addDisk(0, 0, 0, 1.0, 1.0)\n",
        "            \n",
        "            # Create mouth triangle\n",
        "            angle_rad = np.radians(30)  # 30-degree mouth opening\n",
        "            mouth_length = 1.2\n",
        "            \n",
        "            p1 = gmsh.model.occ.addPoint(0, 0, 0)\n",
        "            p2 = gmsh.model.occ.addPoint(mouth_length * np.cos(angle_rad), \n",
        "                                       mouth_length * np.sin(angle_rad), 0)\n",
        "            p3 = gmsh.model.occ.addPoint(mouth_length * np.cos(-angle_rad), \n",
        "                                       mouth_length * np.sin(-angle_rad), 0)\n",
        "            \n",
        "            l1 = gmsh.model.occ.addLine(p1, p2)\n",
        "            l2 = gmsh.model.occ.addLine(p2, p3)  \n",
        "            l3 = gmsh.model.occ.addLine(p3, p1)\n",
        "            \n",
        "            mouth_loop = gmsh.model.occ.addCurveLoop([l1, l2, l3])\n",
        "            mouth_surface = gmsh.model.occ.addPlaneSurface([mouth_loop])\n",
        "            \n",
        "            # Cut mouth from disk\n",
        "            pacman, _ = gmsh.model.occ.cut([(2, disk)], [(2, mouth_surface)])\n",
        "            \n",
        "            gmsh.model.occ.synchronize()\n",
        "            \n",
        "            # Add physical groups\n",
        "            if pacman:\n",
        "                dim, tag = pacman[0]\n",
        "                gmsh.model.addPhysicalGroup(dim, [tag], 1)\n",
        "                gmsh.model.setPhysicalName(dim, 1, \"PacmanDomain\")\n",
        "            \n",
        "            # Set mesh options\n",
        "            gmsh.option.setNumber(\"Mesh.CharacteristicLengthMin\", self.initial_mesh_size * 0.5)\n",
        "            gmsh.option.setNumber(\"Mesh.CharacteristicLengthMax\", self.initial_mesh_size * 2.0)\n",
        "            gmsh.option.setNumber(\"Mesh.Algorithm\", 6)  # Frontal-Delaunay\n",
        "            gmsh.model.mesh.generate(2)\n",
        "            \n",
        "            # Convert to dolfinx\n",
        "            self.mesh, ct, ft = gmshio.model_to_mesh(gmsh.model, MPI.COMM_WORLD, 0, gdim=2)\n",
        "            \n",
        "        finally:\n",
        "            gmsh.finalize()\n",
        "            \n",
        "        print(f\"Created Pac-Man: {self._count_n_cells()} cells\")\n",
        "    \n",
        "    def solve_eigenvalue_problem(self, n_eigenvalues=6):\n",
        "        \"\"\"Solve eigenvalue problem on current mesh\"\"\"\n",
        "        # Create function space\n",
        "        self.V = fem.functionspace(self.mesh, (\"Lagrange\", 1))\n",
        "        \n",
        "        # Define variational forms\n",
        "        u = ufl.TrialFunction(self.V)\n",
        "        v = ufl.TestFunction(self.V)\n",
        "        \n",
        "        a = ufl.inner(ufl.grad(u), ufl.grad(v)) * ufl.dx  # Stiffness\n",
        "        m = ufl.inner(u, v) * ufl.dx                      # Mass\n",
        "        \n",
        "        # Apply homogeneous Dirichlet boundary conditions\n",
        "        boundary_facets = locate_entities_boundary(\n",
        "            self.mesh, self.mesh.topology.dim-1, \n",
        "            lambda x: np.ones(x.shape[1], dtype=bool)  # All boundary\n",
        "        )\n",
        "        boundary_dofs = fem.locate_dofs_topological(self.V, self.mesh.topology.dim-1, boundary_facets)\n",
        "        bc = fem.dirichletbc(default_scalar_type(0.0), boundary_dofs, self.V)\n",
        "        \n",
        "        # Assemble matrices\n",
        "        A = assemble_matrix(fem.form(a), bcs=[bc])\n",
        "        A.assemble()\n",
        "        M = assemble_matrix(fem.form(m), bcs=[bc])\n",
        "        M.assemble()\n",
        "        \n",
        "        # Solve using shift-invert\n",
        "        eps = SLEPc.EPS().create(MPI.COMM_WORLD)\n",
        "        eps.setOperators(A, M)\n",
        "        eps.setProblemType(SLEPc.EPS.ProblemType.GHEP)\n",
        "        \n",
        "        # Set shift based on domain type\n",
        "        if self.domain_type == \"unit_square\":\n",
        "            shift = 15.0\n",
        "        elif self.domain_type == \"l_shape\":\n",
        "            shift = 2.0\n",
        "        elif self.domain_type == \"pacman\":\n",
        "            shift = 3.0\n",
        "        \n",
        "        st = eps.getST()\n",
        "        st.setType(SLEPc.ST.Type.SINVERT)\n",
        "        st.setShift(shift)\n",
        "        \n",
        "        eps.setWhichEigenpairs(SLEPc.EPS.Which.TARGET_MAGNITUDE)\n",
        "        eps.setTarget(shift)\n",
        "        eps.setDimensions(n_eigenvalues + 3)\n",
        "        eps.setTolerances(1e-10, 3000)\n",
        "        eps.setType(SLEPc.EPS.Type.KRYLOVSCHUR)\n",
        "        \n",
        "        eps.solve()\n",
        "        \n",
        "        # Extract results\n",
        "        nconv = eps.getConverged()\n",
        "        results = []\n",
        "        \n",
        "        for i in range(nconv):\n",
        "            eigenval = eps.getEigenvalue(i).real\n",
        "            if eigenval > shift * 0.8:  # Filter based on shift\n",
        "                eigenvec = fem.Function(self.V)\n",
        "                eps.getEigenvector(i, eigenvec.x.petsc_vec)\n",
        "                eigenvec.x.scatter_forward()\n",
        "                \n",
        "                # Normalize\n",
        "                norm = np.sqrt(eigenvec.x.petsc_vec.dot(eigenvec.x.petsc_vec))\n",
        "                if norm > 1e-12:\n",
        "                    eigenvec.x.petsc_vec.scale(1.0 / norm)\n",
        "                \n",
        "                results.append((eigenval, eigenvec))\n",
        "        \n",
        "        # Sort and store results\n",
        "        results.sort(key=lambda x: x[0])\n",
        "        self.eigenvalues = [r[0] for r in results[:n_eigenvalues]]\n",
        "        self.eigenfunctions = [r[1] for r in results[:n_eigenvalues]]\n",
        "        \n",
        "        # Cleanup\n",
        "        eps.destroy()\n",
        "        A.destroy()\n",
        "        M.destroy()\n",
        "        \n",
        "        return self.eigenvalues, self.eigenfunctions\n",
        "    \n",
        "    def gradient_estimate_error(self, eigenfunction, eigenvalue):\n",
        "        \"\"\"\n",
        "        Estimate error using gradient-based indicator\n",
        "        \"\"\"\n",
        "        # Create DG0 space for error indicators\n",
        "        W = fem.functionspace(self.mesh, (\"DG\", 0))\n",
        "        error_indicator = fem.Function(W)\n",
        "        \n",
        "        # Compute gradient magnitude as error indicator\n",
        "        u_dg = ufl.TrialFunction(W)        \n",
        "        v_dg = ufl.TestFunction(W)\n",
        "  \n",
        "        grad_u = ufl.grad(eigenfunction)\n",
        "        grad_norm_expr = ufl.sqrt(ufl.inner(grad_u, grad_u))\n",
        "        \n",
        "        # Project gradient norm to DG0\n",
        "        a_proj = ufl.inner(u_dg, v_dg) * ufl.dx\n",
        "        L_proj = ufl.inner(grad_norm_expr, v_dg) * ufl.dx\n",
        "        \n",
        "        A_proj = assemble_matrix(fem.form(a_proj))\n",
        "        A_proj.assemble()\n",
        "        b_proj = assemble_vector(fem.form(L_proj))\n",
        "        b_proj.assemble()\n",
        "        \n",
        "        # Solve projection\n",
        "        solver = PETSc.KSP().create()\n",
        "        solver.setOperators(A_proj)\n",
        "        solver.setType(PETSc.KSP.Type.CG)\n",
        "        solver.solve(b_proj, error_indicator.x.petsc_vec)\n",
        "        \n",
        "        A_proj.destroy()\n",
        "        b_proj.destroy()\n",
        "        solver.destroy()\n",
        "        \n",
        "        return error_indicator.x.array\n",
        "\n",
        "    def residual_estimate_error(self, eigenfunction, eigenvalue):\n",
        "        \"\"\"\n",
        "        Residual-based error estimator for eigenvalue problems\n",
        "        \n",
        "        η_K² = h_K² ||R_K||²_L²(K) + (1/2) Σ h_e ||J_e||²_L²(e)\n",
        "        \n",
        "        where:\n",
        "        - R_K = λ_h u_h (interior residual, since -Δu_h = λ_h u_h)\n",
        "        - J_e = [∇u_h · n] (jump in normal flux across interior facets)\n",
        "        - h_K = cell diameter, h_e = facet size\n",
        "        \"\"\"\n",
        "        # Create DG0 space for error indicators\n",
        "        W = fem.functionspace(self.mesh, (\"DG\", 0))\n",
        "        error_indicator = fem.Function(W)\n",
        "        \n",
        "        # Define test function and cell/facet measures\n",
        "        w = ufl.TestFunction(W)\n",
        "        h_K = ufl.CellDiameter(self.mesh)\n",
        "        h_e = ufl.FacetArea(self.mesh)  # In 2D, this gives edge length\n",
        "        n = ufl.FacetNormal(self.mesh)\n",
        "        \n",
        "        # Interior residual: R_K = λ_h * u_h \n",
        "        # (since the strong form is -Δu = λu, the residual is λu when Δu ≈ 0)\n",
        "        R_K = eigenvalue * eigenfunction\n",
        "        \n",
        "        # Jump in normal flux: J_e = [∇u_h · n]\n",
        "        grad_u = ufl.grad(eigenfunction)\n",
        "        flux_jump = ufl.jump(grad_u, n)  # Jump across interior facets\n",
        "        \n",
        "        # Residual-based error estimator\n",
        "        # Interior contribution: h_K² ||R_K||²\n",
        "        interior_contrib = h_K**2 * R_K**2 * w * ufl.dx\n",
        "        \n",
        "        # Boundary contribution: (1/2) h_e ||J_e||²  \n",
        "        # Note: ufl.dS integrates over interior facets only\n",
        "        boundary_contrib = 0.5 * h_e * flux_jump**2 * ufl.avg(w) * ufl.dS\n",
        "        \n",
        "        # Total error estimator\n",
        "        error_form = interior_contrib + boundary_contrib\n",
        "        \n",
        "        # Assemble the error estimator\n",
        "        error_vector = assemble_vector(fem.form(error_form))\n",
        "        error_vector.assemble()\n",
        "        \n",
        "        # Extract local error indicators and take square root\n",
        "        # (since we computed η_K², we need sqrt to get η_K)\n",
        "        error_indicators_squared = error_vector.array\n",
        "        error_indicators = np.sqrt(np.maximum(error_indicators_squared, 0.0))  # Ensure non-negative\n",
        "        \n",
        "        return error_indicators        \n",
        "    \n",
        "    def adaptive_refinement(self, err_estimator='residual', n_iterations=4, refinement_fraction=0.25, n_eigenvalues=6):\n",
        "        \"\"\"\n",
        "        Perform adaptive mesh refinement\n",
        "        \"\"\"\n",
        "        print(f\"\\n{'='*60}\")\n",
        "        print(f\"ADAPTIVE REFINEMENT for {self.domain_type.upper()}\")\n",
        "        print(f\"{'='*60}\")\n",
        "        \n",
        "        refinement_history = []\n",
        "        \n",
        "        for iteration in range(n_iterations):\n",
        "            print(f\"\\n--- Iteration {iteration + 1}/{n_iterations} ---\")\n",
        "            \n",
        "            # Solve eigenvalue problem\n",
        "            eigenvalues, eigenfunctions = self.solve_eigenvalue_problem(n_eigenvalues)\n",
        "            \n",
        "            print(f\"Mesh: {self._count_n_cells()} cells, \"\n",
        "                  f\"DOFs: {self.V.dofmap.index_map.size_global}\")\n",
        "            \n",
        "            # Display first few eigenvalues\n",
        "            for i, eigenval in enumerate(eigenvalues[:3]):\n",
        "                print(f\"λ_{i+1} = {eigenval:.6f}\")\n",
        "            \n",
        "            # Save current results\n",
        "            self.save_iteration_results(iteration)\n",
        "            \n",
        "            # Estimate error for first eigenfunction\n",
        "            if eigenfunctions:\n",
        "\n",
        "                if err_estimator == 'residual':\n",
        "                    error_indicators = self.residual_estimate_error(eigenfunctions[0], eigenvalues[0])\n",
        "                elif err_estimator == 'gradient':\n",
        "                    error_indicators = self.gradient_estimate_error(eigenfunctions[0], eigenvalues[0])\n",
        "                \n",
        "                # Mark cells for refinement\n",
        "                threshold = np.percentile(error_indicators, (1 - refinement_fraction) * 100)\n",
        "                cells_to_refine = np.where(error_indicators > threshold)[0]\n",
        "                \n",
        "                print(f\"Refining {len(cells_to_refine)} cells (threshold: {threshold:.3f})\")\n",
        "                \n",
        "                if len(cells_to_refine) == 0:\n",
        "                    print(\"No cells to refine, stopping.\")\n",
        "                    break\n",
        "                \n",
        "                # Store history\n",
        "                refinement_history.append({\n",
        "                    'iteration': iteration + 1,\n",
        "                    'n_cells': self._count_n_cells(),\n",
        "                    'n_dofs': self.V.dofmap.index_map.size_global,\n",
        "                    'eigenvalues': eigenvalues.copy(),\n",
        "                    'error_max': error_indicators.max(),\n",
        "                    'error_mean': error_indicators.mean()\n",
        "                })\n",
        "                \n",
        "                # Refine mesh\n",
        "                if iteration < n_iterations - 1:  # Don't refine on last iteration\n",
        "                    refined_result = refine(self.mesh, cells_to_refine)\n",
        "                    # In dolfinx 0.9.0, refine may return a tuple (mesh, cell_map, vertex_map, facet_map)\n",
        "                    if isinstance(refined_result, tuple):\n",
        "                        self.mesh = refined_result[0]  # Extract just the mesh\n",
        "                    else:\n",
        "                        self.mesh = refined_result\n",
        "        \n",
        "        # Final solve and save\n",
        "        final_eigenvalues, final_eigenfunctions = self.solve_eigenvalue_problem(n_eigenvalues)\n",
        "        self.save_final_results()\n",
        "        self.print_convergence_summary(refinement_history)\n",
        "        \n",
        "        return refinement_history\n",
        "    \n",
        "    def save_iteration_results(self, iteration):\n",
        "        \"\"\"Save results for current iteration\"\"\"\n",
        "        if not self.eigenvalues or not self.eigenfunctions:\n",
        "            return\n",
        "            \n",
        "        # Save eigenvalues\n",
        "        eigenval_file = self.results_folder / f\"{self.domain_type}_eigenvalues_iter_{iteration}.txt\"\n",
        "        np.savetxt(eigenval_file, self.eigenvalues)\n",
        "        \n",
        "        # Save eigenfunctions to XDMF\n",
        "        try:\n",
        "            xdmf_file = self.results_folder / f\"{self.domain_type}_eigenfunctions_iter_{iteration}.xdmf\"\n",
        "            with XDMFFile(self.mesh.comm, xdmf_file, \"w\") as file:\n",
        "                file.write_mesh(self.mesh)\n",
        "                for i, u in enumerate(self.eigenfunctions[:3]):\n",
        "                    u.name = f\"eigenmode_{i+1}\"\n",
        "                    file.write_function(u)\n",
        "        except Exception as e:\n",
        "            print(f\"Could not save XDMF for iteration {iteration}: {e}\")\n",
        "    \n",
        "    def save_final_results(self):\n",
        "        \"\"\"Save final results\"\"\"\n",
        "        if not self.eigenvalues or not self.eigenfunctions:\n",
        "            return\n",
        "            \n",
        "        # Save final eigenvalues\n",
        "        final_eigenval_file = self.results_folder / f\"{self.domain_type}_final_eigenvalues.txt\"\n",
        "        np.savetxt(final_eigenval_file, self.eigenvalues)\n",
        "        \n",
        "        # Save final eigenfunctions\n",
        "        try:\n",
        "            final_xdmf_file = self.results_folder / f\"{self.domain_type}_final_eigenfunctions.xdmf\"\n",
        "            with XDMFFile(self.mesh.comm, final_xdmf_file, \"w\") as file:\n",
        "                file.write_mesh(self.mesh)\n",
        "                for i, u in enumerate(self.eigenfunctions):\n",
        "                    u.name = f\"final_eigenmode_{i+1}\"\n",
        "                    file.write_function(u)\n",
        "        except Exception as e:\n",
        "            print(f\"Could not save final XDMF: {e}\")\n",
        "    \n",
        "    def visualize_eigenmodes(self, max_modes=4, save_html=True, save_png=True):\n",
        "        \"\"\"\n",
        "        Create beautiful visualizations of eigenmodes using PyVista\n",
        "        \"\"\"\n",
        "        if not self.eigenfunctions:\n",
        "            print(\"No eigenfunctions to visualize\")\n",
        "            return\n",
        "        \n",
        "        print(f\"\\nCreating visualizations for {len(self.eigenfunctions)} eigenmodes...\")\n",
        "        \n",
        "        for i, (eigenval, eigenfunction) in enumerate(zip(self.eigenvalues[:max_modes], \n",
        "                                                         self.eigenfunctions[:max_modes])):\n",
        "            try:\n",
        "                # Create PyVista grid\n",
        "                topology, cell_types, geometry = plot.vtk_mesh(self.V)\n",
        "                grid = pyvista.UnstructuredGrid(topology, cell_types, geometry)\n",
        "                grid.point_data[\"Eigenfunction\"] = eigenfunction.x.array.real\n",
        "                \n",
        "                # Create beautiful plot\n",
        "                plotter = pyvista.Plotter(off_screen=True, window_size=(1200, 800))\n",
        "                \n",
        "                # Add mesh with scalar field\n",
        "                mesh_actor = plotter.add_mesh(\n",
        "                    grid, \n",
        "                    scalars=\"Eigenfunction\",\n",
        "                    cmap=\"RdBu_r\",\n",
        "                    show_edges=True,\n",
        "                    scalar_bar_args={\n",
        "                        'title': f'Mode {i+1}\\n',\n",
        "                        'title_font_size': 14,\n",
        "                        'label_font_size': 13,\n",
        "                        'n_labels': 5,\n",
        "                        'width': 0.6,\n",
        "                        'height': 0.05,\n",
        "                        'position_x': 0.2,\n",
        "                        'position_y': 0.02\n",
        "                    }\n",
        "                )\n",
        "                \n",
        "                # Set camera and lighting\n",
        "                plotter.view_xy()\n",
        "                plotter.camera.zoom(1.1)\n",
        "                \n",
        "                # Add title\n",
        "                plotter.add_text(\n",
        "                    f'{self.domain_type.replace(\"_\", \" \").title()}: lambda_{i+1} = {eigenval:.6f}',\n",
        "                    position='upper_left',\n",
        "                    font_size=14,\n",
        "                    color='black'\n",
        "                )\n",
        "                \n",
        "                # Add mesh info\n",
        "                plotter.add_text(\n",
        "                    f'\\n\\nCells: {self._count_n_cells()}, '\n",
        "                    f'DOFs: {self.V.dofmap.index_map.size_global}',\n",
        "                    position='upper_left',#'lower_right',\n",
        "                    font_size=9,\n",
        "                    color='gray'\n",
        "                )\n",
        "                \n",
        "                # Save visualizations\n",
        "                if save_html:\n",
        "                    html_file = self.results_folder / f\"{self.domain_type}_mode_{i+1}.html\"\n",
        "                    plotter.export_html(html_file)\n",
        "                \n",
        "                if save_png:\n",
        "                    png_file = self.results_folder / f\"{self.domain_type}_mode_{i+1}.png\"\n",
        "                    plotter.screenshot(png_file, transparent_background=True)\n",
        "                \n",
        "                print(f\"✓ Saved visualizations for mode {i+1}\")\n",
        "                \n",
        "            except Exception as e:\n",
        "                print(f\"✗ Visualization error for mode {i+1}: {e}\")\n",
        "    \n",
        "    def create_comparison_plot(self):\n",
        "        \"\"\"Create comparison plot of all eigenmodes\"\"\"\n",
        "        if len(self.eigenfunctions) < 4:\n",
        "            return\n",
        "            \n",
        "        try:\n",
        "            # Create 2x2 subplot\n",
        "            plotter = pyvista.Plotter(shape=(2, 2), off_screen=True, window_size=(1600, 1200))\n",
        "            \n",
        "            for i in range(min(4, len(self.eigenfunctions))):\n",
        "                eigenval = self.eigenvalues[i]\n",
        "                eigenfunction = self.eigenfunctions[i]\n",
        "                \n",
        "                # Create grid\n",
        "                topology, cell_types, geometry = plot.vtk_mesh(self.V)\n",
        "                grid = pyvista.UnstructuredGrid(topology, cell_types, geometry)\n",
        "                grid.point_data[\"Eigenfunction\"] = eigenfunction.x.array.real\n",
        "                \n",
        "                # Set subplot\n",
        "                row, col = divmod(i, 2)\n",
        "                plotter.subplot(row, col)\n",
        "                \n",
        "                plotter.add_mesh(\n",
        "                    grid,\n",
        "                    scalars=\"Eigenfunction\", \n",
        "                    cmap=\"RdBu_r\",\n",
        "                    show_edges=False,\n",
        "                    scalar_bar_args={\n",
        "                        'title': f'Mode {i+1}\\n',\n",
        "                        'title_font_size': 14,\n",
        "                        'label_font_size': 13,\n",
        "                    }                    \n",
        "                )\n",
        "                \n",
        "                plotter.add_text(\n",
        "                    f'lambda_{i+1} = {eigenval:.4f}', \n",
        "                    position='upper_left',\n",
        "                    font_size=14)\n",
        "                plotter.view_xy()\n",
        "                plotter.camera.zoom(0.95)\n",
        "            \n",
        "            # Save comparison\n",
        "            comparison_file = self.results_folder / f\"{self.domain_type}_comparison.png\"\n",
        "            plotter.screenshot(comparison_file)\n",
        "            \n",
        "            print(f\"✓ Saved comparison plot: {comparison_file}\")\n",
        "            \n",
        "        except Exception as e:\n",
        "            print(f\"✗ Comparison plot error: {e}\")\n",
        "    \n",
        "    def print_convergence_summary(self, history):\n",
        "        \"\"\"Print convergence summary\"\"\"\n",
        "        print(f\"\\n{'='*60}\")\n",
        "        print(f\"CONVERGENCE SUMMARY - {self.domain_type.upper()}\")\n",
        "        print(f\"{'='*60}\")\n",
        "        print(\"Iter | Cells | DOFs  | λ_1      | λ_2      | λ_3      | Error\")\n",
        "        print(\"-\" * 60)\n",
        "        \n",
        "        for h in history:\n",
        "            eigenvals = h['eigenvalues']\n",
        "            print(f\"{h['iteration']:4d} | {h['n_cells']:5d} | {h['n_dofs']:5d} | \"\n",
        "                  f\"{eigenvals[0]:8.4f} | {eigenvals[1]:8.4f} | {eigenvals[2]:8.4f} | \"\n",
        "                  f\"{h['error_max']:8.3e}\")\n",
        "        \n",
        "        if history:\n",
        "            final = history[-1]['eigenvalues']\n",
        "            print(f\"\\nFinal eigenvalues:\")\n",
        "            for i, eigenval in enumerate(final[:6]):\n",
        "                print(f\"  λ_{i+1} = {eigenval:.8f}\")"
      ],
      "id": "b486db7b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def run_complete_tests():\n",
        "    \"\"\"Run complete test suite with all domains\"\"\"\n",
        "    domains = [\"unit_square\", \"l_shape\", \"pacman\"]\n",
        "    \n",
        "    for domain in domains:\n",
        "        print(f\"\\n{'='*80}\")\n",
        "        print(f\"TESTING {domain.upper()} DOMAIN\")\n",
        "        print(f\"{'='*80}\")\n",
        "        \n",
        "        try:\n",
        "            # Create solver\n",
        "            solver = AdaptiveLaplaceEigenSolver(domain_type=domain, initial_mesh_size=0.1)\n",
        "            \n",
        "            # Create domain\n",
        "            solver.create_domain()\n",
        "            \n",
        "            # Run adaptive refinement\n",
        "            history = solver.adaptive_refinement(\n",
        "                err_estimator='residual', # or 'gradient'\n",
        "                n_iterations=4, \n",
        "                refinement_fraction=0.25, \n",
        "                n_eigenvalues=6\n",
        "            )\n",
        "            \n",
        "            # Create visualizations\n",
        "            print(f\"\\nCreating visualizations for {domain}...\")\n",
        "            solver.visualize_eigenmodes(max_modes=4)\n",
        "            solver.create_comparison_plot()\n",
        "            \n",
        "            print(f\"✓ {domain} test completed successfully!\")\n",
        "            \n",
        "        except Exception as e:\n",
        "            print(f\"✗ {domain} test failed: {e}\")\n",
        "            import traceback\n",
        "            traceback.print_exc()\n",
        "\n",
        "if __name__ == \"__main__\":\n",
        "    run_complete_tests()"
      ],
      "id": "ce2ae327",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![](fenicsx/adaptive_mesh_refinement/unit_square_comparison.png)\n",
        "\n",
        "```{=html}\n",
        "<iframe src=\"fenicsx/adaptive_mesh_refinement/unit_square_mode_1.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\">\n",
        "</iframe>\n",
        "```\n",
        "\n",
        "![](fenicsx/adaptive_mesh_refinement/l_shape_comparison.png)\n",
        "\n",
        "```{=html}\n",
        "<iframe src=\"fenicsx/adaptive_mesh_refinement/l_shape_mode_1.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\">\n",
        "</iframe>\n",
        "```\n",
        "\n",
        "![](fenicsx/adaptive_mesh_refinement/pacman_comparison.png)\n",
        "\n",
        "```{=html}\n",
        "<iframe src=\"fenicsx/adaptive_mesh_refinement/pacman_mode_1.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\">\n",
        "</iframe>\n",
        "```\n",
        "\n",
        "\n",
        "## Subdomains and boundary conditions\n",
        "\n",
        "### Combining Dirichlet and Neumann conditions\n",
        "\n",
        "Author: Jørgen S. Dokken\n",
        "\n",
        "Let us return to the Poisson problem and explore how to extend both the mathematical formulation and the implementation to handle a Dirichlet condition in combination with a Neumann condition.\n",
        "The domain is still the unit square, but this time we impose the Dirichlet condition `u = u_D` on the left and right boundaries, while the Neumann condition\n",
        "\n",
        "$$-\\frac{\\partial u}{\\partial n} = g$$\n",
        "\n",
        "is applied to the remaining boundaries, $y = 0$ and $y = 1$\n",
        "\n",
        "**The PDE problem**\n",
        "\n",
        "Let $\\Lambda_D$ and $\\Lambda_N$ denote the portions of the boundary $\\partial \\Omega$ where the Dirichlet and Neumann conditions are prescribed, respectively\n",
        "The full boundary-value problem is then given by\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "-\\nabla^2 u &= f \\quad \\text{in } \\Omega \\\\\n",
        "u &= u_D \\quad \\text{on } \\Lambda_D \\\\\n",
        "-\\frac{\\partial u}{\\partial n} &= g \\quad \\text{on } \\Lambda_N\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "As before, we choose $u = 1 + x^2 + 2y^2$ as the exact solution and then set $f$, $g$, and $u_D$ to match this choice\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "    f(x,y) &=-6 \\\\\n",
        "    g(x,y) &=\n",
        "    \\begin{cases}\n",
        "        \\phantom{-}0, & y=0\\\\\n",
        "        -4, & y=1\n",
        "    \\end{cases}\\\\\n",
        "    u_D(x,y) &=1+x^2+2y^2\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "To simplify the implementation, we define $g$ as a function over the whole domain \\Omega, making sure it has the correct values at $y=0$ and $y=1$. One possible choice is\n",
        "\n",
        "$$\n",
        " g(x,y)=-4y\n",
        "$$\n",
        "\n",
        "**The variational formulation**\n",
        "\n",
        "The first step is to derive the variational formulation. In this case, the boundary term resulting from integration by parts cannot be omitted, since $v$ vanishes only on $\\Lambda_D$. We obtain\n",
        "\n",
        "$$-\\int_\\Omega (\\nabla^2 u)\\, v \\,\\mathrm{d}x \\;=\\; \\int_\\Omega \\nabla u \\cdot \\nabla v \\,\\mathrm{d}x \\;-\\; \\int_{\\partial \\Omega}\\frac{\\partial u}{\\partial n} v \\,\\mathrm{d}s$$\n",
        "\n",
        "and because $v=0$ on $\\Lambda_D$, it follows that\n",
        "\n",
        "$$-\\int_{\\partial \\Omega}\\frac{\\partial u}{\\partial n} v \\,\\mathrm{d}s \\;=\\; - \\int_{\\Lambda_N}\\frac{\\partial u}{\\partial n} v \\,\\mathrm{d}s \\;=\\; \\int_{\\Lambda_N} g v \\,\\mathrm{d}s$$\n",
        "\n",
        "by applying the boundary condition on $\\Lambda_N$.\n",
        "The resulting weak form is therefore\n",
        "\n",
        "$$\\int_\\Omega \\nabla u \\cdot \\nabla v \\,\\mathrm{d}x \\;=\\; \\int_\\Omega f v \\,\\mathrm{d}x \\;-\\; \\int_{\\Lambda_N} g v \\,\\mathrm{d}s$$\n",
        "\n",
        "Expressing this equation in the standard notation $a(u,v) = L(v)$, we have\n",
        "\n",
        "$$\\begin{aligned}\n",
        "a(u,v) &= \\int_\\Omega \\nabla u \\cdot \\nabla v \\,\\mathrm{d}x \\\\\n",
        "L(v) &= \\int_\\Omega f v \\,\\mathrm{d}x \\;-\\; \\int_{\\Lambda_N} g v \\,\\mathrm{d}s\n",
        "\\end{aligned}$$\n",
        "\n",
        "**Implementation**\n",
        "\n",
        "As in the previous example, we start by defining the mesh, the function space, and the bilinear form $a(u,v)$"
      ],
      "id": "3f0aa6aa"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "\n",
        "from mpi4py import MPI\n",
        "import pyvista\n",
        "\n",
        "from dolfinx import default_scalar_type\n",
        "from dolfinx.fem import (Constant, Function, functionspace,\n",
        "  assemble_scalar, dirichletbc, form, locate_dofs_geometrical)\n",
        "from dolfinx.fem.petsc import LinearProblem\n",
        "from dolfinx.mesh import create_unit_square\n",
        "from dolfinx.plot import vtk_mesh\n",
        "\n",
        "from ufl import SpatialCoordinate, TestFunction, TrialFunction, dot, ds, dx, grad\n",
        "\n",
        "mesh = create_unit_square(MPI.COMM_WORLD, 10, 10)\n",
        "\n",
        "V = functionspace(mesh, (\"Lagrange\", 1))\n",
        "u = TrialFunction(V)\n",
        "v = TestFunction(V)\n",
        "\n",
        "a = dot(grad(u), grad(v)) *dx"
      ],
      "id": "9101ec84",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now we turn to the Neumann and Dirichlet boundary conditions. As before, we use a Python function to mark the part of the boundary where the Dirichlet condition should apply. With this function, we can then identify the corresponding degrees of freedom that satisfy the condition"
      ],
      "id": "ecf04656"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def u_exact(x):\n",
        "  return 1 +x[0]**2 +2 *x[1]**2\n",
        "\n",
        "def boundary_D(x):\n",
        "  return np.logical_or(np.isclose(x[0], 0), np.isclose(x[0], 1))\n",
        "\n",
        "dofs_D = locate_dofs_geometrical(V, boundary_D)\n",
        "\n",
        "u_bc = Function(V)\n",
        "u_bc.interpolate(u_exact)\n",
        "bc = dirichletbc(u_bc, dofs_D)"
      ],
      "id": "d1d054ee",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The next step is to define the Neumann condition. We begin by defining $g$ using `UFL`’s `SpatialCoordinate` function, and then create a boundary integration measure `ds`. Since the test function $v$ vanishes on the Dirichlet boundary, the corresponding integrals drop out. This allows us to simply integrate `g *v *ds` over the entire boundary"
      ],
      "id": "060e8f53"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "f = Constant(mesh, default_scalar_type(-6))\n",
        "\n",
        "x = SpatialCoordinate(mesh)\n",
        "g = -4 *x[1]\n",
        "\n",
        "L = f *v *dx -g *v *ds"
      ],
      "id": "948a2fc9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "At this stage, we are ready to assemble the linear system and solve it"
      ],
      "id": "ef4f792b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "problem = LinearProblem(\n",
        "    a, \n",
        "    L, \n",
        "    bcs=[bc], \n",
        "    petsc_options={\n",
        "        \"ksp_type\": \"preonly\", \n",
        "        \"pc_type\": \"lu\"}\n",
        ")\n",
        "\n",
        "uh = problem.solve()\n",
        "\n",
        "V2 = functionspace(mesh, (\"Lagrange\", 2))\n",
        "uex = Function(V2)\n",
        "uex.interpolate(u_exact)\n",
        "\n",
        "error_L2 = assemble_scalar(form((uh -uex)**2 *dx))\n",
        "error_L2 = np.sqrt(MPI.COMM_WORLD.allreduce(error_L2, op=MPI.SUM))\n",
        "\n",
        "u_vertex_values = uh.x.array\n",
        "\n",
        "uex_1 = Function(V)\n",
        "uex_1.interpolate(uex)\n",
        "u_ex_vertex_values = uex_1.x.array\n",
        "\n",
        "error_max = np.max(np.abs(u_vertex_values -u_ex_vertex_values))\n",
        "error_max = MPI.COMM_WORLD.allreduce(error_max, op=MPI.MAX)\n",
        "\n",
        "print(f\"Error_L2 : {error_L2:.2e}\")\n",
        "print(f\"Error_max : {error_max:.2e}\")"
      ],
      "id": "a8a22a56",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Visualization**\n",
        "\n",
        "To visualize the solution, run the code either as a Python script with `off_screen=True`, or inside a Jupyter notebook with `off_screen=False`"
      ],
      "id": "d917304d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from pathlib import Path\n",
        "\n",
        "results_folder = Path(\"fenicsx/bcs_subdomains\")\n",
        "results_folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "pyvista_cells, cell_types, geometry = vtk_mesh(V)\n",
        "grid = pyvista.UnstructuredGrid(pyvista_cells, cell_types, geometry)\n",
        "grid.point_data[\"u\"] = uh.x.array\n",
        "grid.set_active_scalars(\"u\")\n",
        "\n",
        "plotter = pyvista.Plotter(off_screen=False)\n",
        "plotter.add_text(\"uh\", position=\"upper_edge\", font_size=14, color=\"black\")\n",
        "plotter.add_mesh(grid, show_edges=True)\n",
        "plotter.view_xy()\n",
        "\n",
        "if not pyvista.OFF_SCREEN:\n",
        "    #plotter.show()\n",
        "    plotter.export_html(results_folder/\"neumann_dirichlet.html\")\n",
        "else:\n",
        "    figure = plotter.screenshot(results_folder/\"neumann_dirichlet.png\")"
      ],
      "id": "9455dff4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/bcs_subdomains/neumann_dirichlet.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "### Setting multiple Dirichlet condition\n",
        "\n",
        "In the previous section, we applied the same Dirichlet condition to both the left and right boundaries using a single function. While this works, it is often more flexible to define separate boundary conditions for each side.\n",
        "\n",
        "Let us consider a similar setup to the earlier example, but this time with distinct Dirichlet conditions on the left and right boundaries:\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "-\\nabla^2 u &= f \\quad &&\\text{in } \\Omega \\\\\n",
        "u &= u_L \\quad &&\\text{on } \\Lambda_D^L \\\\\n",
        "u &= u_R \\quad &&\\text{on } \\Lambda_D^R \\\\\n",
        "-\\frac{\\partial u}{\\partial n} &= g \\quad &&\\text{on } \\Lambda_N\n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "Here, $\\Lambda_D^L$ represents the left boundary ($x=0$), and $\\Lambda_D^R$ represents the right boundary ($x=1$)\n",
        "\n",
        "For this example, we choose\n",
        "\n",
        "* $u_L(y) = 1 + 2y^2$\n",
        "\n",
        "* $u_R(y) = 2 + 2y^2$\n",
        "\n",
        "* $g(y) = -4y$\n",
        "\n",
        "in line with the analytical solution introduced earlier\n",
        "\n",
        "As before, we begin by defining the mesh, the function space, and the variational formulation"
      ],
      "id": "0aa09083"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from mpi4py import MPI\n",
        "import pyvista\n",
        "\n",
        "from dolfinx import default_scalar_type\n",
        "from dolfinx.fem import (\n",
        "  Constant, Function, functionspace,\n",
        "  assemble_scalar, dirichletbc, \n",
        "  form, locate_dofs_geometrical\n",
        ")\n",
        "from dolfinx.fem.petsc import LinearProblem\n",
        "from dolfinx.mesh import create_unit_square\n",
        "from dolfinx.plot import vtk_mesh\n",
        "\n",
        "from ufl import (\n",
        "  SpatialCoordinate, \n",
        "  TrialFunction, TestFunction, \n",
        "  dot, dx, ds, grad\n",
        ")\n",
        "\n",
        "def u_exact(x):\n",
        "  return 1 +x[0]**2 +2 *x[1]**2\n",
        "\n",
        "mesh = create_unit_square(MPI.COMM_WORLD, 10, 10)\n",
        "\n",
        "V = functionspace(mesh, (\"Lagrange\", 1))\n",
        "u = TrialFunction(V)\n",
        "v = TestFunction(V)\n",
        "\n",
        "a = dot(grad(u), grad(v)) *dx\n",
        "\n",
        "x = SpatialCoordinate(mesh)\n",
        "f = Constant(mesh, default_scalar_type(-6))\n",
        "g = - 4 *x[1]\n",
        "L = f *v *dx -g *v *ds"
      ],
      "id": "5bf44cc1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Our next step is to mark the two boundaries individually, beginning with the left boundary"
      ],
      "id": "18c78a44"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dofs_L = locate_dofs_geometrical(V, lambda x: np.isclose(x[0], 0))\n",
        "u_L = Function(V)\n",
        "u_L.interpolate(lambda x: 1 +2 *x[1]**2)\n",
        "bc_L = dirichletbc(u_L, dofs_L)"
      ],
      "id": "961fc37b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note that we have used `lambda`-functions to compactly define the functions returning the subdomain evaluation and function evaluation. We can use a similar procedure for the right boundary condition, and gather both boundary conditions in a vector `bcs`"
      ],
      "id": "67cd2f75"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dofs_R = locate_dofs_geometrical(V, lambda x: np.isclose(x[0], 1))\n",
        "u_R = Function(V)\n",
        "u_R.interpolate(lambda x: 2 +2 *x[1]**2)\n",
        "bc_R = dirichletbc(u_R, dofs_R)\n",
        "bcs = [bc_R, bc_L]"
      ],
      "id": "c17a6663",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We are now ready to solve the problem once more and evaluate both the $L^2$ error and the maximum error at the mesh vertices"
      ],
      "id": "fe6a2f92"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "problem = LinearProblem(\n",
        "  a, \n",
        "  L, \n",
        "  bcs=bcs, \n",
        "  petsc_options={\"ksp_type\": \"preonly\", \"pc_type\": \"lu\"}\n",
        ")\n",
        "uh = problem.solve()\n",
        "\n",
        "V2 = functionspace(mesh, (\"Lagrange\", 2))\n",
        "uex = Function(V2)\n",
        "uex.interpolate(u_exact)\n",
        "\n",
        "error_L2 = assemble_scalar(form((uh -uex)**2 *dx))\n",
        "error_L2 = np.sqrt(MPI.COMM_WORLD.allreduce(error_L2, op=MPI.SUM))\n",
        "\n",
        "u_vertex_values = uh.x.array\n",
        "uex_1 = Function(V)\n",
        "uex_1.interpolate(uex)\n",
        "u_ex_vertex_values = uex_1.x.array\n",
        "\n",
        "error_max = np.max(np.abs(u_vertex_values -u_ex_vertex_values))\n",
        "error_max = MPI.COMM_WORLD.allreduce(error_max, op=MPI.MAX)\n",
        "\n",
        "print(f\"Error_L2 : {error_L2:.2e}\")\n",
        "print(f\"Error_max : {error_max:.2e}\")"
      ],
      "id": "115dc0c4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Visualization**\n",
        "\n",
        "To visualize the solution, run the code either as a Python script with `off_screen=True`, or inside a Jupyter notebook with `off_screen=False`"
      ],
      "id": "1c36c7cc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from pathlib import Path\n",
        "\n",
        "results_folder = Path(\"fenicsx/bcs_subdomains\")\n",
        "results_folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "pyvista_cells, cell_types, geometry = vtk_mesh(V)\n",
        "grid = pyvista.UnstructuredGrid(pyvista_cells, cell_types, geometry)\n",
        "grid.point_data[\"u\"] = uh.x.array\n",
        "grid.set_active_scalars(\"u\")\n",
        "\n",
        "plotter = pyvista.Plotter(off_screen=False)\n",
        "plotter.add_text(\"uh\", position=\"upper_edge\", font_size=14, color=\"black\")\n",
        "plotter.add_mesh(grid, show_edges=True)\n",
        "plotter.view_xy()\n",
        "\n",
        "if not pyvista.OFF_SCREEN:\n",
        "    #plotter.show()\n",
        "    plotter.export_html(results_folder/\"multiple_dirichlet.html\")\n",
        "else:\n",
        "    figure = plotter.screenshot(results_folder/\"multiple_dirichlet.png\")"
      ],
      "id": "b935ae47",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/bcs_subdomains/multiple_dirichlet.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "### Defining subdomains for different materials\n",
        "\n",
        "Author: Jørgen S. Dokken\n",
        "\n",
        "Many PDE problems involve domains consisting of different materials. In `FEniCSx`, these cases can be treated by introducing a discontinuous, cell-wise constant function. We can create such a function on any mesh in the following way\n",
        "\n",
        "**Subdomains on built-in meshes**"
      ],
      "id": "a849de92"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from mpi4py import MPI\n",
        "import pyvista\n",
        "\n",
        "import gmsh\n",
        "\n",
        "from dolfinx import default_scalar_type\n",
        "from dolfinx.mesh import create_unit_square, locate_entities\n",
        "from dolfinx.fem import (\n",
        "  Constant, dirichletbc, Function, functionspace, \n",
        "  assemble_scalar, form, \n",
        "  locate_dofs_geometrical, locate_dofs_topological\n",
        ")\n",
        "from dolfinx.fem.petsc import LinearProblem\n",
        "from dolfinx.io import XDMFFile, gmshio\n",
        "from dolfinx.plot import vtk_mesh\n",
        "\n",
        "from ufl import (\n",
        "  SpatialCoordinate, TestFunction, TrialFunction,\n",
        "  dx, grad, inner\n",
        ")\n",
        "\n",
        "mesh = create_unit_square(MPI.COMM_WORLD, 10, 10)\n",
        "Q = functionspace(mesh, (\"DG\", 0))"
      ],
      "id": "0bd7e039",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To illustrate the concept, let’s consider a simple two-dimensional example with two materials. The domain $\\Omega=[0,1]\\times[0,1]$ is split into two subdomains, $\\Omega_1=[0,1]\\times [0,1/2]$ and $\\Omega_2=[0,1]\\times[1/2, 1]$. We start by defining two Python functions, where each function returns `True` whenever the given coordinate falls inside its corresponding subdomain"
      ],
      "id": "fd287245"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def Omega_1(x):\n",
        "  return x[1] <= 0.5\n",
        "\n",
        "def Omega_2(x):\n",
        "  return x[1] >= 0.5"
      ],
      "id": "af67a8d1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Notice that both functions make use of $\\leq$ and $\\geq$. This is because `FEniCSx` evaluates each cell at all of its vertices, and we need every vertex on the interface to return True in order for the interface to be marked correctly.\n",
        "\n",
        "With this in place, we now move on to a variable-coefficient version of the Poisson equation:\n",
        "\n",
        "$$\\begin{aligned}\n",
        "-\\nabla \\cdot &[\\kappa(x,y)\\,\\nabla u(x, y)] = 1 &&\\text{in } \\Omega \\\\[5pt]\n",
        "u &= u_D = 1  &&\\text{on } \\partial\\Omega_D = {(0,y),|, y \\in [0,1]} \\\\[5pt]\n",
        "-\\frac{\\partial u}{\\partial n} &= 0 &&\\text{on } \\partial\\Omega \\setminus \\partial\\Omega_D \n",
        "\\end{aligned}\n",
        "$$\n",
        "\n",
        "The next step is to define the coefficient $\\kappa$"
      ],
      "id": "dd902bd6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "kappa = Function(Q)\n",
        "cells_1 = locate_entities(mesh, mesh.topology.dim, Omega_1)\n",
        "cells_2 = locate_entities(mesh, mesh.topology.dim, Omega_2)"
      ],
      "id": "d4089a2f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "In the previous code block, we determined which cells (triangular elements) belong to $\\Omega_1$ and $\\Omega_2$. Since a DG-0 function has a single degree of freedom per cell, there is a one-to-one correspondence between the degrees of freedom and the cells. We then define the coefficient $\\kappa$ by\n",
        "\n",
        "$$\n",
        "\\kappa =\n",
        "\\begin{cases}\n",
        "\\phantom{.}1 & \\text{if } x \\in \\Omega_1 \\\\\n",
        "0.1 & \\text{if } x \\in \\Omega_2\n",
        "\\end{cases}$$"
      ],
      "id": "67e7a26b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "kappa.x.array[cells_1] = np.full_like(cells_1, 1, dtype=default_scalar_type)\n",
        "kappa.x.array[cells_2] = np.full_like(cells_2, 0.1, dtype=default_scalar_type)"
      ],
      "id": "cc8cd04f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Filter out ghosted cells\n",
        "tdim = mesh.topology.dim\n",
        "num_cells_local = mesh.topology.index_map(tdim).size_local\n",
        "marker = np.zeros(num_cells_local, dtype=np.int32)\n",
        "\n",
        "cells_1 = cells_1[cells_1 < num_cells_local]\n",
        "cells_2 = cells_2[cells_2 < num_cells_local]\n",
        "\n",
        "marker[cells_1] = 1\n",
        "marker[cells_2] = 2\n",
        "\n",
        "mesh.topology.create_connectivity(tdim, tdim)\n",
        "topology, cell_types, x = vtk_mesh(mesh, tdim, np.arange(num_cells_local, dtype=np.int32))"
      ],
      "id": "c6a5a1c3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from pathlib import Path\n",
        "\n",
        "results_folder = Path(\"fenicsx/bcs_subdomains\")\n",
        "results_folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "plotter = pyvista.Plotter(off_screen=False, window_size=[800, 800])\n",
        "\n",
        "grid = pyvista.UnstructuredGrid(topology, cell_types, x)\n",
        "grid.cell_data[\"Marker\"] = marker\n",
        "grid.set_active_scalars(\"Marker\")\n",
        "plotter.add_mesh(grid, show_edges=True)\n",
        "\n",
        "if not pyvista.OFF_SCREEN:\n",
        "    #plotter.show()\n",
        "    plotter.export_html(results_folder/\"subdomains_structured.html\")\n",
        "else:\n",
        "    figure = plotter.screenshot(results_folder/\"subdomains_structured.png\")"
      ],
      "id": "62b398ec",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/bcs_subdomains/subdomains_structured.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "After performing integration by parts, we are now ready to define the variational formulation and the Dirichlet boundary condition"
      ],
      "id": "4034abf9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "V = functionspace(mesh, (\"Lagrange\", 1))\n",
        "u = TrialFunction(V)\n",
        "v = TestFunction(V)\n",
        "\n",
        "a = inner(kappa *grad(u), grad(v)) *dx\n",
        "\n",
        "x = SpatialCoordinate(mesh)\n",
        "L = Constant(mesh, default_scalar_type(1)) *v *dx\n",
        "\n",
        "dofs = locate_dofs_geometrical(V, lambda x: np.isclose(x[0], 0))\n",
        "bcs = [dirichletbc(default_scalar_type(1), dofs, V)]"
      ],
      "id": "2e1012ae",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can now solve the problem and visualize its solution"
      ],
      "id": "a7c1fdbd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "problem = LinearProblem(\n",
        "  a, \n",
        "  L, \n",
        "  bcs=bcs, \n",
        "  petsc_options={\"ksp_type\": \"preonly\", \"pc_type\": \"lu\"}\n",
        ")\n",
        "uh = problem.solve()"
      ],
      "id": "68182e1c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plotter = pyvista.Plotter(off_screen=False, window_size=[800, 800])\n",
        "grid_uh = pyvista.UnstructuredGrid(*vtk_mesh(V))\n",
        "grid_uh.point_data[\"u\"] = uh.x.array.real\n",
        "grid_uh.set_active_scalars(\"u\")\n",
        "\n",
        "plotter.add_mesh(grid_uh, show_edges=True)\n",
        "if not pyvista.OFF_SCREEN:\n",
        "  #plotter.show()\n",
        "  plotter.export_html(results_folder/\"subdomains_structured2.html\")\n",
        "else:\n",
        "  figure = plotter.screenshot(results_folder/\"subdomains_structured2.png\")"
      ],
      "id": "a0a3e4f2",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/bcs_subdomains/subdomains_structured2.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "Distinct behaviors are clearly observed in the two regions, despite both having the same Dirichlet boundary condition at x=0 on the left boundary\n",
        "\n",
        "**Interpolation with Python-function**\n",
        "\n",
        "As we saw in the first approach, in many cases the geometrical coordinates can be used to determine which coefficient to apply. Using the unstructured mesh from the previous example, we illustrate an alternative approach based on interpolation"
      ],
      "id": "cea1778a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def eval_kappa(x):\n",
        "  values = np.zeros(x.shape[1], dtype=default_scalar_type)\n",
        "  \n",
        "  # Create a boolean array indicating which dofs \n",
        "  #   that are in each domain\n",
        "  top_coords = x[1] > 0.5\n",
        "  bottom_coords = x[1] < 0.5\n",
        "\n",
        "  values[top_coords] = np.full(sum(top_coords), 0.1)\n",
        "  values[bottom_coords] = np.full(sum(bottom_coords), 1)\n",
        "\n",
        "  return values"
      ],
      "id": "0c92c59e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "kappa2 = Function(Q)\n",
        "kappa2.interpolate(eval_kappa)"
      ],
      "id": "486b48ee",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We verify this by computing the error between the new function and the previous one"
      ],
      "id": "50df91cf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Difference in kappa's\n",
        "error = mesh.comm.allreduce(assemble_scalar(form((kappa -kappa2)**2 *dx)))\n",
        "print(f'{error = }')"
      ],
      "id": "b5a38daa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Subdomains defined from external mesh data**\n",
        "\n",
        "Let us now consider the same problem, but using `GMSH` to generate both the mesh and the subdomains. We will then show how to use this data to create discontinuous functions in `dolfinx`"
      ],
      "id": "3797dc72"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "gmsh.initialize()\n",
        "\n",
        "proc = MPI.COMM_WORLD.rank\n",
        "\n",
        "top_marker = 2\n",
        "bottom_marker = 1\n",
        "left_marker = 1\n",
        "\n",
        "if proc == 0:\n",
        "  # We create one rectangle for each subdomain\n",
        "  gmsh.model.occ.addRectangle(0, 0, 0, 1, 0.5, tag=1)\n",
        "  gmsh.model.occ.addRectangle(0, 0.5, 0, 1, 0.5, tag=2)\n",
        "  # We fuse the two rectangles and keep the interface between them\n",
        "  gmsh.model.occ.fragment([(2, 1)], [(2, 2)])\n",
        "  gmsh.model.occ.synchronize()\n",
        "\n",
        "  # Mark the top (2) and bottom (1) rectangle\n",
        "  top, bottom = None, None\n",
        "  for surface in gmsh.model.getEntities(dim=2):\n",
        "    com = gmsh.model.occ.getCenterOfMass(surface[0], surface[1])\n",
        "    if np.allclose(com, [0.5, 0.25, 0]):\n",
        "      bottom = surface[1]\n",
        "    else:\n",
        "      top = surface[1]\n",
        "  gmsh.model.addPhysicalGroup(2, [bottom], bottom_marker)\n",
        "  gmsh.model.addPhysicalGroup(2, [top], top_marker)\n",
        "  \n",
        "  # Tag the left boundary\n",
        "  left = []\n",
        "  for line in gmsh.model.getEntities(dim=1):\n",
        "    com = gmsh.model.occ.getCenterOfMass(line[0], line[1])\n",
        "    if np.isclose(com[0], 0):\n",
        "      left.append(line[1])\n",
        "  gmsh.model.addPhysicalGroup(1, left, left_marker)\n",
        "  \n",
        "  gmsh.model.mesh.generate(2)\n",
        "  gmsh.write(str(results_folder/\"gmsh_mesh.msh\"))\n",
        "\n",
        "gmsh.finalize()"
      ],
      "id": "5954aa36",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Read in MSH files with `dolfinx`**\n",
        "\n",
        "You can read MSH files with `dolfinx`, which initially loads them on a single process and then distributes them across the available ranks in the MPI communicator"
      ],
      "id": "8811b1cf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "mesh, cell_markers, facet_markers = gmshio.read_from_msh(\n",
        "  results_folder/\"gmsh_mesh.msh\", \n",
        "  MPI.COMM_WORLD, \n",
        "  gdim=2\n",
        ")"
      ],
      "id": "bafb5c31",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Convert `msh`-files to `XDMF` using `meshio`**\n",
        "\n",
        "We will use `meshio` to read in the `msh` file, and convert it to a more suitable IO format. e start by creating a convenience function for extracting data for a single cell type, and creating a new `meshio.Mesh`"
      ],
      "id": "9a4630d5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import meshio\n",
        "\n",
        "def create_mesh(mesh, cell_type, prune_z=False):\n",
        "  \n",
        "  points = mesh.points[:, :2] if prune_z else mesh.points\n",
        "  cells = mesh.get_cells_type(cell_type)\n",
        "  cell_data = mesh.get_cell_data(\"gmsh:physical\", cell_type)\n",
        "\n",
        "  out_mesh = meshio.Mesh(\n",
        "    points=points, \n",
        "    cells={cell_type: cells}, \n",
        "    cell_data={\"name_to_read\": [cell_data.astype(np.int32)]}\n",
        "  )\n",
        "  \n",
        "  return out_mesh"
      ],
      "id": "b7739a04",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This function returns a `meshio` mesh, including physical markers for the specified type. The `prune_z` argument is used when working with two-dimensional meshes. The last coordinate in the `mesh` (since it is generated in 3D space) must be removed for `dolfinx` to recognize it as a two-dimensional geometry"
      ],
      "id": "2580f027"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "if proc == 0:\n",
        "  # Read in mesh\n",
        "  msh = meshio.read(results_folder/\"gmsh_mesh.msh\")\n",
        "\n",
        "  # Create and save one file for the mesh, and one file for the facets\n",
        "  triangle_mesh = create_mesh(msh, \"triangle\", prune_z=True)\n",
        "  line_mesh = create_mesh(msh, \"line\", prune_z=True)\n",
        "  meshio.write(results_folder/\"mesh.xdmf\", triangle_mesh)\n",
        "  meshio.write(results_folder/\"mt.xdmf\", line_mesh)\n",
        "\n",
        "MPI.COMM_WORLD.barrier()"
      ],
      "id": "edf7a3d5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We have written the mesh and cell markers to one file, and the facet markers to a separate file. This data can be read in `dolfinx` using `XDMFFile.read_mesh` and `XDMFFile.read_meshtags`. A `dolfinx.MeshTags` object stores the entity indices and their corresponding marker values in two one-dimensional arrays.\n",
        "\n",
        "Note that the mesh was generated and written using a single processor. However, since the `XDMF` format supports parallel I/O, the mesh can be read in parallel"
      ],
      "id": "6778c2f4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "with XDMFFile(\n",
        "  MPI.COMM_WORLD, \n",
        "  results_folder/\"mesh.xdmf\", \"r\"\n",
        ") as xdmf:\n",
        "  mesh = xdmf.read_mesh(name=\"Grid\")\n",
        "  ct = xdmf.read_meshtags(mesh, name=\"Grid\")\n",
        "\n",
        "mesh.topology.create_connectivity(mesh.topology.dim, mesh.topology.dim -1)\n",
        "\n",
        "with XDMFFile(\n",
        "  MPI.COMM_WORLD, \n",
        "  results_folder/\"mt.xdmf\", \"r\"\n",
        ") as xdmf:\n",
        "  ft = xdmf.read_meshtags(mesh, name=\"Grid\")"
      ],
      "id": "264f93be",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Having read the mesh together with the associated cell and facet data, we can now construct the discontinuous function kappa as follows:"
      ],
      "id": "9e36b29f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "Q = functionspace(mesh, (\"DG\", 0))\n",
        "kappa = Function(Q)\n",
        "\n",
        "bottom_cells = ct.find(bottom_marker)\n",
        "kappa.x.array[bottom_cells] = np.full_like(\n",
        "  bottom_cells, \n",
        "  1, \n",
        "  dtype=default_scalar_type\n",
        ")\n",
        "\n",
        "top_cells = ct.find(top_marker)\n",
        "kappa.x.array[top_cells] = np.full_like(\n",
        "  top_cells, \n",
        "  0.1, \n",
        "  dtype=default_scalar_type\n",
        ")"
      ],
      "id": "e4d96fec",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The facet data `ft` can also be used efficiently to construct the Dirichlet boundary condition."
      ],
      "id": "bd297af9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "V = functionspace(mesh, (\"Lagrange\", 1))\n",
        "u_bc = Function(V)\n",
        "left_facets = ft.find(left_marker)\n",
        "\n",
        "mesh.topology.create_connectivity(mesh.topology.dim -1, mesh.topology.dim)\n",
        "left_dofs = locate_dofs_topological(V, mesh.topology.dim -1, left_facets)\n",
        "\n",
        "bcs = [dirichletbc(default_scalar_type(1), left_dofs, V)]"
      ],
      "id": "f2dd66ef",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can now solve the problem in a fashion similar to that used above"
      ],
      "id": "32f400f8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u = TrialFunction(V)\n",
        "v = TestFunction(V)\n",
        "\n",
        "a = inner(kappa *grad(u), grad(v)) *dx\n",
        "\n",
        "x = SpatialCoordinate(mesh)\n",
        "L = Constant(mesh, default_scalar_type(1)) *v *dx\n",
        "\n",
        "problem = LinearProblem(\n",
        "  a, \n",
        "  L, \n",
        "  bcs=bcs, \n",
        "  petsc_options={\"ksp_type\": \"preonly\", \"pc_type\": \"lu\"}\n",
        ")\n",
        "uh = problem.solve()"
      ],
      "id": "7697c48d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Since dolfinx.MeshTag contains a value for every cell in the geometry, \n",
        "# we can attach it directly to the grid\n",
        "\n",
        "tdim = mesh.topology.dim\n",
        "mesh.topology.create_connectivity(tdim, tdim)\n",
        "\n",
        "topology, cell_types, x = vtk_mesh(mesh, tdim)\n",
        "grid = pyvista.UnstructuredGrid(topology, cell_types, x)\n",
        "\n",
        "num_local_cells = mesh.topology.index_map(tdim).size_local\n",
        "grid.cell_data[\"Marker\"] = ct.values[ct.indices < num_local_cells]\n",
        "grid.set_active_scalars(\"Marker\")\n",
        "\n",
        "plotter = pyvista.Plotter(off_screen=False, window_size=[800, 800])\n",
        "plotter.add_mesh(grid, show_edges=True)\n",
        "\n",
        "if not pyvista.OFF_SCREEN:\n",
        "  #plotter.show()\n",
        "  plotter.export_html(results_folder/\"subdomains_unstructured.html\")\n",
        "else:\n",
        "  figure = plotter.screenshot(results_folder/\"subdomains_unstructured.png\")"
      ],
      "id": "efc8df60",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/bcs_subdomains/subdomains_unstructured.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```"
      ],
      "id": "b82d82c4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "grid_uh = pyvista.UnstructuredGrid(*vtk_mesh(V))\n",
        "grid_uh.point_data[\"u\"] = uh.x.array.real\n",
        "grid_uh.set_active_scalars(\"u\")\n",
        "\n",
        "plotter = pyvista.Plotter(off_screen=False, window_size=[800, 800])\n",
        "plotter.add_mesh(grid_uh, show_edges=True)\n",
        "\n",
        "if not pyvista.OFF_SCREEN:\n",
        "  #plotter.show()\n",
        "  plotter.export_html(results_folder/\"subdomains_unstructured_u.html\")\n",
        "else:\n",
        "  figure = plotter.screenshot(results_folder/\"subdomains_unstructured_u.png\")"
      ],
      "id": "dd160497",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/bcs_subdomains/subdomains_unstructured_u.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "### Setting multiple Dirichlet, Neumann, and Robin conditions\n",
        "\n",
        "Author: Hans Petter Langtangen and Anders Logg\n",
        "\n",
        "We now look at the variable-coefficient example from the previous section. In this part, we will show how to apply a combination of Dirichlet, Neumann, and Robin boundary conditions to this problem\n",
        "\n",
        "We split the boundary into three distinct parts:\n",
        "\n",
        "* $\\Gamma_D$ for Dirichlet conditions:\n",
        "  \n",
        "  $\\phantom{-\\kappa\\partial}u=u_D^i \\quad\\text{on } \\Gamma_D^i \\quad$ where $\\;\\Gamma_D=\\Gamma_D^0\\cup \\Gamma_D^1 \\cup \\dots$\n",
        "\n",
        "* $\\Gamma_N$ for Neumann conditions: \n",
        "\n",
        "  $\\displaystyle -\\kappa \\frac{\\partial u}{\\partial n}=g_j \\quad\\text{on } \\Gamma_N^j \\quad$ where $\\;\\Gamma_N=\\Gamma_N^0\\cup \\Gamma_N^1 \\cup \\dots$\n",
        "\n",
        "* $\\Gamma_R$ for Robin conditions: \n",
        "\n",
        "  $\\displaystyle -\\kappa \\frac{\\partial u}{\\partial n}=r_k (u -s_k) \\quad\\text{on } \\Gamma_R^k \\quad$  where $\\;\\Gamma_R=\\Gamma_R^0\\cup \\Gamma_R^1 \\cup \\dots$\n",
        "\n",
        "where $r_k$ and $s_k$ are prescribed functions. The Robin condition is commonly used to model heat transfer to the surroundings and arises naturally from Newton’s law of cooling.\n",
        "In this case, $r_k$ represents the heat transfer coefficient, and $s_k$ is the ambient temperature.\n",
        "Both may depend on space and time\n",
        "\n",
        "**The PDE problem and variational formulation**\n",
        "\n",
        "We can summarize the PDE problem as follows:\n",
        "\n",
        "$$\\begin{aligned}\n",
        " -\\nabla &\\cdot (\\kappa \\nabla u) = f &&\\text{in } \\Omega\\\\[6pt]\n",
        "u &= u_D^i \\quad &&\\text{on } \\Gamma_D^i \\\\[5pt]\n",
        "-\\kappa \\frac{\\partial u}{\\partial n} &= g_j &&\\text{on } \\Gamma_N^j\\\\\n",
        "-\\kappa \\frac{\\partial u}{\\partial n} &= r_k (u - s_k) &&\\text{on } \\Gamma_R^k\n",
        "\\end{aligned}$$\n",
        "\n",
        "As usual, we multiply the equation by a test function $v$ and integrate by parts:\n",
        "\n",
        "$$-\\int_{\\Omega} \\nabla \\cdot (\\kappa \\nabla u)\\, v \\,\\mathrm{d}x\n",
        "= \\int_{\\Omega} \\kappa \\nabla u \\cdot \\nabla v \\,\\mathrm{d}x\n",
        "\t-\t\\int_{\\partial \\Omega} \\kappa \\frac{\\partial u}{\\partial n} v \\,\\mathrm{d}s$$\n",
        "\n",
        "On the Dirichlet part ($\\Gamma_D^i$), the boundary integral vanishes since $v = 0$. On the remaining parts of the boundary, we split the contributions into the Neumann boundaries ($\\Gamma_N^i$) and the Robin boundaries ($\\Gamma_R^i$).\n",
        "Inserting the boundary conditions, we obtain\n",
        "\n",
        "$$-\\int_{\\partial\\Omega} \\kappa \\frac{\\partial u}{\\partial n} v \\,\\mathrm{d}s\n",
        "= \\sum_i \\int_{\\Gamma_N^i} g_i v \\,\\mathrm{d}s\n",
        "\t+\t\\sum_i \\int_{\\Gamma_R^i} r_i (u - s_i) v \\,\\mathrm{d}s$$\n",
        "\n",
        "Thus, the variational problem can be written as\n",
        "\n",
        "$$\\begin{aligned}\n",
        "F(u, v)\n",
        "&= \\int_\\Omega \\kappa \\nabla u \\cdot \\nabla v \\,\\mathrm{d}x\n",
        "\t+\t\\sum_i \\int_{\\Gamma_N^i} g_i v \\,\\mathrm{d}s \\\\\n",
        "&\\quad + \\sum_i \\int_{\\Gamma_R^i} r_i (u - s_i) v \\,\\mathrm{d}s\n",
        "\t-\t\\int_\\Omega f v \\,\\mathrm{d}x = 0\n",
        "\\end{aligned}$$\n",
        "\n",
        "We are accustomed to writing the variational formulation in the form $a(u, v) = L(v)$. This requires identifying the integrals that depend on the trial function $u$ and collecting them in $a(u, v)$, while the remaining terms form $L(v)$.\n",
        "Note that the Robin condition contributes to both $a(u, v)$ and $L(v)$\n",
        "\n",
        "Thus, we have\n",
        "\n",
        "$$a(u, v) = \\int_{\\Omega} \\kappa \\nabla u \\cdot \\nabla v \\,\\mathrm{d}x\n",
        "\t+\t\\sum_i \\int_{\\Gamma_R^i} r_i \\, u \\, v \\,\\mathrm{d}s$$\n",
        "\n",
        "$$L(v) = \\int_{\\Omega} f \\, v \\,\\mathrm{d}x\n",
        "\t-\\sum_i \\int_{\\Gamma_N^i} g_i \\, v \\,\\mathrm{d}s\n",
        "\t+\\sum_i \\int_{\\Gamma_R^i} r_i \\, s_i \\, v \\,\\mathrm{d}s$$\n",
        "\n",
        "**Implementation**\n",
        "\n",
        "First, we define the domain \\Omega to be the unit square $[0,1] \\times [0,1]$"
      ],
      "id": "25e3651b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from mpi4py import MPI\n",
        "import pyvista\n",
        "\n",
        "from dolfinx import default_scalar_type\n",
        "from dolfinx.mesh import create_unit_square, locate_entities, meshtags\n",
        "from dolfinx.fem import (\n",
        "  Constant, Function, functionspace, assemble_scalar, \n",
        "  dirichletbc, form, locate_dofs_topological\n",
        ")\n",
        "from dolfinx.fem.petsc import LinearProblem\n",
        "from dolfinx.io import XDMFFile\n",
        "from dolfinx.plot import vtk_mesh\n",
        "\n",
        "from ufl import (\n",
        "  FacetNormal, Measure, SpatialCoordinate, \n",
        "  TestFunction, TrialFunction, \n",
        "  div, dot, dx, grad, inner, lhs, rhs\n",
        ")\n",
        "\n",
        "mesh = create_unit_square(MPI.COMM_WORLD, 10, 10)"
      ],
      "id": "509bfb98",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "In this section, we solve the Poisson problem for the manufactured solution\n",
        "\n",
        "$$u_{ex} = 1 + x^2 + 2y^2$$\n",
        "\n",
        "which gives $\\kappa = 1$ and $f = -6$. The next step is to define the boundary condition parameters and specify where to apply them. In this example, we apply the following:\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "\\phantom{-\\kappa} u &= u_D &&\\quad \\text{for } x=0,1\\\\[5pt]\n",
        "-\\kappa \\frac{\\partial u}{\\partial n} &= r(u - s) &&\\quad \\text{for } y=0\\\\\n",
        "-\\kappa \\frac{\\partial u}{\\partial n} &= g_0 &&\\quad \\text{for } y=1\n",
        "\\end{aligned}$$\n",
        "\n",
        "To reproduce the analytical solution, we set\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "u_D &= u_{ex} = 1 + x^2 + 2y^2 \\\\\n",
        "g_0 &= -\\left.\\frac{\\partial u_{ex}}{\\partial y}\\right\\vert_{y=1} = -4y \\big\\vert_{y=1} = -4\n",
        "\\end{aligned}$$\n",
        "\n",
        "The Robin condition can be specified in many ways. Since\n",
        "\n",
        "$$-\\left.\\frac{\\partial u_{ex}}{\\partial n}\\right\\vert_{y=0} = \\left.\\frac{\\partial u_{ex}}{\\partial y}\\right\\vert_{y=0} = 4y \\big\\vert_{y=0} = 0$$\n",
        "\n",
        "we can choose $r \\neq 0$ arbitrarily and set $s = u_{ex}$. Here, we choose $r = 1000$\n",
        "\n",
        "We can now define all the necessary variables and assemble the traditional part of the variational form"
      ],
      "id": "2c4185d6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "x = SpatialCoordinate(mesh)\n",
        "u_ex = lambda x: 1 +x[0]**2 +2*x[1]**2\n",
        "\n",
        "# Define physical parameters and boundary condtions\n",
        "kappa = Constant(mesh, default_scalar_type(1))\n",
        "\n",
        "f = -div(grad(u_ex(x)))\n",
        "n = FacetNormal(mesh)\n",
        "g = -dot(n, grad(u_ex(x)))\n",
        "s = u_ex(x)\n",
        "r = Constant(mesh, default_scalar_type(1000))\n",
        "\n",
        "# Define function space and standard part of variational form\n",
        "V = functionspace(mesh, (\"Lagrange\", 1))\n",
        "u = TrialFunction(V)\n",
        "v = TestFunction(V)\n",
        "\n",
        "F = kappa *inner(grad(u), grad(v)) *dx -inner(f, v) *dx"
      ],
      "id": "56e9cdfc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We begin by identifying the facets on each boundary and creating a custom integration measure, `ds`"
      ],
      "id": "56266298"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "boundaries = [\n",
        "  (1, lambda x: np.isclose(x[0], 0)),\n",
        "  (2, lambda x: np.isclose(x[0], 1)),\n",
        "  (3, lambda x: np.isclose(x[1], 0)),\n",
        "  (4, lambda x: np.isclose(x[1], 1))\n",
        "]"
      ],
      "id": "9099aab6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we go through each boundary condition and generate `MeshTags` that mark the corresponding facets"
      ],
      "id": "71ffaaae"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "facet_indices, facet_markers = [], []\n",
        "fdim = mesh.topology.dim -1\n",
        "\n",
        "for (marker, locator) in boundaries:\n",
        "  facets = locate_entities(mesh, fdim, locator)\n",
        "  facet_indices.append(facets)\n",
        "  facet_markers.append(np.full_like(facets, marker))\n",
        "\n",
        "facet_indices = np.hstack(facet_indices).astype(np.int32)\n",
        "facet_markers = np.hstack(facet_markers).astype(np.int32)\n",
        "sorted_facets = np.argsort(facet_indices)\n",
        "\n",
        "facet_tag = meshtags(\n",
        "  mesh, \n",
        "  fdim, \n",
        "  facet_indices[sorted_facets], \n",
        "  facet_markers[sorted_facets]\n",
        ")"
      ],
      "id": "3e42633c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Debugging boundary condition**\n",
        "\n",
        "A simple way to debug boundary conditions is to visualize the boundaries in `ParaView`. We do this by writing the `MeshTags` to a file, after which individual boundaries can be examined using the `Threshold` filter"
      ],
      "id": "1ee1d2af"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from pathlib import Path\n",
        "\n",
        "results_folder = Path(\"fenicsx/fundamentals\")\n",
        "results_folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "mesh.topology.create_connectivity(mesh.topology.dim -1, mesh.topology.dim)\n",
        "with XDMFFile(mesh.comm, results_folder/\"facet_tags.xdmf\", \"w\") as xdmf:\n",
        "    xdmf.write_mesh(mesh)\n",
        "    xdmf.write_meshtags(facet_tag, mesh.geometry)"
      ],
      "id": "b762e03f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we define a custom integration measure, `ds`, which can be used to restrict integration to selected facets. Using `ds(1)` ensures that we integrate only over facets that have been assigned the value `1` in the corresponding `facet_tag`"
      ],
      "id": "fde624be"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "ds = Measure(\"ds\", domain=mesh, subdomain_data=facet_tag)"
      ],
      "id": "c0cc2cd4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we define a general boundary condition class that can handle different types of boundary conditions"
      ],
      "id": "314ee938"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "class BoundaryCondition():\n",
        "  def __init__(self, type, marker, values):\n",
        "    self._type = type\n",
        "    if type == \"Dirichlet\":\n",
        "      u_D = Function(V)\n",
        "      u_D.interpolate(values)\n",
        "      facets = facet_tag.find(marker)\n",
        "      dofs = locate_dofs_topological(V, fdim, facets)\n",
        "      self._bc = dirichletbc(u_D, dofs)\n",
        "    elif type == \"Neumann\":\n",
        "      self._bc = inner(values, v) *ds(marker)\n",
        "    elif type == \"Robin\":\n",
        "      self._bc = values[0] *inner(u -values[1], v) *ds(marker)\n",
        "    else:\n",
        "      raise TypeError(f\"Unknown boundary condition: {type:s}\")\n",
        "  \n",
        "  @property\n",
        "  def bc(self):\n",
        "    return self._bc\n",
        "\n",
        "  @property\n",
        "  def type(self):\n",
        "    return self._type\n",
        "\n",
        "# Define the Dirichlet condition\n",
        "boundary_conditions = [\n",
        "  BoundaryCondition(\"Dirichlet\", 1, u_ex),\n",
        "  BoundaryCondition(\"Dirichlet\", 2, u_ex),\n",
        "  BoundaryCondition(\"Robin\", 3, (r, s)),\n",
        "  BoundaryCondition(\"Neumann\", 4, g)\n",
        "]"
      ],
      "id": "e4d04fac",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we go through each boundary condition and add it to $L(v)$ or include it in the list of Dirichlet boundary conditions, depending on its type"
      ],
      "id": "2c02cf19"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "bcs = []\n",
        "for condition in boundary_conditions:\n",
        "  if condition.type == \"Dirichlet\":\n",
        "    bcs.append(condition.bc)\n",
        "  else:\n",
        "    F += condition.bc"
      ],
      "id": "42b44415",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can now create the bilinear form `a` and the linear form `L` using the ufl functions `lhs` and `rhs`"
      ],
      "id": "fe73a05e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Solve linear variational problem\n",
        "a = lhs(F)\n",
        "L = rhs(F)\n",
        "\n",
        "problem = LinearProblem(\n",
        "  a, \n",
        "  L, \n",
        "  bcs=bcs, \n",
        "  petsc_options={\"ksp_type\": \"preonly\", \"pc_type\": \"lu\"}\n",
        ")\n",
        "uh = problem.solve()"
      ],
      "id": "e84bb31b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from pathlib import Path\n",
        "\n",
        "results_folder = Path(\"fenicsx/bcs_subdomains\")\n",
        "results_folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "# Visualize solution\n",
        "pyvista_cells, cell_types, geometry = vtk_mesh(V)\n",
        "grid = pyvista.UnstructuredGrid(pyvista_cells, cell_types, geometry)\n",
        "grid.point_data[\"u\"] = uh.x.array\n",
        "grid.set_active_scalars(\"u\")\n",
        "\n",
        "plotter = pyvista.Plotter(off_screen=True)\n",
        "plotter.add_text(\"uh\", position=\"upper_edge\", font_size=14, color=\"black\")\n",
        "plotter.add_mesh(grid, show_edges=True)\n",
        "plotter.view_xy()\n",
        "\n",
        "if not pyvista.OFF_SCREEN:\n",
        "  #plotter.show()\n",
        "  plotter.export_html(results_folder/\"robin_neumann_dirichlet.html\")\n",
        "else:\n",
        "  figure = plotter.screenshot(results_folder/\"robin_neumann_dirichlet.png\")"
      ],
      "id": "aee8a80c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/bcs_subdomains/robin_neumann_dirichlet.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "**Verification**\n",
        "\n",
        "Following the approach used in the previous problems, we calculate the error of the computed solution and compare it to the analytical solution"
      ],
      "id": "935c16e5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Compute L2 error and error at nodes\n",
        "V_ex = functionspace(mesh, (\"Lagrange\", 2))\n",
        "u_exact = Function(V_ex)\n",
        "u_exact.interpolate(u_ex)\n",
        "\n",
        "error_L2 = np.sqrt(\n",
        "  mesh.comm.allreduce(\n",
        "    assemble_scalar(form((uh -u_exact)**2 *dx)), \n",
        "    op=MPI.SUM\n",
        "  )\n",
        ")\n",
        "\n",
        "u_vertex_values = uh.x.array\n",
        "uex_1 = Function(V)\n",
        "uex_1.interpolate(u_ex)\n",
        "u_ex_vertex_values = uex_1.x.array\n",
        "\n",
        "error_max = np.max(np.abs(u_vertex_values -u_ex_vertex_values))\n",
        "error_max = mesh.comm.allreduce(error_max, op=MPI.MAX)\n",
        "\n",
        "print(f\"Error_L2 : {error_L2:.2e}\")\n",
        "print(f\"Error_max : {error_max:.2e}\")"
      ],
      "id": "0d96055f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "### Component-wise Dirichlet BC\n",
        "\n",
        "Author: Jørgen S. Dokken\n",
        "\n",
        "We consider the linear elasticity problem on the rectangular domain $\\Omega=[0,L]\\times[0,H]$ with displacement $u=(u_x,u_y)$. The strong form with the boundary conditions is\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "-\\,\\nabla\\cdot\\sigma(u) &= f &&\\quad\\text{in }\\Omega\\\\[2mm]\n",
        "u &= 0 &&\\quad\\text{on }\\Gamma_D \\;(\\text{bottom } y=0)\\\\[2mm]\n",
        "u_x &= 0 &&\\quad\\text{on }\\Gamma_{D_x} \\;(\\text{right } x=L) \\\\[2mm]\n",
        "\\sigma(u)\\cdot n &= 0 &&\\quad\\text{on }\\Gamma_N \\;(\\text{left } x=0 \\text{ and top } y=H)\n",
        "\\end{aligned}$$\n",
        "\n",
        "where the stress and strain are given by\n",
        "\n",
        "$$\\begin{aligned}\n",
        "\\sigma(u) &= \\lambda\\,\\mathrm{tr}(\\epsilon(u))\\,I + 2\\mu\\,\\epsilon(u)\\\\[2mm]\n",
        "\\epsilon(u) &= \\tfrac{1}{2}\\big(\\nabla u + \\nabla u^\\top\\big)\n",
        "\\end{aligned}$$\n",
        "\n",
        "**Physical interpretation**\n",
        "\n",
        "* $\\Gamma_D$ (bottom): The boundary is fully clamped, meaning both displacement components vanish\n",
        "\n",
        "$$u = (u_x,u_y) = 0$$\n",
        "\n",
        "* $\\Gamma_{D_x}$ (right): Only the horizontal displacement is constrained\n",
        "$u_x = 0$, while the vertical displacement $u_y$ is left free\n",
        "\n",
        "* $\\Gamma_N$ (left and top): These boundaries are traction-free, that is,\n",
        "\n",
        "$$\\sigma(u)\\cdot n = 0$$\n",
        "\n",
        "The chosen combination of boundary conditions eliminates possible rigid body motions. This ensures that the variational problem admits a unique solution, i.e. the problem is well-posed"
      ],
      "id": "f0a15fcc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from mpi4py import MPI\n",
        "import pyvista\n",
        "\n",
        "from dolfinx import default_scalar_type\n",
        "from dolfinx.mesh import CellType, create_rectangle, locate_entities_boundary\n",
        "from dolfinx.fem import (\n",
        "  Constant, dirichletbc, Function, functionspace, \n",
        "  locate_dofs_geometrical, locate_dofs_topological\n",
        ")\n",
        "from dolfinx.fem.petsc import LinearProblem\n",
        "from dolfinx.plot import vtk_mesh\n",
        "\n",
        "from petsc4py import PETSc\n",
        "\n",
        "from ufl import (\n",
        "  Identity, Measure, TestFunction, TrialFunction, \n",
        "  dot, dx, inner, grad, nabla_div, sym\n",
        ")\n",
        "\n",
        "L = 1\n",
        "H = 1.3\n",
        "\n",
        "lambda_ = 1.25\n",
        "mu = 1\n",
        "rho = 1\n",
        "g = 1"
      ],
      "id": "7474503b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "As in the previous demos, we begin by defining the computational mesh and the corresponding function space. The function space is chosen to represent vector-valued functions, since the unknown displacement field $u = (u_x, u_y)$ has two components"
      ],
      "id": "87d42237"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "mesh = create_rectangle(\n",
        "    MPI.COMM_WORLD, \n",
        "    np.array([[0, 0], [L, H]]), \n",
        "    [30, 30], \n",
        "    cell_type=CellType.triangle\n",
        ")\n",
        "V = functionspace(mesh, (\"Lagrange\", 1, (mesh.geometry.dim,)))"
      ],
      "id": "f4291f3c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Boundary conditions**\n",
        "\n",
        "Next, we define the boundary conditions for our problem"
      ],
      "id": "73268b95"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Define geometric tolerance\n",
        "tol = 1e-8\n",
        "\n",
        "# Locate boundary facets\n",
        "bottom_facets = locate_entities_boundary(\n",
        "  mesh, \n",
        "  mesh.topology.dim -1,\n",
        "  lambda x: np.isclose(x[1], 0.0, atol=tol)\n",
        ")\n",
        "\n",
        "right_facets = locate_entities_boundary(\n",
        "  mesh, \n",
        "  mesh.topology.dim -1,\n",
        "  lambda x: np.isclose(x[0], L, atol=tol)\n",
        ")\n",
        "\n",
        "# Define boundary conditions\n",
        "u_bc = Function(V)\n",
        "\n",
        "# Γ_D (bottom): u = (0,0)\n",
        "bc_bottom = dirichletbc(\n",
        "  PETSc.ScalarType((0.0, 0.0)), \n",
        "  locate_dofs_topological(V, mesh.topology.dim -1, bottom_facets), \n",
        "  V\n",
        ")\n",
        "\n",
        "# Γ_{Dx} (right): u_x = 0\n",
        "bc_right_x = dirichletbc(\n",
        "  PETSc.ScalarType(0.0),\n",
        "  locate_dofs_topological(V.sub(0), mesh.topology.dim -1, right_facets),\n",
        "  V.sub(0)\n",
        ")\n",
        "\n",
        "# Collect Dirichlet boundary conditions\n",
        "bcs = [bc_bottom, bc_right_x]"
      ],
      "id": "8c8f0ecb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note that the traction-free boundaries $\\Gamma_N$ (left and top) do not require explicit constraints in the variational formulation, since they are naturally included through the weak form of the problem\n",
        "\n",
        "**Variational formulation**\n",
        "\n",
        "We now turn to the weak form of the elasticity problem. Multiplying the PDE by a test function $v$ and integrating by parts yields the variational form\n",
        "\n",
        "$$a(u,v) = L(v)$$\n",
        "\n",
        "where\n",
        "\n",
        "$$\\begin{aligned}\n",
        "a(u,v) &= \\int_\\Omega \\sigma(u):\\epsilon(v) \\,\\mathrm{d}x \\\\\n",
        "L(v) &= \\int_\\Omega f \\cdot v \\,\\mathrm{d}x\n",
        "\\end{aligned}$$\n",
        "\n",
        "Note that the Neumann boundary conditions on $\\Gamma_N$ (traction-free boundaries) are naturally included in the weak formulation, and therefore do not need to be imposed explicitly"
      ],
      "id": "b74395df"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Strain and stress\n",
        "def epsilon(u):\n",
        "  return sym(grad(u))\n",
        "\n",
        "# linear problem: tr(epsilon(u)) = nabla_div(u)\n",
        "def sigma(u):\n",
        "  return lambda_ *nabla_div(u) *Identity(len(u)) + 2 *mu *epsilon(u)\n",
        "\n",
        "# Body force\n",
        "f = Constant(mesh, default_scalar_type((0, -rho *g)))\n",
        "\n",
        "# Define trial and test functions\n",
        "u = TrialFunction(V)\n",
        "v = TestFunction(V)\n",
        "\n",
        "# Bilinear form and linear form\n",
        "a = inner(sigma(u), epsilon(v)) *dx\n",
        "L = dot(f, v) *dx  # +dot(T, v) *ds"
      ],
      "id": "55501f92",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "As in the previous demos, we now assemble the system matrix and right-hand side vector, and then use `PETSc` to solve the resulting variational problem"
      ],
      "id": "e885800c"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Define linear problem using PETSc\n",
        "problem = LinearProblem(\n",
        "  a, \n",
        "  L, \n",
        "  bcs=bcs,\n",
        "  petsc_options={\n",
        "    \"ksp_type\": \"preonly\",\n",
        "    \"pc_type\": \"lu\"\n",
        "  }\n",
        ")\n",
        "\n",
        "# Solve the system\n",
        "uh = problem.solve()\n",
        "\n",
        "# Print solver information\n",
        "PETSc.Sys.Print(\"Linear system solved.\")"
      ],
      "id": "8c5b699b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Visualization**"
      ],
      "id": "19455d2d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from pathlib import Path\n",
        "\n",
        "results_folder = Path(\"fenicsx/bcs_subdomains\")\n",
        "results_folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "topology, cell_types, x = vtk_mesh(V)\n",
        "grid = pyvista.UnstructuredGrid(topology, cell_types, x)\n",
        "\n",
        "vals = np.zeros((x.shape[0], 3))\n",
        "vals[:, :len(uh)] = uh.x.array.reshape((x.shape[0], len(uh)))\n",
        "grid[\"u\"] = vals\n",
        "\n",
        "# Create plotter and pyvista grid\n",
        "plotter = pyvista.Plotter(off_screen=False)\n",
        "\n",
        "actor_0 = plotter.add_mesh(grid, style=\"wireframe\", color=\"k\")\n",
        "warped = grid.warp_by_vector(\"u\", factor=1.1)\n",
        "actor_1 = plotter.add_mesh(warped, opacity=0.8)\n",
        "plotter.view_xy()\n",
        "\n",
        "if not pyvista.OFF_SCREEN:\n",
        "  ##p.show()\n",
        "  plotter.export_html(results_folder/\"component.html\")\n",
        "else:\n",
        "  fig_array = plotter.screenshot(results_folder/\"component.png\")"
      ],
      "id": "b67b54e9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/bcs_subdomains/component.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "### Electromagnetics example\n",
        "\n",
        "Author: Hans Petter Langtangen, Anders Logg and Jørgen S. Dokken\n",
        "\n",
        "In this example, we consider an iron cylinder with copper wires wound around it, as illustrated below\n",
        "\n",
        "![](figures/fenicsx_wire.png)\n",
        "\n",
        "A static current of $J = 1\\,\\text{A}$ flows through the copper wires.\n",
        "Our goal is to compute the magnetic field B in the iron cylinder, the copper wires, and the surrounding vacuum\n",
        "\n",
        "To simplify the problem, we note that the cylinder extends far in the $z$-direction, so the field can be assumed to be independent of the $z$-coordinate. This reduces the problem to a two-dimensional cross-section in the $x$–$y$ plane\n",
        "\n",
        "We begin with Maxwell’s equations in magnetostatics:\n",
        "\n",
        "$$\\nabla \\cdot \\mathbf{B} = 0, \\quad \\nabla \\times \\mathbf{H} = \\mathbf{J}\n",
        "$$\n",
        "\n",
        "where $\\mathbf{B}$ is the magnetic flux density, $\\mathbf{H}$ is the magnetic field intensity, and $\\mathbf{J}$ is the current density.\n",
        "The constitutive relation connects $\\mathbf{B}$ and $\\mathbf{H}$:\n",
        "\n",
        "$$\\mathbf{B} = \\mu \\mathbf{H}$$\n",
        "\n",
        "with $\\mu$ denoting the magnetic permeability of the medium\n",
        "\n",
        "**Step 1:** Introducing the Vector Potential\n",
        "\n",
        "Since $\\nabla \\cdot \\mathbf{B} = 0$, we may represent the magnetic flux density using a vector potential $\\mathbf{A}$:\n",
        "\n",
        "$$\\mathbf{B} = \\nabla \\times \\mathbf{A}$$\n",
        "\n",
        "**Step 2:** Substituting into Ampère’s Law\n",
        "\n",
        "Using $\\mathbf{B} = \\mu \\mathbf{H}$, Ampère’s law becomes\n",
        "\n",
        "$$\\nabla \\times \\left(\\frac{1}{\\mu} \\nabla \\times \\mathbf{A}\\right) = \\mathbf{J}$$\n",
        "\n",
        "**Step 3:** Reduction to 2D\n",
        "\n",
        "For a long cylinder aligned with the $z$-axis and a current flowing along $z$, symmetry implies that the vector potential has only a $z$-component:\n",
        "\n",
        "$$\\mathbf{A}(x,y) = (0,0, A_z(x,y))$$\n",
        "\n",
        "Thus, the magnetic flux density lies in the $x$-$y$ plane\n",
        "\n",
        "**Step 4:** Scalar Poisson Equation\n",
        "\n",
        "With this reduction, the vector equation simplifies to a scalar Poisson equation for $A_z$:\n",
        "\n",
        "$$-\\nabla \\cdot \\left(\\frac{1}{\\mu} \\nabla A_z\\right) = J_z$$\n",
        "\n",
        "$$\\lim_{\\vert(x,y)\\vert\\to \\infty}A_z = 0$$\n",
        "\n",
        "where $J_z$ is the $z$-component of the current density. \n",
        "Once $A_z$ is known, the magnetic field can be recovered as\n",
        "\n",
        "$$\\mathbf{B} = \\nabla \\times \\mathbf{A} =\n",
        "\\left(\\frac{\\partial A_z}{\\partial y}, \\; -\\frac{\\partial A_z}{\\partial x}, \\; 0 \\right)$$\n",
        "\n",
        "Since we cannot compute on an infinite domain, we truncate the problem by surrounding the cylinder with a sufficiently large disk. On the boundary of this disk, we impose the condition $A_z = 0$\n",
        "\n",
        "The current density $J_z$ is prescribed inside the circular cross-sections of the copper wires. In the interior set of circles, we assign a current of $+1\\,\\mathrm{A}$, while in the exterior set of circles, we assign a current of $-1\\,\\mathrm{A}$. This ensures that the net current in the domain is balanced, making the problem well-posed and allowing for a consistent computation of the magnetic field throughout the iron, copper, and vacuum regions\n",
        "\n",
        "**Variational formulation**\n",
        "\n",
        "To derive the variational problem, we multiply the governing PDE\n",
        "by a test function $v$ and integrate over the computational domain $\\Omega$:\n",
        "\n",
        "$$-\\int_\\Omega \\nabla \\cdot \\left( \\mu^{-1} \\nabla A_z \\right) v \\,\\mathrm{d}x = \\int_\\Omega J_z v \\,\\mathrm{d}x$$\n",
        "\n",
        "Applying integration by parts (Green’s theorem) gives\n",
        "\n",
        "$$\\int_\\Omega \\mu^{-1} \\nabla A_z \\cdot \\nabla v \\,\\mathrm{d}x\n",
        "\t-\\int_{\\partial \\Omega} \\mu^{-1} \\frac{\\partial A_z}{\\partial n} v \\,\\mathrm{d}s = \\int_\\Omega J_z v \\,\\mathrm{d}x$$\n",
        "\n",
        "On the boundary $\\partial \\Omega$, we have prescribed $A_z = 0$, which implies that the test function $v$ also vanishes there. Consequently, the boundary integral disappears, leaving us with the variational formulation:\n",
        "\n",
        "$$a(A_z, v) = L(v)$$\n",
        "\n",
        "where\n",
        "\n",
        "$$ a(A_z, v) = \\int_\\Omega \\mu^{-1} \\nabla A_z \\cdot \\nabla v \\,\\mathrm{d}x, \\qquad\n",
        "L(v) = \\int_\\Omega J_z v \\,\\mathrm{d}x$$\n",
        "\n",
        "Thus, the problem reduces to finding $A_z \\in V$, where $V$ is the appropriate function space with homogeneous Dirichlet boundary conditions, such that\n",
        "\n",
        "$$a(A_z, v) = L(v) \\quad \\text{for all } v \\in V$$\n",
        "\n",
        "**Meshing a complex structure with subdomains**\n",
        "\n",
        "We now turn to the practical implementation of the problem. The first step is to create the computational mesh. We can construct this geometry in `GMSH`. Each physical region (iron, copper wires, vacuum, and outer boundary) is tagged with unique markers. These markers are preserved when the mesh is imported into `dolfinx`, and they allow us to assign different material parameters and source terms"
      ],
      "id": "d7162c22"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "\"\"\"\n",
        "Electromagnetic coil geometry generation using Gmsh and DOLFINx.\n",
        "This script creates a 2D geometry consisting of:\n",
        "- Iron cylinder (magnetic core)\n",
        "- Copper wire windings (inner and outer)\n",
        "- Vacuum/air background\n",
        "\"\"\"\n",
        "\n",
        "# Import required libraries\n",
        "import numpy as np\n",
        "from mpi4py import MPI\n",
        "\n",
        "import gmsh\n",
        "import pyvista\n",
        "\n",
        "from dolfinx import default_scalar_type\n",
        "from dolfinx.fem import (dirichletbc, Expression, Function, functionspace, \n",
        "                        locate_dofs_topological)\n",
        "from dolfinx.fem.petsc import LinearProblem\n",
        "from dolfinx.io import XDMFFile\n",
        "from dolfinx.io.gmshio import model_to_mesh\n",
        "from dolfinx.mesh import compute_midpoints, locate_entities_boundary\n",
        "from dolfinx.plot import vtk_mesh\n",
        "\n",
        "from ufl import TestFunction, TrialFunction, as_vector, dot, dx, grad, inner\n",
        "\n",
        "# MPI configuration\n",
        "rank = MPI.COMM_WORLD.rank\n",
        "\n",
        "# Initialize Gmsh\n",
        "gmsh.initialize()\n",
        "\n",
        "# ============================================================================\n",
        "# GEOMETRY PARAMETERS\n",
        "# ============================================================================\n",
        "R = 5      # Radius of computational domain\n",
        "\n",
        "a = 1      # Inner radius of iron cylinder\n",
        "b = 1.2    # Outer radius of iron cylinder\n",
        "\n",
        "N = 8      # Number of copper wire windings\n",
        "c_1 = 0.8  # Radius of inner copper wire circle\n",
        "c_2 = 1.4  # Radius of outer copper wire circle\n",
        "r = 0.1    # Radius of individual copper wires\n",
        "\n",
        "# Mesh parameters\n",
        "gdim = 2           # Geometric dimension (2D problem)\n",
        "model_rank = 0     # MPI rank responsible for geometry creation\n",
        "mesh_comm = MPI.COMM_WORLD\n",
        "\n",
        "# ============================================================================\n",
        "# GEOMETRY CREATION\n",
        "# ============================================================================\n",
        "if mesh_comm.rank == model_rank:\n",
        "\n",
        "    # ------------------------------------------------------------------------\n",
        "    # Create background domain (vacuum/air)\n",
        "    # ------------------------------------------------------------------------\n",
        "    print(\"Creating background domain...\")\n",
        "    background = gmsh.model.occ.addDisk(0, 0, 0, R, R)\n",
        "    gmsh.model.occ.synchronize()    \n",
        "    \n",
        "    # ------------------------------------------------------------------------\n",
        "    # Create iron cylinder (magnetic core)\n",
        "    # ------------------------------------------------------------------------\n",
        "    print(\"Creating iron cylinder geometry...\")\n",
        "    \n",
        "    # Create outer and inner boundaries of iron cylinder\n",
        "    outer_iron = gmsh.model.occ.addCircle(0, 0, 0, b)\n",
        "    inner_iron = gmsh.model.occ.addCircle(0, 0, 0, a)\n",
        "    \n",
        "    # Create curve loops and surface for iron cylinder (annular region)\n",
        "    gmsh.model.occ.addCurveLoop([outer_iron], 5)\n",
        "    gmsh.model.occ.addCurveLoop([inner_iron], 6)\n",
        "    iron = gmsh.model.occ.addPlaneSurface([5, 6])  # Surface with hole\n",
        "    gmsh.model.occ.synchronize()\n",
        "\n",
        "     # ------------------------------------------------------------------------\n",
        "    # Create copper wire windings\n",
        "    # ------------------------------------------------------------------------\n",
        "    print(f\"Creating {N} inner and {N} outer copper wire windings...\")\n",
        "    \n",
        "    # Inner copper wires (North polarity) - evenly distributed\n",
        "    angles_N = [i * 2 * np.pi / N for i in range(N)]\n",
        "    wires_N = []\n",
        "    for v in angles_N:\n",
        "        x_pos = c_1 * np.cos(v)\n",
        "        y_pos = c_1 * np.sin(v)\n",
        "        wire = gmsh.model.occ.addDisk(x_pos, y_pos, 0, r, r)\n",
        "        wires_N.append((2, wire))\n",
        "\n",
        "    # Outer copper wires (South polarity) - offset by half angle\n",
        "    angles_S = [(i + 0.5) * 2 * np.pi / N for i in range(N)]\n",
        "    wires_S = []\n",
        "    for v in angles_S:\n",
        "        x_pos = c_2 * np.cos(v)\n",
        "        y_pos = c_2 * np.sin(v)\n",
        "        wire = gmsh.model.occ.addDisk(x_pos, y_pos, 0, r, r)\n",
        "        wires_S.append((2, wire))\n",
        "    \n",
        "    gmsh.model.occ.synchronize()\n",
        "\n",
        "    # ------------------------------------------------------------------------\n",
        "    # Boolean operations to create final geometry\n",
        "    # ------------------------------------------------------------------------\n",
        "    print(\"Performing boolean operations...\")\n",
        "    \n",
        "    # Combine all surfaces for fragmentation\n",
        "    all_surfaces = [(2, iron)]\n",
        "    all_surfaces.extend(wires_S)\n",
        "    all_surfaces.extend(wires_N)\n",
        "    \n",
        "    # Fragment the background domain with all other surfaces\n",
        "    # This creates non-overlapping regions\n",
        "    whole_domain = gmsh.model.occ.fragment([(2, background)], all_surfaces)\n",
        "    gmsh.model.occ.synchronize()\n",
        "\n",
        "    # ------------------------------------------------------------------------\n",
        "    # Assign physical markers to different regions\n",
        "    # Physical markers are used for material properties:\n",
        "    # - Tag 0: Vacuum/air background\n",
        "    # - Tag 1: Iron cylinder\n",
        "    # - Tags 2 to N+1: Inner copper wires\n",
        "    # - Tags N+2 to 2*N+1: Outer copper wires\n",
        "    # ------------------------------------------------------------------------\n",
        "    print(\"Assigning physical markers...\")\n",
        "    \n",
        "    inner_tag = 2\n",
        "    outer_tag = 2 + N\n",
        "    background_surfaces = []\n",
        "    other_surfaces = []\n",
        "    \n",
        "    # Classify each surface based on geometric properties\n",
        "    for domain in whole_domain[0]:\n",
        "        # Get center of mass and total mass of the domain\n",
        "        com = gmsh.model.occ.getCenterOfMass(domain[0], domain[1])\n",
        "        mass = gmsh.model.occ.getMass(domain[0], domain[1])\n",
        "\n",
        "        # Identify iron cylinder by its characteristic mass\n",
        "        if np.isclose(mass, np.pi * (b**2 - a**2), rtol=1e-3):\n",
        "            gmsh.model.addPhysicalGroup(domain[0], [domain[1]], tag=1)\n",
        "            other_surfaces.append(domain)\n",
        "            print(f\"  Iron cylinder identified (tag=1)\")        \n",
        "\n",
        "        # Identify background surfaces by center of mass at origin\n",
        "        elif np.allclose(com, [0, 0, 0], atol=1e-6):\n",
        "            background_surfaces.append(domain[1])        \n",
        "        \n",
        "        # Identify inner copper wires by distance from origin\n",
        "        elif np.isclose(np.linalg.norm(com), c_1, rtol=1e-3):\n",
        "            gmsh.model.addPhysicalGroup(domain[0], [domain[1]], inner_tag)\n",
        "            print(f\"  Inner wire identified (tag={inner_tag})\")\n",
        "            inner_tag += 1\n",
        "            other_surfaces.append(domain)\n",
        "        \n",
        "        # Identify outer copper wires by distance from origin\n",
        "        elif np.isclose(np.linalg.norm(com), c_2, rtol=1e-3):\n",
        "            gmsh.model.addPhysicalGroup(domain[0], [domain[1]], outer_tag)\n",
        "            print(f\"  Outer wire identified (tag={outer_tag})\")\n",
        "            outer_tag += 1\n",
        "            other_surfaces.append(domain)\n",
        "    \n",
        "    # Assign physical marker for vacuum/air background\n",
        "    gmsh.model.addPhysicalGroup(2, background_surfaces, tag=0)\n",
        "    print(f\"  Background/vacuum regions identified (tag=0)\")\n",
        "\n",
        "    # ------------------------------------------------------------------------\n",
        "    # Configure adaptive mesh sizing\n",
        "    # ------------------------------------------------------------------------\n",
        "    print(\"Configuring mesh size fields...\")\n",
        "    \n",
        "    # Create distance field from wire and iron boundaries\n",
        "    gmsh.model.mesh.field.add(\"Distance\", 1)\n",
        "    edges = gmsh.model.getBoundary(other_surfaces, oriented=False)\n",
        "    gmsh.model.mesh.field.setNumbers(1, \"EdgesList\", [e[1] for e in edges])\n",
        "    \n",
        "    # Create threshold field for adaptive sizing\n",
        "    gmsh.model.mesh.field.add(\"Threshold\", 2)\n",
        "    gmsh.model.mesh.field.setNumber(2, \"IField\", 1)\n",
        "    gmsh.model.mesh.field.setNumber(2, \"LcMin\", r / 3)    # Fine mesh near wires\n",
        "    gmsh.model.mesh.field.setNumber(2, \"LcMax\", 6 * r)    # Coarse mesh far away\n",
        "    gmsh.model.mesh.field.setNumber(2, \"DistMin\", 4 * r)  # Distance for fine mesh\n",
        "    gmsh.model.mesh.field.setNumber(2, \"DistMax\", 10 * r) # Distance for coarse mesh\n",
        "    \n",
        "    # Set minimum field as background mesh\n",
        "    gmsh.model.mesh.field.add(\"Min\", 5)\n",
        "    gmsh.model.mesh.field.setNumbers(5, \"FieldsList\", [2])\n",
        "    gmsh.model.mesh.field.setAsBackgroundMesh(5)\n",
        "\n",
        "    # ------------------------------------------------------------------------\n",
        "    # Generate and optimize mesh\n",
        "    # ------------------------------------------------------------------------\n",
        "    print(\"Generating mesh...\")\n",
        "    \n",
        "    # Use Frontal-Delaunay algorithm for 2D meshing\n",
        "    gmsh.option.setNumber(\"Mesh.Algorithm\", 7)\n",
        "    \n",
        "    # Generate 2D mesh\n",
        "    gmsh.model.mesh.generate(gdim)\n",
        "    \n",
        "    # Optimize mesh quality using Netgen optimizer\n",
        "    print(\"Optimizing mesh quality...\")\n",
        "    gmsh.model.mesh.optimize(\"Netgen\")\n",
        "    \n",
        "    print(\"Geometry and mesh generation completed successfully!\")\n",
        "\n",
        "# Note: After this point, you would typically:\n",
        "# 1. Convert the Gmsh model to DOLFINx mesh using model_to_mesh()\n",
        "# 2. Set up the electromagnetic problem (Maxwell's equations)\n",
        "# 3. Apply boundary conditions\n",
        "# 4. Solve the finite element problem"
      ],
      "id": "181461f8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Following the Navier–Stokes tutorial, we load the mesh directly into DOLFINx without first writing it to a file"
      ],
      "id": "712f7a92"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "mesh, ct, _ = model_to_mesh(gmsh.model, mesh_comm, model_rank, gdim=2)\n",
        "gmsh.finalize()"
      ],
      "id": "b08832b5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To inspect the mesh, we use `ParaView` and obtain the following result"
      ],
      "id": "fdce70b1"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from pathlib import Path\n",
        "\n",
        "results_folder = Path(\"fenicsx/bcs_subdomains\")\n",
        "results_folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "with XDMFFile(MPI.COMM_WORLD, results_folder/\"mt_electro.xdmf\", \"w\") as xdmf:\n",
        "    xdmf.write_mesh(mesh)\n",
        "    xdmf.write_meshtags(ct, mesh.geometry)"
      ],
      "id": "4e84cfb8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "![](fenicsx/bcs_subdomains/mt_electro.png)\n",
        "\n",
        "We can also visualize the subdomains using `PyVista`"
      ],
      "id": "e3b2b92f"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plotter = pyvista.Plotter(off_screen=False)\n",
        "\n",
        "tdim = mesh.topology.dim\n",
        "mesh.topology.create_connectivity(tdim, tdim)\n",
        "num_local_cells = mesh.topology.index_map(tdim).size_local\n",
        "\n",
        "grid = pyvista.UnstructuredGrid(*vtk_mesh(mesh, tdim))\n",
        "grid.cell_data[\"Marker\"] = ct.values[ct.indices < num_local_cells]\n",
        "grid.set_active_scalars(\"Marker\")\n",
        "\n",
        "actor = plotter.add_mesh(grid, show_edges=True)\n",
        "plotter.view_xy()\n",
        "\n",
        "if not pyvista.OFF_SCREEN:\n",
        "    #plotter.show()\n",
        "    plotter.export_html(results_folder/\"cell_tags.html\")    \n",
        "else:\n",
        "    cell_tag_fig = plotter.screenshot(results_folder/\"cell_tags.png\")"
      ],
      "id": "a79693bb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/bcs_subdomains/cell_tags.html\"\n",
        "        width=\"100%\" height=\"800px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "Next, we define discontinuous functions for permeability $\\mu$ and current $J_z$, based on the MeshTags as in “Defining subdomains for different materials”"
      ],
      "id": "4e8c0285"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "\"\"\"\n",
        "Material properties and current density setup for electromagnetic simulation.\n",
        "This code assigns material properties (permeability) and current densities \n",
        "to different regions of the electromagnetic coil geometry.\n",
        "\"\"\"\n",
        "\n",
        "# ============================================================================\n",
        "# MATERIAL PROPERTIES AND CURRENT DENSITY SETUP\n",
        "# ============================================================================\n",
        "\n",
        "def setup_material_properties(mesh, ct, N):\n",
        "    \"\"\"\n",
        "    Set up material properties and current densities for electromagnetic simulation.\n",
        "    \n",
        "    Parameters:\n",
        "    -----------\n",
        "    mesh : dolfinx.mesh.Mesh\n",
        "        The computational mesh\n",
        "    ct : dolfinx.mesh.MeshTags\n",
        "        Cell tags identifying different material regions\n",
        "    N : int\n",
        "        Number of copper wire windings\n",
        "        \n",
        "    Returns:\n",
        "    --------\n",
        "    mu : dolfinx.fem.Function\n",
        "        Magnetic permeability function\n",
        "    J : dolfinx.fem.Function\n",
        "        Current density function\n",
        "    \"\"\"\n",
        "    \n",
        "    # Create discontinuous Galerkin function space (piecewise constant)\n",
        "    # DG(0) is appropriate for material properties that are constant within each element\n",
        "    Q = functionspace(mesh, (\"DG\", 0))\n",
        "    \n",
        "    # Get unique material tags from the mesh\n",
        "    material_tags = np.unique(ct.values)\n",
        "    print(f\"Found material tags: {material_tags}\")\n",
        "    \n",
        "    # Initialize functions for magnetic permeability and current density\n",
        "    mu = Function(Q)  # Magnetic permeability [H/m]\n",
        "    J = Function(Q)   # Current density [A/m²]\n",
        "    \n",
        "    # Initialize current density to zero everywhere\n",
        "    # (only copper wires will have non-zero current)\n",
        "    J.x.array[:] = 0.0\n",
        "    \n",
        "    print(\"Assigning material properties...\")\n",
        "    \n",
        "    # ------------------------------------------------------------------------\n",
        "    # MATERIAL PROPERTY DEFINITIONS\n",
        "    # ------------------------------------------------------------------------\n",
        "    \n",
        "    # Physical constants and material properties\n",
        "    mu_0 = 4 * np.pi * 1e-7        # Vacuum permeability [H/m]\n",
        "    mu_copper = 1.26e-6            # Copper permeability ≈ μ₀ [H/m]\n",
        "    mu_iron = 1e-5                 # Iron permeability (simplified) [H/m]\n",
        "                                   # Note: Real iron μ ≈ 6.3e-3, but using 1e-5 here\n",
        "    \n",
        "    # Current density magnitude [A/m²]\n",
        "    current_density_positive = 1.0   # Inner wires (North polarity)\n",
        "    current_density_negative = -1.0  # Outer wires (South polarity)\n",
        "    \n",
        "    # ------------------------------------------------------------------------\n",
        "    # ASSIGN PROPERTIES TO EACH MATERIAL REGION\n",
        "    # ------------------------------------------------------------------------\n",
        "    \n",
        "    for tag in material_tags:\n",
        "        # Find all cells belonging to this material tag\n",
        "        cells = ct.find(tag)\n",
        "        num_cells = len(cells)\n",
        "        \n",
        "        # Assign magnetic permeability based on material type\n",
        "        if tag == 0:\n",
        "            # Vacuum/air background\n",
        "            mu_value = mu_0\n",
        "            material_name = \"Vacuum/Air\"\n",
        "            \n",
        "        elif tag == 1:\n",
        "            # Iron cylinder (magnetic core)\n",
        "            mu_value = mu_iron\n",
        "            material_name = \"Iron\"\n",
        "            \n",
        "        else:\n",
        "            # Copper wires (both inner and outer)\n",
        "            mu_value = mu_copper\n",
        "            material_name = \"Copper\"\n",
        "        \n",
        "        # Set permeability values for all cells in this region\n",
        "        mu.x.array[cells] = np.full_like(cells, mu_value, dtype=default_scalar_type)\n",
        "        \n",
        "        # ------------------------------------------------------------------------\n",
        "        # ASSIGN CURRENT DENSITIES TO COPPER WIRES\n",
        "        # ------------------------------------------------------------------------\n",
        "        \n",
        "        # Inner copper wires (tags 2 to N+1) - positive current (North polarity)\n",
        "        if tag in range(2, 2 + N):\n",
        "            J.x.array[cells] = np.full_like(cells, current_density_positive, \n",
        "                                          dtype=default_scalar_type)\n",
        "            current_info = f\" | J = +{current_density_positive} A/m²\"\n",
        "            \n",
        "        # Outer copper wires (tags N+2 to 2N+1) - negative current (South polarity)\n",
        "        elif tag in range(2 + N, 2 * N + 2):\n",
        "            J.x.array[cells] = np.full_like(cells, current_density_negative, \n",
        "                                          dtype=default_scalar_type)\n",
        "            current_info = f\" | J = {current_density_negative} A/m²\"\n",
        "            \n",
        "        else:\n",
        "            # Non-conducting materials (vacuum, iron)\n",
        "            current_info = \" | J = 0 A/m²\"\n",
        "        \n",
        "        # Print material assignment summary\n",
        "        print(f\"  Tag {tag:2d}: {material_name:10s} \"\n",
        "              f\"| μ = {mu_value:.2e} H/m{current_info} \"\n",
        "              f\"| {num_cells:4d} cells\")\n",
        "    \n",
        "    print(\"Material properties assignment completed.\")\n",
        "    \n",
        "    return mu, J\n",
        "\n",
        "# ============================================================================\n",
        "# USAGE EXAMPLE\n",
        "# ============================================================================\n",
        "\n",
        "# Assuming mesh, ct, and N are already defined from the geometry creation\n",
        "mu, J = setup_material_properties(mesh, ct, N)"
      ],
      "id": "f1d46b7e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "In the code above, a slightly less extreme value for the magnetic permeability of iron was chosen to make the solution more illustrative; otherwise, the field in the iron cylinder would dominate completely.\n",
        "\n",
        "We now proceed to define the weak problem"
      ],
      "id": "0de2d823"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "\"\"\"\n",
        "Finite Element Formulation for 2D Electromagnetic Problem (Magnetostatic).\n",
        "This code sets up the weak form for solving ∇×(1/μ ∇×A) = J\n",
        "where A is the magnetic vector potential (z-component only in 2D)\n",
        "\"\"\"\n",
        "\n",
        "def setup_electromagnetic_problem(mesh, mu, J):\n",
        "    \"\"\"\n",
        "    Set up finite element formulation for 2D magnetostatic problem.\n",
        "    \n",
        "    Parameters:\n",
        "    -----------\n",
        "    mesh : dolfinx.mesh.Mesh\n",
        "        Computational mesh\n",
        "    mu : dolfinx.fem.Function  \n",
        "        Magnetic permeability function\n",
        "    J : dolfinx.fem.Function\n",
        "        Current density function\n",
        "        \n",
        "    Returns:\n",
        "    --------\n",
        "    a : ufl.Form\n",
        "        Bilinear form (left-hand side)\n",
        "    L : ufl.Form  \n",
        "        Linear form (right-hand side)\n",
        "    bc : dolfinx.fem.DirichletBC\n",
        "        Boundary condition\n",
        "    V : dolfinx.fem.FunctionSpace\n",
        "        Function space\n",
        "    \"\"\"\n",
        "    \n",
        "    print(\"Setting up finite element formulation...\")\n",
        "    \n",
        "    # ------------------------------------------------------------------------\n",
        "    # Function Space Definition\n",
        "    # ------------------------------------------------------------------------\n",
        "    # Use first-order Lagrange elements (P1) for magnetic vector potential\n",
        "    # In 2D, we solve for A_z component only (out-of-plane)\n",
        "    V = functionspace(mesh, (\"Lagrange\", 1))\n",
        "    \n",
        "    print(f\"Function space: P1 Lagrange elements\")\n",
        "    print(f\"Total DOFs: {V.dofmap.index_map.size_global}\")\n",
        "    \n",
        "    # ------------------------------------------------------------------------\n",
        "    # Boundary Conditions\n",
        "    # ------------------------------------------------------------------------\n",
        "    # Apply homogeneous Dirichlet BC: A_z = 0 on entire boundary\n",
        "    # This assumes the magnetic vector potential vanishes at far-field\n",
        "    \n",
        "    # Get topological dimension for boundary identification\n",
        "    tdim = mesh.topology.dim  # Should be 2 for 2D problem\n",
        "    \n",
        "    # Locate all boundary facets (edges in 2D, faces in 3D)\n",
        "    # The lambda function returns True for all boundary points\n",
        "    facets = locate_entities_boundary(mesh, tdim - 1, \n",
        "                                    lambda x: np.full(x.shape[1], True))\n",
        "    \n",
        "    # Find degrees of freedom on boundary facets\n",
        "    dofs = locate_dofs_topological(V, tdim - 1, facets)\n",
        "    \n",
        "    # Create homogeneous Dirichlet boundary condition: A_z = 0\n",
        "    bc = dirichletbc(default_scalar_type(0), dofs, V)\n",
        "    \n",
        "    print(f\"Boundary condition: A_z = 0 on {len(facets)} boundary facets\")\n",
        "    print(f\"Constrained DOFs: {len(dofs)}\")\n",
        "    \n",
        "    # ------------------------------------------------------------------------\n",
        "    # Weak Form Definition\n",
        "    # ------------------------------------------------------------------------\n",
        "    # Define trial and test functions\n",
        "    u = TrialFunction(V)  # Trial function (A_z)\n",
        "    v = TestFunction(V)   # Test function\n",
        "    \n",
        "    # Bilinear form: a(u,v) = ∫ (1/μ) ∇u · ∇v dx\n",
        "    # This comes from the weak form of ∇×(1/μ ∇×A) = J\n",
        "    # In 2D: ∇×A = (∂A_z/∂y, -∂A_z/∂x), so |∇×A|² = |∇A_z|²\n",
        "    a = (1 / mu) * dot(grad(u), grad(v)) * dx\n",
        "    \n",
        "    # Linear form: L(v) = ∫ J·v dx  \n",
        "    # Current density source term\n",
        "    L = J * v * dx\n",
        "    \n",
        "    print(\"Weak form successfully defined:\")\n",
        "    print(\"  Bilinear form: a(u,v) = ∫ (1/μ) ∇u·∇v dx\")\n",
        "    print(\"  Linear form:   L(v)   = ∫ J v dx\")\n",
        "    print(\"  Boundary condition: u = 0 on ∂Ω\")\n",
        "    \n",
        "    return a, L, bc, V\n",
        "\n",
        "a, L, bc, V = setup_electromagnetic_problem(mesh, mu, J)    "
      ],
      "id": "65e03a92",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We are now ready to solve the linear problem"
      ],
      "id": "f03b3c18"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def solve_electromagnetic_enhanced(V, a, L, bc, solver_options=None):\n",
        "    \"\"\"\n",
        "    Enhanced solver with better control and monitoring.\n",
        "    \"\"\"\n",
        "    \n",
        "    print(\"Setting up enhanced electromagnetic solver...\")\n",
        "    \n",
        "    # Create solution function\n",
        "    A_z = Function(V)\n",
        "    A_z.name = \"MagneticVectorPotential\"  # For visualization\n",
        "    \n",
        "    # Default solver options\n",
        "    if solver_options is None:\n",
        "        solver_options = {\n",
        "            \"ksp_type\": \"cg\",           # Conjugate Gradient\n",
        "            \"pc_type\": \"hypre\",         # Hypre preconditioner  \n",
        "            \"ksp_rtol\": 1e-8,           # Relative tolerance\n",
        "            \"ksp_atol\": 1e-12,          # Absolute tolerance\n",
        "            \"ksp_max_it\": 1000,         # Maximum iterations\n",
        "            \"ksp_monitor\": None,        # Monitor convergence\n",
        "        }\n",
        "    \n",
        "    # Create linear problem with custom options\n",
        "    problem = LinearProblem(\n",
        "        a, L, \n",
        "        u=A_z, \n",
        "        bcs=[bc],\n",
        "        petsc_options=solver_options\n",
        "    )\n",
        "    \n",
        "    print(\"Solver configuration:\")\n",
        "    print(f\"  Method: {solver_options.get('ksp_type', 'default')}\")\n",
        "    print(f\"  Preconditioner: {solver_options.get('pc_type', 'default')}\")\n",
        "    print(f\"  Tolerance: {solver_options.get('ksp_rtol', 'default')}\")\n",
        "    \n",
        "    # Solve with timing\n",
        "    import time\n",
        "    start_time = time.time()\n",
        "    \n",
        "    try:\n",
        "        problem.solve()\n",
        "        solve_time = time.time() -start_time\n",
        "        \n",
        "        print(\"✅ Solution completed successfully!\")\n",
        "        print(f\"  Solve time: {solve_time:.3f} seconds\")\n",
        "        print(f\"  Solution range: [{A_z.x.array.min():.6e}, {A_z.x.array.max():.6e}]\")\n",
        "        print(f\"  Solution norm: {np.linalg.norm(A_z.x.array):.6e}\")\n",
        "        \n",
        "        # Check for reasonable solution\n",
        "        if np.all(np.abs(A_z.x.array) < 1e-15):\n",
        "            print(\"⚠️  WARNING: Solution is nearly zero - check source terms and materials\")\n",
        "            \n",
        "    except Exception as e:\n",
        "        print(f\"❌ Solver failed: {e}\")\n",
        "        raise\n",
        "    \n",
        "    return A_z\n",
        "\n",
        "A_z = solve_electromagnetic_enhanced(V, a, L, bc)"
      ],
      "id": "27fd82a0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "As we have computed the magnetic potential, we can now calculate the magnetic field by setting $\\mathbf{B} = \\nabla \\times A_z$. Note that, since we have chosen a function space of first-order piecewise linear functions to represent the potential, the curl of a function in this space is a discontinuous zeroth-order function (i.e., a function that is constant on each cell). We use `dolfinx.fem.Expression` to interpolate the curl into the function space `W`"
      ],
      "id": "d3da3141"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "\"\"\"\n",
        "Magnetic flux density calculation from magnetic vector potential.\n",
        "This code computes B = ∇ × A where A = A_z ẑ in 2D.\n",
        "Result: B = (∂A_z/∂y, -∂A_z/∂x) = (B_x, B_y)\n",
        "\"\"\"\n",
        "\n",
        "def calculate_magnetic_field(mesh, A_z):\n",
        "    \"\"\"\n",
        "    Magnetic field calculation\n",
        "    \n",
        "    Parameters:\n",
        "    -----------\n",
        "    mesh : dolfinx.mesh.Mesh\n",
        "        Computational mesh\n",
        "    A_z : dolfinx.fem.Function\n",
        "        Magnetic vector potential (z-component)\n",
        "        \n",
        "    Returns:\n",
        "    --------\n",
        "    B : dolfinx.fem.Function\n",
        "        Magnetic flux density vector field (B_x, B_y)\n",
        "    \"\"\"\n",
        "    \n",
        "    print(\"Calculating magnetic flux density B = ∇ × A...\")\n",
        "    \n",
        "    # Create vector function space for B field\n",
        "    # DG(0) = piecewise constant discontinuous elements\n",
        "    # (mesh.geometry.dim, ) creates vector space with 2 components in 2D\n",
        "    W = functionspace(mesh, (\"DG\", 0, (mesh.geometry.dim, )))\n",
        "    \n",
        "    # Create function to store magnetic flux density\n",
        "    B = Function(W)\n",
        "    B.name = \"MagneticFluxDensity\"\n",
        "    \n",
        "    # Calculate B = ∇ × A = (∂A_z/∂y, -∂A_z/∂x) in 2D\n",
        "    # A_z.dx(0) = ∂A_z/∂x (derivative w.r.t. first coordinate)  \n",
        "    # A_z.dx(1) = ∂A_z/∂y (derivative w.r.t. second coordinate)\n",
        "    B_expr = Expression(\n",
        "        as_vector((A_z.dx(1), -A_z.dx(0))), \n",
        "        W.element.interpolation_points()\n",
        "    )\n",
        "    \n",
        "    # Interpolate the expression onto the DG function space\n",
        "    B.interpolate(B_expr)\n",
        "    \n",
        "    # Calculate magnitude for reporting\n",
        "    B_magnitude = np.sqrt(B.x.array[0::2]**2 + B.x.array[1::2]**2)\n",
        "    \n",
        "    print(\"✅ Magnetic flux density calculated successfully!\")\n",
        "    print(f\"  B_x range: [{B.x.array[0::2].min():.6e}, {B.x.array[0::2].max():.6e}] T\")\n",
        "    print(f\"  B_y range: [{B.x.array[1::2].min():.6e}, {B.x.array[1::2].max():.6e}] T\") \n",
        "    print(f\"  |B| range: [{B_magnitude.min():.6e}, {B_magnitude.max():.6e}] T\")\n",
        "    \n",
        "    return B\n",
        "\n",
        "B = calculate_magnetic_field(mesh, A_z)"
      ],
      "id": "c2e02ac8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note that we use `ufl.as_vector` to interpret the Python tuple `(A_z.dx(1), -A_z.dx(0))` as a vector in UFL\n",
        "\n",
        "We now plot the magnetic potential `A_z` and the magnetic field `B`. To do this, we first create a new `plotter`"
      ],
      "id": "2554ecfc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "plotter = pyvista.Plotter(off_screen=False)\n",
        "\n",
        "Az_grid = pyvista.UnstructuredGrid(*vtk_mesh(V))\n",
        "Az_grid.point_data[\"A_z\"] = A_z.x.array\n",
        "Az_grid.set_active_scalars(\"A_z\")\n",
        "\n",
        "warp = Az_grid.warp_by_scalar(\"A_z\", factor=1e7)\n",
        "actor = plotter.add_mesh(warp, show_edges=True)\n",
        "\n",
        "if not pyvista.OFF_SCREEN:\n",
        "    #plotter.show()\n",
        "    plotter.export_html(results_folder/\"Az.html\")    \n",
        "else:\n",
        "    Az_fig = plotter.screenshot(results_folder/\"Az.png\")"
      ],
      "id": "fb4e778a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/bcs_subdomains/Az.html\"\n",
        "        width=\"100%\" height=\"800px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "**Visualizing the magnetic field**\n",
        "\n",
        "Since the magnetic field is a piecewise-constant vector field, we need to create a custom plotting function. We begin by computing the midpoints of each cell, which are the locations where we want to visualize the cell-wise constant vectors. Next, we extract the data from the function `B` and reshape it into 3D vectors. Finally, we associate each vector with its corresponding midpoint using `pyvista.PolyData`"
      ],
      "id": "ff24efa8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "\"\"\"\n",
        "Magnetic field visualization using PyVista for 2D electromagnetic simulation.\n",
        "This code creates vector glyphs to visualize the magnetic flux density B field.\n",
        "\"\"\"\n",
        "\n",
        "def visualize_magnetic_field(mesh, B, scale_factor=2e6):\n",
        "    \"\"\"\n",
        "    Magnetic field visualization\n",
        "    \n",
        "    Parameters:\n",
        "    -----------\n",
        "    mesh : dolfinx.mesh.Mesh\n",
        "        The computational mesh\n",
        "    B : dolfinx.fem.Function\n",
        "        Magnetic flux density vector field\n",
        "    scale_factor : float\n",
        "        Scaling factor for vector glyphs\n",
        "        \n",
        "    Returns:\n",
        "    --------\n",
        "    plotter : pyvista.Plotter\n",
        "        Configured plotter object\n",
        "    \"\"\"\n",
        "    \n",
        "    print(\"Setting up magnetic field visualization...\")\n",
        "    \n",
        "    # Extract function space information from B\n",
        "    W = B.function_space  # Get function space from B field\n",
        "\n",
        "    # Create plotter\n",
        "    plotter = pyvista.Plotter(off_screen=False)\n",
        "    plotter.set_position([0, 0, 5])  # Camera position\n",
        "    \n",
        "    # -----------------------------------------------------------------------\n",
        "    # MESH SETUP (with ghost cells for parallel processing)\n",
        "    # -----------------------------------------------------------------------\n",
        "    \n",
        "    # Get topology information including ghost cells\n",
        "    top_imap = mesh.topology.index_map(mesh.topology.dim)\n",
        "    num_cells = top_imap.size_local + top_imap.num_ghosts\n",
        "    \n",
        "    print(f\"Total cells (including ghosts): {num_cells}\")\n",
        "    \n",
        "    # Ensure connectivity is created\n",
        "    mesh.topology.create_connectivity(mesh.topology.dim, mesh.topology.dim)\n",
        "    \n",
        "    # Compute cell midpoints for vector placement\n",
        "    cell_indices = np.arange(num_cells, dtype=np.int32)\n",
        "    midpoints = compute_midpoints(mesh, mesh.topology.dim, cell_indices)\n",
        "    \n",
        "    # -----------------------------------------------------------------------\n",
        "    # VECTOR FIELD DATA PREPARATION\n",
        "    # -----------------------------------------------------------------------\n",
        "    \n",
        "    # Get DOF information \n",
        "    num_dofs = W.dofmap.index_map.size_local + W.dofmap.index_map.num_ghosts\n",
        "    block_size = W.dofmap.index_map_bs  # Should be 2 for 2D vector field\n",
        "    \n",
        "    print(f\"DOFs: {num_dofs}, Block size: {block_size}\")\n",
        "    \n",
        "    # Verify consistency\n",
        "    assert num_cells == num_dofs, f\"Mismatch: {num_cells} cells vs {num_dofs} DOFs\"\n",
        "    \n",
        "    # Prepare 3D vector data (PyVista requires 3D vectors)\n",
        "    values = np.zeros((num_dofs, 3), dtype=np.float64)\n",
        "    \n",
        "    # Reshape B field data and assign to first 2 components\n",
        "    # B.x.array is [Bx0, By0, Bx1, By1, ...] for DG elements\n",
        "    B_reshaped = B.x.array.real.reshape(num_dofs, block_size)\n",
        "    values[:, :mesh.geometry.dim] = B_reshaped  # Fill (Bx, By, 0)\n",
        "    \n",
        "    print(f\"B field range: [{np.linalg.norm(values, axis=1).min():.3e}, \"\n",
        "          f\"{np.linalg.norm(values, axis=1).max():.3e}] T\")\n",
        "    \n",
        "    # -----------------------------------------------------------------------\n",
        "    # PYVISTA VISUALIZATION SETUP  \n",
        "    # -----------------------------------------------------------------------\n",
        "    \n",
        "    # Create point cloud at cell midpoints\n",
        "    cloud = pyvista.PolyData(midpoints)\n",
        "    cloud[\"B\"] = values  # Attach vector field data\n",
        "    \n",
        "    # Create vector glyphs (arrows) \n",
        "    glyphs = cloud.glyph(\"B\", factor=scale_factor)\n",
        "    \n",
        "    # Add wireframe mesh\n",
        "    try:\n",
        "        # Convert DOLFINx mesh to PyVista grid\n",
        "        grid = vtk_mesh(mesh, mesh.topology.dim)[0]\n",
        "        actor_mesh = plotter.add_mesh(grid, style=\"wireframe\", color=\"k\", \n",
        "                                     line_width=1, opacity=0.3)\n",
        "    except Exception as e:\n",
        "        print(f\"⚠️  Could not add mesh wireframe: {e}\")\n",
        "        actor_mesh = None\n",
        "    \n",
        "    # Add vector field glyphs\n",
        "    actor_vectors = plotter.add_mesh(glyphs, color=\"red\", \n",
        "                                   scalar_bar_args={\"title\": \"B [T]\"})\n",
        "    \n",
        "    # Set up camera and view\n",
        "    plotter.camera_position = \"xy\"  # Top-down view for 2D\n",
        "    plotter.add_axes()\n",
        "    plotter.show_grid()\n",
        "    \n",
        "    print(\"✅ Visualization setup complete!\")\n",
        "    \n",
        "    return plotter\n",
        "\n",
        "plotter = visualize_magnetic_field(mesh, B)"
      ],
      "id": "3236378f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "if not pyvista.OFF_SCREEN:\n",
        "    #plotter.show()\n",
        "    plotter.export_html(results_folder/\"B.html\")    \n",
        "else:\n",
        "    Az_fig = plotter.screenshot(results_folder/\"B.png\")"
      ],
      "id": "3c87d7b0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/bcs_subdomains/B.html\"\n",
        "        width=\"100%\" height=\"800px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```\n",
        "\n",
        "## Best Practices for FEniCSx\n",
        "\n",
        "### Solver configuration\n",
        "\n",
        "Author: Jørgen S. Dokken\n",
        "\n",
        "In this section, we demonstrate how to specify the linear algebra solver to be used for solving our PDEs, and how to verify the implementation by examining convergence rates:\n",
        "\n",
        "$$-\\Delta u = f \\quad \\text{in } \\Omega, \\qquad\n",
        "u = u_D \\quad \\text{on } \\partial \\Omega$$\n",
        "\n",
        "Using the manufactured solution $u_D = \\cos(2\\pi x)\\cos(2\\pi y)$, we obtain the right-hand side function $f = 8\\pi^2 \\cos(2\\pi x)\\cos(2\\pi y)$\n",
        "\n",
        "We begin by creating a generic module that evaluates the analytical solution at any point $x$"
      ],
      "id": "3cdec6f5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy\n",
        "from mpi4py import MPI\n",
        "from petsc4py import PETSc\n",
        "\n",
        "from dolfinx.mesh import create_unit_square, locate_entities_boundary\n",
        "from dolfinx.fem import dirichletbc, functionspace, Function, locate_dofs_topological\n",
        "from dolfinx.fem.petsc import LinearProblem\n",
        "\n",
        "import ufl\n",
        "from ufl import SpatialCoordinate, TestFunction, TrialFunction, div, dx, inner, grad\n",
        "\n",
        "\n",
        "def u_ex(mod):\n",
        "    return lambda x: mod.cos(2 * mod.pi * x[0]) * mod.cos(2 * mod.pi * x[1])"
      ],
      "id": "36db1e8d",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note that the return type of `u_ex` is a lambda function. Therefore, we can define two separate lambda functions: one using `NumPy` (for interpolation) and one using `UFL` (for defining the source term)"
      ],
      "id": "ae970490"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "u_numpy = u_ex(numpy)\n",
        "u_ufl = u_ex(ufl)"
      ],
      "id": "0064f887",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We begin by defining the source term in `UFL`, using `ufl.SpatialCoordinate` as the input to `u_ufl`"
      ],
      "id": "e8c91122"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "mesh = create_unit_square(MPI.COMM_WORLD, 30, 30)\n",
        "x = SpatialCoordinate(mesh)\n",
        "f = -div(grad(u_ufl(x)))"
      ],
      "id": "7da24672",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, let us define our linear variational problem"
      ],
      "id": "6b07d94b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "V = functionspace(mesh, (\"Lagrange\", 1))\n",
        "u = TrialFunction(V)\n",
        "v = TestFunction(V)\n",
        "\n",
        "a = inner(grad(u), grad(v)) *dx\n",
        "L = f *v *dx\n",
        "\n",
        "u_bc = Function(V)\n",
        "u_bc.interpolate(u_numpy)\n",
        "\n",
        "facets = locate_entities_boundary(\n",
        "  mesh, \n",
        "  mesh.topology.dim -1, \n",
        "  lambda x: numpy.full(x.shape[1], True)\n",
        ")\n",
        "dofs = locate_dofs_topological(V, mesh.topology.dim -1, facets)\n",
        "bcs = [dirichletbc(u_bc, dofs)]"
      ],
      "id": "97a52ee7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We begin by solving the problem using LU factorization, a direct solver method similar to Gaussian elimination"
      ],
      "id": "10358ef0"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "default_problem = LinearProblem(\n",
        "  a, \n",
        "  L, \n",
        "  bcs=bcs,\n",
        "  petsc_options={\"ksp_type\": \"preonly\", \"pc_type\": \"lu\"}\n",
        ")\n",
        "uh = default_problem.solve()"
      ],
      "id": "4920cc41",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We now examine the solver process by inspecting the `PETSc` solver. Since the view options in `PETSc` are not adapted for notebooks (for example, `solver.view()` prints output to the terminal when used in a `.py` file), we instead write the solver output to a file, read it back, and then print it"
      ],
      "id": "fce04d93"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from pathlib import Path\n",
        "\n",
        "results_folder = Path(\"fenicsx/best_practices\")\n",
        "results_folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "lu_solver = default_problem.solver\n",
        "viewer = PETSc.Viewer().createASCII(str(results_folder/\"lu_output.txt\"))\n",
        "lu_solver.view(viewer)\n",
        "viewer.destroy()\n",
        "\n",
        "with open(str(results_folder/\"lu_output.txt\"), \"r\") as solver_output:\n",
        "  for line in solver_output:\n",
        "      print(line.rstrip()) "
      ],
      "id": "ab7f4ee8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "This is a robust and straightforward method, and it is recommended for problems with up to a few thousand unknowns. It can be used efficiently for many 2D problems and smaller 3D problems. However, sparse LU decomposition quickly becomes inefficient, since for an $N \\times N$ matrix the number of floating-point operations scales as $\\sim \\tfrac{2}{3}N^3$\n",
        "\n",
        "For larger problems, we instead turn to iterative methods, which are faster and require less memory\n",
        "\n",
        "**How to choose a linear solver and preconditioner**\n",
        "\n",
        "Since the Poisson equation leads to a symmetric, positive-definite system matrix, the optimal Krylov solver is the conjugate gradient (CG) method. By default, the preconditioner is incomplete LU factorization (ILU), a widely used and robust choice\n",
        "\n",
        "The preconditioner can be changed by setting \"`pc_type`\" to any of the other `PETSc` preconditioners, as listed in the [`PETSc` KSP solvers](https://petsc.org/release/manual/ksp/#tab-kspdefaults) and [`PETSc` preconditioners](https://petsc.org/release/manual/ksp/#tab-pcdefaults) documentation\n",
        "\n",
        "Any `PETSc` option can be set through the `petsc_options` input, including the absolute tolerance (\"`ksp_atol`\"), relative tolerance (\"`ksp_rtol`\"), and maximum number of iterations (\"`ksp_max_it`\")"
      ],
      "id": "cf3ae788"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "cg_problem = LinearProblem(\n",
        "  a, \n",
        "  L, \n",
        "  bcs=bcs,\n",
        "  petsc_options={\n",
        "    \"ksp_type\": \"cg\", \n",
        "    \"ksp_rtol\": 1e-6, \n",
        "    \"ksp_atol\": 1e-10, \n",
        "    \"ksp_max_it\": 1000\n",
        "  }\n",
        ")\n",
        "uh = cg_problem.solve()\n",
        "\n",
        "cg_solver = cg_problem.solver\n",
        "viewer = PETSc.Viewer().createASCII(str(results_folder/\"cg_output.txt\"))\n",
        "cg_solver.view(viewer)\n",
        "viewer.destroy()\n",
        "\n",
        "with open(str(results_folder/\"cg_output.txt\"), \"r\") as solver_output:\n",
        "  for line in solver_output.readlines():\n",
        "      print(line.rstrip())    "
      ],
      "id": "1587d6a4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "For non-symmetric systems, it is preferable to use a Krylov solver designed for such problems, for example `GMRES`"
      ],
      "id": "98603ea4"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "gmres_problem = LinearProblem(\n",
        "  a, \n",
        "  L, \n",
        "  bcs=bcs,\n",
        "  petsc_options={\n",
        "    \"ksp_type\": \"gmres\", \n",
        "    \"ksp_rtol\": 1e-6, \n",
        "    \"ksp_atol\": 1e-10, \n",
        "    \"ksp_max_it\": 1000, \n",
        "    \"pc_type\": \"none\"\n",
        "  }\n",
        ")\n",
        "uh = gmres_problem.solve()\n",
        "\n",
        "gmres_solver = gmres_problem.solver\n",
        "viewer = PETSc.Viewer().createASCII(str(results_folder/\"gmres_output.txt\"))\n",
        "gmres_solver.view(viewer)\n",
        "viewer.destroy()\n",
        "\n",
        "with open(str(results_folder/\"gmres_output.txt\"), \"r\") as solver_output:\n",
        "  for line in solver_output.readlines():\n",
        "      print(line.rstrip())       "
      ],
      "id": "affe00d1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "::: callout-note\n",
        "When using manufactured solutions, we often expect the error to be close to machine precision. However, this becomes more complicated when iterative methods are employed. The key issue is ensuring that the error introduced by the iterative solver remains smaller than the tolerance used in the convergence test. For linear elements and small meshes, a tolerance in the range of $10^{-12}$ to $10^{-14}$ also works well when using Krylov solvers\n",
        ":::\n",
        "\n",
        "### JIT options and visualization using Pandas\n",
        "\n",
        "Author: Jørgen S. Dokken\n",
        "\n",
        "In this section, we explore how to optimize and inspect the integration kernels used in `dolfinx`. As seen in the previous demos, `dolfinx` uses the Unified Form Language ([`UFL`](https://github.com/FEniCS/ufl/)) to describe variational problems\n",
        "\n",
        "These `UFL` descriptions must be translated into code for assembling the right- and left-hand sides of the discrete variational problem\n",
        "\n",
        "`dolfinx` uses [`ffcx`](https://github.com/FEniCS/ffcx/) to generate efficient `C` code for assembling element matrices. This `C` code is then compiled via [`CFFI`](https://cffi.readthedocs.io/en/latest/), and a variety of compilation options can be specified\n",
        "\n",
        "We begin by specifying the current directory as the location to store the generated `C` files. The current directory is obtained using `pathlib`"
      ],
      "id": "25c989bd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import time\n",
        "from typing import Dict\n",
        "from pathlib import Path\n",
        "\n",
        "from mpi4py import MPI\n",
        "import pandas as pd\n",
        "\n",
        "import matplotlib.pyplot as plt\n",
        "import seaborn\n",
        "\n",
        "from dolfinx.mesh import create_unit_cube\n",
        "from dolfinx.fem import functionspace, form\n",
        "from dolfinx.fem.petsc import assemble_matrix\n",
        "\n",
        "import ufl\n",
        "from ufl import TestFunction, TrialFunction, dx, inner\n",
        "\n",
        "cache_dir = f\"{str(Path.cwd())}/.cache\"\n",
        "print(f\"Directory to put C files in: {cache_dir}\")"
      ],
      "id": "a94e2273",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we generate a general function to assemble the mass matrix for a unit cube. Note that we use `dolfinx.fem.form` to compile the variational form. For code that uses `dolfinx.fem.petsc.LinearProblem`, you can pass `jit_options` as a keyword argument"
      ],
      "id": "40dd5a63"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def compile_form(space: str, degree: int, jit_options: Dict):\n",
        "    N = 10\n",
        "    mesh = create_unit_cube(MPI.COMM_WORLD, N, N, N)\n",
        "    \n",
        "    V = functionspace(mesh, (space, degree))\n",
        "    u = TrialFunction(V)\n",
        "    v = TestFunction(V)\n",
        "    \n",
        "    a = inner(u, v) *dx\n",
        "    a_compiled = form(a, jit_options=jit_options)\n",
        "    \n",
        "    start = time.perf_counter()\n",
        "    assemble_matrix(a_compiled)\n",
        "    end = time.perf_counter()\n",
        "    \n",
        "    return end -start"
      ],
      "id": "d9283a29",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We begin by examining the different levels of optimization that the `C` compiler can apply to the generated code. A list of available optimization options, along with their explanations, can be found [here](https://gcc.gnu.org/onlinedocs/gcc/Optimize-Options.html)"
      ],
      "id": "b4188805"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "optimization_options = [\"-O1\", \"-O2\", \"-O3\", \"-Ofast\"]"
      ],
      "id": "bc97a2ba",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The next option to consider is whether to compile the code with `-march=native`. This option enables CPU-specific instructions for the local machine, which can lead to different results on different systems. More information can be found [here](https://gcc.gnu.org/onlinedocs/gcc/AArch64-Options.html#g_t-march-and--mcpu-Feature-Modifiers)"
      ],
      "id": "baeb1a1a"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "march_native = [True, False]"
      ],
      "id": "71eed08c",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We select a subset of finite element spaces and vary the order of each space to examine how it affects the assembly time under different compilation option"
      ],
      "id": "7f428ec6"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "results = {\"Space\": [], \"Degree\": [], \"Options\": [], \"Time\": []}\n",
        "for space in [\"N1curl\", \"Lagrange\", \"RT\"]:\n",
        "  for degree in [1, 2, 3]:\n",
        "    for native in march_native:\n",
        "      for option in optimization_options:\n",
        "        if native:\n",
        "          cffi_options = [option, \"-march=native\"]\n",
        "        else:\n",
        "          cffi_options = [option]\n",
        "        jit_options = {\n",
        "          \"cffi_extra_compile_args\": cffi_options,\n",
        "          \"cache_dir\": cache_dir, \n",
        "          \"cffi_libraries\": [\"m\"]\n",
        "        }\n",
        "        \n",
        "        runtime = compile_form(space, degree, jit_options=jit_options)\n",
        "\n",
        "        results[\"Space\"].append(space)\n",
        "        results[\"Degree\"].append(str(degree))\n",
        "        results[\"Options\"].append(\"\\n\".join(cffi_options))\n",
        "        results[\"Time\"].append(runtime)"
      ],
      "id": "10059d84",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We have now stored all the results in a dictionary. To visualize them, we use `pandas` and its `DataFrame` class. In a Jupyter notebook, the data can be inspected as follows:"
      ],
      "id": "9c6fdc35"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "results_df = pd.DataFrame.from_dict(results)\n",
        "results_df"
      ],
      "id": "5a9d64e5",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can now create a plot for each element type to visualize how the results vary with different compilation options. A new column is created for each element type and degree"
      ],
      "id": "ec42c124"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "seaborn.set(style=\"ticks\")\n",
        "seaborn.set_style(\"darkgrid\")\n",
        "\n",
        "results_df[\"Element\"] = results_df[\"Space\"] +\" \" +results_df[\"Degree\"]\n",
        "hue_order = sorted(results_df[\"Space\"].unique())\n",
        "for degree in [1, 2, 3]:\n",
        "  df_degree = results_df[results_df[\"Degree\"] == str(degree)]\n",
        "\n",
        "  g = seaborn.catplot(\n",
        "    x=\"Options\", \n",
        "    y=\"Time\", \n",
        "    hue=\"Space\",\n",
        "    hue_order=hue_order, \n",
        "    kind=\"bar\", \n",
        "    data=df_degree,\n",
        "    height=3,\n",
        "    aspect=4.0)\n",
        "  g.fig.suptitle(f\"Degree = {degree}\", y=1.02)"
      ],
      "id": "e1aa5baa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We observe that the compile time increases as the degree of the function space grows, and that the greatest speedup is achieved when using `-O3` or `-Ofast` in combination with `-march=native`\n",
        "\n",
        "### Error control: Computing convergence rates\n",
        "\n",
        "Author: Jørgen S. Dokken, Hans Petter Langtangen, Anders Logg\n",
        "\n",
        "For any numerical method, one of the most fundamental questions is its convergence rate: how fast the error decreases as the resolution is increased (i.e., as the mesh size is decreased)\n",
        "\n",
        "In the finite element method, this typically involves proving—either theoretically or empirically—that the error $\\| u - u_h \\|$ is bounded by a constant times the mesh size $h$ raised to some power $p$, that is,\n",
        "\n",
        "$$\\| u - u_h \\| \\le C \\, h^p$$\n",
        "\n",
        "for some constant $C$ independent of the mesh. The number $p$ is called the convergence rate of the method. Note that different norms, such as the $L^2$-norm or the $H^1$-norm, generally yield different convergence rates\n",
        "\n",
        "**Computing error norms**\n",
        "\n",
        "We first construct a manufactured problem based on the same configuration used in the solver"
      ],
      "id": "e3e648a7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from mpi4py import MPI\n",
        "\n",
        "from dolfinx import default_scalar_type\n",
        "from dolfinx.mesh import create_unit_square, locate_entities_boundary\n",
        "from dolfinx.fem import (Expression, Function, functionspace,\n",
        "                         assemble_scalar, dirichletbc, form, locate_dofs_topological)\n",
        "from dolfinx.fem.petsc import LinearProblem\n",
        "\n",
        "import ufl\n",
        "from ufl import (SpatialCoordinate, TestFunction, TrialFunction, \n",
        "                 div, dot, dx, grad, inner)\n",
        "\n",
        "def u_ex(mod):\n",
        "  return lambda x: mod.cos(2 *mod.pi *x[0]) *mod.cos(2 *mod.pi *x[1])\n",
        "\n",
        "u_numpy = u_ex(np)\n",
        "u_ufl = u_ex(ufl)\n",
        "\n",
        "def solve_poisson(N=10, degree=1):\n",
        "\n",
        "  mesh = create_unit_square(MPI.COMM_WORLD, N, N)\n",
        "    \n",
        "  x = SpatialCoordinate(mesh)\n",
        "  f = -div(grad(u_ufl(x)))\n",
        "    \n",
        "  V = functionspace(mesh, (\"Lagrange\", degree))\n",
        "  u = TrialFunction(V)\n",
        "  v = TestFunction(V)\n",
        "    \n",
        "  a = inner(grad(u), grad(v)) *dx\n",
        "  L = f *v *dx\n",
        "    \n",
        "  u_bc = Function(V)\n",
        "  u_bc.interpolate(u_numpy)\n",
        "    \n",
        "  facets = locate_entities_boundary(\n",
        "    mesh, \n",
        "    mesh.topology.dim -1, \n",
        "    lambda x: np.full(x.shape[1], True)\n",
        "  )\n",
        "  dofs = locate_dofs_topological(\n",
        "    V, \n",
        "    mesh.topology.dim -1, \n",
        "    facets\n",
        "  )\n",
        "  bcs = [dirichletbc(u_bc, dofs)]\n",
        "    \n",
        "  default_problem = LinearProblem(\n",
        "    a, \n",
        "    L, \n",
        "    bcs=bcs, \n",
        "    petsc_options={\"ksp_type\": \"preonly\", \"pc_type\": \"lu\"}\n",
        "  )\n",
        "\n",
        "  return default_problem.solve(), u_ufl(x)"
      ],
      "id": "164197a8",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Now, we compute the error between the analytical solution $u_{\\text{ex}} = u_{\\text{ufl}}(x)$ and the approximate solution $u_h$. The $L^2$-norm of the error\n",
        "\n",
        "$$\\| u_e - u_h \\|_{L^2(\\Omega)} = \\left( \\int_\\Omega |u_e - u_h|^2 \\, dx \\right)^{1/2}$$\n",
        "\n",
        "measures the pointwise accuracy of the approximate solution in an average sense. It quantifies how close $u_h$ is to $u_e$ in terms of their values"
      ],
      "id": "fd795847"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "uh, u_ex = solve_poisson(10)\n",
        "comm = uh.function_space.mesh.comm\n",
        "\n",
        "error_L2 = form((uh -u_ex)**2 *ufl.dx)\n",
        "E_L2 = np.sqrt(comm.allreduce(assemble_scalar(error_L2), MPI.SUM))\n",
        "\n",
        "if comm.rank == 0:\n",
        "  print(f\"L2-error: {E_L2:.2e}\")"
      ],
      "id": "578dde2f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Sometimes it is of interest to compute the error of the gradient field,\n",
        "$\\| \\nabla (u_e - u_h) \\|$,\n",
        "often referred to as the $H_0^1$-norm of the error. This can be expressed as\n",
        "\n",
        "$$\\left( \\int_\\Omega \\lvert \\nabla (u_e - u_h) \\rvert^2 \\, dx \\right)^{1/2}$$\n",
        "\n",
        "The $H_0^1$-norm measures the error in the so-called energy space, which is particularly relevant for elliptic partial differential equations, as it reflects how well the numerical solution captures the energy of the exact solution"
      ],
      "id": "745dc104"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "eh = uh -u_ex\n",
        "error_H10 = form(dot(grad(eh), grad(eh)) *dx)\n",
        "E_H10 = np.sqrt(comm.allreduce(assemble_scalar(error_H10), op=MPI.SUM))\n",
        "\n",
        "if comm.rank == 0:\n",
        "  print(f\"H01-error: {E_H10:.2e}\")"
      ],
      "id": "a2eca1e6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Reliable error norm computation**\n",
        "\n",
        "However, expanding the expression gives\n",
        "\n",
        "$$(u_{\\text{ex}} - u_h)^2 = u_{\\text{ex}}^2 + u_h^2 - 2u_{\\text{ex}}u_h$$\n",
        "\n",
        "If the error is small (while the solutions themselves are of moderate size), this calculation involves subtracting two quantities of order one—namely $u_{\\text{ex}}^2 + u_h^2 \\sim 1$ and $2u_{\\text{ex}}u_h \\sim 1$—to obtain a much smaller number. This subtraction is prone to round-off errors\n",
        "\n",
        "To avoid this issue, we interpolate both the approximate and the exact solutions into a higher-order function space. We then subtract their degrees of freedom to form an explicit error function. Finally, we assemble (integrate) the squared error and take the square root to obtain the $L^2$-norm"
      ],
      "id": "b258caa9"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def error_L2(uh, u_ex, degree_raise=3):\n",
        "\n",
        "  # Create higher order function space\n",
        "  mesh = uh.function_space.mesh\n",
        "  degree = uh.function_space.ufl_element().degree\n",
        "  family = uh.function_space.ufl_element().family_name\n",
        "    \n",
        "  W = functionspace(mesh, (family, degree +degree_raise))\n",
        "    \n",
        "  # Interpolate approximate solution\n",
        "  u_W = Function(W)\n",
        "  u_W.interpolate(uh)\n",
        "\n",
        "  # Interpolate exact solution, special handling if exact solution\n",
        "  # is a ufl expression or a python lambda function\n",
        "  u_ex_W = Function(W)\n",
        "  if isinstance(u_ex, ufl.core.expr.Expr):\n",
        "    u_expr = Expression(u_ex, W.element.interpolation_points())\n",
        "    u_ex_W.interpolate(u_expr)\n",
        "  else:\n",
        "    u_ex_W.interpolate(u_ex)\n",
        "\n",
        "  # Compute the error in the higher order function space\n",
        "  e_W = Function(W)\n",
        "  e_W.x.array[:] = u_W.x.array -u_ex_W.x.array\n",
        "\n",
        "  # Integrate the error\n",
        "  error = form(ufl.inner(e_W, e_W) *ufl.dx)\n",
        "  error_local = assemble_scalar(error)\n",
        "  error_global = mesh.comm.allreduce(error_local, op=MPI.SUM)\n",
        "  \n",
        "  return np.sqrt(error_global)"
      ],
      "id": "7a6ed65e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Computing convergence rates**\n",
        "\n",
        "Let us consider a sequence of mesh resolutions\n",
        "\n",
        "$$h_0 > h_1 > h_2 > \\cdots, \\qquad h_i = \\frac{1}{N_i}$$\n",
        "\n",
        "where $N_i$ denotes the number of subdivisions (or degrees of freedom) in the discretization. We compute the numerical error for a range of values of $N_i$"
      ],
      "id": "8a678108"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "Ns = [4, 8, 16, 32, 64]\n",
        "Es = np.zeros(len(Ns), dtype=default_scalar_type)\n",
        "hs = np.zeros(len(Ns), dtype=np.float64)\n",
        "\n",
        "for i, N in enumerate(Ns):\n",
        "  uh, u_ex = solve_poisson(N, degree=1)\n",
        "  comm = uh.function_space.mesh.comm\n",
        "\n",
        "  # Accepts either u_numpy or u_ex\n",
        "  # Use u_numpy for L2 error (no JIT needed)\n",
        "  hs[i] = 1. /Ns[i]\n",
        "  Es[i] = error_L2(uh, u_numpy)\n",
        "  if comm.rank == 0:\n",
        "    print(f\"h: {hs[i]:.2e} Error: {Es[i]:.2e}\")"
      ],
      "id": "d12182ab",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "If we assume that the error $E_i$ can be expressed as\n",
        "\n",
        "$E_i = C h_i^r$\n",
        "\n",
        "with unknown constants $C$ and $r$, then by comparing two consecutive experiments\n",
        "\n",
        "$$E_{i-1} = C h_{i-1}^r, \\qquad E_i = C h_i^r$$\n",
        "\n",
        "we can solve for $r$:\n",
        "\n",
        "$$r = \\frac{\\ln(E_i / E_{i-1})}{\\ln(h_i / h_{i-1})}$$\n",
        "\n",
        "As $i$ increases, the computed values of $r$ should approach the expected convergence rate, which in the case of the $L^2$-error is typically the polynomial degree plus one. This calculation can be implemented compactly using `NumPy`"
      ],
      "id": "3f6d1335"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "rates = np.log(Es[1:] /Es[:-1]) /np.log(hs[1:] /hs[:-1])\n",
        "if comm.rank == 0:\n",
        "  print(f\"Rates: {rates}\")"
      ],
      "id": "a207c409",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We perform a similar study for different polynomial orders to verify the previous claim"
      ],
      "id": "8653cb5e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "degrees = [1, 2, 3, 4]\n",
        "for degree in degrees:\n",
        "  hs = np.zeros(len(Ns), dtype=np.float64)\n",
        "  Es = np.zeros(len(Ns), dtype=default_scalar_type)\n",
        "    \n",
        "  for i, N in enumerate(Ns):\n",
        "    uh, u_ex = solve_poisson(N, degree=degree)\n",
        "    comm = uh.function_space.mesh.comm\n",
        "\n",
        "    hs[i] = 1. /Ns[i]    \n",
        "    Es[i] = error_L2(uh, u_numpy, degree_raise=3)\n",
        "\n",
        "    if comm.rank == 0:\n",
        "      print(f\"h: {hs[i]:.2e} Error: {Es[i]:.2e}\")\n",
        "    \n",
        "  rates = np.log(Es[1:] /Es[:-1]) /np.log(hs[1:] /hs[:-1])\n",
        "  if comm.rank == 0:\n",
        "    print(f\"Polynomial degree {degree:d}, Rates {rates}\\n\")"
      ],
      "id": "8b30e7e7",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Infinity norm estimates**\n",
        "\n",
        "We first define a function to evaluate the infinity norm, i.e., the maximum pointwise error between the numerical and exact solutions"
      ],
      "id": "f7a71a5b"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def error_infinity(u_h, u_ex):\n",
        "  # Interpolate exact solution (UFL or lambda handled separately)\n",
        "  u_ex_V = Function(u_h.function_space)\n",
        "  comm = u_h.function_space.mesh.comm\n",
        "    \n",
        "  if isinstance(u_ex, ufl.core.expr.Expr):\n",
        "    u_expr = Expression(u_ex, u_h.function_space.element.interpolation_points())\n",
        "    u_ex_V.interpolate(u_expr)\n",
        "  else:\n",
        "    u_ex_V.interpolate(u_ex)\n",
        "\n",
        "  # Compute global infinity norm from local maxima  \n",
        "  error_max_local = np.max(np.abs(u_h.x.array -u_ex_V.x.array))\n",
        "  error_max = comm.allreduce(error_max_local, op=MPI.MAX)\n",
        "\n",
        "  return error_max"
      ],
      "id": "fb9490d3",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Performing this procedure for various polynomial degrees produces the following results:"
      ],
      "id": "54f00c42"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "for degree in degrees:\n",
        "  hs = np.zeros(len(Ns), dtype=np.float64)    \n",
        "  Es = np.zeros(len(Ns), dtype=default_scalar_type)\n",
        "\n",
        "  for i, N in enumerate(Ns):\n",
        "    uh, u_ex = solve_poisson(N, degree=degree)\n",
        "    comm = uh.function_space.mesh.comm\n",
        "\n",
        "    hs[i] = 1. /Ns[i]    \n",
        "    Es[i] = error_infinity(uh, u_numpy)\n",
        "\n",
        "    if comm.rank == 0:\n",
        "       print(f\"h: {hs[i]:.2e} Error: {Es[i]:.2e}\")\n",
        "    \n",
        "  rates = np.log(Es[1:] /Es[:-1]) /np.log(hs[1:] /hs[:-1])\n",
        "  if comm.rank == 0:\n",
        "    print(f\"Polynomial degree {degree:d}, Rates {rates}\\n\")"
      ],
      "id": "5cbc9e47",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We observe superconvergence for second-order polynomials, resulting in an observed fourth-order convergence\n",
        "\n",
        "\n",
        "### Custom Newton solvers\n",
        "\n",
        "Author: Jørgen S. Dokken\n",
        "\n",
        "Newton’s Method, as used in the non-linear Poisson problem, is a technique for solving a non-linear equation by iteratively solving a sequence of linear equations.\n",
        "Given a function $F:\\mathbb{R}^M \\to \\mathbb{R}^M$, the iterates $u_k, u_{k+1} \\in \\mathbb{R}^M$ satisfy\n",
        "\n",
        "$$u_{k+1} = u_k - J_F(u_k)^{-1} F(u_k)$$\n",
        "\n",
        "where $J_F(u_k)$ is the Jacobian matrix of $F$ at $u_k$\n",
        "\n",
        "Introducing the increment $\\delta u_k = u_{k+1} - u_k$, this can be rewritten as the linear system\n",
        "\n",
        "$$J_F(u_k) \\, \\delta u_k = - F(u_k)$$\n",
        "\n",
        "with the update\n",
        "\n",
        "$$u_{k+1} = u_k + \\delta u_k$$\n",
        "\n",
        "**Problem specification**\n",
        "\n",
        "We start by importing the required libraries"
      ],
      "id": "221ebbaf"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "import numpy as np\n",
        "from mpi4py import MPI\n",
        "from petsc4py import PETSc\n",
        "\n",
        "import matplotlib.pyplot as plt\n",
        "import pyvista\n",
        "\n",
        "import dolfinx\n",
        "import dolfinx.fem.petsc\n",
        "\n",
        "import ufl\n",
        "\n",
        "plt.style.use('default')"
      ],
      "id": "07a09964",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We consider the following non-linear problem:\n",
        "\n",
        "$$u^2 - 2u = x^2 + 4x + 3 \\quad \\text{for } x \\in [0,1]$$\n",
        "\n",
        "This problem has two solutions: $u = -x - 1$ and $u = x + 3$. We define these roots as Python functions and create an appropriate array of points for plotting the solutions"
      ],
      "id": "910ac9bc"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def root_0(x):\n",
        "  return 3 +x[0]\n",
        "\n",
        "def root_1(x):\n",
        "  return -1 -x[0]\n",
        "\n",
        "N = 10\n",
        "x_spacing = np.linspace(0, 1, N)\n",
        "roots = [root_0, root_1]"
      ],
      "id": "c59d26f1",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Starting with the initial guess $u_0 = 0$, we then define the mesh, the function space, and the function `uh` for the numerical solution"
      ],
      "id": "acaf991d"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "mesh = dolfinx.mesh.create_unit_interval(MPI.COMM_WORLD, N)\n",
        "\n",
        "V = dolfinx.fem.functionspace(mesh, (\"Lagrange\", 1))\n",
        "uh = dolfinx.fem.Function(V)"
      ],
      "id": "aca591bb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Definition of residual and Jacobian**\n",
        "\n",
        "We then formulate the variational problem by multiplying with a test function and integrating over the domain $[0,1]$"
      ],
      "id": "a54dc970"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "v = ufl.TestFunction(V)\n",
        "\n",
        "x = ufl.SpatialCoordinate(mesh)\n",
        "F = uh**2 *v *ufl.dx -2 *uh *v *ufl.dx -(x[0]**2 +4 *x[0] +3) *v *ufl.dx\n",
        "residual = dolfinx.fem.form(F)"
      ],
      "id": "9aca4e30",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "The Jacobian $J_F$ is then obtained by applying `ufl.derivative` to the variational form"
      ],
      "id": "9f1d33be"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "J = ufl.derivative(F, uh)\n",
        "jacobian = dolfinx.fem.form(J)"
      ],
      "id": "585a6734",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "As the problem will be solved iteratively, the sparse matrix and residual vector are assembled only once\n",
        "\n",
        "**Setup of iteration-independent structures**"
      ],
      "id": "692934ba"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "A = dolfinx.fem.petsc.create_matrix(jacobian)\n",
        "L = dolfinx.fem.petsc.create_vector(residual)"
      ],
      "id": "98ceba14",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We then set up the linear solver together with a vector to hold the update `du`"
      ],
      "id": "0b54e990"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "solver = PETSc.KSP().create(mesh.comm)\n",
        "solver.setOperators(A)\n",
        "\n",
        "du = dolfinx.fem.Function(V)"
      ],
      "id": "c249b8cb",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To monitor the evolution of `uh` during the iterations, we obtain the DoF coordinates and sort them in ascending order"
      ],
      "id": "06660e94"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "coords = V.tabulate_dof_coordinates()[:, 0]\n",
        "sort_order = np.argsort(coords)\n",
        "\n",
        "max_iterations = 25\n",
        "solutions = np.zeros((max_iterations +1, len(coords)))\n",
        "solutions[0] = uh.x.array[sort_order]"
      ],
      "id": "76653695",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "At this stage, we are ready to solve the linearized problem. For each iteration, the Jacobian and residual are reassembled, and the norm of the update (`dx`) is used as the stopping criterion"
      ],
      "id": "f69ab8d2"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "i = 0\n",
        "while i < max_iterations:\n",
        "  # Assemble Jacobian and residual\n",
        "  with L.localForm() as loc_L:\n",
        "    loc_L.set(0)\n",
        "  A.zeroEntries()\n",
        "  dolfinx.fem.petsc.assemble_matrix(A, jacobian)\n",
        "  A.assemble()\n",
        "  dolfinx.fem.petsc.assemble_vector(L, residual)\n",
        "  L.ghostUpdate(addv=PETSc.InsertMode.ADD_VALUES, mode=PETSc.ScatterMode.REVERSE)\n",
        "\n",
        "  # Scale residual by -1\n",
        "  L.scale(-1)\n",
        "  L.ghostUpdate(addv=PETSc.InsertMode.INSERT_VALUES, mode=PETSc.ScatterMode.FORWARD)\n",
        "\n",
        "  # Solve linear problem\n",
        "  solver.solve(L, du.x.petsc_vec)\n",
        "  du.x.scatter_forward()\n",
        "  \n",
        "  # Update u_{i+1} = u_i + delta u_i\n",
        "  uh.x.array[:] += du.x.array\n",
        "  i += 1\n",
        "\n",
        "  # Compute norm of update\n",
        "  correction_norm = du.x.petsc_vec.norm(0)  # L^2 norm\n",
        "  print(f\"Iteration {i}: {correction_norm = :.6e}\")\n",
        "  if correction_norm < 1e-10:\n",
        "    break\n",
        "  solutions[i, :] = uh.x.array[sort_order]"
      ],
      "id": "28a0295e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "At this point, we compute the residual magnitude to monitor convergence"
      ],
      "id": "a76eeecd"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dolfinx.fem.petsc.assemble_vector(L, residual)\n",
        "print(f\"Final residual = {L.norm(0):.6e}\")"
      ],
      "id": "03b6e38f",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Visualization of Newton iterations**\n",
        "\n",
        "We now study how the solution evolves and quantify its error with respect to the two exact roots of the problem"
      ],
      "id": "43c6f3c3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Plot solution for each of the iterations\n",
        "fig = plt.figure(figsize=(8, 6))\n",
        "\n",
        "for j, solution in enumerate(solutions[:i]):\n",
        "  plt.plot(coords[sort_order], solution, label=f\"Iteration {j}\")\n",
        "\n",
        "# Plot each of the roots of the problem, \n",
        "# and compare the approximate solution with each of them\n",
        "for j, root in enumerate(roots):\n",
        "  u_ex = root(x)\n",
        "  \n",
        "  L2_error = dolfinx.fem.form(ufl.inner(uh -u_ex, uh -u_ex) *ufl.dx)\n",
        "  global_L2 = mesh.comm.allreduce(\n",
        "    dolfinx.fem.assemble_scalar(L2_error), \n",
        "    op=MPI.SUM\n",
        "  )\n",
        "  print(f\"L2-error (root {j}) {np.sqrt(global_L2):.6e}\")\n",
        "\n",
        "  plt.plot(x_spacing, root(x_spacing.reshape(1, -1)), ':o', label=f'root_{j}')\n",
        "\n",
        "plt.xlabel('x')\n",
        "plt.ylabel('u')\n",
        "plt.grid()\n",
        "plt.legend(bbox_to_anchor=(1.05, 1), loc='upper left')"
      ],
      "id": "4e55186b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "**Newton's method with DirichletBC**\n",
        "\n",
        "In the previous example, we did not incorporate Dirichlet boundary conditions. We now extend the formulation to the non-linear Poisson problem, where such boundary conditions play a central role. As a first step, we define the computational mesh, the analytical solution, and the corresponding forcing term `f`"
      ],
      "id": "c9952679"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "def q(u):\n",
        "  return 1 +u**2\n",
        "\n",
        "domain = dolfinx.mesh.create_unit_square(MPI.COMM_WORLD, 10, 10)\n",
        "\n",
        "x = ufl.SpatialCoordinate(domain)\n",
        "u_ufl = 1 +x[0] +2 *x[1]\n",
        "f = - ufl.div(q(u_ufl) *ufl.grad(u_ufl))\n",
        "\n",
        "def u_exact(x):\n",
        "  return eval(str(u_ufl))"
      ],
      "id": "6575b15b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Next, we specify the Dirichlet boundary condition `bc`, and define the variational residual `F` together with its Jacobian `J`"
      ],
      "id": "bace1307"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "V = dolfinx.fem.functionspace(domain, (\"Lagrange\", 1))\n",
        "\n",
        "u_D = dolfinx.fem.Function(V)\n",
        "u_D.interpolate(u_exact)\n",
        "\n",
        "fdim = domain.topology.dim -1\n",
        "domain.topology.create_connectivity(fdim, fdim +1)\n",
        "boundary_facets = dolfinx.mesh.exterior_facet_indices(domain.topology)\n",
        "bc = dolfinx.fem.dirichletbc(\n",
        "  u_D, \n",
        "  dolfinx.fem.locate_dofs_topological(V, fdim, boundary_facets)\n",
        ")\n",
        "\n",
        "uh = dolfinx.fem.Function(V)\n",
        "v = ufl.TestFunction(V)\n",
        "\n",
        "F = q(uh) *ufl.dot(ufl.grad(uh), ufl.grad(v)) *ufl.dx -f *v *ufl.dx\n",
        "J = ufl.derivative(F, uh)\n",
        "\n",
        "residual = dolfinx.fem.form(F)\n",
        "jacobian = dolfinx.fem.form(J)"
      ],
      "id": "a503a621",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We then set up the system matrix `A`, the right-hand side vector `L`, and the update function `du`"
      ],
      "id": "42915f6e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "du = dolfinx.fem.Function(V)\n",
        "\n",
        "A = dolfinx.fem.petsc.create_matrix(jacobian)\n",
        "L = dolfinx.fem.petsc.create_vector(residual)\n",
        "\n",
        "solver = PETSc.KSP().create(mesh.comm)\n",
        "solver.setOperators(A)"
      ],
      "id": "25aa869a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Since this problem has strong Dirichlet boundary conditions, we need to apply a lifting to the right-hand side of our Newton problem. Recall that our goal is to solve the system\n",
        "\n",
        "$$\\begin{aligned}\n",
        "J_F(u_k)\\,\\delta u_k &= - F(u_k),\\\\\n",
        "u_{k+1} &= u_k + \\delta u_k\n",
        "\\end{aligned}$$\n",
        "\n",
        "We require that\n",
        "\n",
        "$$u_{k+1}\\vert_{\\text{bc}} = u_D$$\n",
        "\n",
        "However, we do not know if the current iterate satisfies the boundary condition, i.e., whether\n",
        "\n",
        "$$u_k\\vert_{\\text{bc}} = u_D$$\n",
        "\n",
        "To enforce the boundary condition, we therefore apply the following condition on the Newton correction $\\delta u_k$:\n",
        "\n",
        "$$\\delta u_k \\vert_{\\text{bc}} = u_D - u_k \\vert_{\\text{bc}}$$\n",
        "\n",
        "This leads to the following Newton scheme with strong Dirichlet conditions:\n",
        "\n",
        "$$\n",
        "\\begin{aligned}\n",
        "J_F(u_k)\\,\\delta u_k &= -F(u_k), & \\delta u_k \\vert_{\\text{bc}} &= u_D - u_k\\vert_{\\text{bc}},\\\\\n",
        "u_{k+1} &= u_k + \\delta u_k\n",
        "\\end{aligned}$$"
      ],
      "id": "fee23711"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "i = 0\n",
        "error = dolfinx.fem.form(\n",
        "  ufl.inner(uh -u_ufl, uh -u_ufl) *ufl.dx(metadata={\"quadrature_degree\": 4})\n",
        ")\n",
        "L2_error = []\n",
        "du_norm = []\n",
        "while i < max_iterations:\n",
        "  # Assemble Jacobian and residual\n",
        "  with L.localForm() as loc_L:\n",
        "    loc_L.set(0)\n",
        "  A.zeroEntries()\n",
        "  dolfinx.fem.petsc.assemble_matrix(A, jacobian, bcs=[bc])\n",
        "  A.assemble()\n",
        "  dolfinx.fem.petsc.assemble_vector(L, residual)\n",
        "  L.ghostUpdate(addv=PETSc.InsertMode.ADD, mode=PETSc.ScatterMode.REVERSE)\n",
        "  L.scale(-1)\n",
        "\n",
        "  # Compute b - J(u_D-u_(i-1))\n",
        "  dolfinx.fem.petsc.apply_lifting(\n",
        "    L, \n",
        "    [jacobian], \n",
        "    [[bc]], \n",
        "    x0=[uh.x.petsc_vec], \n",
        "    alpha=1\n",
        "  )\n",
        "  \n",
        "  # Set du|_bc = u_{i-1}-u_D\n",
        "  dolfinx.fem.petsc.set_bc(L, [bc], uh.x.petsc_vec, 1.0)\n",
        "  L.ghostUpdate(addv=PETSc.InsertMode.INSERT_VALUES, mode=PETSc.ScatterMode.FORWARD)\n",
        "\n",
        "  # Solve linear problem\n",
        "  solver.solve(L, du.x.petsc_vec)\n",
        "  du.x.scatter_forward()\n",
        "\n",
        "  # Update u_{i+1} = u_i + delta u_i\n",
        "  uh.x.array[:] += du.x.array\n",
        "  i += 1\n",
        "\n",
        "  # Compute norm of update\n",
        "  correction_norm = du.x.petsc_vec.norm(0)\n",
        "\n",
        "  # Compute L2 error comparing to the analytical solution\n",
        "  L2_error.append(np.sqrt(mesh.comm.allreduce(dolfinx.fem.assemble_scalar(error), op=MPI.SUM)))\n",
        "  du_norm.append(correction_norm)\n",
        "\n",
        "  print(f\"Iteration {i}: {correction_norm = :.6e}, L2_error = {L2_error[-1]:.6e}\")\n",
        "  if correction_norm < 1e-10:\n",
        "    break"
      ],
      "id": "c1701b1a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We visualize the convergence by plotting the $L^2$-error and the residual norm ($\\delta u$) across iterations"
      ],
      "id": "76421186"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "fig = plt.figure(figsize=(12, 4))\n",
        "\n",
        "plt.subplot(121)\n",
        "plt.semilogy(np.arange(i), L2_error, 'bo')\n",
        "plt.grid()\n",
        "\n",
        "plt.xlabel(\"Iterations\")\n",
        "plt.ylabel(r\"$L^2$ - error\")\n",
        "\n",
        "plt.subplot(122)\n",
        "plt.semilogy(np.arange(i), du_norm, 'ro')\n",
        "plt.grid()\n",
        "\n",
        "plt.xlabel(\"Iterations\")\n",
        "plt.ylabel(r\"$\\vert\\vert \\delta u\\vert\\vert$\");"
      ],
      "id": "374d95d0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We compute the maximum error and plot the solution"
      ],
      "id": "0afb3875"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "error_max = domain.comm.allreduce(\n",
        "  np.max(np.abs(uh.x.array -u_D.x.array)), \n",
        "  op=MPI.MAX\n",
        ")\n",
        "\n",
        "if domain.comm.rank == 0:\n",
        "  print(f\"Error_max = {error_max:.6e}\")"
      ],
      "id": "e6b2ee5e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "from pathlib import Path\n",
        "\n",
        "results_folder = Path(\"fenicsx/best_practices\")\n",
        "results_folder.mkdir(exist_ok=True, parents=True)\n",
        "\n",
        "u_topology, u_cell_types, u_geometry = dolfinx.plot.vtk_mesh(V)\n",
        "u_grid = pyvista.UnstructuredGrid(u_topology, u_cell_types, u_geometry)\n",
        "\n",
        "u_grid.point_data[\"u\"] = uh.x.array.real\n",
        "u_grid.set_active_scalars(\"u\")\n",
        "\n",
        "u_plotter = pyvista.Plotter(off_screen=False)\n",
        "u_plotter.add_mesh(u_grid, show_edges=True)\n",
        "u_plotter.view_xy()\n",
        "\n",
        "if not pyvista.OFF_SCREEN:\n",
        "  #u_plotter.show()\n",
        "  u_plotter.export_html(results_folder/\"newton_solution.html\")"
      ],
      "id": "d2de1232",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "```{=html}\n",
        "<iframe src=\"fenicsx/best_practices/newton_solution.html\"\n",
        "        width=\"100%\" height=\"400px\"\n",
        "        style=\"border:none;\"\n",
        "        allowfullscreen\n",
        "        loading=\"lazy\">        \n",
        "</iframe>\n",
        "```"
      ],
      "id": "8ca3e6bf"
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "fenicsx",
      "language": "python",
      "display_name": "FEniCSx",
      "path": "/Users/kyyoo/Library/Jupyter/kernels/fenicsx"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}