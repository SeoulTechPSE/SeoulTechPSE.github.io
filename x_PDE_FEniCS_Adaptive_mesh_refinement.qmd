---
title: "Adaptive mesh refinement with GMSH/FEniCSx"
jupyter: fenicsx
---

### Adaptive mesh refinement with GMSH/FEniCSx {#sec-fenicsx-adaptive-mesh}

In this section, we consider an adaptive mesh refinement method applied to the Laplace eigenvalue problem 

#### Solving the eigenvalue problem

We consider the Laplace eigenvalue problem with adaptive mesh refinement. The finite element discretization is performed using `dolfinx`, while `PETSc/SLEPc` are used for the linear algebra and eigenvalue solver. The geometry is generated with `GMSH`

**Problem definition**

We study the Laplace eigenvalue problem:

$$
-\Delta u = \lambda u \quad \text{in } \Omega,
\quad u = 0 \quad \text{on } \partial\Omega
$$

We use a variational formulation: find $(\lambda, u) \in \mathbb{R} \times V_h$ such that

$$
a(u, v) = \lambda m(u, v), \quad \forall v \in V_h
$$

with

$$
a(u, v) = \int_\Omega \nabla u \cdot \nabla v \, dx,
\quad
m(u, v) = \int_\Omega u v \, dx
$$

#### Adaptive mesh refinement

Adaptive mesh refinement improves solution accuracy by selectively refining elements where errors are largest. Two common approaches for eigenvalue problems are gradient-based and residual-based error estimation

**Gradient-based refinement**

Uses the magnitude of the solution gradient as an error indicator:

$$ \eta_K = \int_K |\nabla u_h| \, dx $$

* Advantages

  * Simple and computationally cheap
  * Works well for smooth solutions
  * Intuitive: large gradients suggest refinement needs

* Limitations

  * May over-refine in regions with naturally large gradients
  * Doesn't account for actual PDE residual
  * Less theoretically rigorous

**Residual-based refinement**

Uses the PDE residual and flux jumps across element boundaries:

$$\eta_K^2 = h_K^2 \|R_K\|_{L^2(K)}^2 + \frac{1}{2} \sum_{e \in \partial K} h_e \|J_e\|_{L^2(e)}^2$$​

where $R_K = \lambda_h u_h$  (interior residual) and $J_e = [\nabla u_h \cdot n]$ (flux jump) 

* Advantages

  * Theoretically rigorous error bound
  * Accounts for both interior and boundary contributions
  * Better handles singularities and discontinuities
  * More efficient refinement strategy

* Limitations

  * More complex implementation
  * Higher computational cost
  * Requires careful treatment of jumps

**Implementation tips**

  * Threshold selection: Use percentile-based marking (e.g., top 25%)
  * Scaling: Residual estimator naturally scales with mesh size
  * Stability: Ensure non-negative error indicators
  * Convergence: Monitor eigenvalue changes across refinement levels

Both methods provide effective adaptive strategies, with residual-based estimation offering superior theoretical foundations at the cost of implementation complexity

#### Implementation

We begin by importing the necessary packages:

```{python}
import numpy as np
from pathlib import Path
from mpi4py import MPI
from petsc4py import PETSc
from slepc4py import SLEPc
import pyvista
import gmsh

from dolfinx import fem, mesh, plot, default_scalar_type
from dolfinx.fem.petsc import assemble_matrix, assemble_vector  # fenicsx 0.9.0
from dolfinx.mesh import create_unit_square, locate_entities_boundary, refine
from dolfinx.io import gmshio, XDMFFile
import ufl
```

In this section, we’ll go through a complete workflow for generating, converting, and visualizing 2D meshes—specifically a square, an L-shaped domain, and a Pac-Man shape—using GMSH, FEniCSx, and PyVista.

Once the meshes are ready, we’ll set up a helper function that solves the eigenvalue problem with `SLEPc` on a discretized domain.

Next, we’ll run the adaptive mesh refinement (AMR) algorithm. To make visualization easier, we’ll also add a helper function that attaches the relevant data to the plotter at each refinement step.

Finally, we’ll set up some parameters to check the convergence of the algorithm

```{python}
class AdaptiveLaplaceEigenSolver:
    """
    Adaptive Laplace eigenvalue solver with visualization
    """
    
    def __init__(self, domain_type="unit_square", initial_mesh_size=0.1):
        self.domain_type = domain_type
        self.initial_mesh_size = initial_mesh_size
        self.mesh = None
        self.V = None

        self.eigenvalues = []
        self.eigenfunctions = []

        self.results_folder = Path("fenicsx/adaptive_mesh_refinement")
        self.results_folder.mkdir(exist_ok=True, parents=True)
        
        print(f"Initialized solver for {domain_type} domain")
        
    def create_domain(self):
        """Create computational domain"""
        if self.domain_type == "unit_square":
            self.mesh = create_unit_square(MPI.COMM_WORLD, 20, 20, mesh.CellType.triangle)
            print(f"Created unit square: {self._count_n_cells()} cells")
            
        elif self.domain_type == "l_shape":
            self._create_l_shape_domain()
            
        elif self.domain_type == "pacman":
            self._create_pacman_domain()
            
        else:
            raise ValueError(f"Unknown domain type: {self.domain_type}")

    def _count_n_cells(self):
        return self.mesh.topology.index_map(2).size_global
    
    def _create_l_shape_domain(self):
        """Create L-shaped domain using GMSH"""
        gmsh.initialize()
        gmsh.model.add("l_shape")
        
        try:
            # Create L-shape
            rect1 = gmsh.model.occ.addRectangle(0, 0, 0, 1, 1)
            rect2 = gmsh.model.occ.addRectangle(0, 1, 0, 1, 1)
            rect3 = gmsh.model.occ.addRectangle(1, 0, 0, 1, 1)
            
            # Fuse rectangles
            fused1, _ = gmsh.model.occ.fuse([(2, rect1)], [(2, rect2)])
            fused2, _ = gmsh.model.occ.fuse(fused1, [(2, rect3)])
            
            gmsh.model.occ.synchronize()
            
            # Add physical groups
            surfaces = gmsh.model.getEntities(2)
            if surfaces:
                gmsh.model.addPhysicalGroup(2, [s[1] for s in surfaces], 1)
                gmsh.model.setPhysicalName(2, 1, "LDomain")
            
            # Set mesh size
            gmsh.option.setNumber("Mesh.CharacteristicLengthMin", self.initial_mesh_size * 0.5)
            gmsh.option.setNumber("Mesh.CharacteristicLengthMax", self.initial_mesh_size * 2.0)
            gmsh.model.mesh.generate(2)
            
            # Convert to dolfinx
            self.mesh, ct, ft = gmshio.model_to_mesh(gmsh.model, MPI.COMM_WORLD, 0, gdim=2)
            
        finally:
            gmsh.finalize()
            
        print(f"Created L-shape: {self._count_n_cells()} cells")
    
    def _create_pacman_domain(self):
        """Create Pac-Man domain using GMSH"""
        gmsh.initialize()
        gmsh.model.add("pacman")
        
        try:
            # Create Pac-Man shape
            disk = gmsh.model.occ.addDisk(0, 0, 0, 1.0, 1.0)
            
            # Create mouth triangle
            angle_rad = np.radians(30)  # 30-degree mouth opening
            mouth_length = 1.2
            
            p1 = gmsh.model.occ.addPoint(0, 0, 0)
            p2 = gmsh.model.occ.addPoint(mouth_length * np.cos(angle_rad), 
                                       mouth_length * np.sin(angle_rad), 0)
            p3 = gmsh.model.occ.addPoint(mouth_length * np.cos(-angle_rad), 
                                       mouth_length * np.sin(-angle_rad), 0)
            
            l1 = gmsh.model.occ.addLine(p1, p2)
            l2 = gmsh.model.occ.addLine(p2, p3)  
            l3 = gmsh.model.occ.addLine(p3, p1)
            
            mouth_loop = gmsh.model.occ.addCurveLoop([l1, l2, l3])
            mouth_surface = gmsh.model.occ.addPlaneSurface([mouth_loop])
            
            # Cut mouth from disk
            pacman, _ = gmsh.model.occ.cut([(2, disk)], [(2, mouth_surface)])
            
            gmsh.model.occ.synchronize()
            
            # Add physical groups
            if pacman:
                dim, tag = pacman[0]
                gmsh.model.addPhysicalGroup(dim, [tag], 1)
                gmsh.model.setPhysicalName(dim, 1, "PacmanDomain")
            
            # Set mesh options
            gmsh.option.setNumber("Mesh.CharacteristicLengthMin", self.initial_mesh_size * 0.5)
            gmsh.option.setNumber("Mesh.CharacteristicLengthMax", self.initial_mesh_size * 2.0)
            gmsh.option.setNumber("Mesh.Algorithm", 6)  # Frontal-Delaunay
            gmsh.model.mesh.generate(2)
            
            # Convert to dolfinx
            self.mesh, ct, ft = gmshio.model_to_mesh(gmsh.model, MPI.COMM_WORLD, 0, gdim=2)
            
        finally:
            gmsh.finalize()
            
        print(f"Created Pac-Man: {self._count_n_cells()} cells")
    
    def solve_eigenvalue_problem(self, n_eigenvalues=6):
        """Solve eigenvalue problem on current mesh"""
        # Create function space
        self.V = fem.functionspace(self.mesh, ("Lagrange", 1))
        
        # Define variational forms
        u = ufl.TrialFunction(self.V)
        v = ufl.TestFunction(self.V)
        
        a = ufl.inner(ufl.grad(u), ufl.grad(v)) * ufl.dx  # Stiffness
        m = ufl.inner(u, v) * ufl.dx                      # Mass
        
        # Apply homogeneous Dirichlet boundary conditions
        boundary_facets = locate_entities_boundary(
            self.mesh, self.mesh.topology.dim-1, 
            lambda x: np.ones(x.shape[1], dtype=bool)  # All boundary
        )
        boundary_dofs = fem.locate_dofs_topological(self.V, self.mesh.topology.dim-1, boundary_facets)
        bc = fem.dirichletbc(default_scalar_type(0.0), boundary_dofs, self.V)
        
        # Assemble matrices
        A = assemble_matrix(fem.form(a), bcs=[bc])
        A.assemble()
        M = assemble_matrix(fem.form(m), bcs=[bc])
        M.assemble()
        
        # Solve using shift-invert
        eps = SLEPc.EPS().create(MPI.COMM_WORLD)
        eps.setOperators(A, M)
        eps.setProblemType(SLEPc.EPS.ProblemType.GHEP)
        
        # Set shift based on domain type
        if self.domain_type == "unit_square":
            shift = 15.0
        elif self.domain_type == "l_shape":
            shift = 2.0
        elif self.domain_type == "pacman":
            shift = 3.0
        
        st = eps.getST()
        st.setType(SLEPc.ST.Type.SINVERT)
        st.setShift(shift)
        
        eps.setWhichEigenpairs(SLEPc.EPS.Which.TARGET_MAGNITUDE)
        eps.setTarget(shift)
        eps.setDimensions(n_eigenvalues + 3)
        eps.setTolerances(1e-10, 3000)
        eps.setType(SLEPc.EPS.Type.KRYLOVSCHUR)
        
        eps.solve()
        
        # Extract results
        nconv = eps.getConverged()
        results = []
        
        for i in range(nconv):
            eigenval = eps.getEigenvalue(i).real
            if eigenval > shift * 0.8:  # Filter based on shift
                eigenvec = fem.Function(self.V)
                eps.getEigenvector(i, eigenvec.x.petsc_vec)
                eigenvec.x.scatter_forward()
                
                # Normalize
                norm = np.sqrt(eigenvec.x.petsc_vec.dot(eigenvec.x.petsc_vec))
                if norm > 1e-12:
                    eigenvec.x.petsc_vec.scale(1.0 / norm)
                
                results.append((eigenval, eigenvec))
        
        # Sort and store results
        results.sort(key=lambda x: x[0])
        self.eigenvalues = [r[0] for r in results[:n_eigenvalues]]
        self.eigenfunctions = [r[1] for r in results[:n_eigenvalues]]
        
        # Cleanup
        eps.destroy()
        A.destroy()
        M.destroy()
        
        return self.eigenvalues, self.eigenfunctions
    
    def gradient_estimate_error(self, eigenfunction, eigenvalue):
        """
        Estimate error using gradient-based indicator
        """
        # Create DG0 space for error indicators
        W = fem.functionspace(self.mesh, ("DG", 0))
        error_indicator = fem.Function(W)
        
        # Compute gradient magnitude as error indicator
        u_dg = ufl.TrialFunction(W)        
        v_dg = ufl.TestFunction(W)
  
        grad_u = ufl.grad(eigenfunction)
        grad_norm_expr = ufl.sqrt(ufl.inner(grad_u, grad_u))
        
        # Project gradient norm to DG0
        a_proj = ufl.inner(u_dg, v_dg) * ufl.dx
        L_proj = ufl.inner(grad_norm_expr, v_dg) * ufl.dx
        
        A_proj = assemble_matrix(fem.form(a_proj))
        A_proj.assemble()
        b_proj = assemble_vector(fem.form(L_proj))
        b_proj.assemble()
        
        # Solve projection
        solver = PETSc.KSP().create()
        solver.setOperators(A_proj)
        solver.setType(PETSc.KSP.Type.CG)
        solver.solve(b_proj, error_indicator.x.petsc_vec)
        
        A_proj.destroy()
        b_proj.destroy()
        solver.destroy()
        
        return error_indicator.x.array

    def residual_estimate_error(self, eigenfunction, eigenvalue):
        """
        Residual-based error estimator for eigenvalue problems
        
        η_K² = h_K² ||R_K||²_L²(K) + (1/2) Σ h_e ||J_e||²_L²(e)
        
        where:
        - R_K = λ_h u_h (interior residual, since -Δu_h = λ_h u_h)
        - J_e = [∇u_h · n] (jump in normal flux across interior facets)
        - h_K = cell diameter, h_e = facet size
        """
        # Create DG0 space for error indicators
        W = fem.functionspace(self.mesh, ("DG", 0))
        error_indicator = fem.Function(W)
        
        # Define test function and cell/facet measures
        w = ufl.TestFunction(W)
        h_K = ufl.CellDiameter(self.mesh)
        h_e = ufl.FacetArea(self.mesh)  # In 2D, this gives edge length
        n = ufl.FacetNormal(self.mesh)
        
        # Interior residual: R_K = λ_h * u_h 
        # (since the strong form is -Δu = λu, the residual is λu when Δu ≈ 0)
        R_K = eigenvalue * eigenfunction
        
        # Jump in normal flux: J_e = [∇u_h · n]
        grad_u = ufl.grad(eigenfunction)
        flux_jump = ufl.jump(grad_u, n)  # Jump across interior facets
        
        # Residual-based error estimator
        # Interior contribution: h_K² ||R_K||²
        interior_contrib = h_K**2 * R_K**2 * w * ufl.dx
        
        # Boundary contribution: (1/2) h_e ||J_e||²  
        # Note: ufl.dS integrates over interior facets only
        boundary_contrib = 0.5 * h_e * flux_jump**2 * ufl.avg(w) * ufl.dS
        
        # Total error estimator
        error_form = interior_contrib + boundary_contrib
        
        # Assemble the error estimator
        error_vector = assemble_vector(fem.form(error_form))
        error_vector.assemble()
        
        # Extract local error indicators and take square root
        # (since we computed η_K², we need sqrt to get η_K)
        error_indicators_squared = error_vector.array
        error_indicators = np.sqrt(np.maximum(error_indicators_squared, 0.0))  # Ensure non-negative
        
        return error_indicators        
    
    def adaptive_refinement(self, err_estimator='residual', n_iterations=4, refinement_fraction=0.25, n_eigenvalues=6):
        """
        Perform adaptive mesh refinement
        """
        print(f"\n{'='*60}")
        print(f"ADAPTIVE REFINEMENT for {self.domain_type.upper()}")
        print(f"{'='*60}")
        
        refinement_history = []
        
        for iteration in range(n_iterations):
            print(f"\n--- Iteration {iteration + 1}/{n_iterations} ---")
            
            # Solve eigenvalue problem
            eigenvalues, eigenfunctions = self.solve_eigenvalue_problem(n_eigenvalues)
            
            print(f"Mesh: {self._count_n_cells()} cells, "
                  f"DOFs: {self.V.dofmap.index_map.size_global}")
            
            # Display first few eigenvalues
            for i, eigenval in enumerate(eigenvalues[:3]):
                print(f"λ_{i+1} = {eigenval:.6f}")
            
            # Save current results
            self.save_iteration_results(iteration)
            
            # Estimate error for first eigenfunction
            if eigenfunctions:

                if err_estimator == 'residual':
                    error_indicators = self.residual_estimate_error(eigenfunctions[0], eigenvalues[0])
                elif err_estimator == 'gradient':
                    error_indicators = self.gradient_estimate_error(eigenfunctions[0], eigenvalues[0])
                
                # Mark cells for refinement
                threshold = np.percentile(error_indicators, (1 - refinement_fraction) * 100)
                cells_to_refine = np.where(error_indicators > threshold)[0]
                
                print(f"Refining {len(cells_to_refine)} cells (threshold: {threshold:.3f})")
                
                if len(cells_to_refine) == 0:
                    print("No cells to refine, stopping.")
                    break
                
                # Store history
                refinement_history.append({
                    'iteration': iteration + 1,
                    'n_cells': self._count_n_cells(),
                    'n_dofs': self.V.dofmap.index_map.size_global,
                    'eigenvalues': eigenvalues.copy(),
                    'error_max': error_indicators.max(),
                    'error_mean': error_indicators.mean()
                })
                
                # Refine mesh
                if iteration < n_iterations - 1:  # Don't refine on last iteration
                    refined_result = refine(self.mesh, cells_to_refine)
                    # In dolfinx 0.9.0, refine may return a tuple (mesh, cell_map, vertex_map, facet_map)
                    if isinstance(refined_result, tuple):
                        self.mesh = refined_result[0]  # Extract just the mesh
                    else:
                        self.mesh = refined_result
        
        # Final solve and save
        final_eigenvalues, final_eigenfunctions = self.solve_eigenvalue_problem(n_eigenvalues)
        self.save_final_results()
        self.print_convergence_summary(refinement_history)
        
        return refinement_history
    
    def save_iteration_results(self, iteration):
        """Save results for current iteration"""
        if not self.eigenvalues or not self.eigenfunctions:
            return
            
        # Save eigenvalues
        eigenval_file = self.results_folder / f"{self.domain_type}_eigenvalues_iter_{iteration}.txt"
        np.savetxt(eigenval_file, self.eigenvalues)
        
        # Save eigenfunctions to XDMF
        try:
            xdmf_file = self.results_folder / f"{self.domain_type}_eigenfunctions_iter_{iteration}.xdmf"
            with XDMFFile(self.mesh.comm, xdmf_file, "w") as file:
                file.write_mesh(self.mesh)
                for i, u in enumerate(self.eigenfunctions[:3]):
                    u.name = f"eigenmode_{i+1}"
                    file.write_function(u)
        except Exception as e:
            print(f"Could not save XDMF for iteration {iteration}: {e}")
    
    def save_final_results(self):
        """Save final results"""
        if not self.eigenvalues or not self.eigenfunctions:
            return
            
        # Save final eigenvalues
        final_eigenval_file = self.results_folder / f"{self.domain_type}_final_eigenvalues.txt"
        np.savetxt(final_eigenval_file, self.eigenvalues)
        
        # Save final eigenfunctions
        try:
            final_xdmf_file = self.results_folder / f"{self.domain_type}_final_eigenfunctions.xdmf"
            with XDMFFile(self.mesh.comm, final_xdmf_file, "w") as file:
                file.write_mesh(self.mesh)
                for i, u in enumerate(self.eigenfunctions):
                    u.name = f"final_eigenmode_{i+1}"
                    file.write_function(u)
        except Exception as e:
            print(f"Could not save final XDMF: {e}")
    
    def visualize_eigenmodes(self, max_modes=4, save_html=True, save_png=True):
        """
        Create beautiful visualizations of eigenmodes using PyVista
        """
        if not self.eigenfunctions:
            print("No eigenfunctions to visualize")
            return
        
        print(f"\nCreating visualizations for {len(self.eigenfunctions)} eigenmodes...")
        
        for i, (eigenval, eigenfunction) in enumerate(zip(self.eigenvalues[:max_modes], 
                                                         self.eigenfunctions[:max_modes])):
            try:
                # Create PyVista grid
                topology, cell_types, geometry = plot.vtk_mesh(self.V)
                grid = pyvista.UnstructuredGrid(topology, cell_types, geometry)
                grid.point_data["Eigenfunction"] = eigenfunction.x.array.real
                
                # Create beautiful plot
                plotter = pyvista.Plotter(off_screen=True, window_size=(1200, 800))
                
                # Add mesh with scalar field
                mesh_actor = plotter.add_mesh(
                    grid, 
                    scalars="Eigenfunction",
                    cmap="RdBu_r",
                    show_edges=True,
                    scalar_bar_args={
                        'title': f'Mode {i+1}\n',
                        'title_font_size': 14,
                        'label_font_size': 13,
                        'n_labels': 5,
                        'width': 0.6,
                        'height': 0.05,
                        'position_x': 0.2,
                        'position_y': 0.02
                    }
                )
                
                # Set camera and lighting
                plotter.view_xy()
                plotter.camera.zoom(1.1)
                
                # Add title
                plotter.add_text(
                    f'{self.domain_type.replace("_", " ").title()}: lambda_{i+1} = {eigenval:.6f}',
                    position='upper_left',
                    font_size=14,
                    color='black'
                )
                
                # Add mesh info
                plotter.add_text(
                    f'\n\nCells: {self._count_n_cells()}, '
                    f'DOFs: {self.V.dofmap.index_map.size_global}',
                    position='upper_left',#'lower_right',
                    font_size=9,
                    color='gray'
                )
                
                # Save visualizations
                if save_html:
                    html_file = self.results_folder / f"{self.domain_type}_mode_{i+1}.html"
                    plotter.export_html(html_file)
                
                if save_png:
                    png_file = self.results_folder / f"{self.domain_type}_mode_{i+1}.png"
                    plotter.screenshot(png_file, transparent_background=True)
                
                print(f"✓ Saved visualizations for mode {i+1}")
                
            except Exception as e:
                print(f"✗ Visualization error for mode {i+1}: {e}")
    
    def create_comparison_plot(self):
        """Create comparison plot of all eigenmodes"""
        if len(self.eigenfunctions) < 4:
            return
            
        try:
            # Create 2x2 subplot
            plotter = pyvista.Plotter(shape=(2, 2), off_screen=True, window_size=(1600, 1200))
            
            for i in range(min(4, len(self.eigenfunctions))):
                eigenval = self.eigenvalues[i]
                eigenfunction = self.eigenfunctions[i]
                
                # Create grid
                topology, cell_types, geometry = plot.vtk_mesh(self.V)
                grid = pyvista.UnstructuredGrid(topology, cell_types, geometry)
                grid.point_data["Eigenfunction"] = eigenfunction.x.array.real
                
                # Set subplot
                row, col = divmod(i, 2)
                plotter.subplot(row, col)
                
                plotter.add_mesh(
                    grid,
                    scalars="Eigenfunction", 
                    cmap="RdBu_r",
                    show_edges=False,
                    scalar_bar_args={
                        'title': f'Mode {i+1}\n',
                        'title_font_size': 14,
                        'label_font_size': 13,
                    }                    
                )
                
                plotter.add_text(
                    f'lambda_{i+1} = {eigenval:.4f}', 
                    position='upper_left',
                    font_size=14)
                plotter.view_xy()
                plotter.camera.zoom(0.95)
            
            # Save comparison
            comparison_file = self.results_folder / f"{self.domain_type}_comparison.png"
            plotter.screenshot(comparison_file)
            
            print(f"✓ Saved comparison plot: {comparison_file}")
            
        except Exception as e:
            print(f"✗ Comparison plot error: {e}")
    
    def print_convergence_summary(self, history):
        """Print convergence summary"""
        print(f"\n{'='*60}")
        print(f"CONVERGENCE SUMMARY - {self.domain_type.upper()}")
        print(f"{'='*60}")
        print("Iter | Cells | DOFs  | λ_1      | λ_2      | λ_3      | Error")
        print("-" * 60)
        
        for h in history:
            eigenvals = h['eigenvalues']
            print(f"{h['iteration']:4d} | {h['n_cells']:5d} | {h['n_dofs']:5d} | "
                  f"{eigenvals[0]:8.4f} | {eigenvals[1]:8.4f} | {eigenvals[2]:8.4f} | "
                  f"{h['error_max']:8.3e}")
        
        if history:
            final = history[-1]['eigenvalues']
            print(f"\nFinal eigenvalues:")
            for i, eigenval in enumerate(final[:6]):
                print(f"  λ_{i+1} = {eigenval:.8f}")
```

```{python}
def run_complete_tests():
    """Run complete test suite with all domains"""
    domains = ["unit_square", "l_shape", "pacman"]
    
    for domain in domains:
        print(f"\n{'='*80}")
        print(f"TESTING {domain.upper()} DOMAIN")
        print(f"{'='*80}")
        
        try:
            # Create solver
            solver = AdaptiveLaplaceEigenSolver(domain_type=domain, initial_mesh_size=0.1)
            
            # Create domain
            solver.create_domain()
            
            # Run adaptive refinement
            history = solver.adaptive_refinement(
                err_estimator='residual', # or 'gradient'
                n_iterations=4, 
                refinement_fraction=0.25, 
                n_eigenvalues=6
            )
            
            # Create visualizations
            print(f"\nCreating visualizations for {domain}...")
            solver.visualize_eigenmodes(max_modes=4)
            solver.create_comparison_plot()
            
            print(f"✓ {domain} test completed successfully!")
            
        except Exception as e:
            print(f"✗ {domain} test failed: {e}")
            import traceback
            traceback.print_exc()

if __name__ == "__main__":
    run_complete_tests()
```

![](fenicsx/adaptive_mesh_refinement/unit_square_comparison.png)

```{=html}
<iframe src="fenicsx/adaptive_mesh_refinement/unit_square_mode_1.html"
        width="100%" height="400px"
        style="border:none;">
</iframe>
```

![](fenicsx/adaptive_mesh_refinement/l_shape_comparison.png)

```{=html}
<iframe src="fenicsx/adaptive_mesh_refinement/l_shape_mode_1.html"
        width="100%" height="400px"
        style="border:none;">
</iframe>
```

![](fenicsx/adaptive_mesh_refinement/pacman_comparison.png)

```{=html}
<iframe src="fenicsx/adaptive_mesh_refinement/pacman_mode_1.html"
        width="100%" height="400px"
        style="border:none;">
</iframe>
```