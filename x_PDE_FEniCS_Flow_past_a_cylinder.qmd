---
title: "Flow past a cylinder"
jupyter: fenicsx
---

#### Flow past a cylinder {#sec-fenicsx-flow-past-a-cylinder}

Author: Jørgen S. Dokken — Modifications by Kee-Youn Yoo

In this section, we consider a slightly more challenging problem: flow past a cylinder. The geometry and parameters are taken from the [DFG 2D-3 benchmark](https://wwwold.mathematik.tu-dortmund.de/~featflow/en/benchmarks/cfdbenchmarking/flow/dfg_benchmark3_re100.html) in FeatFlow

To solve this problem efficiently and ensure numerical stability, we replace the first-order backward difference scheme with a Crank–Nicolson time discretization, combined with a semi-implicit Adams–Bashforth approximation of the nonlinear term

::: callout-note
This demo is computationally demanding, with a run time of up to 15 minutes, as it uses parameters from the DFG 2D-3 benchmark, which consists of 12,800 time steps.
It is advised to download this demo rather than running it in a browser.
The run time can be reduced by using 2 or 3 MPI processes
:::

The computational geometry chosen for this example is 
![Fluid channel with a circular obstacle](figures/turek.png)

The kinematic viscosity is given by $\nu = 0.001 = \frac{\mu}{\rho}$, and the inflow velocity profile is specified as

$$
u(x,y,t) = \left( \frac{4U(t)y(0.41-y)}{0.41^2}, 0 \right)
$$

where
$$
U(t) = 1.5 \sin\left(\tfrac{\pi t}{8}\right)
$$

This profile attains a maximum value of $1.5$ at $y = 0.41/2$. No scaling is applied in this problem, since all parameters are given explicitly

**Mesh generation**

As in the Deflection of a Membrane example, we use `GMSH` to generate the mesh. We first create the rectangle and the obstacle

```{python}
import sys

import numpy as np
import matplotlib.pyplot as plt
from tqdm.notebook import tqdm

from mpi4py import MPI
from petsc4py import PETSc
import gmsh

from dolfinx.cpp.mesh import to_type, cell_entity_type
from dolfinx.fem import (Constant, Function, functionspace,
  assemble_scalar, dirichletbc, form, locate_dofs_topological, set_bc)
from dolfinx.fem.petsc import (apply_lifting, assemble_matrix, 
  assemble_vector, create_vector, create_matrix, set_bc)
from dolfinx.mesh import create_mesh, meshtags_from_entities
from dolfinx.graph import adjacencylist
from dolfinx.geometry import (bb_tree, compute_collisions_points, 
  compute_colliding_cells)
from dolfinx.io import VTXWriter, distribute_entity_data, gmshio

from basix.ufl import element
from ufl import (FacetNormal, Identity, Measure, 
  TestFunction, TrialFunction, as_vector, 
  div, dot, ds, dx, inner, lhs, grad, nabla_grad, rhs, sym, system)

mesh_comm = MPI.COMM_WORLD
model_rank = 0

if not gmsh.isInitialized():
    gmsh.initialize()

gdim = 2
L = 2.2
H = 0.41
c_x = c_y = 0.2
r = 0.05

# Ensure that mesh generation is performed only on
#  the specified process (model_rank) in parallel runs,
#  since Gmsh is not parallel-safe
if mesh_comm.rank == model_rank:

  for dim, tag in gmsh.model.occ.getEntities(gdim):
    gmsh.model.occ.remove([(dim, tag)])

  rectangle = gmsh.model.occ.addRectangle(0, 0, 0, L, H, tag=1)
  obstacle = gmsh.model.occ.addDisk(c_x, c_y, 0, r, r)
```

The next step is to subtract the obstacle from the channel, so that the interior of the circle is not meshed

```{python}
if mesh_comm.rank == model_rank:
  fluid = gmsh.model.occ.cut([(gdim, rectangle)], [(gdim, obstacle)])
  gmsh.model.occ.synchronize()
```

To make GMSH mesh the fluid domain, we add a physical volume marker

```{python}
# ID for the fluid domain
fluid_marker = 1

# Remove any existing physical groups with the same (dim, tag)
for dim, tag in gmsh.model.getPhysicalGroups():
    if dim == gdim and tag == fluid_marker:
        gmsh.model.removePhysicalGroups([(dim, tag)])

if mesh_comm.rank == model_rank:
  # get all volume entities (2D: surfaces, 3D: volumes)
  volumes = gmsh.model.getEntities(dim=gdim)

  # ensure there is exactly one fluid region
  assert (len(volumes) == 1)

  # Register the volume as a physical group with marker = fluid_marker
  gmsh.model.addPhysicalGroup(
    volumes[0][0], 
    [volumes[0][1]], 
    fluid_marker
  )

  # Assign a human-readable name ("Fluid") to this physical group
  gmsh.model.setPhysicalName(
    volumes[0][0], 
    fluid_marker, 
    "Fluid"
  )
```

To label the different surfaces of the mesh, we proceed as follows:
	
1.	Assign marker 2 to the inflow (left-hand side)
2.	Assign marker 3 to the outflow (right-hand side)
3.	Assign marker 4 to the fluid walls
4.	Assign marker 5 to the obstacle

We determine the correct marker for each surface by computing the center of mass of each geometric entity. This way, we can automatically identify and label each boundary in the mesh

```{python}
# Define boundary markers (unique IDs)
inlet_marker, outlet_marker, wall_marker, obstacle_marker = 2, 3, 4, 5
inflow, outflow, walls, obstacle = [], [], [], []

if mesh_comm.rank == model_rank:
  # Extract all 1D boundary entities of the fluid volume
  boundaries = gmsh.model.getBoundary(volumes, oriented=False)
  
  # Identify each boundary by its center of mass
  for boundary in boundaries:
    center_of_mass = gmsh.model.occ.getCenterOfMass(
      boundary[0], 
      boundary[1]
    )
    
    # Left boundary → Inlet
    if np.allclose(center_of_mass, [0, H /2, 0]):
      inflow.append(boundary[1])
    # Right boundary → Outlet
    elif np.allclose(center_of_mass, [L, H /2, 0]):
      outflow.append(boundary[1])
    # Top/bottom → Walls
    elif np.allclose(center_of_mass, [L /2, H, 0]) or \
         np.allclose(center_of_mass, [L /2, 0, 0]):
      walls.append(boundary[1])
    # Remaining boundary → Obstacle
    else:
      obstacle.append(boundary[1])
  
  # Register boundaries as physical groups with human-readable names
  gmsh.model.addPhysicalGroup(1, walls, wall_marker)
  gmsh.model.setPhysicalName(1, wall_marker, "Walls")
  
  gmsh.model.addPhysicalGroup(1, inflow, inlet_marker)
  gmsh.model.setPhysicalName(1, inlet_marker, "Inlet")
  
  gmsh.model.addPhysicalGroup(1, outflow, outlet_marker)
  gmsh.model.setPhysicalName(1, outlet_marker, "Outlet")
    
  gmsh.model.addPhysicalGroup(1, obstacle, obstacle_marker)
  gmsh.model.setPhysicalName(1, obstacle_marker, "Obstacle")
```

In previous meshes, uniform element sizes were employed. In this example, variable mesh sizes are used to better capture the flow in the region of interest, particularly around the circular obstacle. This is accomplished using `GMSH` fields

```{python}
# Define minimum element size near obstacle (1/3 of radius)
res_min = r /3

if mesh_comm.rank == model_rank:
  # Distance field: measure distance from obstacle edges
  distance_field = gmsh.model.mesh.field.add("Distance")
  gmsh.model.mesh.field.setNumbers(distance_field, "EdgesList", obstacle)
  
  # Threshold field: refine mesh based on distance
  threshold_field = gmsh.model.mesh.field.add("Threshold")
  gmsh.model.mesh.field.setNumber(threshold_field, "IField", distance_field)
  # fine near obstacle
  gmsh.model.mesh.field.setNumber(threshold_field, "LcMin", res_min)
  # coarse far away
  gmsh.model.mesh.field.setNumber(threshold_field, "LcMax", 0.25 *H)
  # within radius → LcMin
  gmsh.model.mesh.field.setNumber(threshold_field, "DistMin", r)
  # beyond 2H → LcMax
  gmsh.model.mesh.field.setNumber(threshold_field, "DistMax", 2 *H)
  
  # Min field: apply the smallest size rule if multiple fields exist
  min_field = gmsh.model.mesh.field.add("Min")
  gmsh.model.mesh.field.setNumbers(min_field, "FieldsList", [threshold_field])

  # Set background mesh: controls final mesh refinement
  gmsh.model.mesh.field.setAsBackgroundMesh(min_field)
```

**Generating mesh**

We are now ready to generate the mesh. At this stage, we need to decide whether the mesh should consist of triangles or quadrilaterals. In this demo, to match the DFG 2D-3 benchmark, we use second-order quadrilateral elements

```{python}
if mesh_comm.rank == model_rank:
  # Set mesh algorithm for quadrilaterals (Delquad/Delaunay)
  gmsh.option.setNumber("Mesh.Algorithm", 8)

  # Choose recombination algorithm (Blossom)
  gmsh.option.setNumber("Mesh.RecombinationAlgorithm", 2)

  # Apply recombination to all elements (triangles → quads)
  gmsh.option.setNumber("Mesh.RecombineAll", 1)
  
  # Set subdivision algorithm for recombined quads
  gmsh.option.setNumber("Mesh.SubdivisionAlgorithm", 1)

  # Generate the mesh for the given dimension
  gmsh.model.mesh.generate(gdim)

  # Upgrade mesh to second-order (quadratic) elements
  gmsh.model.mesh.setOrder(2)

  # Optimize mesh quality using Netgen optimizer
  gmsh.model.mesh.optimize("Netgen")
```

**Loading mesh and boundary markers**

Having generated the mesh, we now need to load it together with the corresponding facet markers into `DOLFINx`.
We follow the same structure as in Deflection of a membrane, with the difference that facet markers are also loaded.
For more details about the function used below, see [A GMSH tutorial for DOLFINx](https://jsdokken.com/src/tutorial_gmsh.html)

```{python}
# Convert GMSH model to DOLFINx mesh and facet markers
mesh, _, ft = gmshio.model_to_mesh(
  gmsh.model, 
  mesh_comm, 
  model_rank, 
  gdim=gdim
)

# Assign a human-readable name to the facet markers
ft.name = "Facet markers"

gmsh.finalize()
```

```{python}
# For notebook only
if "ipykernel" in sys.modules:

  import pyvista
  from dolfinx import plot

  V = functionspace(mesh, ("Lagrange", 2))

  # Extract topology from mesh and create pyvista mesh
  topology, cell_types, x = plot.vtk_mesh(V)
  grid = pyvista.UnstructuredGrid(topology, cell_types, x)

  plotter = pyvista.Plotter(off_screen=True)
  plotter.add_mesh(grid, show_edges=True)
  plotter.add_axes()
  plotter.view_xy()

  # if not pyvista.OFF_SCREEN:
  #   plotter.show()

  # HTML 저장
  plotter.export_html("fenicsx/ns/flow_past_a_cylinder_mesh.html")
```

```{=html}
<iframe src="fenicsx/ns/flow_past_a_cylinder_mesh.html"
        width="100%" height="350px"
        style="border:none;">
</iframe>
```

**Physical and discretization parameters**

In accordance with the DGF-2 benchmark, the problem-specific parameters are defined

```{python}
t = 0
T = 8                        # Final time
dt = 1 /1600                 # Time step size
num_steps = int(T /dt)

k = Constant(mesh, PETSc.ScalarType(dt))
mu = Constant(mesh, PETSc.ScalarType(0.001))  # Dynamic viscosity
rho = Constant(mesh, PETSc.ScalarType(1))     # Density
```

::: callout-note
Converting the notebook to a Python script and running it with `mpirun` considerably decreases the runtime
:::

**Boundary conditions**

After creating the mesh and the corresponding mesh tags, we can define the function spaces V and Q together with the boundary conditions. Since ft contains the facet markers, we use it to identify the facets corresponding to the inlet and the walls

```{python}
v_cg2 = element(
  "Lagrange", 
  mesh.topology.cell_name(), 
  2, 
  shape=(mesh.geometry.dim, )
)
s_cg1 = element(
  "Lagrange", 
  mesh.topology.cell_name(), 
  1
)
V = functionspace(mesh, v_cg2)
Q = functionspace(mesh, s_cg1)

fdim = mesh.topology.dim -1

# Define boundary conditions
class InletVelocity():
  def __init__(self, t):
    self.t = t

  def __call__(self, x):
    values = np.zeros((gdim, x.shape[1]), dtype=PETSc.ScalarType)
    values[0] = 4 *1.5 *np.sin(self.t *np.pi /8) *x[1] *(0.41 -x[1]) /(0.41**2)
    return values

# Inlet
u_inlet = Function(V)
inlet_velocity = InletVelocity(t)
u_inlet.interpolate(inlet_velocity)
bcu_inflow = dirichletbc(
  u_inlet, 
  locate_dofs_topological(V, fdim, ft.find(inlet_marker))
)

# Walls
u_nonslip = np.array((0,) *mesh.geometry.dim, dtype=PETSc.ScalarType)
bcu_walls = dirichletbc(
  u_nonslip, 
  locate_dofs_topological(V, fdim, ft.find(wall_marker)), 
  V
)

# Obstacle
bcu_obstacle = dirichletbc(
  u_nonslip, 
  locate_dofs_topological(V, fdim, ft.find(obstacle_marker)), 
  V
)

bcu = [bcu_inflow, bcu_obstacle, bcu_walls]

# Outlet
bcp_outlet = dirichletbc(
  PETSc.ScalarType(0), 
  locate_dofs_topological(Q, fdim, ft.find(outlet_marker)), 
  Q
)
bcp = [bcp_outlet]
```

**Variational form**

In contrast to Poiseuille flow, we employ a Crank–Nicolson discretization together with a semi-implicit Adams–Bashforth approximation

The first step can be written as

$$
\rho\left(\frac{u^* -u^n}{\delta t} +\left(\frac{3}{2}u^{n} -\frac{1}{2} u^{n-1}\right)\cdot \frac{1}{2}\nabla (u^* +u^n) \right) - \frac{1}{2}\mu \Delta( u^* + u^n )+ \nabla p^{n-\tfrac{1}{2}} = f^{n+\tfrac{1}{2}} \;\, \text{ in } \Omega
$$

$$
u^{*}=g(\cdot, t^{n+1}) \;\, \text{ on } \partial \Omega_{D}
$$

$$
\tfrac{1}{2}\nu \nabla (u^*+u^n) \cdot n = p^{n-\tfrac{1}{2}} \;\, \text{ on } \partial \Omega_{N}
$$

where the temporal derivative of the velocity uses the two previous time steps, and the pressure is computed in a staggered manner, at the midpoint between the previous and the current solution

The second step is

$$
\nabla^2 \phi = \frac{\rho}{\delta t} \nabla \cdot u^* \;\,\text{in } \Omega
$$

$$
\nabla \phi \cdot n = 0 \;\, \text{on } \partial \Omega_D
$$

$$
\phi = 0 \;\,\text{on } \partial\Omega_N
$$

where $p^{n+\tfrac{1}{2}}=p^{n-\tfrac{1}{2}} + \phi$

Finally, the third step is

$$
\rho (u^{n+1}-u^{*}) = -\delta t \nabla\phi
$$

We begin by defining all the variables required in the variational formulations

```{python}
u = TrialFunction(V)
v = TestFunction(V)

u_ = Function(V)
u_.name = "u"

u_s = Function(V)
u_n = Function(V)
u_n1 = Function(V)

p = TrialFunction(Q)
q = TestFunction(Q)

p_ = Function(Q)
p_.name = "p"

phi = Function(Q)
```

Next, we define the variational formulation for the first step, where the diffusion and pressure terms are integrated by parts

```{python}
f = Constant(mesh, PETSc.ScalarType((0, 0)))

F1 = rho /k *dot(u -u_n, v) *dx
F1 += inner(dot(1.5 *u_n -0.5 *u_n1, 0.5 *nabla_grad(u +u_n)), v) *dx
F1 += 0.5 *mu *inner(grad(u +u_n), grad(v)) *dx -dot(p_, div(v)) *dx
F1 += dot(f, v) *dx

a1 = form(lhs(F1))
L1 = form(rhs(F1))

A1 = create_matrix(a1)
b1 = create_vector(L1)
```

Next, we set up the second step

```{python}
a2 = form(dot(grad(p), grad(q)) *dx)
L2 = form(-rho /k *dot(div(u_s), q) *dx)

A2 = assemble_matrix(a2, bcs=bcp)
A2.assemble()
b2 = create_vector(L2)
```

We finally complete the last step

```{python}
a3 = form(rho *dot(u, v) *dx)
L3 = form(rho *dot(u_s, v) *dx -k *dot(nabla_grad(phi), v) *dx)

A3 = assemble_matrix(a3)
A3.assemble()
b3 = create_vector(L3)
```

As in the previous tutorials, we use PETSc as the linear algebra backend

```{python}
# Solver for step 1
solver1 = PETSc.KSP().create(mesh.comm)
solver1.setOperators(A1)
solver1.setType(PETSc.KSP.Type.BCGS)
pc1 = solver1.getPC()
pc1.setType(PETSc.PC.Type.JACOBI)

# Solver for step 2
solver2 = PETSc.KSP().create(mesh.comm)
solver2.setOperators(A2)
solver2.setType(PETSc.KSP.Type.MINRES)
pc2 = solver2.getPC()
pc2.setType(PETSc.PC.Type.HYPRE)
pc2.setHYPREType("boomeramg")

# Solver for step 3
solver3 = PETSc.KSP().create(mesh.comm)
solver3.setOperators(A3)
solver3.setType(PETSc.KSP.Type.CG)
pc3 = solver3.getPC()
pc3.setType(PETSc.PC.Type.SOR)
```

**Verification of the implementation by computing known physical quantities**

As a further verification of our implementation, we compute the drag and lift coefficients over the obstacle, defined as

$$
C_{\text{D}}(u,p,t,\partial\Omega_S) = \frac{2}{\rho L U_{\text{mean}}^2}\int_{\partial\Omega_S}\rho \nu n \cdot \nabla u_{t_S}(t)n_y - p(t)n_x\,\mathrm{d} s
$$

$$
C_{\text{L}}(u,p,t,\partial\Omega_S) = -\frac{2}{\rho L U_{\text{mean}}^2}\int_{\partial\Omega_S}\rho \nu n \cdot \nabla u_{t_S}(t)n_x + p(t)n_y\,\mathrm{d} s
$$

where $u_{t_S}$ is the tangential velocity component at the obstacle interface $\partial\Omega_S$, defined as $u_{t_S}=u\cdot (n_y,-n_x)$, $U_{\text{mean}}=1$ is the average inflow velocity, and $L$ is the channel length. We use UFL to define the relevant integrals and assemble them at each time step

```{python}
n = -FacetNormal(mesh)  # Normal pointing out of obstacle
dObs = Measure(
  "ds", 
  domain=mesh, 
  subdomain_data=ft, 
  subdomain_id=obstacle_marker
)

u_t = inner(as_vector((n[1], -n[0])), u_)

drag = form(2 /0.1 *(mu /rho *inner(grad(u_t), n) *n[1] -p_ *n[0]) *dObs)
lift = form(-2 /0.1 *(mu /rho *inner(grad(u_t), n) *n[0] +p_ *n[1]) *dObs)

if mesh.comm.rank == 0:
  C_D = np.zeros(num_steps, dtype=PETSc.ScalarType)
  C_L = np.zeros(num_steps, dtype=PETSc.ScalarType)
  t_u = np.zeros(num_steps, dtype=np.float64)
  t_p = np.zeros(num_steps, dtype=np.float64)
```

We will also evaluate the pressure at two points: one in front of the obstacle, $(0.15, 0.2)$, and one behind it, $(0.25, 0.2)$. To do this, we first need to determine which cell contains each point, so that we can construct a linear combination of the local basis functions and their coefficients

```{python}
tree = bb_tree(mesh, mesh.geometry.dim)
points = np.array([[0.15, 0.2, 0], [0.25, 0.2, 0]])

cell_candidates = compute_collisions_points(tree, points)
colliding_cells = compute_colliding_cells(mesh, cell_candidates, points)

front_cells = colliding_cells.links(0)
back_cells = colliding_cells.links(1)

if mesh.comm.rank == 0:
  p_diff = np.zeros(num_steps, dtype=PETSc.ScalarType)
```

**Solving the time-dependent problem**

As in the previous example, we create output files for the velocity and pressure and solve the time-dependent problem. Since the problem involves many time steps, we use the tqdm package to visualize the progress

```{python}
from pathlib import Path

folder = Path("fenicsx/ns")
folder.mkdir(exist_ok=True, parents=True)

vtx_u = VTXWriter(mesh.comm, folder/"dfg2D-3-u.bp", [u_], engine="BP4")
vtx_p = VTXWriter(mesh.comm, folder/"dfg2D-3-p.bp", [p_], engine="BP4")
vtx_u.write(t)
vtx_p.write(t)

for i in tqdm(range(num_steps), desc="Time Stepping", unit='step'):

  # Update current time step
  t += dt
  
  # Update inlet velocity
  inlet_velocity.t = t
  u_inlet.interpolate(inlet_velocity)

  # Step 1: Tentative velocity step
  A1.zeroEntries()
  assemble_matrix(A1, a1, bcs=bcu)
  A1.assemble()
  
  with b1.localForm() as loc:
    loc.set(0)
  assemble_vector(b1, L1)
  apply_lifting(b1, [a1], [bcu])
  
  b1.ghostUpdate(
    addv=PETSc.InsertMode.ADD_VALUES, 
    mode=PETSc.ScatterMode.REVERSE
  )
  
  set_bc(b1, bcu)
  
  solver1.solve(b1, u_s.x.petsc_vec)
  u_s.x.scatter_forward()

  # Step 2: Pressure corrrection step
  with b2.localForm() as loc:
    loc.set(0)
  assemble_vector(b2, L2)
  apply_lifting(b2, [a2], [bcp])

  b2.ghostUpdate(
    addv=PETSc.InsertMode.ADD_VALUES, 
    mode=PETSc.ScatterMode.REVERSE
  )

  set_bc(b2, bcp)

  solver2.solve(b2, phi.x.petsc_vec)
  phi.x.scatter_forward()

  p_.x.petsc_vec.axpy(1, phi.x.petsc_vec)
  p_.x.scatter_forward()

  # Step 3: Velocity correction step
  with b3.localForm() as loc:
    loc.set(0)
  assemble_vector(b3, L3)

  b3.ghostUpdate(
    addv=PETSc.InsertMode.ADD_VALUES, 
    mode=PETSc.ScatterMode.REVERSE
  )
  
  solver3.solve(b3, u_.x.petsc_vec)
  u_.x.scatter_forward()

  # Write solutions to file
  vtx_u.write(t)
  vtx_p.write(t)

  # Update variable with solution form this time step
  with (
    u_.x.petsc_vec.localForm() as loc_, 
    u_n.x.petsc_vec.localForm() as loc_n, 
    u_n1.x.petsc_vec.localForm() as loc_n1
  ):
    loc_n.copy(loc_n1)
    loc_.copy(loc_n)

  # Compute physical quantities
  # For this to work in paralell, we gather contributions from all processors
  # to processor zero and sum the contributions
  drag_coeff = mesh.comm.gather(assemble_scalar(drag), root=0)
  lift_coeff = mesh.comm.gather(assemble_scalar(lift), root=0)
  
  p_front = None
  if len(front_cells) > 0:
    p_front = p_.eval(points[0], front_cells[:1])
  p_front = mesh.comm.gather(p_front, root=0)
  
  p_back = None
  if len(back_cells) > 0:
    p_back = p_.eval(points[1], back_cells[:1])
  p_back = mesh.comm.gather(p_back, root=0)
  
  if mesh.comm.rank == 0:
    t_u[i] = t
    t_p[i] = t -dt /2
    C_D[i] = sum(drag_coeff)
    C_L[i] = sum(lift_coeff)
    
    # Choose first pressure that is found from the different processors
    for pressure in p_front:
      if pressure is not None:
        p_diff[i] = pressure[0]
        break
    for pressure in p_back:
      if pressure is not None:
        p_diff[i] -= pressure[0]
        break

vtx_u.close()
vtx_p.close()
```

::: {.video}
![](fenicsx/ns/dfg2D-3-u.mp4)
:::

::: {.video}
![](fenicsx/ns/dfg2D-3-p.mp4)
:::

**Verification using data from `FEATFLOW`**

We use `matplotlib` to compare our numerical results with the reference data provided by `FEATFLOW` for different discretization levels

```{python}
if mesh.comm.rank == 0:
  # Compute the total number of velocity degrees of freedom (DOFs)
  # - V.dofmap.index_map.size_global : global number of scalar DOFs
  # - V.dofmap.index_map_bs          : block size (e.g., 2 in 2D, 3 in 3D for vector spaces)
  #   → Total number of velocity DOFs = block size × scalar DOFs  
  num_velocity_dofs = V.dofmap.index_map_bs *V.dofmap.index_map.size_global

  # Compute the total number of pressure degrees of freedom (DOFs)
  # - Typically: Q.dofmap.index_map.size_global × Q.dofmap.index_map_bs
  #   (for scalar pressure spaces, block size = 1)
  num_pressure_dofs = Q.dofmap.index_map_bs *Q.dofmap.index_map.size_global

  turek = np.loadtxt(folder/"bdforces_lv4")
  turek_p = np.loadtxt(folder/"pointvalues_lv4")
  
  fig = plt.figure(figsize=(25, 8))

  l1 = plt.plot(
    t_u, C_D, 
    label=f"FEniCSx ({num_velocity_dofs +num_pressure_dofs:d} dofs)", linewidth=2
  )
  l2 = plt.plot(
    turek[1:, 1], turek[1:, 3], 
    marker="x", markevery=50, linestyle="", markersize=4, 
    label="FEATFLOW (42016 dofs)")

  plt.title("Drag Coefficient")
  plt.grid()
  plt.legend()
  plt.savefig(folder/"drag_comparison.png")
  plt.show()

  fig = plt.figure(figsize=(25, 8))

  l1 = plt.plot(
    t_u, C_L, 
    label=f"FEniCSx ({num_velocity_dofs +num_pressure_dofs:d} dofs)", linewidth=2
  )
  l2 = plt.plot(
    turek[1:, 1], turek[1:, 4], 
    marker="x", markevery=50, linestyle="", markersize=4, 
    label="FEATFLOW (42016 dofs)"
  )
  
  plt.title("Lift Coefficient")
  plt.grid()
  plt.legend()
  plt.savefig(folder/"lift_comparison.png")
  plt.show()  

  fig = plt.figure(figsize=(25, 8))

  l1 = plt.plot(
    t_p, p_diff, 
    label=f"FEniCSx ({num_velocity_dofs + num_pressure_dofs:d} dofs)", linewidth=2
  )
  l2 = plt.plot(
    turek[1:, 1], turek_p[1:, 6] -turek_p[1:, -1], 
    marker="x", markevery=50, linestyle="", markersize=4, 
    label="FEATFLOW (42016 dofs)"
  )
  
  plt.title("Pressure difference")
  plt.grid()
  plt.legend()
  plt.savefig(folder/"pressure_comparison.png")
  plt.show()
```